local docs = {LspAttach = {binding = "LspAttach", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "After an LSP client performs \"initialize\" and attaches to a buffer. The\n|autocmd-pattern| is the buffer name. The client ID is passed in the\nLua handler |event-data| argument.\n\nExample: >lua\nvim.api.nvim_create_autocmd('LspAttach', {\n  callback = function(ev)\n    local client = vim.lsp.get_client_by_id(ev.data.client_id)\n    -- ...\n  end\n})\n<\nNote: If the LSP server performs dynamic registration, capabilities may be\nregistered any time _after_ LspAttach. In that case you may want to handle\nthe \"registerCapability\" event.\n\nExample: >lua\nvim.lsp.handlers['client/registerCapability'] = (function(overridden)\n  return function(err, res, ctx)\n    local result = overridden(err, res, ctx)\n    local client = vim.lsp.get_client_by_id(ctx.client_id)\n    if not client then\n      return\n    end\n    for bufnr, _ in pairs(client.attached_buffers) do\n      -- Call your custom on_attach logic...\n      -- my_on_attach(client, bufnr)\n    end\n    return result\n  end\nend)(vim.lsp.handlers['client/registerCapability'])"}}, LspDetach = {binding = "LspDetach", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Just before an LSP client detaches from a buffer. The |autocmd-pattern| is\nthe buffer name. The client ID is passed in the Lua handler |event-data|\nargument.\n\nExample: >lua\nvim.api.nvim_create_autocmd('LspDetach', {\n  callback = function(args)\n    -- Get the detaching client\n    local client = vim.lsp.get_client_by_id(args.data.client_id)\n\n    -- Remove the autocommand to format the buffer on save, if it exists\n    if client:supports_method('textDocument/formatting') then\n      vim.api.nvim_clear_autocmds({\n        event = 'BufWritePre',\n        buffer = args.buf,\n      })\n    end\n  end,\n})\n<"}}, LspNotify = {binding = "LspNotify", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "This event is triggered after each successful notification sent to an\nLSP server.\n\nThe client_id, LSP method, and parameters are sent in the Lua handler\n|event-data| table argument.\n\nExample: >lua\nvim.api.nvim_create_autocmd('LspNotify', {\n  callback = function(args)\n    local bufnr = args.buf\n    local client_id = args.data.client_id\n    local method = args.data.method\n    local params = args.data.params\n\n    -- do something with the notification\n    if method == 'textDocument/...' then\n      update_buffer(bufnr)\n    end\n  end,\n})\n<"}}, LspProgress = {binding = "LspProgress", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Upon receipt of a progress notification from the server. Notifications can\nbe polled from a `progress` ring buffer of a |vim.lsp.Client| or use\n|vim.lsp.status()| to get an aggregate message.\n\nIf the server sends a \"work done progress\", the `pattern` is set to `kind`\n(one of `begin`, `report` or `end`).\n\nThe Lua handler |event-data| argument has `client_id` and `params`\nproperties, where `params` is the request params sent by the server (see\n`lsp.ProgressParams`).\n\nExample: >vim\n    autocmd LspProgress * redrawstatus\n<"}}, LspRequest = {binding = "LspRequest", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "For each request sent to an LSP server, this event is triggered for\nevery change to the request's status. The status can be one of\n`pending`, `complete`, or `cancel` and is sent as the {type} on the\n\"data\" table passed to the callback function.\n\nIt triggers when the initial request is sent ({type} == `pending`) and\nwhen the LSP server responds ({type} == `complete`). If a cancellation\nis requested using `client.cancel_request(request_id)`, then this event\nwill trigger with {type} == `cancel`.\n\nThe Lua handler |event-data| argument has the client ID, request ID, and\nrequest (described at |vim.lsp.Client|, {requests} field). If the request\ntype is `complete`, the request will be deleted from the client's pending\nrequests table after processing the event handlers.\n\nExample: >lua\nvim.api.nvim_create_autocmd('LspRequest', {\n  callback = function(args)\n    local bufnr = args.buf\n    local client_id = args.data.client_id\n    local request_id = args.data.request_id\n    local request = args.data.request\n    if request.type == 'pending' then\n      -- do something with pending requests\n      track_pending(client_id, bufnr, request_id, request)\n    elseif request.type == 'cancel' then\n      -- do something with pending cancel requests\n      track_canceling(client_id, bufnr, request_id, request)\n    elseif request.type == 'complete' then\n      -- do something with finished requests. this pending\n      -- request entry is about to be removed since it is complete\n      track_finish(client_id, bufnr, request_id, request)\n    end\n  end,\n})\n<"}}, LspTokenUpdate = {binding = "LspTokenUpdate", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "When a visible semantic token is sent or updated by the LSP server, or\nwhen an existing token becomes visible for the first time. The\n|autocmd-pattern| is the buffer name. The Lua handler |event-data|\nargument has the client ID and token (see\n|vim.lsp.semantic_tokens.get_at_pos()|).\n\nExample: >lua\nvim.api.nvim_create_autocmd('LspTokenUpdate', {\n  callback = function(args)\n    local token = args.data.token\n    if token.type == 'variable' and not token.modifiers.readonly then\n      vim.lsp.semantic_tokens.highlight_token(\n        token, args.buf, args.data.client_id, 'MyMutableVariableHighlight'\n      )\n    end\n  end,\n})\n<\nNote: doing anything other than calling\n|vim.lsp.semantic_tokens.highlight_token()| is considered experimental."}}, TermCursorNC = {binding = "TermCursorNC", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUnfocused |terminal| windows do not have a cursor."}}, tohtml = {binding = "tohtml", fields = {tohtml = {binding = "tohtml", fields = {tohtml = {binding = "tohtml", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winid", "?opt"}, ["fnl/docstring"] = "Converts the buffer shown in the window {winid} to HTML and returns the\noutput as a list of string.\n\nParameters: ~\n  \226\128\162 {winid}  (`integer?`) Window to convert (defaults to current window)\n  \226\128\162 {opt}    (`table?`) Optional parameters.\n             \226\128\162 {title}? (`string|false`, default: buffer name) Title tag\n               to set in the generated HTML code.\n             \226\128\162 {number_lines}? (`boolean`, default: `false`) Show line\n               numbers.\n             \226\128\162 {font}? (`string[]|string`, default: `guifont`) Fonts to\n               use.\n             \226\128\162 {width}? (`integer`, default: 'textwidth' if non-zero or\n               window width otherwise) Width used for items which are\n               either right aligned or repeat a character infinitely.\n             \226\128\162 {range}? (`integer[]`, default: entire buffer) Range of\n               rows to use.\n\nReturn: ~\n    (`string[]`)"}}}, metadata = {["fls/itemKind"] = "Module"}}}, metadata = {["fls/itemKind"] = "Module"}}, vim = {binding = "vim", fields = {NIL = {binding = "NIL", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Special value representing NIL in |RPC| and |v:null| in Vimscript\nconversion, and similar cases. Lua `nil` cannot be used as part of a Lua\ntable representing a Dictionary or Array, because it is treated as\nmissing: `{\"foo\", nil}` is the same as `{\"foo\"}`."}}, api = {binding = "api", fields = {nvim__complete_set = {binding = "nvim__complete_set", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"index", "opts"}, ["fnl/docstring"] = "EXPERIMENTAL: this API may change in the future.\n\nSets info for the completion item at the given index. If the info text was\nshown in a window, returns the window and buffer ids, or empty dict if not\nshown.\n\nParameters: ~\n  \226\128\162 {index}  Completion candidate index\n  \226\128\162 {opts}   Optional parameters.\n             \226\128\162 info: (string) info text.\n\nReturn: ~\n    Dict containing these keys:\n    \226\128\162 winid: (number) floating window id\n    \226\128\162 bufnr: (number) buffer id in floating window"}}, nvim__get_runtime = {binding = "nvim__get_runtime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pat", "all", "opts"}, ["fnl/docstring"] = "Find files in runtime directories\n\nAttributes: ~\n    |api-fast|\n    Since: 0.6.0\n\nParameters: ~\n  \226\128\162 {pat}   pattern of files to search for\n  \226\128\162 {all}   whether to return all matches or only the first\n  \226\128\162 {opts}  is_lua: only search Lua subdirs\n\nReturn: ~\n    list of absolute paths to the found files"}}, nvim__id = {binding = "nvim__id", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"obj"}, ["fnl/docstring"] = "Returns object given as argument.\n\nThis API function is used for testing. One should not rely on its presence\nin plugins.\n\nParameters: ~\n  \226\128\162 {obj}  Object to return.\n\nReturn: ~\n    its argument."}}, nvim__id_array = {binding = "nvim__id_array", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"arr"}, ["fnl/docstring"] = "Returns array given as argument.\n\nThis API function is used for testing. One should not rely on its presence\nin plugins.\n\nParameters: ~\n  \226\128\162 {arr}  Array to return.\n\nReturn: ~\n    its argument."}}, nvim__id_dict = {binding = "nvim__id_dict", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dct"}, ["fnl/docstring"] = "Returns dict given as argument.\n\nThis API function is used for testing. One should not rely on its presence\nin plugins.\n\nParameters: ~\n  \226\128\162 {dct}  Dict to return.\n\nReturn: ~\n    its argument."}}, nvim__id_float = {binding = "nvim__id_float", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"flt"}, ["fnl/docstring"] = "Returns floating-point value given as argument.\n\nThis API function is used for testing. One should not rely on its presence\nin plugins.\n\nParameters: ~\n  \226\128\162 {flt}  Value to return.\n\nReturn: ~\n    its argument."}}, nvim__inspect_cell = {binding = "nvim__inspect_cell", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"grid", "row", "col"}, ["fnl/docstring"] = "NB: if your UI doesn't use hlstate, this will not return hlstate first\ntime."}}, nvim__invalidate_glyph_cache = {binding = "nvim__invalidate_glyph_cache", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "For testing. The condition in schar_cache_clear_if_full is hard to reach,\nso this function can be used to force a cache clear in a test."}}, nvim__ns_get = {binding = "nvim__ns_get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id"}, ["fnl/docstring"] = "EXPERIMENTAL: this API will change in the future.\n\nGet the properties for namespace\n\nParameters: ~\n  \226\128\162 {ns_id}  Namespace\n\nReturn: ~\n    Map defining the namespace properties, see |nvim__ns_set()|"}}, nvim__ns_set = {binding = "nvim__ns_set", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id", "opts"}, ["fnl/docstring"] = "EXPERIMENTAL: this API will change in the future.\n\nSet some properties for namespace\n\nParameters: ~\n  \226\128\162 {ns_id}  Namespace\n  \226\128\162 {opts}   Optional parameters to set:\n             \226\128\162 wins: a list of windows to be scoped in"}}, nvim__redraw = {binding = "nvim__redraw", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "EXPERIMENTAL: this API may change in the future.\n\nInstruct Nvim to redraw various components.\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {opts}  Optional parameters.\n            \226\128\162 win: Target a specific |window-ID| as described below.\n            \226\128\162 buf: Target a specific buffer number as described below.\n            \226\128\162 flush: Update the screen with pending updates.\n            \226\128\162 valid: When present mark `win`, `buf`, or all windows for\n              redraw. When `true`, only redraw changed lines (useful for\n              decoration providers). When `false`, forcefully redraw.\n            \226\128\162 range: Redraw a range in `buf`, the buffer in `win` or the\n              current buffer (useful for decoration providers). Expects a\n              tuple `[first, last]` with the first and last line number of\n              the range, 0-based end-exclusive |api-indexing|.\n            \226\128\162 cursor: Immediately update cursor position on the screen in\n              `win` or the current window.\n            \226\128\162 statuscolumn: Redraw the 'statuscolumn' in `buf`, `win` or\n              all windows.\n            \226\128\162 statusline: Redraw the 'statusline' in `buf`, `win` or all\n              windows.\n            \226\128\162 winbar: Redraw the 'winbar' in `buf`, `win` or all windows.\n            \226\128\162 tabline: Redraw the 'tabline'.\n\nSee also: ~\n  \226\128\162 |:redraw|"}}, nvim__stats = {binding = "nvim__stats", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets internal stats.\n\nReturn: ~\n    Map of various internal stats."}}, nvim_buf_add_highlight = {binding = "nvim_buf_add_highlight", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |vim.hl.range()| or |nvim_buf_set_extmark()|"}}, nvim_buf_attach = {binding = "nvim_buf_attach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "send_buffer", "opts"}, ["fnl/docstring"] = "Activates buffer-update events on a channel, or as Lua callbacks.\n\nExample (Lua): capture buffer updates in a global `events` variable (use\n\"vim.print(events)\" to see its contents): >lua\n    events = {}\n    vim.api.nvim_buf_attach(0, false, {\n      on_lines = function(...)\n        table.insert(events, {...})\n      end,\n    })\n<\n\nAttributes: ~\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {buffer}       Buffer id, or 0 for current buffer\n  \226\128\162 {send_buffer}  True if the initial notification should contain the\n                   whole buffer: first notification will be\n                   `nvim_buf_lines_event`. Else the first notification\n                   will be `nvim_buf_changedtick_event`. Not for Lua\n                   callbacks.\n  \226\128\162 {opts}         Optional parameters.\n                   \226\128\162 on_lines: Lua callback invoked on change. Return a\n                     truthy value (not `false` or `nil`) to detach. Args:\n                     \226\128\162 the string \"lines\"\n                     \226\128\162 buffer id\n                     \226\128\162 b:changedtick\n                     \226\128\162 first line that changed (zero-indexed)\n                     \226\128\162 last line that was changed\n                     \226\128\162 last line in the updated range\n                     \226\128\162 byte count of previous contents\n                     \226\128\162 deleted_codepoints (if `utf_sizes` is true)\n                     \226\128\162 deleted_codeunits (if `utf_sizes` is true)\n                   \226\128\162 on_bytes: Lua callback invoked on change. This\n                     callback receives more granular information about the\n                     change compared to on_lines. Return a truthy value\n                     (not `false` or `nil`) to detach. Args:\n                     \226\128\162 the string \"bytes\"\n                     \226\128\162 buffer id\n                     \226\128\162 b:changedtick\n                     \226\128\162 start row of the changed text (zero-indexed)\n                     \226\128\162 start column of the changed text\n                     \226\128\162 byte offset of the changed text (from the start of\n                       the buffer)\n                     \226\128\162 old end row of the changed text (offset from start\n                       row)\n                     \226\128\162 old end column of the changed text (if old end row\n                       = 0, offset from start column)\n                     \226\128\162 old end byte length of the changed text\n                     \226\128\162 new end row of the changed text (offset from start\n                       row)\n                     \226\128\162 new end column of the changed text (if new end row\n                       = 0, offset from start column)\n                     \226\128\162 new end byte length of the changed text\n                   \226\128\162 on_changedtick: Lua callback invoked on changedtick\n                     increment without text change. Args:\n                     \226\128\162 the string \"changedtick\"\n                     \226\128\162 buffer id\n                     \226\128\162 b:changedtick\n                   \226\128\162 on_detach: Lua callback invoked on detach. Args:\n                     \226\128\162 the string \"detach\"\n                     \226\128\162 buffer id\n                   \226\128\162 on_reload: Lua callback invoked on reload. The entire\n                     buffer content should be considered changed. Args:\n                     \226\128\162 the string \"reload\"\n                     \226\128\162 buffer id\n                   \226\128\162 utf_sizes: include UTF-32 and UTF-16 size of the\n                     replaced region, as args to `on_lines`.\n                   \226\128\162 preview: also attach to command preview (i.e.\n                     'inccommand') events.\n\nReturn: ~\n    False if attach failed (invalid parameter, or buffer isn't loaded);\n    otherwise True. TODO: LUA_API_NO_EVAL\n\nSee also: ~\n  \226\128\162 |nvim_buf_detach()|\n  \226\128\162 |api-buffer-updates-lua|"}}, nvim_buf_call = {binding = "nvim_buf_call", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "fun"}, ["fnl/docstring"] = "Call a function with buffer as temporary current buffer.\n\nThis temporarily switches current buffer to \"buffer\". If the current\nwindow already shows \"buffer\", the window is not switched. If a window\ninside the current tabpage (including a float) already shows the buffer,\nthen one of those windows will be set as current window temporarily.\nOtherwise a temporary scratch window (called the \"autocmd window\" for\nhistorical reasons) will be used.\n\nThis is useful e.g. to call Vimscript functions that only work with the\ncurrent buffer/window currently, like `jobstart(\226\128\166, {'term': v:true})`.\n\nAttributes: ~\n    Lua |vim.api| only\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {fun}     Function to call inside the buffer (currently Lua callable\n              only)\n\nReturn: ~\n    Return value of function."}}, nvim_buf_clear_namespace = {binding = "nvim_buf_clear_namespace", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "ns_id", "line_start", "line_end"}, ["fnl/docstring"] = "Clears |namespace|d objects (highlights, |extmarks|, virtual text) from a\nregion.\n\nLines are 0-indexed. |api-indexing| To clear the namespace in the entire\nbuffer, specify line_start=0 and line_end=-1.\n\nAttributes: ~\n    Since: 0.3.2\n\nParameters: ~\n  \226\128\162 {buffer}      Buffer id, or 0 for current buffer\n  \226\128\162 {ns_id}       Namespace to clear, or -1 to clear all namespaces.\n  \226\128\162 {line_start}  Start of range of lines to clear\n  \226\128\162 {line_end}    End of range of lines to clear (exclusive) or -1 to\n                  clear to end of buffer."}}, nvim_buf_create_user_command = {binding = "nvim_buf_create_user_command", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name", "command", "opts"}, ["fnl/docstring"] = "Creates a buffer-local command |user-commands|.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {buffer}   Buffer id, or 0 for current buffer.\n\nSee also: ~\n  \226\128\162 nvim_create_user_command\n\n                                             "}}, nvim_buf_del_extmark = {binding = "nvim_buf_del_extmark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "ns_id", "id"}, ["fnl/docstring"] = "Removes an |extmark|.\n\nAttributes: ~\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {ns_id}   Namespace id from |nvim_create_namespace()|\n  \226\128\162 {id}      Extmark id\n\nReturn: ~\n    true if the extmark was found, else false\n\n                                            "}}, nvim_buf_del_keymap = {binding = "nvim_buf_del_keymap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "mode", "lhs"}, ["fnl/docstring"] = "Unmaps a buffer-local |mapping| for the given mode.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nSee also: ~\n  \226\128\162 |nvim_del_keymap()|"}}, nvim_buf_del_mark = {binding = "nvim_buf_del_mark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name"}, ["fnl/docstring"] = "Deletes a named mark in the buffer. See |mark-motions|.\n\nNote: ~\n  \226\128\162 only deletes marks set in the buffer, if the mark is not set in the\n    buffer it will return false.\n\nAttributes: ~\n    Since: 0.6.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer to set the mark on\n  \226\128\162 {name}    Mark name\n\nReturn: ~\n    true if the mark was deleted, else false.\n\nSee also: ~\n  \226\128\162 |nvim_buf_set_mark()|\n  \226\128\162 |nvim_del_mark()|"}}, nvim_buf_del_user_command = {binding = "nvim_buf_del_user_command", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name"}, ["fnl/docstring"] = "Delete a buffer-local user-defined command.\n\nOnly commands created with |:command-buffer| or\n|nvim_buf_create_user_command()| can be deleted with this function.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer.\n  \226\128\162 {name}    Name of the command to delete."}}, nvim_buf_del_var = {binding = "nvim_buf_del_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name"}, ["fnl/docstring"] = "Removes a buffer-scoped (b:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {name}    Variable name"}}, nvim_buf_delete = {binding = "nvim_buf_delete", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "opts"}, ["fnl/docstring"] = "Deletes the buffer. See |:bwipeout|\n\nAttributes: ~\n    not allowed when |textlock| is active or in the |cmdwin|\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {opts}    Optional parameters. Keys:\n              \226\128\162 force: Force deletion and ignore unsaved changes.\n              \226\128\162 unload: Unloaded only, do not delete. See |:bunload|"}}, nvim_buf_detach = {binding = "nvim_buf_detach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Deactivates buffer-update events on the channel.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nReturn: ~\n    False if detach failed (because the buffer isn't loaded); otherwise\n    True.\n\nSee also: ~\n  \226\128\162 |nvim_buf_attach()|\n  \226\128\162 |api-lua-detach| for detaching Lua callbacks"}}, nvim_buf_get_changedtick = {binding = "nvim_buf_get_changedtick", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Gets a changed tick of a buffer\n\nAttributes: ~\n    Since: 0.2.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nReturn: ~\n    `b:changedtick` value."}}, nvim_buf_get_commands = {binding = "nvim_buf_get_commands", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "opts"}, ["fnl/docstring"] = "Gets a map of buffer-local |user-commands|.\n\nAttributes: ~\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {opts}    Optional parameters. Currently not used.\n\nReturn: ~\n    Map of maps describing commands."}}, nvim_buf_get_extmark_by_id = {binding = "nvim_buf_get_extmark_by_id", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "ns_id", "id", "opts"}, ["fnl/docstring"] = "Gets the position (0-indexed) of an |extmark|.\n\nAttributes: ~\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {ns_id}   Namespace id from |nvim_create_namespace()|\n  \226\128\162 {id}      Extmark id\n  \226\128\162 {opts}    Optional parameters. Keys:\n              \226\128\162 details: Whether to include the details dict\n              \226\128\162 hl_name: Whether to include highlight group name instead\n                of id, true if omitted\n\nReturn: ~\n    0-indexed (row, col) tuple or empty list () if extmark id was absent\n\n                                                 "}}, nvim_buf_get_extmarks = {binding = "nvim_buf_get_extmarks", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "ns_id", "start", "end", "opts"}, ["fnl/docstring"] = "Gets |extmarks| in \"traversal order\" from a |charwise| region defined by\nbuffer positions (inclusive, 0-indexed |api-indexing|).\n\nRegion can be given as (row,col) tuples, or valid extmark ids (whose\npositions define the bounds). 0 and -1 are understood as (0,0) and (-1,-1)\nrespectively, thus the following are equivalent: >lua\n    vim.api.nvim_buf_get_extmarks(0, my_ns, 0, -1, {})\n    vim.api.nvim_buf_get_extmarks(0, my_ns, {0,0}, {-1,-1}, {})\n<\n\nIf `end` is less than `start`, marks are returned in reverse order.\n(Useful with `limit`, to get the first marks prior to a given position.)\n\nNote: For a reverse range, `limit` does not actually affect the traversed\nrange, just how many marks are returned\n\nNote: when using extmark ranges (marks with a end_row/end_col position)\nthe `overlap` option might be useful. Otherwise only the start position of\nan extmark will be considered.\n\nNote: legacy signs placed through the |:sign| commands are implemented as\nextmarks and will show up here. Their details array will contain a\n`sign_name` field.\n\nExample: >lua\n    local api = vim.api\n    local pos = api.nvim_win_get_cursor(0)\n    local ns  = api.nvim_create_namespace('my-plugin')\n    -- Create new extmark at line 1, column 1.\n    local m1  = api.nvim_buf_set_extmark(0, ns, 0, 0, {})\n    -- Create new extmark at line 3, column 1.\n    local m2  = api.nvim_buf_set_extmark(0, ns, 2, 0, {})\n    -- Get extmarks only from line 3.\n    local ms  = api.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})\n    -- Get all marks in this buffer + namespace.\n    local all = api.nvim_buf_get_extmarks(0, ns, 0, -1, {})\n    vim.print(ms)\n<\n\nAttributes: ~\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {ns_id}   Namespace id from |nvim_create_namespace()| or -1 for all\n              namespaces\n  \226\128\162 {start}   Start of range: a 0-indexed (row, col) or valid extmark id\n              (whose position defines the bound). |api-indexing|\n  \226\128\162 {end}     End of range (inclusive): a 0-indexed (row, col) or valid\n              extmark id (whose position defines the bound).\n              |api-indexing|\n  \226\128\162 {opts}    Optional parameters. Keys:\n              \226\128\162 limit: Maximum number of marks to return\n              \226\128\162 details: Whether to include the details dict\n              \226\128\162 hl_name: Whether to include highlight group name instead\n                of id, true if omitted\n              \226\128\162 overlap: Also include marks which overlap the range, even\n                if their start position is less than `start`\n              \226\128\162 type: Filter marks by type: \"highlight\", \"sign\",\n                \"virt_text\" and \"virt_lines\"\n\nReturn: ~\n    List of `[extmark_id, row, col]` tuples in \"traversal order\".\n\n                                                  "}}, nvim_buf_get_keymap = {binding = "nvim_buf_get_keymap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "mode"}, ["fnl/docstring"] = "Gets a list of buffer-local |mapping| definitions.\n\nAttributes: ~\n    Since: 0.2.1\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {mode}    Mode short-name (\"n\", \"i\", \"v\", ...)\n\nReturn: ~\n    Array of |maparg()|-like dictionaries describing mappings. The\n    \"buffer\" key holds the associated buffer id.\n\n                                                    "}}, nvim_buf_get_lines = {binding = "nvim_buf_get_lines", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "start", "end", "strict_indexing"}, ["fnl/docstring"] = "Gets a line-range from the buffer.\n\nIndexing is zero-based, end-exclusive. Negative indices are interpreted as\nlength+1+index: -1 refers to the index past the end. So to get the last\nelement use start=-2 and end=-1.\n\nOut-of-bounds indices are clamped to the nearest valid value, unless\n`strict_indexing` is set.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}           Buffer id, or 0 for current buffer\n  \226\128\162 {start}            First line index\n  \226\128\162 {end}              Last line index, exclusive\n  \226\128\162 {strict_indexing}  Whether out-of-bounds should be an error.\n\nReturn: ~\n    Array of lines, or empty array for unloaded buffer.\n\nSee also: ~\n  \226\128\162 |nvim_buf_get_text()|"}}, nvim_buf_get_mark = {binding = "nvim_buf_get_mark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name"}, ["fnl/docstring"] = "Returns a `(row,col)` tuple representing the position of the named mark.\n\"End of line\" column position is returned as |v:maxcol| (big number). See\n|mark-motions|.\n\nMarks are (1,0)-indexed. |api-indexing|\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {name}    Mark name\n\nReturn: ~\n    (row, col) tuple, (0, 0) if the mark is not set, or is an\n    uppercase/file mark set in another buffer.\n\nSee also: ~\n  \226\128\162 |nvim_buf_set_mark()|\n  \226\128\162 |nvim_buf_del_mark()|"}}, nvim_buf_get_name = {binding = "nvim_buf_get_name", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Gets the full file name for the buffer\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nReturn: ~\n    Buffer name"}}, nvim_buf_get_offset = {binding = "nvim_buf_get_offset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "index"}, ["fnl/docstring"] = "Returns the byte offset of a line (0-indexed). |api-indexing|\n\nLine 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.\n'fileformat' and 'fileencoding' are ignored. The line index just after the\nlast line gives the total byte-count of the buffer. A final EOL byte is\ncounted if it would be written, see 'eol'.\n\nUnlike |line2byte()|, throws error for out-of-bounds indexing. Returns -1\nfor unloaded buffer.\n\nAttributes: ~\n    Since: 0.3.2\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {index}   Line index\n\nReturn: ~\n    Integer byte offset, or -1 for unloaded buffer.\n\n                                                     "}}, nvim_buf_get_text = {binding = "nvim_buf_get_text", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "start_row", "start_col", "end_row", "end_col", "opts"}, ["fnl/docstring"] = "Gets a range from the buffer (may be partial lines, unlike\n|nvim_buf_get_lines()|).\n\nIndexing is zero-based. Row indices are end-inclusive, and column indices\nare end-exclusive.\n\nPrefer |nvim_buf_get_lines()| when retrieving entire lines.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {buffer}     Buffer id, or 0 for current buffer\n  \226\128\162 {start_row}  First line index\n  \226\128\162 {start_col}  Starting column (byte offset) on first line\n  \226\128\162 {end_row}    Last line index, inclusive\n  \226\128\162 {end_col}    Ending column (byte offset) on last line, exclusive\n  \226\128\162 {opts}       Optional parameters. Currently unused.\n\nReturn: ~\n    Array of lines, or empty array for unloaded buffer."}}, nvim_buf_get_var = {binding = "nvim_buf_get_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name"}, ["fnl/docstring"] = "Gets a buffer-scoped (b:) variable.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {name}    Variable name\n\nReturn: ~\n    Variable value"}}, nvim_buf_is_loaded = {binding = "nvim_buf_is_loaded", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Checks if a buffer is valid and loaded. See |api-buffer| for more info\nabout unloaded buffers.\n\nAttributes: ~\n    Since: 0.3.2\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nReturn: ~\n    true if the buffer is valid and loaded, false otherwise."}}, nvim_buf_is_valid = {binding = "nvim_buf_is_valid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Checks if a buffer is valid.\n\nNote: ~\n  \226\128\162 Even if a buffer is valid it may have been unloaded. See |api-buffer|\n    for more info about unloaded buffers.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nReturn: ~\n    true if the buffer is valid, false otherwise."}}, nvim_buf_line_count = {binding = "nvim_buf_line_count", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Returns the number of lines in the given buffer.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nReturn: ~\n    Line count, or 0 for unloaded buffer. |api-buffer|\n\n                                                   "}}, nvim_buf_set_extmark = {binding = "nvim_buf_set_extmark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "ns_id", "line", "col", "opts"}, ["fnl/docstring"] = "Creates or updates an |extmark|.\n\nBy default a new extmark is created when no id is passed in, but it is\nalso possible to create a new mark by passing in a previously unused id or\nmove an existing mark by passing in its id. The caller must then keep\ntrack of existing and unused ids itself. (Useful over RPC, to avoid\nwaiting for the return value.)\n\nUsing the optional arguments, it is possible to use this to highlight a\nrange of text, and also to associate virtual text to the mark.\n\nIf present, the position defined by `end_col` and `end_row` should be\nafter the start position in order for the extmark to cover a range. An\nearlier end position is not an error, but then it behaves like an empty\nrange (no highlighting).\n\nAttributes: ~\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {ns_id}   Namespace id from |nvim_create_namespace()|\n  \226\128\162 {line}    Line where to place the mark, 0-based. |api-indexing|\n  \226\128\162 {col}     Column where to place the mark, 0-based. |api-indexing|\n  \226\128\162 {opts}    Optional parameters.\n              \226\128\162 id : id of the extmark to edit.\n              \226\128\162 end_row : ending line of the mark, 0-based inclusive.\n              \226\128\162 end_col : ending col of the mark, 0-based exclusive.\n              \226\128\162 hl_group : highlight group used for the text range. This\n                and below highlight groups can be supplied either as a\n                string or as an integer, the latter of which can be\n                obtained using |nvim_get_hl_id_by_name()|.\n                Multiple highlight groups can be stacked by passing an\n                array (highest priority last).\n              \226\128\162 hl_eol : when true, for a multiline highlight covering the\n                EOL of a line, continue the highlight for the rest of the\n                screen line (just like for diff and cursorline highlight).\n              \226\128\162 virt_text : virtual text to link to this mark. A list of\n                `[text, highlight]` tuples, each representing a text chunk\n                with specified highlight. `highlight` element can either\n                be a single highlight group, or an array of multiple\n                highlight groups that will be stacked (highest priority\n                last).\n              \226\128\162 virt_text_pos : position of virtual text. Possible values:\n                \226\128\162 \"eol\": right after eol character (default).\n                \226\128\162 \"eol_right_align\": display right aligned in the window\n                  unless the virtual text is longer than the space\n                  available. If the virtual text is too long, it is\n                  truncated to fit in the window after the EOL character.\n                  If the line is wrapped, the virtual text is shown after\n                  the end of the line rather than the previous screen\n                  line.\n                \226\128\162 \"overlay\": display over the specified column, without\n                  shifting the underlying text.\n                \226\128\162 \"right_align\": display right aligned in the window.\n                \226\128\162 \"inline\": display at the specified column, and shift the\n                  buffer text to the right as needed.\n              \226\128\162 virt_text_win_col : position the virtual text at a fixed\n                window column (starting from the first text column of the\n                screen line) instead of \"virt_text_pos\".\n              \226\128\162 virt_text_hide : hide the virtual text when the background\n                text is selected or hidden because of scrolling with\n                'nowrap' or 'smoothscroll'. Currently only affects\n                \"overlay\" virt_text.\n              \226\128\162 virt_text_repeat_linebreak : repeat the virtual text on\n                wrapped lines.\n              \226\128\162 hl_mode : control how highlights are combined with the\n                highlights of the text. Currently only affects virt_text\n                highlights, but might affect `hl_group` in later versions.\n                \226\128\162 \"replace\": only show the virt_text color. This is the\n                  default.\n                \226\128\162 \"combine\": combine with background text color.\n                \226\128\162 \"blend\": blend with background text color. Not supported\n                  for \"inline\" virt_text.\n              \226\128\162 virt_lines : virtual lines to add next to this mark This\n                should be an array over lines, where each line in turn is\n                an array over `[text, highlight]` tuples. In general,\n                buffer and window options do not affect the display of the\n                text. In particular 'wrap' and 'linebreak' options do not\n                take effect, so the number of extra screen lines will\n                always match the size of the array. However the 'tabstop'\n                buffer option is still used for hard tabs. By default\n                lines are placed below the buffer line containing the\n                mark.\n              \226\128\162 virt_lines_above: place virtual lines above instead.\n              \226\128\162 virt_lines_leftcol: Place virtual lines in the leftmost\n                column of the window, bypassing sign and number columns.\n              \226\128\162 virt_lines_overflow: controls how to handle virtual lines\n                wider than the window. Currently takes the one of the\n                following values:\n                \226\128\162 \"trunc\": truncate virtual lines on the right (default).\n                \226\128\162 \"scroll\": virtual lines can scroll horizontally with\n                  'nowrap', otherwise the same as \"trunc\".\n              \226\128\162 ephemeral : for use with |nvim_set_decoration_provider()|\n                callbacks. The mark will only be used for the current\n                redraw cycle, and not be permanently stored in the buffer.\n              \226\128\162 right_gravity : boolean that indicates the direction the\n                extmark will be shifted in when new text is inserted (true\n                for right, false for left). Defaults to true.\n              \226\128\162 end_right_gravity : boolean that indicates the direction\n                the extmark end position (if it exists) will be shifted in\n                when new text is inserted (true for right, false for\n                left). Defaults to false.\n              \226\128\162 undo_restore : Restore the exact position of the mark if\n                text around the mark was deleted and then restored by\n                undo. Defaults to true.\n              \226\128\162 invalidate : boolean that indicates whether to hide the\n                extmark if the entirety of its range is deleted. For\n                hidden marks, an \"invalid\" key is added to the \"details\"\n                array of |nvim_buf_get_extmarks()| and family. If\n                \"undo_restore\" is false, the extmark is deleted instead.\n              \226\128\162 priority: a priority value for the highlight group, sign\n                attribute or virtual text. For virtual text, item with\n                highest priority is drawn last. For example treesitter\n                highlighting uses a value of 100.\n              \226\128\162 strict: boolean that indicates extmark should not be\n                placed if the line or column value is past the end of the\n                buffer or end of the line respectively. Defaults to true.\n              \226\128\162 sign_text: string of length 1-2 used to display in the\n                sign column.\n              \226\128\162 sign_hl_group: highlight group used for the sign column\n                text.\n              \226\128\162 number_hl_group: highlight group used for the number\n                column.\n              \226\128\162 line_hl_group: highlight group used for the whole line.\n              \226\128\162 cursorline_hl_group: highlight group used for the sign\n                column text when the cursor is on the same line as the\n                mark and 'cursorline' is enabled.\n              \226\128\162 conceal: string which should be either empty or a single\n                character. Enable concealing similar to |:syn-conceal|.\n                When a character is supplied it is used as |:syn-cchar|.\n                \"hl_group\" is used as highlight for the cchar if provided,\n                otherwise it defaults to |hl-Conceal|.\n              \226\128\162 conceal_lines: string which should be empty. When\n                provided, lines in the range are not drawn at all\n                (according to 'conceallevel'); the next unconcealed line\n                is drawn instead.\n              \226\128\162 spell: boolean indicating that spell checking should be\n                performed within this extmark\n              \226\128\162 ui_watched: boolean that indicates the mark should be\n                drawn by a UI. When set, the UI will receive win_extmark\n                events. Note: the mark is positioned by virt_text\n                attributes. Can be used together with virt_text.\n              \226\128\162 url: A URL to associate with this extmark. In the TUI, the\n                OSC 8 control sequence is used to generate a clickable\n                hyperlink to this URL.\n\nReturn: ~\n    Id of the created/updated extmark"}}, nvim_buf_set_keymap = {binding = "nvim_buf_set_keymap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "mode", "lhs", "rhs", "opts"}, ["fnl/docstring"] = "Sets a buffer-local |mapping| for the given mode.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n\nSee also: ~\n  \226\128\162 |nvim_set_keymap()|\n\n                                                    "}}, nvim_buf_set_lines = {binding = "nvim_buf_set_lines", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "start", "end", "strict_indexing", "replacement"}, ["fnl/docstring"] = "Sets (replaces) a line-range in the buffer.\n\nIndexing is zero-based, end-exclusive. Negative indices are interpreted as\nlength+1+index: -1 refers to the index past the end. So to change or\ndelete the last line use start=-2 and end=-1.\n\nTo insert lines at a given index, set `start` and `end` to the same index.\nTo delete a range of lines, set `replacement` to an empty array.\n\nOut-of-bounds indices are clamped to the nearest valid value, unless\n`strict_indexing` is set.\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}           Buffer id, or 0 for current buffer\n  \226\128\162 {start}            First line index\n  \226\128\162 {end}              Last line index, exclusive\n  \226\128\162 {strict_indexing}  Whether out-of-bounds should be an error.\n  \226\128\162 {replacement}      Array of lines to use as replacement\n\nSee also: ~\n  \226\128\162 |nvim_buf_set_text()|\n\n                                                     "}}, nvim_buf_set_mark = {binding = "nvim_buf_set_mark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name", "line", "col", "opts"}, ["fnl/docstring"] = "Sets a named mark in the given buffer, all marks are allowed\nfile/uppercase, visual, last change, etc. See |mark-motions|.\n\nMarks are (1,0)-indexed. |api-indexing|\n\nNote: ~\n  \226\128\162 Passing 0 as line deletes the mark\n\nAttributes: ~\n    Since: 0.6.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer to set the mark on\n  \226\128\162 {name}    Mark name\n  \226\128\162 {line}    Line number\n  \226\128\162 {col}     Column/row number\n  \226\128\162 {opts}    Optional parameters. Reserved for future use.\n\nReturn: ~\n    true if the mark was set, else false.\n\nSee also: ~\n  \226\128\162 |nvim_buf_del_mark()|\n  \226\128\162 |nvim_buf_get_mark()|"}}, nvim_buf_set_name = {binding = "nvim_buf_set_name", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name"}, ["fnl/docstring"] = "Sets the full file name for a buffer, like |:file_f|\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {name}    Buffer name\n\n                                                     "}}, nvim_buf_set_text = {binding = "nvim_buf_set_text", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "start_row", "start_col", "end_row", "end_col", "replacement"}, ["fnl/docstring"] = "Sets (replaces) a range in the buffer\n\nThis is recommended over |nvim_buf_set_lines()| when only modifying parts\nof a line, as extmarks will be preserved on non-modified parts of the\ntouched lines.\n\nIndexing is zero-based. Row indices are end-inclusive, and column indices\nare end-exclusive.\n\nTo insert text at a given `(row, column)` location, use\n`start_row = end_row = row` and `start_col = end_col = col`. To delete the\ntext in a range, use `replacement = {}`.\n\nNote: ~\n  \226\128\162 Prefer |nvim_buf_set_lines()| (for performance) to add or delete\n    entire lines.\n  \226\128\162 Prefer |nvim_paste()| or |nvim_put()| to insert (instead of replace)\n    text at cursor.\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}       Buffer id, or 0 for current buffer\n  \226\128\162 {start_row}    First line index\n  \226\128\162 {start_col}    Starting column (byte offset) on first line\n  \226\128\162 {end_row}      Last line index, inclusive\n  \226\128\162 {end_col}      Ending column (byte offset) on last line, exclusive\n  \226\128\162 {replacement}  Array of lines to use as replacement"}}, nvim_buf_set_var = {binding = "nvim_buf_set_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "name", "value"}, ["fnl/docstring"] = "Sets a buffer-scoped (b:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id, or 0 for current buffer\n  \226\128\162 {name}    Variable name\n  \226\128\162 {value}   Variable value"}}, nvim_call_dict_function = {binding = "nvim_call_dict_function", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict", "fn", "args"}, ["fnl/docstring"] = "Calls a Vimscript |Dictionary-function| with the given arguments.\n\nOn execution error: fails with Vimscript error, updates v:errmsg.\n\nAttributes: ~\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {dict}  Dict, or String evaluating to a Vimscript |self| dict\n  \226\128\162 {fn}    Name of the function defined on the Vimscript dict\n  \226\128\162 {args}  Function arguments packed in an Array\n\nReturn: ~\n    Result of the function call"}}, nvim_call_function = {binding = "nvim_call_function", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fn", "args"}, ["fnl/docstring"] = "Calls a Vimscript function with the given arguments.\n\nOn execution error: fails with Vimscript error, updates v:errmsg.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {fn}    Function to call\n  \226\128\162 {args}  Function arguments packed in an Array\n\nReturn: ~\n    Result of the function call"}}, nvim_chan_send = {binding = "nvim_chan_send", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"chan", "data"}, ["fnl/docstring"] = "Send data to channel `id`. For a job, it writes it to the stdin of the\nprocess. For the stdio channel |channel-stdio|, it writes to Nvim's\nstdout. For an internal terminal instance (|nvim_open_term()|) it writes\ndirectly to terminal output. See |channel-bytes| for more information.\n\nThis function writes raw data, not RPC messages. If the channel was\ncreated with `rpc=true` then the channel expects RPC messages, use\n|vim.rpcnotify()| and |vim.rpcrequest()| instead.\n\nAttributes: ~\n    |RPC| only\n    Lua |vim.api| only\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {chan}  id of the channel\n  \226\128\162 {data}  data to write. 8-bit clean: can contain NUL bytes."}}, nvim_clear_autocmds = {binding = "nvim_clear_autocmds", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "Clears all autocommands selected by {opts}. To delete autocmds see\n|nvim_del_autocmd()|.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {opts}  Parameters\n            \226\128\162 event: (string|table) Examples:\n              \226\128\162 event: \"pat1\"\n              \226\128\162 event: { \"pat1\" }\n              \226\128\162 event: { \"pat1\", \"pat2\", \"pat3\" }\n            \226\128\162 pattern: (string|table)\n              \226\128\162 pattern or patterns to match exactly.\n                \226\128\162 For example, if you have `*.py` as that pattern for the\n                  autocmd, you must pass `*.py` exactly to clear it.\n                  `test.py` will not match the pattern.\n              \226\128\162 defaults to clearing all patterns.\n              \226\128\162 NOTE: Cannot be used with {buffer}\n            \226\128\162 buffer: (bufnr)\n              \226\128\162 clear only |autocmd-buflocal| autocommands.\n              \226\128\162 NOTE: Cannot be used with {pattern}\n            \226\128\162 group: (string|int) The augroup name or id.\n              \226\128\162 NOTE: If not passed, will only delete autocmds not in any\n                group."}}, nvim_cmd = {binding = "nvim_cmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "opts"}, ["fnl/docstring"] = "Executes an Ex command.\n\nUnlike |nvim_command()| this command takes a structured Dict instead of a\nString. This allows for easier construction and manipulation of an Ex\ncommand. This also allows for things such as having spaces inside a\ncommand argument, expanding filenames in a command that otherwise doesn't\nexpand filenames, etc. Command arguments may also be Number, Boolean or\nString.\n\nThe first argument may also be used instead of count for commands that\nsupport it in order to make their usage simpler with |vim.cmd()|. For\nexample, instead of `vim.cmd.bdelete{ count = 2 }`, you may do\n`vim.cmd.bdelete(2)`.\n\nOn execution error: fails with Vimscript error, updates v:errmsg.\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {cmd}   Command to execute. Must be a Dict that can contain the same\n            values as the return value of |nvim_parse_cmd()| except\n            \"addr\", \"nargs\" and \"nextcmd\" which are ignored if provided.\n            All values except for \"cmd\" are optional.\n  \226\128\162 {opts}  Optional parameters.\n            \226\128\162 output: (boolean, default false) Whether to return command\n              output.\n\nReturn: ~\n    Command output (non-error, non-shell |:!|) if `output` is true, else\n    empty string.\n\nSee also: ~\n  \226\128\162 |nvim_exec2()|\n  \226\128\162 |nvim_command()|\n\n                                              "}}, nvim_command = {binding = "nvim_command", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"command"}, ["fnl/docstring"] = "Executes an Ex command.\n\nOn execution error: fails with Vimscript error, updates v:errmsg.\n\nPrefer |nvim_cmd()| or |nvim_exec2()| instead. To modify an Ex command in\na structured way before executing it, modify the result of\n|nvim_parse_cmd()| then pass it to |nvim_cmd()|.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {command}  Ex command string"}}, nvim_create_augroup = {binding = "nvim_create_augroup", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "opts"}, ["fnl/docstring"] = "Create or get an autocommand group |autocmd-groups|.\n\nTo get an existing group id, do: >lua\n    local id = vim.api.nvim_create_augroup('my.lsp.config', {\n        clear = false\n    })\n<\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {name}  String: The name of the group\n  \226\128\162 {opts}  Dict Parameters\n            \226\128\162 clear (bool) optional: defaults to true. Clear existing\n              commands if the group already exists |autocmd-groups|.\n\nReturn: ~\n    Integer id of the created group.\n\nSee also: ~\n  \226\128\162 |autocmd-groups|"}}, nvim_create_autocmd = {binding = "nvim_create_autocmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"event", "opts"}, ["fnl/docstring"] = "Creates an |autocommand| event handler, defined by `callback` (Lua\nfunction or Vimscript function name string) or `command` (Ex command\nstring).\n\nExample using Lua callback: >lua\n    vim.api.nvim_create_autocmd({'BufEnter', 'BufWinEnter'}, {\n      pattern = {'*.c', '*.h'},\n      callback = function(ev)\n        print(string.format('event fired: %s', vim.inspect(ev)))\n      end\n    })\n<\n\nExample using an Ex command as the handler: >lua\n    vim.api.nvim_create_autocmd({'BufEnter', 'BufWinEnter'}, {\n      pattern = {'*.c', '*.h'},\n      command = \"echo 'Entering a C or C++ file'\",\n    })\n<\n\nNote: `pattern` is NOT automatically expanded (unlike with |:autocmd|),\nthus names like \"$HOME\" and \"~\" must be expanded explicitly: >lua\n    pattern = vim.fn.expand('~') .. '/some/path/*.py'\n<\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {event}  (string|array) Event(s) that will trigger the handler\n             (`callback` or `command`).\n  \226\128\162 {opts}   Options dict:\n             \226\128\162 group (string|integer) optional: autocommand group name or\n               id to match against.\n             \226\128\162 pattern (string|array) optional: pattern(s) to match\n               literally |autocmd-pattern|.\n             \226\128\162 buffer (integer) optional: buffer number for buffer-local\n               autocommands |autocmd-buflocal|. Cannot be used with\n               {pattern}.\n             \226\128\162 desc (string) optional: description (for documentation and\n               troubleshooting).\n             \226\128\162 callback (function|string) optional: Lua function (or\n               Vimscript function name, if string) called when the\n               event(s) is triggered. Lua callback can return a truthy\n               value (not `false` or `nil`) to delete the autocommand, and\n               receives one argument, a table with these keys:\n                                                              *event-args*\n               \226\128\162 id: (number) autocommand id\n               \226\128\162 event: (string) name of the triggered event\n                 |autocmd-events|\n               \226\128\162 group: (number|nil) autocommand group id, if any\n               \226\128\162 file: (string) <afile> (not expanded to a full path)\n               \226\128\162 match: (string) <amatch> (expanded to a full path)\n               \226\128\162 buf: (number) <abuf>\n               \226\128\162 data: (any) arbitrary data passed from\n                 |nvim_exec_autocmds()|                       *event-data*\n             \226\128\162 command (string) optional: Vim command to execute on event.\n               Cannot be used with {callback}\n             \226\128\162 once (boolean) optional: defaults to false. Run the\n               autocommand only once |autocmd-once|.\n             \226\128\162 nested (boolean) optional: defaults to false. Run nested\n               autocommands |autocmd-nested|.\n\nReturn: ~\n    Autocommand id (number)\n\nSee also: ~\n  \226\128\162 |autocommand|\n  \226\128\162 |nvim_del_autocmd()|"}}, nvim_create_buf = {binding = "nvim_create_buf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"listed", "scratch"}, ["fnl/docstring"] = "Creates a new, empty, unnamed buffer.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {listed}   Sets 'buflisted'\n  \226\128\162 {scratch}  Creates a \"throwaway\" |scratch-buffer| for temporary work\n               (always 'nomodified'). Also sets 'nomodeline' on the\n               buffer.\n\nReturn: ~\n    Buffer id, or 0 on error\n\nSee also: ~\n  \226\128\162 buf_open_scratch"}}, nvim_create_namespace = {binding = "nvim_create_namespace", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Creates a new namespace or gets an existing one.               *namespace*\n\nNamespaces are used for buffer highlights and virtual text, see\n|nvim_buf_set_extmark()|.\n\nNamespaces can be named or anonymous. If `name` matches an existing\nnamespace, the associated id is returned. If `name` is an empty string a\nnew, anonymous namespace is created.\n\nAttributes: ~\n    Since: 0.3.2\n\nParameters: ~\n  \226\128\162 {name}  Namespace name or empty string\n\nReturn: ~\n    Namespace id"}}, nvim_create_user_command = {binding = "nvim_create_user_command", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "command", "opts"}, ["fnl/docstring"] = "Creates a global |user-commands| command.\n\nFor Lua usage see |lua-guide-commands-create|.\n\nExample: >vim\n    :call nvim_create_user_command('SayHello', 'echo \"Hello world!\"', {'bang': v:true})\n    :SayHello\n    Hello world!\n<\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {name}     Name of the new user command. Must begin with an uppercase\n               letter.\n  \226\128\162 {command}  Replacement command to execute when this user command is\n               executed. When called from Lua, the command can also be a\n               Lua function. The function is called with a single table\n               argument that contains the following keys:\n               \226\128\162 name: (string) Command name\n               \226\128\162 args: (string) The args passed to the command, if any\n                 <args>\n               \226\128\162 fargs: (table) The args split by unescaped whitespace\n                 (when more than one argument is allowed), if any <f-args>\n               \226\128\162 nargs: (string) Number of arguments |:command-nargs|\n               \226\128\162 bang: (boolean) \"true\" if the command was executed with a\n                 ! modifier <bang>\n               \226\128\162 line1: (number) The starting line of the command range\n                 <line1>\n               \226\128\162 line2: (number) The final line of the command range\n                 <line2>\n               \226\128\162 range: (number) The number of items in the command range:\n                 0, 1, or 2 <range>\n               \226\128\162 count: (number) Any count supplied <count>\n               \226\128\162 reg: (string) The optional register, if specified <reg>\n               \226\128\162 mods: (string) Command modifiers, if any <mods>\n               \226\128\162 smods: (table) Command modifiers in a structured format.\n                 Has the same structure as the \"mods\" key of\n                 |nvim_parse_cmd()|.\n  \226\128\162 {opts}     Optional |command-attributes|.\n               \226\128\162 Set boolean attributes such as |:command-bang| or\n                 |:command-bar| to true (but not |:command-buffer|, use\n                 |nvim_buf_create_user_command()| instead).\n               \226\128\162 \"complete\" |:command-complete| also accepts a Lua\n                 function which works like\n                 |:command-completion-customlist|.\n               \226\128\162 Other parameters:\n                 \226\128\162 desc: (string) Used for listing the command when a Lua\n                   function is used for {command}.\n                 \226\128\162 force: (boolean, default true) Override any previous\n                   definition.\n                 \226\128\162 preview: (function) Preview callback for 'inccommand'\n                   |:command-preview|"}}, nvim_del_augroup_by_id = {binding = "nvim_del_augroup_by_id", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id"}, ["fnl/docstring"] = "Delete an autocommand group by id.\n\nTo get a group id one can use |nvim_get_autocmds()|.\n\nNOTE: behavior differs from |:augroup-delete|. When deleting a group,\nautocommands contained in this group will also be deleted and cleared.\nThis group will no longer exist.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {id}  Integer The id of the group.\n\nSee also: ~\n  \226\128\162 |nvim_del_augroup_by_name()|\n  \226\128\162 |nvim_create_augroup()|"}}, nvim_del_augroup_by_name = {binding = "nvim_del_augroup_by_name", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Delete an autocommand group by name.\n\nNOTE: behavior differs from |:augroup-delete|. When deleting a group,\nautocommands contained in this group will also be deleted and cleared.\nThis group will no longer exist.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {name}  String The name of the group.\n\nSee also: ~\n  \226\128\162 |autocmd-groups|"}}, nvim_del_autocmd = {binding = "nvim_del_autocmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id"}, ["fnl/docstring"] = "Deletes an autocommand by id.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {id}  Integer Autocommand id returned by |nvim_create_autocmd()|"}}, nvim_del_current_line = {binding = "nvim_del_current_line", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Deletes the current line.\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.1.0"}}, nvim_del_keymap = {binding = "nvim_del_keymap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"mode", "lhs"}, ["fnl/docstring"] = "Unmaps a global |mapping| for the given mode.\n\nTo unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.\n\nAttributes: ~\n    Since: 0.4.0\n\nSee also: ~\n  \226\128\162 |nvim_set_keymap()|"}}, nvim_del_mark = {binding = "nvim_del_mark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Deletes an uppercase/file named mark. See |mark-motions|.\n\nNote: ~\n  \226\128\162 Lowercase name (or other buffer-local mark) is an error.\n\nAttributes: ~\n    Since: 0.6.0\n\nParameters: ~\n  \226\128\162 {name}  Mark name\n\nReturn: ~\n    true if the mark was deleted, else false.\n\nSee also: ~\n  \226\128\162 |nvim_buf_del_mark()|\n  \226\128\162 |nvim_get_mark()|"}}, nvim_del_user_command = {binding = "nvim_del_user_command", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Delete a user-defined command.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {name}  Name of the command to delete."}}, nvim_del_var = {binding = "nvim_del_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Removes a global (g:) variable.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {name}  Variable name"}}, nvim_echo = {binding = "nvim_echo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"chunks", "history", "opts"}, ["fnl/docstring"] = "Prints a message given by a list of `[text, hl_group]` \"chunks\".\n\nExample: >lua\n    vim.api.nvim_echo({ { 'chunk1-line1\\nchunk1-line2\\n' }, { 'chunk2-line1' } }, true, {})\n<\n\nAttributes: ~\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {chunks}   List of `[text, hl_group]` pairs, where each is a `text`\n               string highlighted by the (optional) name or ID `hl_group`.\n  \226\128\162 {history}  if true, add to |message-history|.\n  \226\128\162 {opts}     Optional parameters.\n               \226\128\162 err: Treat the message like `:echoerr`. Sets `hl_group`\n                 to |hl-ErrorMsg| by default.\n               \226\128\162 verbose: Message is controlled by the 'verbose' option.\n                 Nvim invoked with `-V3log` will write the message to the\n                 \"log\" file instead of standard output."}}, nvim_err_write = {binding = "nvim_err_write", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |nvim_echo()| with `{err=true}`."}}, nvim_err_writeln = {binding = "nvim_err_writeln", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |nvim_echo()| with `{err=true}`."}}, nvim_eval = {binding = "nvim_eval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Evaluates a Vimscript |expression|. Dicts and Lists are recursively\nexpanded.\n\nOn execution error: fails with Vimscript error, updates v:errmsg.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {expr}  Vimscript expression string\n\nReturn: ~\n    Evaluation result or expanded object"}}, nvim_eval_statusline = {binding = "nvim_eval_statusline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "opts"}, ["fnl/docstring"] = "Evaluates statusline string.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.6.0\n\nParameters: ~\n  \226\128\162 {str}   Statusline string (see 'statusline').\n  \226\128\162 {opts}  Optional parameters.\n            \226\128\162 winid: (number) |window-ID| of the window to use as context\n              for statusline.\n            \226\128\162 maxwidth: (number) Maximum width of statusline.\n            \226\128\162 fillchar: (string) Character to fill blank spaces in the\n              statusline (see 'fillchars'). Treated as single-width even\n              if it isn't.\n            \226\128\162 highlights: (boolean) Return highlight information.\n            \226\128\162 use_winbar: (boolean) Evaluate winbar instead of statusline.\n            \226\128\162 use_tabline: (boolean) Evaluate tabline instead of\n              statusline. When true, {winid} is ignored. Mutually\n              exclusive with {use_winbar}.\n            \226\128\162 use_statuscol_lnum: (number) Evaluate statuscolumn for this\n              line number instead of statusline.\n\nReturn: ~\n    Dict containing statusline information, with these keys:\n    \226\128\162 str: (string) Characters that will be displayed on the statusline.\n    \226\128\162 width: (number) Display width of the statusline.\n    \226\128\162 highlights: Array containing highlight information of the\n      statusline. Only included when the \"highlights\" key in {opts} is\n      true. Each element of the array is a |Dict| with these keys:\n      \226\128\162 start: (number) Byte index (0-based) of first character that uses\n        the highlight.\n      \226\128\162 group: (string) Deprecated. Use `groups` instead.\n      \226\128\162 groups: (array) Names of stacked highlight groups (highest\n        priority last)."}}, nvim_exec2 = {binding = "nvim_exec2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"src", "opts"}, ["fnl/docstring"] = "Executes Vimscript (multiline block of Ex commands), like anonymous\n|:source|.\n\nUnlike |nvim_command()| this function supports heredocs, script-scope\n(s:), etc.\n\nOn execution error: fails with Vimscript error, updates v:errmsg.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {src}   Vimscript code\n  \226\128\162 {opts}  Optional parameters.\n            \226\128\162 output: (boolean, default false) Whether to capture and\n              return all (non-error, non-shell |:!|) output.\n\nReturn: ~\n    Dict containing information about execution, with these keys:\n    \226\128\162 output: (string|nil) Output if `opts.output` is true.\n\nSee also: ~\n  \226\128\162 |execute()|\n  \226\128\162 |nvim_command()|\n  \226\128\162 |nvim_cmd()|\n\n                                                 "}}, nvim_exec_autocmds = {binding = "nvim_exec_autocmds", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"event", "opts"}, ["fnl/docstring"] = "Execute all autocommands for {event} that match the corresponding {opts}\n|autocmd-execute|.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {event}  (String|Array) The event or events to execute\n  \226\128\162 {opts}   Dict of autocommand options:\n             \226\128\162 group (string|integer) optional: the autocommand group name\n               or id to match against. |autocmd-groups|.\n             \226\128\162 pattern (string|array) optional: defaults to \"*\"\n               |autocmd-pattern|. Cannot be used with {buffer}.\n             \226\128\162 buffer (integer) optional: buffer number\n               |autocmd-buflocal|. Cannot be used with {pattern}.\n             \226\128\162 modeline (bool) optional: defaults to true. Process the\n               modeline after the autocommands <nomodeline>.\n             \226\128\162 data (any): arbitrary data to send to the autocommand\n               callback. See |nvim_create_autocmd()| for details.\n\nSee also: ~\n  \226\128\162 |:doautocmd|"}}, nvim_exec_lua = {binding = "nvim_exec_lua", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"code", "args"}, ["fnl/docstring"] = "Execute Lua code. Parameters (if any) are available as `...` inside the\nchunk. The chunk can return a value.\n\nOnly statements are executed. To evaluate an expression, prefix it with\n`return`: return my_function(...)\n\nAttributes: ~\n    |RPC| only\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {code}  Lua code to execute\n  \226\128\162 {args}  Arguments to the code\n\nReturn: ~\n    Return value of Lua code if present or NIL."}}, nvim_feedkeys = {binding = "nvim_feedkeys", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"keys", "mode", "escape_ks"}, ["fnl/docstring"] = "Sends input-keys to Nvim, subject to various quirks controlled by `mode`\nflags. This is a blocking call, unlike |nvim_input()|.\n\nOn execution error: does not fail, but updates v:errmsg.\n\nTo input sequences like <C-o> use |nvim_replace_termcodes()| (typically\nwith escape_ks=false) to replace |keycodes|, then pass the result to\nnvim_feedkeys().\n\nExample: >vim\n    :let key = nvim_replace_termcodes(\"<C-o>\", v:true, v:false, v:true)\n    :call nvim_feedkeys(key, 'n', v:false)\n<\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {keys}       to be typed\n  \226\128\162 {mode}       behavior flags, see |feedkeys()|\n  \226\128\162 {escape_ks}  If true, escape K_SPECIAL bytes in `keys`. This should be\n                 false if you already used |nvim_replace_termcodes()|, and\n                 true otherwise.\n\nSee also: ~\n  \226\128\162 feedkeys()\n  \226\128\162 vim_strsave_escape_ks"}}, nvim_get_all_options_info = {binding = "nvim_get_all_options_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the option information for all options.\n\nThe dict has the full option names as keys and option metadata dicts as\ndetailed at |nvim_get_option_info2()|.\n\nAttributes: ~\n    Since: 0.5.0\n\nReturn: ~\n    dict of all options\n\nSee also: ~\n  \226\128\162 |nvim_get_commands()|"}}, nvim_get_api_info = {binding = "nvim_get_api_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a 2-tuple (Array), where item 0 is the current channel id and item\n1 is the |api-metadata| map (Dict).\n\nAttributes: ~\n    |api-fast|\n    |RPC| only\n    Since: 0.1.0\n\nReturn: ~\n    2-tuple `[{channel-id}, {api-metadata}]`"}}, nvim_get_autocmds = {binding = "nvim_get_autocmds", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "Get all autocommands that match the corresponding {opts}.\n\nThese examples will get autocommands matching ALL the given criteria: >lua\n    -- Matches all criteria\n    autocommands = vim.api.nvim_get_autocmds({\n      group = 'MyGroup',\n      event = {'BufEnter', 'BufWinEnter'},\n      pattern = {'*.c', '*.h'}\n    })\n\n    -- All commands from one group\n    autocommands = vim.api.nvim_get_autocmds({\n      group = 'MyGroup',\n    })\n<\n\nNOTE: When multiple patterns or events are provided, it will find all the\nautocommands that match any combination of them.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {opts}  Dict with at least one of the following:\n            \226\128\162 buffer: (integer) Buffer number or list of buffer numbers\n              for buffer local autocommands |autocmd-buflocal|. Cannot be\n              used with {pattern}\n            \226\128\162 event: (string|table) event or events to match against\n              |autocmd-events|.\n            \226\128\162 id: (integer) Autocommand ID to match.\n            \226\128\162 group: (string|table) the autocommand group name or id to\n              match against.\n            \226\128\162 pattern: (string|table) pattern or patterns to match against\n              |autocmd-pattern|. Cannot be used with {buffer}\n\nReturn: ~\n    Array of autocommands matching the criteria, with each item containing\n    the following fields:\n    \226\128\162 buffer: (integer) the buffer number.\n    \226\128\162 buflocal: (boolean) true if the autocommand is buffer local.\n    \226\128\162 command: (string) the autocommand command. Note: this will be empty\n      if a callback is set.\n    \226\128\162 callback: (function|string|nil): Lua function or name of a Vim\n      script function which is executed when this autocommand is\n      triggered.\n    \226\128\162 desc: (string) the autocommand description.\n    \226\128\162 event: (string) the autocommand event.\n    \226\128\162 id: (integer) the autocommand id (only when defined with the API).\n    \226\128\162 group: (integer) the autocommand group id.\n    \226\128\162 group_name: (string) the autocommand group name.\n    \226\128\162 once: (boolean) whether the autocommand is only run once.\n    \226\128\162 pattern: (string) the autocommand pattern. If the autocommand is\n      buffer local |autocmd-buffer-local|:"}}, nvim_get_chan_info = {binding = "nvim_get_chan_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"chan"}, ["fnl/docstring"] = "Gets information about a channel.\n\nSee |nvim_list_uis()| for an example of how to get channel info.\n\nAttributes: ~\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {chan}  channel_id, or 0 for current channel\n\nReturn: ~\n    Channel info dict with these keys:\n    \226\128\162 \"id\" Channel id.\n    \226\128\162 \"argv\" (optional) Job arguments list.\n    \226\128\162 \"stream\" Stream underlying the channel.\n      \226\128\162 \"stdio\" stdin and stdout of this Nvim instance\n      \226\128\162 \"stderr\" stderr of this Nvim instance\n      \226\128\162 \"socket\" TCP/IP socket or named pipe\n      \226\128\162 \"job\" Job with communication over its stdio.\n    \226\128\162 \"mode\" How data received on the channel is interpreted.\n      \226\128\162 \"bytes\" Send and receive raw bytes.\n      \226\128\162 \"terminal\" |terminal| instance interprets ASCII sequences.\n      \226\128\162 \"rpc\" |RPC| communication on the channel is active.\n    \226\128\162 \"pty\" (optional) Name of pseudoterminal. On a POSIX system this is a\n      device path like \"/dev/pts/1\". If unknown, the key will still be\n      present if a pty is used (e.g. for conpty on Windows).\n    \226\128\162 \"buffer\" (optional) Buffer connected to |terminal| instance.\n    \226\128\162 \"client\" (optional) Info about the peer (client on the other end of\n      the channel), as set by |nvim_set_client_info()|."}}, nvim_get_color_by_name = {binding = "nvim_get_color_by_name", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Returns the 24-bit RGB value of a |nvim_get_color_map()| color name or\n\"#rrggbb\" hexadecimal string.\n\nExample: >vim\n    :echo nvim_get_color_by_name(\"Pink\")\n    :echo nvim_get_color_by_name(\"#cbcbcb\")\n<\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {name}  Color name or \"#rrggbb\" string\n\nReturn: ~\n    24-bit RGB value, or -1 for invalid argument."}}, nvim_get_color_map = {binding = "nvim_get_color_map", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a map of color names and RGB values.\n\nKeys are color names (e.g. \"Aqua\") and values are 24-bit RGB color values\n(e.g. 65535).\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    Map of color names and RGB values."}}, nvim_get_commands = {binding = "nvim_get_commands", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "Gets a map of global (non-buffer-local) Ex commands.\n\nCurrently only |user-commands| are supported, not builtin Ex commands.\n\nAttributes: ~\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {opts}  Optional parameters. Currently only supports {\"builtin\":false}\n\nReturn: ~\n    Map of maps describing commands.\n\nSee also: ~\n  \226\128\162 |nvim_get_all_options_info()|"}}, nvim_get_context = {binding = "nvim_get_context", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "Gets a map of the current editor state.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {opts}  Optional parameters.\n            \226\128\162 types: List of |context-types| (\"regs\", \"jumps\", \"bufs\",\n              \"gvars\", \226\128\166) to gather, or empty for \"all\".\n\nReturn: ~\n    map of global |context|."}}, nvim_get_current_buf = {binding = "nvim_get_current_buf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current buffer.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    Buffer id"}}, nvim_get_current_line = {binding = "nvim_get_current_line", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current line.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    Current line string"}}, nvim_get_current_tabpage = {binding = "nvim_get_current_tabpage", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current tabpage.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    |tab-ID|"}}, nvim_get_current_win = {binding = "nvim_get_current_win", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current window.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    |window-ID|"}}, nvim_get_hl = {binding = "nvim_get_hl", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id", "opts"}, ["fnl/docstring"] = "Gets all or specific highlight groups in a namespace.\n\nNote: ~\n  \226\128\162 When the `link` attribute is defined in the highlight definition map,\n    other attributes will not be taking effect (see |:hi-link|).\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {ns_id}  Get highlight groups for namespace ns_id\n             |nvim_get_namespaces()|. Use 0 to get global highlight groups\n             |:highlight|.\n  \226\128\162 {opts}   Options dict:\n             \226\128\162 name: (string) Get a highlight definition by name.\n             \226\128\162 id: (integer) Get a highlight definition by id.\n             \226\128\162 link: (boolean, default true) Show linked group name\n               instead of effective definition |:hi-link|.\n             \226\128\162 create: (boolean, default true) When highlight group\n               doesn't exist create it.\n\nReturn: ~\n    Highlight groups as a map from group name to a highlight definition\n    map as in |nvim_set_hl()|, or only a single highlight definition map\n    if requested by name or id."}}, nvim_get_hl_id_by_name = {binding = "nvim_get_hl_id_by_name", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Gets a highlight group by name\n\nsimilar to |hlID()|, but allocates a new ID if not present.\n\nAttributes: ~\n    Since: 0.5.0"}}, nvim_get_hl_ns = {binding = "nvim_get_hl_ns", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "Gets the active highlight namespace.\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {opts}  Optional parameters\n            \226\128\162 winid: (number) |window-ID| for retrieving a window's\n              highlight namespace. A value of -1 is returned when\n              |nvim_win_set_hl_ns()| has not been called for the window\n              (or was called with a namespace of -1).\n\nReturn: ~\n    Namespace id, or -1"}}, nvim_get_keymap = {binding = "nvim_get_keymap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"mode"}, ["fnl/docstring"] = "Gets a list of global (non-buffer-local) |mapping| definitions.\n\nAttributes: ~\n    Since: 0.2.1\n\nParameters: ~\n  \226\128\162 {mode}  Mode short-name (\"n\", \"i\", \"v\", ...)\n\nReturn: ~\n    Array of |maparg()|-like dictionaries describing mappings. The\n    \"buffer\" key is always zero."}}, nvim_get_mark = {binding = "nvim_get_mark", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "opts"}, ["fnl/docstring"] = "Returns a `(row, col, buffer, buffername)` tuple representing the position\nof the uppercase/file named mark. \"End of line\" column position is\nreturned as |v:maxcol| (big number). See |mark-motions|.\n\nMarks are (1,0)-indexed. |api-indexing|\n\nNote: ~\n  \226\128\162 Lowercase name (or other buffer-local mark) is an error.\n\nAttributes: ~\n    Since: 0.6.0\n\nParameters: ~\n  \226\128\162 {name}  Mark name\n  \226\128\162 {opts}  Optional parameters. Reserved for future use.\n\nReturn: ~\n    4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if the mark is\n    not set.\n\nSee also: ~\n  \226\128\162 |nvim_buf_set_mark()|\n  \226\128\162 |nvim_del_mark()|"}}, nvim_get_mode = {binding = "nvim_get_mode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current mode. |mode()| \"blocking\" is true if Nvim is waiting for\ninput.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.2.0\n\nReturn: ~\n    Dict { \"mode\": String, \"blocking\": Boolean }"}}, nvim_get_namespaces = {binding = "nvim_get_namespaces", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets existing, non-anonymous |namespace|s.\n\nAttributes: ~\n    Since: 0.3.2\n\nReturn: ~\n    dict that maps from names to namespace ids.\n\n                                          "}}, nvim_get_option_info2 = {binding = "nvim_get_option_info2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "opts"}, ["fnl/docstring"] = "Gets the option information for one option from arbitrary buffer or window\n\nResulting dict has keys:\n\226\128\162 name: Name of the option (like 'filetype')\n\226\128\162 shortname: Shortened name of the option (like 'ft')\n\226\128\162 type: type of option (\"string\", \"number\" or \"boolean\")\n\226\128\162 default: The default value for the option\n\226\128\162 was_set: Whether the option was set.\n\226\128\162 last_set_sid: Last set script id (if any)\n\226\128\162 last_set_linenr: line number where option was set\n\226\128\162 last_set_chan: Channel where option was set (0 for local)\n\226\128\162 scope: one of \"global\", \"win\", or \"buf\"\n\226\128\162 global_local: whether win or buf option has a global value\n\226\128\162 commalist: List of comma separated values\n\226\128\162 flaglist: List of single char flags\n\nWhen {scope} is not provided, the last set information applies to the\nlocal value in the current buffer or window if it is available, otherwise\nthe global value information is returned. This behavior can be disabled by\nexplicitly specifying {scope} in the {opts} table.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {name}  Option name\n  \226\128\162 {opts}  Optional parameters\n            \226\128\162 scope: One of \"global\" or \"local\". Analogous to |:setglobal|\n              and |:setlocal|, respectively.\n            \226\128\162 win: |window-ID|. Used for getting window local options.\n            \226\128\162 buf: Buffer number. Used for getting buffer local options.\n              Implies {scope} is \"local\".\n\nReturn: ~\n    Option Information"}}, nvim_get_option_value = {binding = "nvim_get_option_value", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "opts"}, ["fnl/docstring"] = "Gets the value of an option. The behavior of this function matches that of\n|:set|: the local value of an option is returned if it exists; otherwise,\nthe global value is returned. Local values always correspond to the\ncurrent buffer or window, unless \"buf\" or \"win\" is set in {opts}.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {name}  Option name\n  \226\128\162 {opts}  Optional parameters\n            \226\128\162 scope: One of \"global\" or \"local\". Analogous to |:setglobal|\n              and |:setlocal|, respectively.\n            \226\128\162 win: |window-ID|. Used for getting window local options.\n            \226\128\162 buf: Buffer number. Used for getting buffer local options.\n              Implies {scope} is \"local\".\n            \226\128\162 filetype: |filetype|. Used to get the default option for a\n              specific filetype. Cannot be used with any other option.\n              Note: this will trigger |ftplugin| and all |FileType|\n              autocommands for the corresponding filetype.\n\nReturn: ~\n    Option value\n\n                                                 "}}, nvim_get_proc = {binding = "nvim_get_proc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pid"}, ["fnl/docstring"] = "Gets info describing process `pid`.\n\nAttributes: ~\n    Since: 0.3.0\n\nReturn: ~\n    Map of process properties, or NIL if process not found."}}, nvim_get_proc_children = {binding = "nvim_get_proc_children", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pid"}, ["fnl/docstring"] = "Gets the immediate children of process `pid`.\n\nAttributes: ~\n    Since: 0.3.0\n\nReturn: ~\n    Array of child process ids, empty if process not found."}}, nvim_get_runtime_file = {binding = "nvim_get_runtime_file", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "all"}, ["fnl/docstring"] = "Finds files in runtime directories, in 'runtimepath' order.\n\n\"name\" can contain wildcards. For example\n`nvim_get_runtime_file(\"colors/*.{vim,lua}\", true)` will return all color\nscheme files. Always use forward slashes (/) in the search pattern for\nsubdirectories regardless of platform.\n\nIt is not an error to not find any files. An empty array is returned then.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {name}  pattern of files to search for\n  \226\128\162 {all}   whether to return all matches or only the first\n\nReturn: ~\n    list of absolute paths to the found files"}}, nvim_get_var = {binding = "nvim_get_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Gets a global (g:) variable.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {name}  Variable name\n\nReturn: ~\n    Variable value"}}, nvim_get_vvar = {binding = "nvim_get_vvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Gets a v: variable.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {name}  Variable name\n\nReturn: ~\n    Variable value"}}, nvim_input = {binding = "nvim_input", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"keys"}, ["fnl/docstring"] = "Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a low-level\ninput buffer and the call is non-blocking (input is processed\nasynchronously by the eventloop).\n\nTo input blocks of text, |nvim_paste()| is much faster and should be\npreferred.\n\nOn execution error: does not fail, but updates v:errmsg.\n\nNote: ~\n  \226\128\162 |keycodes| like <CR> are translated, so \"<\" is special. To input a\n    literal \"<\", send <LT>.\n  \226\128\162 For mouse events use |nvim_input_mouse()|. The pseudokey form\n    `<LeftMouse><col,row>` is deprecated since |api-level| 6.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {keys}  to be typed\n\nReturn: ~\n    Number of bytes actually written (can be fewer than requested if the\n    buffer becomes full).\n\n                                                      "}}, nvim_input_mouse = {binding = "nvim_input_mouse", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"button", "action", "modifier", "grid", "row", "col"}, ["fnl/docstring"] = "Send mouse event from GUI.\n\nNon-blocking: does not wait on any result, but queues the event to be\nprocessed soon by the event loop.\n\nNote: ~\n  \226\128\162 Currently this doesn't support \"scripting\" multiple mouse events by\n    calling it multiple times in a loop: the intermediate mouse positions\n    will be ignored. It should be used to implement real-time mouse input\n    in a GUI. The deprecated pseudokey form (`<LeftMouse><col,row>`) of\n    |nvim_input()| has the same limitation.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {button}    Mouse button: one of \"left\", \"right\", \"middle\", \"wheel\",\n                \"move\", \"x1\", \"x2\".\n  \226\128\162 {action}    For ordinary buttons, one of \"press\", \"drag\", \"release\".\n                For the wheel, one of \"up\", \"down\", \"left\", \"right\".\n                Ignored for \"move\".\n  \226\128\162 {modifier}  String of modifiers each represented by a single char. The\n                same specifiers are used as for a key press, except that\n                the \"-\" separator is optional, so \"C-A-\", \"c-a\" and \"CA\"\n                can all be used to specify Ctrl+Alt+click.\n  \226\128\162 {grid}      Grid number if the client uses |ui-multigrid|, else 0.\n  \226\128\162 {row}       Mouse row-position (zero-based, like redraw events)\n  \226\128\162 {col}       Mouse column-position (zero-based, like redraw events)"}}, nvim_list_bufs = {binding = "nvim_list_bufs", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current list of buffers.\n\nIncludes unlisted (unloaded/deleted) buffers, like `:ls!`. Use\n|nvim_buf_is_loaded()| to check if a buffer is loaded.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    List of buffer ids"}}, nvim_list_chans = {binding = "nvim_list_chans", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Get information about all open channels.\n\nAttributes: ~\n    Since: 0.3.0\n\nReturn: ~\n    Array of Dictionaries, each describing a channel with the format\n    specified at |nvim_get_chan_info()|."}}, nvim_list_runtime_paths = {binding = "nvim_list_runtime_paths", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the paths contained in |runtime-search-path|.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    List of paths"}}, nvim_list_tabpages = {binding = "nvim_list_tabpages", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current list of |tab-ID|s.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    List of |tab-ID|s"}}, nvim_list_uis = {binding = "nvim_list_uis", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets a list of dictionaries representing attached UIs.\n\nExample: The Nvim builtin |TUI| sets its channel info as described in\n|startup-tui|. In particular, it sets `client.name` to \"nvim-tui\". So you\ncan check if the TUI is running by inspecting the client name of each UI: >lua\n    vim.print(vim.api.nvim_get_chan_info(vim.api.nvim_list_uis()[1].chan).client.name)\n<\n\nAttributes: ~\n    Since: 0.3.0\n\nReturn: ~\n    Array of UI dictionaries, each with these keys:\n    \226\128\162 \"height\" Requested height of the UI\n    \226\128\162 \"width\" Requested width of the UI\n    \226\128\162 \"rgb\" true if the UI uses RGB colors (false implies |cterm-colors|)\n    \226\128\162 \"ext_...\" Requested UI extensions, see |ui-option|\n    \226\128\162 \"chan\" |channel-id| of remote UI"}}, nvim_list_wins = {binding = "nvim_list_wins", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current list of all |window-ID|s in all tabpages.\n\nAttributes: ~\n    Since: 0.1.0\n\nReturn: ~\n    List of |window-ID|s"}}, nvim_load_context = {binding = "nvim_load_context", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Sets the current editor state from the given |context| map.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {dict}  |Context| map."}}, nvim_notify = {binding = "nvim_notify", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |nvim_echo()| or `nvim_exec_lua(\"vim.notify(...)\", ...)` instead."}}, nvim_open_term = {binding = "nvim_open_term", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "opts"}, ["fnl/docstring"] = "Open a terminal instance in a buffer\n\nBy default (and currently the only option) the terminal will not be\nconnected to an external process. Instead, input sent on the channel will\nbe echoed directly by the terminal. This is useful to display ANSI\nterminal sequences returned as part of a rpc message, or similar.\n\nNote: to directly initiate the terminal using the right size, display the\nbuffer in a configured window before calling this. For instance, for a\nfloating display, first create an empty buffer using |nvim_create_buf()|,\nthen display it using |nvim_open_win()|, and then call this function. Then\n|nvim_chan_send()| can be called immediately to process sequences in a\nvirtual terminal having the intended size.\n\nExample: this `TermHl` command can be used to display and highlight raw\nANSI termcodes, so you can use Nvim as a \"scrollback pager\" (for terminals\nlike kitty):                     *ansi-colorize* *terminal-scrollback-pager* >lua\n    vim.api.nvim_create_user_command('TermHl', function()\n      vim.api.nvim_open_term(0, {})\n    end, { desc = 'Highlights ANSI termcodes in curbuf' })\n<\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {buffer}  the buffer to use (expected to be empty)\n  \226\128\162 {opts}    Optional parameters.\n              \226\128\162 on_input: Lua callback for input sent, i e keypresses in\n                terminal mode. Note: keypresses are sent raw as they would\n                be to the pty master end. For instance, a carriage return\n                is sent as a \"\\r\", not as a \"\\n\". |textlock| applies. It\n                is possible to call |nvim_chan_send()| directly in the\n                callback however. `[\"input\", term, bufnr, data]`\n              \226\128\162 force_crlf: (boolean, default true) Convert \"\\n\" to\n                \"\\r\\n\".\n\nReturn: ~\n    Channel id, or 0 on error"}}, nvim_open_win = {binding = "nvim_open_win", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer", "enter", "config"}, ["fnl/docstring"] = "Opens a new split window, or a floating window if `relative` is specified,\nor an external window (managed by the UI) if `external` is specified.\n\nFloats are windows that are drawn above the split layout, at some anchor\nposition in some other window. Floats can be drawn internally or by\nexternal GUI with the |ui-multigrid| extension. External windows are only\nsupported with multigrid GUIs, and are displayed as separate top-level\nwindows.\n\nFor a general overview of floats, see |api-floatwin|.\n\nThe `width` and `height` of the new window must be specified when opening\na floating window, but are optional for normal windows.\n\nIf `relative` and `external` are omitted, a normal \"split\" window is\ncreated. The `win` property determines which window will be split. If no\n`win` is provided or `win == 0`, a window will be created adjacent to the\ncurrent window. If -1 is provided, a top-level split will be created.\n`vertical` and `split` are only valid for normal windows, and are used to\ncontrol split direction. For `vertical`, the exact direction is determined\nby |'splitright'| and |'splitbelow'|. Split windows cannot have\n`bufpos`/`row`/`col`/`border`/`title`/`footer` properties.\n\nWith relative=editor (row=0,col=0) refers to the top-left corner of the\nscreen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right\ncorner. Fractional values are allowed, but the builtin implementation\n(used by non-multigrid UIs) will always round down to nearest integer.\n\nOut-of-bounds values, and configurations that make the float not fit\ninside the main editor, are allowed. The builtin implementation truncates\nvalues so floats are fully within the main screen grid. External GUIs\ncould let floats hover outside of the main window like a tooltip, but this\nshould not be used to specify arbitrary WM screen positions.\n\nExample (Lua): window-relative float >lua\n    vim.api.nvim_open_win(0, false,\n      {relative='win', row=3, col=3, width=12, height=3})\n<\n\nExample (Lua): buffer-relative float (travels as buffer is scrolled) >lua\n    vim.api.nvim_open_win(0, false,\n      {relative='win', width=12, height=3, bufpos={100,10}})\n<\n\nExample (Lua): vertical split left of the current window >lua\n    vim.api.nvim_open_win(0, false, {\n      split = 'left',\n      win = 0\n    })\n<\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer to display, or 0 for current buffer\n  \226\128\162 {enter}   Enter the window (make it the current window)\n  \226\128\162 {config}  Map defining the window configuration. Keys:\n              \226\128\162 relative: Sets the window layout to \"floating\", placed at\n                (row,col) coordinates relative to:\n                \226\128\162 \"cursor\" Cursor position in current window.\n                \226\128\162 \"editor\" The global editor grid.\n                \226\128\162 \"laststatus\" 'laststatus' if present, or last row.\n                \226\128\162 \"mouse\" Mouse position.\n                \226\128\162 \"tabline\" Tabline if present, or first row.\n                \226\128\162 \"win\" Window given by the `win` field, or current\n                  window.\n              \226\128\162 win: |window-ID| window to split, or relative window when\n                creating a float (relative=\"win\").\n              \226\128\162 anchor: Decides which corner of the float to place at\n                (row,col):\n                \226\128\162 \"NW\" northwest (default)\n                \226\128\162 \"NE\" northeast\n                \226\128\162 \"SW\" southwest\n                \226\128\162 \"SE\" southeast\n              \226\128\162 width: Window width (in character cells). Minimum of 1.\n              \226\128\162 height: Window height (in character cells). Minimum of 1.\n              \226\128\162 bufpos: Places float relative to buffer text (only when\n                relative=\"win\"). Takes a tuple of zero-indexed\n                `[line, column]`. `row` and `col` if given are applied\n                relative to this position, else they default to:\n                \226\128\162 `row=1` and `col=0` if `anchor` is \"NW\" or \"NE\"\n                \226\128\162 `row=0` and `col=0` if `anchor` is \"SW\" or \"SE\" (thus\n                  like a tooltip near the buffer text).\n              \226\128\162 row: Row position in units of \"screen cell height\", may be\n                fractional.\n              \226\128\162 col: Column position in units of \"screen cell width\", may\n                be fractional.\n              \226\128\162 focusable: Enable focus by user actions (wincmds, mouse\n                events). Defaults to true. Non-focusable windows can be\n                entered by |nvim_set_current_win()|, or, when the `mouse`\n                field is set to true, by mouse events. See |focusable|.\n              \226\128\162 mouse: Specify how this window interacts with mouse\n                events. Defaults to `focusable` value.\n                \226\128\162 If false, mouse events pass through this window.\n                \226\128\162 If true, mouse events interact with this window\n                  normally.\n              \226\128\162 external: GUI should display the window as an external\n                top-level window. Currently accepts no other positioning\n                configuration together with this.\n              \226\128\162 zindex: Stacking order. floats with higher `zindex` go on\n                top on floats with lower indices. Must be larger than\n                zero. The following screen elements have hard-coded\n                z-indices:\n                \226\128\162 100: insert completion popupmenu\n                \226\128\162 200: message scrollback\n                \226\128\162 250: cmdline completion popupmenu (when\n                  wildoptions+=pum) The default value for floats are 50.\n                  In general, values below 100 are recommended, unless\n                  there is a good reason to overshadow builtin elements.\n              \226\128\162 style: (optional) Configure the appearance of the window.\n                Currently only supports one value:\n                \226\128\162 \"minimal\" Nvim will display the window with many UI\n                  options disabled. This is useful when displaying a\n                  temporary float where the text should not be edited.\n                  Disables 'number', 'relativenumber', 'cursorline',\n                  'cursorcolumn', 'foldcolumn', 'spell' and 'list'\n                  options. 'signcolumn' is changed to `auto` and\n                  'colorcolumn' is cleared. 'statuscolumn' is changed to\n                  empty. The end-of-buffer region is hidden by setting\n                  `eob` flag of 'fillchars' to a space char, and clearing\n                  the |hl-EndOfBuffer| region in 'winhighlight'.\n              \226\128\162 border: Style of (optional) window border. This can either\n                be a string or an array. The string values are the same as\n                those described in 'winborder'. If it is an array, it\n                should have a length of eight or any divisor of eight. The\n                array will specify the eight chars building up the border\n                in a clockwise fashion starting with the top-left corner.\n                As an example, the double box style could be specified as: >\n                 [ \"\226\149\148\", \"\226\149\144\" ,\"\226\149\151\", \"\226\149\145\", \"\226\149\157\", \"\226\149\144\", \"\226\149\154\", \"\226\149\145\" ].\n<\n                If the number of chars are less than eight, they will be\n                repeated. Thus an ASCII border could be specified as >\n                 [ \"/\", \"-\", \\\"\\\\\\\\\\\", \"|\" ],\n<\n                or all chars the same as >\n                 [ \"x\" ].\n<\n                An empty string can be used to turn off a specific border,\n                for instance, >\n                 [ \"\", \"\", \"\", \">\", \"\", \"\", \"\", \"<\" ]\n<\n                will only make vertical borders but not horizontal ones.\n                By default, `FloatBorder` highlight is used, which links\n                to `WinSeparator` when not defined. It could also be\n                specified by character: >\n                 [ [\"+\", \"MyCorner\"], [\"x\", \"MyBorder\"] ].\n<\n              \226\128\162 title: Title (optional) in window border, string or list.\n                List should consist of `[text, highlight]` tuples. If\n                string, or a tuple lacks a highlight, the default\n                highlight group is `FloatTitle`.\n              \226\128\162 title_pos: Title position. Must be set with `title`\n                option. Value can be one of \"left\", \"center\", or \"right\".\n                Default is `\"left\"`.\n              \226\128\162 footer: Footer (optional) in window border, string or\n                list. List should consist of `[text, highlight]` tuples.\n                If string, or a tuple lacks a highlight, the default\n                highlight group is `FloatFooter`.\n              \226\128\162 footer_pos: Footer position. Must be set with `footer`\n                option. Value can be one of \"left\", \"center\", or \"right\".\n                Default is `\"left\"`.\n              \226\128\162 noautocmd: If true then all autocommands are blocked for\n                the duration of the call.\n              \226\128\162 fixed: If true when anchor is NW or SW, the float window\n                would be kept fixed even if the window would be truncated.\n              \226\128\162 hide: If true the floating window will be hidden and the\n                cursor will be invisible when focused on it.\n              \226\128\162 vertical: Split vertically |:vertical|.\n              \226\128\162 split: Split direction: \"left\", \"right\", \"above\", \"below\".\n\nReturn: ~\n    |window-ID|, or 0 on error"}}, nvim_out_write = {binding = "nvim_out_write", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |nvim_echo()|."}}, nvim_parse_cmd = {binding = "nvim_parse_cmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "opts"}, ["fnl/docstring"] = "Parse command line.\n\nDoesn't check the validity of command arguments.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {str}   Command line string to parse. Cannot contain \"\\n\".\n  \226\128\162 {opts}  Optional parameters. Reserved for future use.\n\nReturn: ~\n    Dict containing command information, with these keys:\n    \226\128\162 cmd: (string) Command name.\n    \226\128\162 range: (array) (optional) Command range (<line1> <line2>). Omitted\n      if command doesn't accept a range. Otherwise, has no elements if no\n      range was specified, one element if only a single range item was\n      specified, or two elements if both range items were specified.\n    \226\128\162 count: (number) (optional) Command <count>. Omitted if command\n      cannot take a count.\n    \226\128\162 reg: (string) (optional) Command <register>. Omitted if command\n      cannot take a register.\n    \226\128\162 bang: (boolean) Whether command contains a <bang> (!) modifier.\n    \226\128\162 args: (array) Command arguments.\n    \226\128\162 addr: (string) Value of |:command-addr|. Uses short name or \"line\"\n      for -addr=lines.\n    \226\128\162 nargs: (string) Value of |:command-nargs|.\n    \226\128\162 nextcmd: (string) Next command if there are multiple commands\n      separated by a |:bar|. Empty if there isn't a next command.\n    \226\128\162 magic: (dict) Which characters have special meaning in the command\n      arguments.\n      \226\128\162 file: (boolean) The command expands filenames. Which means\n        characters such as \"%\", \"#\" and wildcards are expanded.\n      \226\128\162 bar: (boolean) The \"|\" character is treated as a command separator\n        and the double quote character (\") is treated as the start of a\n        comment.\n    \226\128\162 mods: (dict) |:command-modifiers|.\n      \226\128\162 filter: (dict) |:filter|.\n        \226\128\162 pattern: (string) Filter pattern. Empty string if there is no\n          filter.\n        \226\128\162 force: (boolean) Whether filter is inverted or not.\n      \226\128\162 silent: (boolean) |:silent|.\n      \226\128\162 emsg_silent: (boolean) |:silent!|.\n      \226\128\162 unsilent: (boolean) |:unsilent|.\n      \226\128\162 sandbox: (boolean) |:sandbox|.\n      \226\128\162 noautocmd: (boolean) |:noautocmd|.\n      \226\128\162 browse: (boolean) |:browse|.\n      \226\128\162 confirm: (boolean) |:confirm|.\n      \226\128\162 hide: (boolean) |:hide|.\n      \226\128\162 horizontal: (boolean) |:horizontal|.\n      \226\128\162 keepalt: (boolean) |:keepalt|.\n      \226\128\162 keepjumps: (boolean) |:keepjumps|.\n      \226\128\162 keepmarks: (boolean) |:keepmarks|.\n      \226\128\162 keeppatterns: (boolean) |:keeppatterns|.\n      \226\128\162 lockmarks: (boolean) |:lockmarks|.\n      \226\128\162 noswapfile: (boolean) |:noswapfile|.\n      \226\128\162 tab: (integer) |:tab|. -1 when omitted.\n      \226\128\162 verbose: (integer) |:verbose|. -1 when omitted.\n      \226\128\162 vertical: (boolean) |:vertical|.\n      \226\128\162 split: (string) Split modifier string, is an empty string when\n        there's no split modifier. If there is a split modifier it can be\n        one of:\n        \226\128\162 \"aboveleft\": |:aboveleft|.\n        \226\128\162 \"belowright\": |:belowright|.\n        \226\128\162 \"topleft\": |:topleft|.\n        \226\128\162 \"botright\": |:botright|."}}, nvim_parse_expression = {binding = "nvim_parse_expression", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "flags", "highlight"}, ["fnl/docstring"] = "Parse a Vimscript expression.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {expr}       Expression to parse. Always treated as a single line.\n  \226\128\162 {flags}      Flags:\n                 \226\128\162 \"m\" if multiple expressions in a row are allowed (only\n                   the first one will be parsed),\n                 \226\128\162 \"E\" if EOC tokens are not allowed (determines whether\n                   they will stop parsing process or be recognized as an\n                   operator/space, though also yielding an error).\n                 \226\128\162 \"l\" when needing to start parsing with lvalues for\n                   \":let\" or \":for\". Common flag sets:\n                 \226\128\162 \"m\" to parse like for `\":echo\"`.\n                 \226\128\162 \"E\" to parse like for `\"<C-r>=\"`.\n                 \226\128\162 empty string for \":call\".\n                 \226\128\162 \"lm\" to parse for \":let\".\n  \226\128\162 {highlight}  If true, return value will also include \"highlight\" key\n                 containing array of 4-tuples (arrays) (Integer, Integer,\n                 Integer, String), where first three numbers define the\n                 highlighted region and represent line, starting column\n                 and ending column (latter exclusive: one should highlight\n                 region [start_col, end_col)).\n\nReturn: ~\n    \226\128\162 AST: top-level dict with these keys:\n      \226\128\162 \"error\": Dict with error, present only if parser saw some error.\n        Contains the following keys:\n        \226\128\162 \"message\": String, error message in printf format, translated.\n          Must contain exactly one \"%.*s\".\n        \226\128\162 \"arg\": String, error message argument.\n      \226\128\162 \"len\": Amount of bytes successfully parsed. With flags equal to \"\"\n        that should be equal to the length of expr string. (\"Successfully\n        parsed\" here means \"participated in AST creation\", not \"till the\n        first error\".)\n      \226\128\162 \"ast\": AST, either nil or a dict with these keys:\n        \226\128\162 \"type\": node type, one of the value names from ExprASTNodeType\n          stringified without \"kExprNode\" prefix.\n        \226\128\162 \"start\": a pair `[line, column]` describing where node is\n          \"started\" where \"line\" is always 0 (will not be 0 if you will be\n          using this API on e.g. \":let\", but that is not present yet).\n          Both elements are Integers.\n        \226\128\162 \"len\": \226\128\156length\226\128\157 of the node. This and \"start\" are there for\n          debugging purposes primary (debugging parser and providing debug\n          information).\n        \226\128\162 \"children\": a list of nodes described in top/\"ast\". There always\n          is zero, one or two children, key will not be present if node\n          has no children. Maximum number of children may be found in\n          node_maxchildren array.\n    \226\128\162 Local values (present only for certain nodes):\n      \226\128\162 \"scope\": a single Integer, specifies scope for \"Option\" and\n        \"PlainIdentifier\" nodes. For \"Option\" it is one of ExprOptScope\n        values, for \"PlainIdentifier\" it is one of ExprVarScope values.\n      \226\128\162 \"ident\": identifier (without scope, if any), present for \"Option\",\n        \"PlainIdentifier\", \"PlainKey\" and \"Environment\" nodes.\n      \226\128\162 \"name\": Integer, register name (one character) or -1. Only present\n        for \"Register\" nodes.\n      \226\128\162 \"cmp_type\": String, comparison type, one of the value names from\n        ExprComparisonType, stringified without \"kExprCmp\" prefix. Only\n        present for \"Comparison\" nodes.\n      \226\128\162 \"ccs_strategy\": String, case comparison strategy, one of the value\n        names from ExprCaseCompareStrategy, stringified without\n        \"kCCStrategy\" prefix. Only present for \"Comparison\" nodes.\n      \226\128\162 \"augmentation\": String, augmentation type for \"Assignment\" nodes.\n        Is either an empty string, \"Add\", \"Subtract\" or \"Concat\" for \"=\",\n        \"+=\", \"-=\" or \".=\" respectively.\n      \226\128\162 \"invert\": Boolean, true if result of comparison needs to be\n        inverted. Only present for \"Comparison\" nodes.\n      \226\128\162 \"ivalue\": Integer, integer value for \"Integer\" nodes.\n      \226\128\162 \"fvalue\": Float, floating-point value for \"Float\" nodes.\n      \226\128\162 \"svalue\": String, value for \"SingleQuotedString\" and\n        \"DoubleQuotedString\" nodes."}}, nvim_paste = {binding = "nvim_paste", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"data", "crlf", "phase"}, ["fnl/docstring"] = "Pastes at cursor (in any mode), and sets \"redo\" so dot (|.|) will repeat\nthe input. UIs call this to implement \"paste\", but it's also intended for\nuse by scripts to input large, dot-repeatable blocks of text (as opposed\nto |nvim_input()| which is subject to mappings/events and is thus much\nslower).\n\nInvokes the |vim.paste()| handler, which handles each mode appropriately.\n\nErrors ('nomodifiable', `vim.paste()` failure, \226\128\166) are reflected in `err`\nbut do not affect the return value (which is strictly decided by\n`vim.paste()`). On error or cancel, subsequent calls are ignored\n(\"drained\") until the next paste is initiated (phase 1 or -1).\n\nUseful in mappings and scripts to insert multiline text. Example: >lua\n    vim.keymap.set('n', 'x', function()\n      vim.api.nvim_paste([[\n        line1\n        line2\n        line3\n      ]], false, -1)\n    end, { buffer = true })\n<\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {data}   Multiline input. Lines break at LF (\"\\n\"). May be binary\n             (containing NUL bytes).\n  \226\128\162 {crlf}   Also break lines at CR and CRLF.\n  \226\128\162 {phase}  -1: paste in a single call (i.e. without streaming). To\n             \"stream\" a paste, call `nvim_paste` sequentially with these\n             `phase` values:\n             \226\128\162 1: starts the paste (exactly once)\n             \226\128\162 2: continues the paste (zero or more times)\n             \226\128\162 3: ends the paste (exactly once)\n\nReturn: ~\n    \226\128\162 true: Client may continue pasting.\n    \226\128\162 false: Client should cancel the paste."}}, nvim_put = {binding = "nvim_put", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lines", "type", "after", "follow"}, ["fnl/docstring"] = "Puts text at cursor, in any mode. For dot-repeatable input, use\n|nvim_paste()|.\n\nCompare |:put| and |p| which are always linewise.\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {lines}   |readfile()|-style list of lines. |channel-lines|\n  \226\128\162 {type}    Edit behavior: any |getregtype()| result, or:\n              \226\128\162 \"b\" |blockwise-visual| mode (may include width, e.g. \"b3\")\n              \226\128\162 \"c\" |charwise| mode\n              \226\128\162 \"l\" |linewise| mode\n              \226\128\162 \"\" guess by contents, see |setreg()|\n  \226\128\162 {after}   If true insert after cursor (like |p|), or before (like\n              |P|).\n  \226\128\162 {follow}  If true place cursor at end of inserted text.\n\n                                                "}}, nvim_replace_termcodes = {binding = "nvim_replace_termcodes", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "from_part", "do_lt", "special"}, ["fnl/docstring"] = "Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a string with\nthe internal representation.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {str}        String to be converted.\n  \226\128\162 {from_part}  Legacy Vim parameter. Usually true.\n  \226\128\162 {do_lt}      Also translate <lt>. Ignored if `special` is false.\n  \226\128\162 {special}    Replace |keycodes|, e.g. <CR> becomes a \"\\r\" char.\n\nSee also: ~\n  \226\128\162 replace_termcodes\n  \226\128\162 cpoptions\n\n                                            "}}, nvim_select_popupmenu_item = {binding = "nvim_select_popupmenu_item", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"item", "insert", "finish", "opts"}, ["fnl/docstring"] = "Selects an item in the completion popup menu.\n\nIf neither |ins-completion| nor |cmdline-completion| popup menu is active\nthis API call is silently ignored. Useful for an external UI using\n|ui-popupmenu| to control the popup menu with the mouse. Can also be used\nin a mapping; use <Cmd> |:map-cmd| or a Lua mapping to ensure the mapping\ndoesn't end completion mode.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {item}    Index (zero-based) of the item to select. Value of -1\n              selects nothing and restores the original text.\n  \226\128\162 {insert}  For |ins-completion|, whether the selection should be\n              inserted in the buffer. Ignored for |cmdline-completion|.\n  \226\128\162 {finish}  Finish the completion and dismiss the popup menu. Implies\n              {insert}.\n  \226\128\162 {opts}    Optional parameters. Reserved for future use.\n\n                                                  "}}, nvim_set_client_info = {binding = "nvim_set_client_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "version", "type", "methods", "attributes"}, ["fnl/docstring"] = "Self-identifies the client, and sets optional flags on the channel.\nDefines the `client` object returned by |nvim_get_chan_info()|.\n\nClients should call this just after connecting, to provide hints for\ndebugging and orchestration. (Note: Something is better than nothing!\nFields are optional, but at least set `name`.)\n\nCan be called more than once; caller should merge old info if appropriate.\nExample: a library first identifies the channel, then a plugin using that\nlibrary later identifies itself.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.3.0\n\nParameters: ~\n  \226\128\162 {name}        Client short-name. Sets the `client.name` field of\n                  |nvim_get_chan_info()|.\n  \226\128\162 {version}     Dict describing the version, with these (optional) keys:\n                  \226\128\162 \"major\" major version (defaults to 0 if not set, for\n                    no release yet)\n                  \226\128\162 \"minor\" minor version\n                  \226\128\162 \"patch\" patch number\n                  \226\128\162 \"prerelease\" string describing a prerelease, like\n                    \"dev\" or \"beta1\"\n                  \226\128\162 \"commit\" hash or similar identifier of commit\n  \226\128\162 {type}        Must be one of the following values. Client libraries\n                  should default to \"remote\" unless overridden by the\n                  user.\n                  \226\128\162 \"remote\" remote client connected \"Nvim flavored\"\n                    MessagePack-RPC (responses must be in reverse order of\n                    requests). |msgpack-rpc|\n                  \226\128\162 \"msgpack-rpc\" remote client connected to Nvim via\n                    fully MessagePack-RPC compliant protocol.\n                  \226\128\162 \"ui\" gui frontend\n                  \226\128\162 \"embedder\" application using Nvim as a component (for\n                    example, IDE/editor implementing a vim mode).\n                  \226\128\162 \"host\" plugin host, typically started by nvim\n                  \226\128\162 \"plugin\" single plugin, started by nvim\n  \226\128\162 {methods}     Builtin methods in the client. For a host, this does not\n                  include plugin methods which will be discovered later.\n                  The key should be the method name, the values are dicts\n                  with these (optional) keys (more keys may be added in\n                  future versions of Nvim, thus unknown keys are ignored.\n                  Clients must only use keys defined in this or later\n                  versions of Nvim):\n                  \226\128\162 \"async\" if true, send as a notification. If false or\n                    unspecified, use a blocking request\n                  \226\128\162 \"nargs\" Number of arguments. Could be a single integer\n                    or an array of two integers, minimum and maximum\n                    inclusive.\n  \226\128\162 {attributes}  Arbitrary string:string map of informal client\n                  properties. Suggested keys:\n                  \226\128\162 \"pid\": Process id.\n                  \226\128\162 \"website\": Client homepage URL (e.g. GitHub\n                    repository)\n                  \226\128\162 \"license\": License description (\"Apache 2\", \"GPLv3\",\n                    \"MIT\", \226\128\166)\n                  \226\128\162 \"logo\": URI or path to image, preferably small logo or\n                    icon. .png or .svg format is preferred."}}, nvim_set_current_buf = {binding = "nvim_set_current_buf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buffer"}, ["fnl/docstring"] = "Sets the current window's buffer to `buffer`.\n\nAttributes: ~\n    not allowed when |textlock| is active or in the |cmdwin|\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {buffer}  Buffer id"}}, nvim_set_current_dir = {binding = "nvim_set_current_dir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dir"}, ["fnl/docstring"] = "Changes the global working directory.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {dir}  Directory path"}}, nvim_set_current_line = {binding = "nvim_set_current_line", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"line"}, ["fnl/docstring"] = "Sets the text on the current line.\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {line}  Line contents"}}, nvim_set_current_tabpage = {binding = "nvim_set_current_tabpage", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage"}, ["fnl/docstring"] = "Sets the current tabpage.\n\nAttributes: ~\n    not allowed when |textlock| is active or in the |cmdwin|\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID| to focus"}}, nvim_set_current_win = {binding = "nvim_set_current_win", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Sets the current window (and tabpage, implicitly).\n\nAttributes: ~\n    not allowed when |textlock| is active or in the |cmdwin|\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID| to focus"}}, nvim_set_decoration_provider = {binding = "nvim_set_decoration_provider", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id", "opts"}, ["fnl/docstring"] = "Set or change decoration provider for a |namespace|\n\nThis is a very general purpose interface for having Lua callbacks being\ntriggered during the redraw code.\n\nThe expected usage is to set |extmarks| for the currently redrawn buffer.\n|nvim_buf_set_extmark()| can be called to add marks on a per-window or\nper-lines basis. Use the `ephemeral` key to only use the mark for the\ncurrent screen redraw (the callback will be called again for the next\nredraw).\n\nNote: this function should not be called often. Rather, the callbacks\nthemselves can be used to throttle unneeded callbacks. the `on_start`\ncallback can return `false` to disable the provider until the next redraw.\nSimilarly, return `false` in `on_win` will skip the `on_line` calls for\nthat window (but any extmarks set in `on_win` will still be used). A\nplugin managing multiple sources of decoration should ideally only set one\nprovider, and merge the sources internally. You can use multiple `ns_id`\nfor the extmarks set/modified inside the callback anyway.\n\nNote: doing anything other than setting extmarks is considered\nexperimental. Doing things like changing options are not explicitly\nforbidden, but is likely to have unexpected consequences (such as 100% CPU\nconsumption). Doing `vim.rpcnotify` should be OK, but `vim.rpcrequest` is\nquite dubious for the moment.\n\nNote: It is not allowed to remove or update extmarks in `on_line`\ncallbacks.\n\nAttributes: ~\n    Lua |vim.api| only\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {ns_id}  Namespace id from |nvim_create_namespace()|\n  \226\128\162 {opts}   Table of callbacks:\n             \226\128\162 on_start: called first on each screen redraw >\n                [\"start\", tick]\n<\n             \226\128\162 on_buf: called for each buffer being redrawn (once per\n               edit, before window callbacks) >\n                [\"buf\", bufnr, tick]\n<\n             \226\128\162 on_win: called when starting to redraw a specific window. >\n                [\"win\", winid, bufnr, toprow, botrow]\n<\n             \226\128\162 on_line: called for each buffer line being redrawn. (The\n               interaction with fold lines is subject to change) >\n                [\"line\", winid, bufnr, row]\n<\n             \226\128\162 on_end: called at the end of a redraw cycle >\n                [\"end\", tick]\n<"}}, nvim_set_hl = {binding = "nvim_set_hl", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id", "name", "val"}, ["fnl/docstring"] = "Sets a highlight group.\n\nNote: ~\n  \226\128\162 Unlike the `:highlight` command which can update a highlight group,\n    this function completely replaces the definition. For example:\n    `nvim_set_hl(0, 'Visual', {})` will clear the highlight group\n    'Visual'.\n  \226\128\162 The fg and bg keys also accept the string values `\"fg\"` or `\"bg\"`\n    which act as aliases to the corresponding foreground and background\n    values of the Normal group. If the Normal group has not been defined,\n    using these values results in an error.\n  \226\128\162 If `link` is used in combination with other attributes; only the\n    `link` will take effect (see |:hi-link|).\n\nAttributes: ~\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {ns_id}  Namespace id for this highlight |nvim_create_namespace()|.\n             Use 0 to set a highlight group globally |:highlight|.\n             Highlights from non-global namespaces are not active by\n             default, use |nvim_set_hl_ns()| or |nvim_win_set_hl_ns()| to\n             activate them.\n  \226\128\162 {name}   Highlight group name, e.g. \"ErrorMsg\"\n  \226\128\162 {val}    Highlight definition map, accepts the following keys:\n             \226\128\162 fg: color name or \"#RRGGBB\", see note.\n             \226\128\162 bg: color name or \"#RRGGBB\", see note.\n             \226\128\162 sp: color name or \"#RRGGBB\"\n             \226\128\162 blend: integer between 0 and 100\n             \226\128\162 bold: boolean\n             \226\128\162 standout: boolean\n             \226\128\162 underline: boolean\n             \226\128\162 undercurl: boolean\n             \226\128\162 underdouble: boolean\n             \226\128\162 underdotted: boolean\n             \226\128\162 underdashed: boolean\n             \226\128\162 strikethrough: boolean\n             \226\128\162 italic: boolean\n             \226\128\162 reverse: boolean\n             \226\128\162 nocombine: boolean\n             \226\128\162 link: name of another highlight group to link to, see\n               |:hi-link|.\n             \226\128\162 default: Don't override existing definition |:hi-default|\n             \226\128\162 ctermfg: Sets foreground of cterm color |ctermfg|\n             \226\128\162 ctermbg: Sets background of cterm color |ctermbg|\n             \226\128\162 cterm: cterm attribute map, like |highlight-args|. If not\n               set, cterm attributes will match those from the attribute\n               map documented above.\n             \226\128\162 force: if true force update the highlight group when it\n               exists."}}, nvim_set_hl_ns = {binding = "nvim_set_hl_ns", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id"}, ["fnl/docstring"] = "Set active namespace for highlights defined with |nvim_set_hl()|. This can\nbe set for a single window, see |nvim_win_set_hl_ns()|.\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {ns_id}  the namespace to use"}}, nvim_set_hl_ns_fast = {binding = "nvim_set_hl_ns_fast", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns_id"}, ["fnl/docstring"] = "Set active namespace for highlights defined with |nvim_set_hl()| while\nredrawing.\n\nThis function meant to be called while redrawing, primarily from\n|nvim_set_decoration_provider()| on_win and on_line callbacks, which are\nallowed to change the namespace during a redraw cycle.\n\nAttributes: ~\n    |api-fast|\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {ns_id}  the namespace to activate"}}, nvim_set_keymap = {binding = "nvim_set_keymap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"mode", "lhs", "rhs", "opts"}, ["fnl/docstring"] = "Sets a global |mapping| for the given mode.\n\nTo set a buffer-local mapping, use |nvim_buf_set_keymap()|.\n\nUnlike |:map|, leading/trailing whitespace is accepted as part of the\n{lhs} or {rhs}. Empty {rhs} is <Nop>. |keycodes| are replaced as usual.\n\nExample: >vim\n    call nvim_set_keymap('n', ' <NL>', '', {'nowait': v:true})\n<\n\nis equivalent to: >vim\n    nmap <nowait> <Space><NL> <Nop>\n<\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {mode}  Mode short-name (map command prefix: \"n\", \"i\", \"v\", \"x\", \226\128\166)\n            or \"!\" for |:map!|, or empty string for |:map|. \"ia\", \"ca\" or\n            \"!a\" for abbreviation in Insert mode, Cmdline mode, or both,\n            respectively\n  \226\128\162 {lhs}   Left-hand-side |{lhs}| of the mapping.\n  \226\128\162 {rhs}   Right-hand-side |{rhs}| of the mapping.\n  \226\128\162 {opts}  Optional parameters map: Accepts all |:map-arguments| as keys\n            except <buffer>, values are booleans (default false). Also:\n            \226\128\162 \"noremap\" disables |recursive_mapping|, like |:noremap|\n            \226\128\162 \"desc\" human-readable description.\n            \226\128\162 \"callback\" Lua function called in place of {rhs}.\n            \226\128\162 \"replace_keycodes\" (boolean) When \"expr\" is true, replace\n              keycodes in the resulting string (see\n              |nvim_replace_termcodes()|). Returning nil from the Lua\n              \"callback\" is equivalent to returning an empty string."}}, nvim_set_option_value = {binding = "nvim_set_option_value", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "value", "opts"}, ["fnl/docstring"] = "Sets the value of an option. The behavior of this function matches that of\n|:set|: for global-local options, both the global and local value are set\nunless otherwise specified with {scope}.\n\nNote the options {win} and {buf} cannot be used together.\n\nAttributes: ~\n    Since: 0.7.0\n\nParameters: ~\n  \226\128\162 {name}   Option name\n  \226\128\162 {value}  New option value\n  \226\128\162 {opts}   Optional parameters\n             \226\128\162 scope: One of \"global\" or \"local\". Analogous to\n               |:setglobal| and |:setlocal|, respectively.\n             \226\128\162 win: |window-ID|. Used for setting window local option.\n             \226\128\162 buf: Buffer number. Used for setting buffer local option."}}, nvim_set_var = {binding = "nvim_set_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "value"}, ["fnl/docstring"] = "Sets a global (g:) variable.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {name}   Variable name\n  \226\128\162 {value}  Variable value"}}, nvim_set_vvar = {binding = "nvim_set_vvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "value"}, ["fnl/docstring"] = "Sets a v: variable, if it is not readonly.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {name}   Variable name\n  \226\128\162 {value}  Variable value"}}, nvim_strwidth = {binding = "nvim_strwidth", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"text"}, ["fnl/docstring"] = "Calculates the number of display cells occupied by `text`. Control\ncharacters including <Tab> count as one cell.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {text}  Some text\n\nReturn: ~\n    Number of cells"}}, nvim_subscribe = {binding = "nvim_subscribe", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nPlugins must maintain their own \"multicast\" channels list."}}, nvim_tabpage_del_var = {binding = "nvim_tabpage_del_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage", "name"}, ["fnl/docstring"] = "Removes a tab-scoped (t:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n  \226\128\162 {name}     Variable name"}}, nvim_tabpage_get_number = {binding = "nvim_tabpage_get_number", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage"}, ["fnl/docstring"] = "Gets the tabpage number\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n\nReturn: ~\n    Tabpage number"}}, nvim_tabpage_get_var = {binding = "nvim_tabpage_get_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage", "name"}, ["fnl/docstring"] = "Gets a tab-scoped (t:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n  \226\128\162 {name}     Variable name\n\nReturn: ~\n    Variable value"}}, nvim_tabpage_get_win = {binding = "nvim_tabpage_get_win", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage"}, ["fnl/docstring"] = "Gets the current window in a tabpage\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n\nReturn: ~\n    |window-ID|"}}, nvim_tabpage_is_valid = {binding = "nvim_tabpage_is_valid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage"}, ["fnl/docstring"] = "Checks if a tabpage is valid\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n\nReturn: ~\n    true if the tabpage is valid, false otherwise"}}, nvim_tabpage_list_wins = {binding = "nvim_tabpage_list_wins", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage"}, ["fnl/docstring"] = "Gets the windows in a tabpage\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n\nReturn: ~\n    List of windows in `tabpage`\n\n                                                  "}}, nvim_tabpage_set_var = {binding = "nvim_tabpage_set_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage", "name", "value"}, ["fnl/docstring"] = "Sets a tab-scoped (t:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n  \226\128\162 {name}     Variable name\n  \226\128\162 {value}    Variable value"}}, nvim_tabpage_set_win = {binding = "nvim_tabpage_set_win", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabpage", "win"}, ["fnl/docstring"] = "Sets the current window in a tabpage\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {tabpage}  |tab-ID|, or 0 for current tabpage\n  \226\128\162 {win}      |window-ID|, must already belong to {tabpage}"}}, nvim_ui_attach = {binding = "nvim_ui_attach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"width", "height", "options"}, ["fnl/docstring"] = "Activates UI events on the channel.\n\nEntry point of all UI clients. Allows |--embed| to continue startup.\nImplies that the client is ready to show the UI. Adds the client to the\nlist of UIs. |nvim_list_uis()|\n\nNote: ~\n  \226\128\162 If multiple UI clients are attached, the global screen dimensions\n    degrade to the smallest client. E.g. if client A requests 80x40 but\n    client B requests 200x100, the global screen has size 80x40.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {width}    Requested screen columns\n  \226\128\162 {height}   Requested screen rows\n  \226\128\162 {options}  |ui-option| map"}}, nvim_ui_detach = {binding = "nvim_ui_detach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Deactivates UI events on the channel.\n\nRemoves the client from the list of UIs. |nvim_list_uis()|\n\nAttributes: ~\n    |RPC| only\n    Since: 0.1.0\n\n                                                "}}, nvim_ui_pum_set_bounds = {binding = "nvim_ui_pum_set_bounds", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"width", "height", "row", "col"}, ["fnl/docstring"] = "Tells Nvim the geometry of the popupmenu, to align floating windows with\nan external popup menu.\n\nNote that this method is not to be confused with\n|nvim_ui_pum_set_height()|, which sets the number of visible items in the\npopup menu, while this function sets the bounding box of the popup menu,\nincluding visual elements such as borders and sliders. Floats need not use\nthe same font size, nor be anchored to exact grid corners, so one can set\nfloating-point numbers to the popup menu geometry.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {width}   Popupmenu width.\n  \226\128\162 {height}  Popupmenu height.\n  \226\128\162 {row}     Popupmenu row.\n  \226\128\162 {col}     Popupmenu height."}}, nvim_ui_pum_set_height = {binding = "nvim_ui_pum_set_height", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"height"}, ["fnl/docstring"] = "Tells Nvim the number of elements displaying in the popupmenu, to decide\n<PageUp> and <PageDown> movement.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {height}  Popupmenu height, must be greater than zero."}}, nvim_ui_set_focus = {binding = "nvim_ui_set_focus", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"gained"}, ["fnl/docstring"] = "Tells the nvim server if focus was gained or lost by the GUI\n\nAttributes: ~\n    |RPC| only\n    Since: 0.9.0"}}, nvim_ui_set_option = {binding = "nvim_ui_set_option", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "value"}, ["fnl/docstring"] = "Attributes: ~\n    |RPC| only\n    Since: 0.1.0"}}, nvim_ui_term_event = {binding = "nvim_ui_term_event", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"event", "value"}, ["fnl/docstring"] = "Tells Nvim when a terminal event has occurred\n\nThe following terminal events are supported:\n\226\128\162 \"termresponse\": The terminal sent an OSC or DCS response sequence to\n  Nvim. The payload is the received response. Sets |v:termresponse| and\n  fires |TermResponse|.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {event}  Event name\n  \226\128\162 {value}  Event payload"}}, nvim_ui_try_resize = {binding = "nvim_ui_try_resize", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"width", "height"}, ["fnl/docstring"] = "Attributes: ~\n    |RPC| only\n    Since: 0.1.0\n\n                                               "}}, nvim_ui_try_resize_grid = {binding = "nvim_ui_try_resize_grid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"grid", "width", "height"}, ["fnl/docstring"] = "Tell Nvim to resize a grid. Triggers a grid_resize event with the\nrequested grid size or the maximum size if it exceeds size limits.\n\nOn invalid grid handle, fails with error.\n\nAttributes: ~\n    |RPC| only\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {grid}    The handle of the grid to be changed.\n  \226\128\162 {width}   The new requested width.\n  \226\128\162 {height}  The new requested height."}}, nvim_unsubscribe = {binding = "nvim_unsubscribe", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nPlugins must maintain their own \"multicast\" channels list."}}, nvim_win_call = {binding = "nvim_win_call", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "fun"}, ["fnl/docstring"] = "Calls a function with window as temporary current window.\n\nAttributes: ~\n    Lua |vim.api| only\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {fun}     Function to call inside the window (currently Lua callable\n              only)\n\nReturn: ~\n    Return value of function.\n\nSee also: ~\n  \226\128\162 |win_execute()|\n  \226\128\162 |nvim_buf_call()|"}}, nvim_win_close = {binding = "nvim_win_close", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "force"}, ["fnl/docstring"] = "Closes the window (like |:close| with a |window-ID|).\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {force}   Behave like `:close!` The last window of a buffer with\n              unwritten changes can be closed. The buffer will become\n              hidden, even if 'hidden' is not set."}}, nvim_win_del_var = {binding = "nvim_win_del_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "name"}, ["fnl/docstring"] = "Removes a window-scoped (w:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {name}    Variable name"}}, nvim_win_get_buf = {binding = "nvim_win_get_buf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the current buffer in a window\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    Buffer id"}}, nvim_win_get_config = {binding = "nvim_win_get_config", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets window configuration.\n\nThe returned value may be given to |nvim_open_win()|.\n\n`relative` is empty for normal windows.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    Map defining the window configuration, see |nvim_open_win()|"}}, nvim_win_get_cursor = {binding = "nvim_win_get_cursor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the (1,0)-indexed, buffer-relative cursor position for a given window\n(different windows showing the same buffer have independent cursor\npositions). |api-indexing|\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    (row, col) tuple\n\nSee also: ~\n  \226\128\162 |getcurpos()|"}}, nvim_win_get_height = {binding = "nvim_win_get_height", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the window height\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    Height as a count of rows"}}, nvim_win_get_number = {binding = "nvim_win_get_number", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the window number\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    Window number"}}, nvim_win_get_position = {binding = "nvim_win_get_position", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the window position in display cells. First position is zero.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    (row, col) tuple with the window position"}}, nvim_win_get_tabpage = {binding = "nvim_win_get_tabpage", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the window tabpage\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    Tabpage that contains the window"}}, nvim_win_get_var = {binding = "nvim_win_get_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "name"}, ["fnl/docstring"] = "Gets a window-scoped (w:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {name}    Variable name\n\nReturn: ~\n    Variable value"}}, nvim_win_get_width = {binding = "nvim_win_get_width", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Gets the window width\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    Width as a count of columns"}}, nvim_win_hide = {binding = "nvim_win_hide", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Closes the window and hide the buffer it contains (like |:hide| with a\n|window-ID|).\n\nLike |:hide| the buffer becomes hidden unless another window is editing\nit, or 'bufhidden' is `unload`, `delete` or `wipe` as opposed to |:close|\nor |nvim_win_close()|, which will close the buffer.\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.5.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window"}}, nvim_win_is_valid = {binding = "nvim_win_is_valid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window"}, ["fnl/docstring"] = "Checks if a window is valid\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n\nReturn: ~\n    true if the window is valid, false otherwise"}}, nvim_win_set_buf = {binding = "nvim_win_set_buf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "buffer"}, ["fnl/docstring"] = "Sets the current buffer in a window, without side effects\n\nAttributes: ~\n    not allowed when |textlock| is active\n    Since: 0.3.2\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {buffer}  Buffer id"}}, nvim_win_set_config = {binding = "nvim_win_set_config", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "config"}, ["fnl/docstring"] = "Configures window layout. Cannot be used to move the last window in a\ntabpage to a different one.\n\nWhen reconfiguring a window, absent option keys will not be changed.\n`row`/`col` and `relative` must be reconfigured together.\n\nAttributes: ~\n    Since: 0.4.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {config}  Map defining the window configuration, see |nvim_open_win()|\n\nSee also: ~\n  \226\128\162 |nvim_open_win()|"}}, nvim_win_set_cursor = {binding = "nvim_win_set_cursor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "pos"}, ["fnl/docstring"] = "Sets the (1,0)-indexed cursor position in the window. |api-indexing| This\nscrolls the window even if it is not the current one.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {pos}     (row, col) tuple representing the new position"}}, nvim_win_set_height = {binding = "nvim_win_set_height", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "height"}, ["fnl/docstring"] = "Sets the window height.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {height}  Height as a count of rows"}}, nvim_win_set_hl_ns = {binding = "nvim_win_set_hl_ns", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "ns_id"}, ["fnl/docstring"] = "Set highlight namespace for a window. This will use highlights defined\nwith |nvim_set_hl()| for this namespace, but fall back to global\nhighlights (ns=0) when missing.\n\nThis takes precedence over the 'winhighlight' option.\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {ns_id}   the namespace to use"}}, nvim_win_set_var = {binding = "nvim_win_set_var", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "name", "value"}, ["fnl/docstring"] = "Sets a window-scoped (w:) variable\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {name}    Variable name\n  \226\128\162 {value}   Variable value"}}, nvim_win_set_width = {binding = "nvim_win_set_width", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "width"}, ["fnl/docstring"] = "Sets the window width. This will only succeed if the screen is split\nvertically.\n\nAttributes: ~\n    Since: 0.1.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window\n  \226\128\162 {width}   Width as a count of columns"}}, nvim_win_text_height = {binding = "nvim_win_text_height", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"window", "opts"}, ["fnl/docstring"] = "Computes the number of screen lines occupied by a range of text in a given\nwindow. Works for off-screen text and takes folds into account.\n\nDiff filler or virtual lines above a line are counted as a part of that\nline, unless the line is on \"start_row\" and \"start_vcol\" is specified.\n\nDiff filler or virtual lines below the last buffer line are counted in the\nresult when \"end_row\" is omitted.\n\nLine indexing is similar to |nvim_buf_get_text()|.\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {window}  |window-ID|, or 0 for current window.\n  \226\128\162 {opts}    Optional parameters:\n              \226\128\162 start_row: Starting line index, 0-based inclusive. When\n                omitted start at the very top.\n              \226\128\162 end_row: Ending line index, 0-based inclusive. When\n                omitted end at the very bottom.\n              \226\128\162 start_vcol: Starting virtual column index on \"start_row\",\n                0-based inclusive, rounded down to full screen lines. When\n                omitted include the whole line.\n              \226\128\162 end_vcol: Ending virtual column index on \"end_row\",\n                0-based exclusive, rounded up to full screen lines. When\n                omitted include the whole line.\n\nReturn: ~\n    Dict containing text height information, with these keys:\n    \226\128\162 all: The total number of screen lines occupied by the range.\n    \226\128\162 fill: The number of diff filler or virtual lines among them.\n\nSee also: ~\n  \226\128\162 |virtcol()| for text width."}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "Nvim API api\n\nNvim exposes a powerful API that can be used by plugins and external processes\nvia RPC, Lua and Vimscript (eval-api).\n\nApplications can also embed libnvim to work with the C API directly."}}, b = {binding = "b", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Buffer-scoped (|b:|) variables for the current buffer.\nInvalid or unset key returns `nil`. Can be indexed with\nan integer to access variables for a specific buffer."}}, base64 = {binding = "base64", fields = {decode = {binding = "decode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Decode a Base64 encoded string.\n\nParameters: ~\n  \226\128\162 {str}  (`string`) Base64 encoded string\n\nReturn: ~\n    (`string`) Decoded string"}}, encode = {binding = "encode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Encode {str} using Base64.\n\nParameters: ~\n  \226\128\162 {str}  (`string`) String to encode\n\nReturn: ~\n    (`string`) Encoded string"}}}, metadata = {["fls/itemKind"] = "Module"}}, bo = {binding = "bo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Get or set buffer-scoped |options| for the buffer with number {bufnr}.\nLike `:setlocal`. If {bufnr} is omitted then the current buffer is used.\nInvalid {bufnr} or key is an error.\n\nExample: >lua\n    local bufnr = vim.api.nvim_get_current_buf()\n    vim.bo[bufnr].buflisted = true    -- same as vim.bo.buflisted = true\n    print(vim.bo.comments)\n    print(vim.bo.baz)                 -- error: invalid key\n<"}}, call = {binding = "call", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"func", "..."}, ["fnl/docstring"] = "Invokes |vim-function| or |user-function| {func} with arguments {...}.\nSee also |vim.fn|.\nEquivalent to: >lua\n    vim.fn[func]({...})\n<\n"}}, cmd = {binding = "cmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"command"}, ["fnl/docstring"] = "Executes Vimscript (|Ex-commands|).\n\nCan be indexed with a command name to get a function, thus you can write\n`vim.cmd.echo(\226\128\166)` instead of `vim.cmd{cmd='echo',\226\128\166}`.\n\nExamples: >lua\n    -- Single command:\n    vim.cmd('echo 42')\n    -- Multiline script:\n    vim.cmd([[\n      augroup my.group\n        autocmd!\n        autocmd FileType c setlocal cindent\n      augroup END\n    ]])\n\n    -- Ex command :echo \"foo\". Note: string literals must be double-quoted.\n    vim.cmd('echo \"foo\"')\n    vim.cmd { cmd = 'echo', args = { '\"foo\"' } }\n    vim.cmd.echo({ args = { '\"foo\"' } })\n    vim.cmd.echo('\"foo\"')\n\n    -- Ex command :write! myfile.txt\n    vim.cmd('write! myfile.txt')\n    vim.cmd { cmd = 'write', args = { 'myfile.txt' }, bang = true }\n    vim.cmd.write { args = { 'myfile.txt' }, bang = true }\n    vim.cmd.write { 'myfile.txt', bang = true }\n\n    -- Ex command :vertical resize +2\n    vim.cmd.resize({ '+2', mods = { vertical = true } })\n<\n\nParameters: ~\n  \226\128\162 {command}  (`string|table`) Command(s) to execute.\n               \226\128\162 The string form supports multiline Vimscript (alias to\n                 |nvim_exec2()|, behaves like |:source|).\n               \226\128\162 The table form executes a single command (alias to\n                 |nvim_cmd()|).\n\nSee also: ~\n  \226\128\162 |ex-cmd-index|"}}, deep_equal = {binding = "deep_equal", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"a", "b"}, ["fnl/docstring"] = "Deep compare values for equality\n\nTables are compared recursively unless they both provide the `eq`\nmetamethod. All other types are compared using the equality `==` operator.\n\nParameters: ~\n  \226\128\162 {a}  (`any`) First value\n  \226\128\162 {b}  (`any`) Second value\n\nReturn: ~\n    (`boolean`) `true` if values are equals, else `false`"}}, deepcopy = {binding = "deepcopy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"orig", "?noref"}, ["fnl/docstring"] = "Returns a deep copy of the given object. Non-table objects are copied as\nin a typical Lua assignment, whereas table objects are copied recursively.\nFunctions are naively copied, so functions in the copied table point to\nthe same functions as those in the input table. Userdata and threads are\nnot copied and will throw an error.\n\nNote: `noref=true` is much more performant on tables with unique table\nfields, while `noref=false` is more performant on tables that reuse table\nfields.\n\nParameters: ~\n  \226\128\162 {orig}   (`table`) Table to copy\n  \226\128\162 {noref}  (`boolean?`) When `false` (default) a contained table is only\n             copied once and all references point to this single copy.\n             When `true` every occurrence of a table results in a new\n             copy. This also means that a cyclic reference can cause\n             `deepcopy()` to fail.\n\nReturn: ~\n    (`table`) Table of copied keys and (nested) values."}}, defaulttable = {binding = "defaulttable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?createfn"}, ["fnl/docstring"] = "Creates a table whose missing keys are provided by {createfn} (like\nPython's \"defaultdict\").\n\nIf {createfn} is `nil` it defaults to defaulttable() itself, so accessing\nnested keys creates nested tables: >lua\n    local a = vim.defaulttable()\n    a.b.c = 1\n<\n\nParameters: ~\n  \226\128\162 {createfn}  (`fun(key:any):any?`) Provides the value for a missing\n                `key`.\n\nReturn: ~\n    (`table`) Empty table with `__index` metamethod."}}, defer_fn = {binding = "defer_fn", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fn", "timeout"}, ["fnl/docstring"] = "Defers calling {fn} until {timeout} ms passes.\n\nUse to do a one-shot timer that calls {fn} Note: The {fn} is\n|vim.schedule_wrap()|ped automatically, so API functions are safe to call.\n\nParameters: ~\n  \226\128\162 {fn}       (`function`) Callback to call once `timeout` expires\n  \226\128\162 {timeout}  (`integer`) Number of milliseconds to wait before calling\n               `fn`\n\nReturn: ~\n    (`table`) timer luv timer object\n\n                                                         "}}, deprecate = {binding = "deprecate", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?alternative", "version", "?plugin", "?backtrace"}, ["fnl/docstring"] = "Shows a deprecation message to the user.\n\nParameters: ~\n  \226\128\162 {name}         (`string`) Deprecated feature (function, API, etc.).\n  \226\128\162 {alternative}  (`string?`) Suggested alternative feature.\n  \226\128\162 {version}      (`string`) Version when the deprecated function will be\n                   removed.\n  \226\128\162 {plugin}       (`string?`) Name of the plugin that owns the deprecated\n                   feature. Defaults to \"Nvim\".\n  \226\128\162 {backtrace}    (`boolean?`) Prints backtrace. Defaults to true.\n\nReturn: ~\n    (`string?`) Deprecated message, or nil if no message was shown."}}, diagnostic = {binding = "diagnostic", fields = {JumpOpts = {binding = "JumpOpts", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nrenamed its \"cursor_position\" field to \"pos\"."}}, config = {binding = "config", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts", "?namespace"}, ["fnl/docstring"] = "Configure diagnostic options globally or for a specific diagnostic\nnamespace.\n\nConfiguration can be specified globally, per-namespace, or ephemerally\n(i.e. only for a single call to |vim.diagnostic.set()| or\n|vim.diagnostic.show()|). Ephemeral configuration has highest priority,\nfollowed by namespace configuration, and finally global configuration.\n\nFor example, if a user enables virtual text globally with >lua\n    vim.diagnostic.config({ virtual_text = true })\n<\n\nand a diagnostic producer sets diagnostics with >lua\n    vim.diagnostic.set(ns, 0, diagnostics, { virtual_text = false })\n<\n\nthen virtual text will not be enabled for those diagnostics.\n\nParameters: ~\n  \226\128\162 {opts}       (`vim.diagnostic.Opts?`) When omitted or `nil`, retrieve\n                 the current configuration. Otherwise, a configuration\n                 table (see |vim.diagnostic.Opts|).\n  \226\128\162 {namespace}  (`integer?`) Update the options for the given namespace.\n                 When omitted, update the global diagnostic options.\n\nReturn: ~\n    (`vim.diagnostic.Opts?`) Current diagnostic config if {opts} is\n    omitted. See |vim.diagnostic.Opts|."}}, count = {binding = "count", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?opts"}, ["fnl/docstring"] = "Get current diagnostics count.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer number to get diagnostics from. Use 0 for\n             current buffer or nil for all buffers.\n  \226\128\162 {opts}   (`vim.diagnostic.GetOpts?`) See |vim.diagnostic.GetOpts|.\n\nReturn: ~\n    (`table`) Table with actually present severity values as keys (see\n    |diagnostic-severity|) and integer counts as values."}}, enable = {binding = "enable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?enable", "?filter"}, ["fnl/docstring"] = "Enables or disables diagnostics.\n\nTo \"toggle\", pass the inverse of `is_enabled()`: >lua\n    vim.diagnostic.enable(not vim.diagnostic.is_enabled())\n<\n\nParameters: ~\n  \226\128\162 {enable}  (`boolean?`) true/nil to enable, false to disable\n  \226\128\162 {filter}  (`table?`) Optional filters |kwargs|, or `nil` for all.\n              \226\128\162 {ns_id}? (`integer`) Diagnostic namespace, or `nil` for\n                all.\n              \226\128\162 {bufnr}? (`integer`) Buffer number, or 0 for current\n                buffer, or `nil` for all buffers."}}, fromqflist = {binding = "fromqflist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Convert a list of quickfix items to a list of diagnostics.\n\nParameters: ~\n  \226\128\162 {list}  (`table[]`) List of quickfix items from |getqflist()| or\n            |getloclist()|.\n\nReturn: ~\n    (`vim.Diagnostic[]`) See |vim.Diagnostic|."}}, get = {binding = "get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?opts"}, ["fnl/docstring"] = "Get current diagnostics.\n\nModifying diagnostics in the returned table has no effect. To set\ndiagnostics in a buffer, use |vim.diagnostic.set()|.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer number to get diagnostics from. Use 0 for\n             current buffer or nil for all buffers.\n  \226\128\162 {opts}   (`vim.diagnostic.GetOpts?`) See |vim.diagnostic.GetOpts|.\n\nReturn: ~\n    (`vim.Diagnostic[]`) Fields `bufnr`, `end_lnum`, `end_col`, and\n    `severity` are guaranteed to be present. See |vim.Diagnostic|."}}, get_namespace = {binding = "get_namespace", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"namespace"}, ["fnl/docstring"] = "Get namespace metadata.\n\nParameters: ~\n  \226\128\162 {namespace}  (`integer`) Diagnostic namespace\n\nReturn: ~\n    (`vim.diagnostic.NS`) Namespace metadata. See |vim.diagnostic.NS|."}}, get_namespaces = {binding = "get_namespaces", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Get current diagnostic namespaces.\n\nReturn: ~\n    (`table<integer,vim.diagnostic.NS>`) List of active diagnostic\n    namespaces |vim.diagnostic|."}}, get_next = {binding = "get_next", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Get the next diagnostic closest to the cursor position.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.diagnostic.JumpOpts?`) See |vim.diagnostic.JumpOpts|.\n\nReturn: ~\n    (`vim.Diagnostic?`) Next diagnostic. See |vim.Diagnostic|."}}, get_next_pos = {binding = "get_next_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse the \"lnum\" and \"col\" fields from the\n\t\t\t\treturn value of |vim.diagnostic.get_next()| instead."}}, get_prev = {binding = "get_prev", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Get the previous diagnostic closest to the cursor position.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.diagnostic.JumpOpts?`) See |vim.diagnostic.JumpOpts|.\n\nReturn: ~\n    (`vim.Diagnostic?`) Previous diagnostic. See |vim.Diagnostic|."}}, get_prev_pos = {binding = "get_prev_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse the \"lnum\" and \"col\" fields from the\n\t\t\t\treturn value of |vim.diagnostic.get_prev()| instead."}}, goto_next = {binding = "goto_next", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |vim.diagnostic.jump()| with `{count=1, float=true}` instead."}}, goto_prev = {binding = "goto_prev", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |vim.diagnostic.jump()| with `{count=-1, float=true}` instead."}}, hide = {binding = "hide", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?namespace", "?bufnr"}, ["fnl/docstring"] = "Hide currently displayed diagnostics.\n\nThis only clears the decorations displayed in the buffer. Diagnostics can\nbe redisplayed with |vim.diagnostic.show()|. To completely remove\ndiagnostics, use |vim.diagnostic.reset()|.\n\nTo hide diagnostics and prevent them from re-displaying, use\n|vim.diagnostic.enable()|.\n\nParameters: ~\n  \226\128\162 {namespace}  (`integer?`) Diagnostic namespace. When omitted, hide\n                 diagnostics from all namespaces.\n  \226\128\162 {bufnr}      (`integer?`) Buffer number, or 0 for current buffer. When\n                 omitted, hide diagnostics in all buffers."}}, is_enabled = {binding = "is_enabled", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?filter"}, ["fnl/docstring"] = "Check whether diagnostics are enabled.\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {filter}  (`table?`) Optional filters |kwargs|, or `nil` for all.\n              \226\128\162 {ns_id}? (`integer`) Diagnostic namespace, or `nil` for\n                all.\n              \226\128\162 {bufnr}? (`integer`) Buffer number, or 0 for current\n                buffer, or `nil` for all buffers.\n\nReturn: ~\n    (`boolean`)"}}, jump = {binding = "jump", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "Move to a diagnostic.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.diagnostic.JumpOpts`) See |vim.diagnostic.JumpOpts|.\n\nReturn: ~\n    (`vim.Diagnostic?`) The diagnostic that was moved to. See\n    |vim.Diagnostic|.\n\n                                                  "}}, match = {binding = "match", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "pat", "groups", "severity_map", "?defaults"}, ["fnl/docstring"] = "Parse a diagnostic from a string.\n\nFor example, consider a line of output from a linter: >\n    WARNING filename:27:3: Variable 'foo' does not exist\n<\n\nThis can be parsed into |vim.Diagnostic| structure with: >lua\n    local s = \"WARNING filename:27:3: Variable 'foo' does not exist\"\n    local pattern = \"^(%w+) %w+:(%d+):(%d+): (.+)$\"\n    local groups = { \"severity\", \"lnum\", \"col\", \"message\" }\n    vim.diagnostic.match(s, pattern, groups, { WARNING = vim.diagnostic.WARN })\n<\n\nParameters: ~\n  \226\128\162 {str}           (`string`) String to parse diagnostics from.\n  \226\128\162 {pat}           (`string`) Lua pattern with capture groups.\n  \226\128\162 {groups}        (`string[]`) List of fields in a |vim.Diagnostic|\n                    structure to associate with captures from {pat}.\n  \226\128\162 {severity_map}  (`table`) A table mapping the severity field from\n                    {groups} with an item from |vim.diagnostic.severity|.\n  \226\128\162 {defaults}      (`table?`) Table of default values for any fields not\n                    listed in {groups}. When omitted, numeric values\n                    default to 0 and \"severity\" defaults to ERROR.\n\nReturn: ~\n    (`vim.Diagnostic?`) |vim.Diagnostic| structure or `nil` if {pat} fails\n    to match {str}."}}, open_float = {binding = "open_float", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Show diagnostics in a floating window.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.diagnostic.Opts.Float?`) See\n            |vim.diagnostic.Opts.Float|.\n\nReturn (multiple): ~\n    (`integer?`) float_bufnr\n    (`integer?`) winid"}}, reset = {binding = "reset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?namespace", "?bufnr"}, ["fnl/docstring"] = "Remove all diagnostics from the given namespace.\n\nUnlike |vim.diagnostic.hide()|, this function removes all saved\ndiagnostics. They cannot be redisplayed using |vim.diagnostic.show()|. To\nsimply remove diagnostic decorations in a way that they can be\nre-displayed, use |vim.diagnostic.hide()|.\n\nParameters: ~\n  \226\128\162 {namespace}  (`integer?`) Diagnostic namespace. When omitted, remove\n                 diagnostics from all namespaces.\n  \226\128\162 {bufnr}      (`integer?`) Remove diagnostics for the given buffer.\n                 When omitted, diagnostics are removed for all buffers."}}, set = {binding = "set", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"namespace", "bufnr", "diagnostics", "?opts"}, ["fnl/docstring"] = "Set diagnostics for the given namespace and buffer.\n\nParameters: ~\n  \226\128\162 {namespace}    (`integer`) The diagnostic namespace\n  \226\128\162 {bufnr}        (`integer`) Buffer number\n  \226\128\162 {diagnostics}  (`vim.Diagnostic[]`) See |vim.Diagnostic|.\n  \226\128\162 {opts}         (`vim.diagnostic.Opts?`) Display options to pass to\n                   |vim.diagnostic.show()|. See |vim.diagnostic.Opts|."}}, setloclist = {binding = "setloclist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Add buffer diagnostics to the location list.\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) Configuration table with the following keys:\n            \226\128\162 {namespace}? (`integer`) Only add diagnostics from the given\n              namespace.\n            \226\128\162 {winnr}? (`integer`, default: `0`) Window number to set\n              location list for.\n            \226\128\162 {open}? (`boolean`, default: `true`) Open the location list\n              after setting.\n            \226\128\162 {title}? (`string`) Title of the location list. Defaults to\n              \"Diagnostics\".\n            \226\128\162 {severity}? (`vim.diagnostic.SeverityFilter`) See\n              |diagnostic-severity|."}}, setqflist = {binding = "setqflist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Add all diagnostics to the quickfix list.\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) Configuration table with the following keys:\n            \226\128\162 {namespace}? (`integer`) Only add diagnostics from the given\n              namespace.\n            \226\128\162 {open}? (`boolean`, default: `true`) Open quickfix list\n              after setting.\n            \226\128\162 {title}? (`string`) Title of quickfix list. Defaults to\n              \"Diagnostics\". If there's already a quickfix list with this\n              title, it's updated. If not, a new quickfix list is created.\n            \226\128\162 {severity}? (`vim.diagnostic.SeverityFilter`) See\n              |diagnostic-severity|.\n\n                                                   "}}, severity = {binding = "severity", fields = {ERROR = {binding = "ERROR", metadata = {["fls/itemKind"] = "EnumMember"}}, HINT = {binding = "HINT", metadata = {["fls/itemKind"] = "EnumMember"}}, INFO = {binding = "INFO", metadata = {["fls/itemKind"] = "EnumMember"}}, WARN = {binding = "WARN", metadata = {["fls/itemKind"] = "EnumMember"}}}, metadata = {["fls/itemKind"] = "Module"}}, show = {binding = "show", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?namespace", "?bufnr", "?diagnostics", "?opts"}, ["fnl/docstring"] = "Display diagnostics for the given namespace and buffer.\n\nParameters: ~\n  \226\128\162 {namespace}    (`integer?`) Diagnostic namespace. When omitted, show\n                   diagnostics from all namespaces.\n  \226\128\162 {bufnr}        (`integer?`) Buffer number, or 0 for current buffer.\n                   When omitted, show diagnostics in all buffers.\n  \226\128\162 {diagnostics}  (`vim.Diagnostic[]?`) The diagnostics to display. When\n                   omitted, use the saved diagnostics for the given\n                   namespace and buffer. This can be used to display a\n                   list of diagnostics without saving them or to display\n                   only a subset of diagnostics. May not be used when\n                   {namespace} or {bufnr} is nil. See |vim.Diagnostic|.\n  \226\128\162 {opts}         (`vim.diagnostic.Opts?`) Display options. See\n                   |vim.diagnostic.Opts|."}}, toqflist = {binding = "toqflist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"diagnostics"}, ["fnl/docstring"] = "Convert a list of diagnostics to a list of quickfix items that can be\npassed to |setqflist()| or |setloclist()|.\n\nParameters: ~\n  \226\128\162 {diagnostics}  (`vim.Diagnostic[]`) See |vim.Diagnostic|.\n\nReturn: ~\n    (`table[]`) Quickfix list items |setqflist-what|"}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "Diagnostic framework\nNvim provides a framework for displaying errors or warnings from external\ntools, otherwise known as \"diagnostics\". These diagnostics can come from a\nvariety of sources, such as linters or LSP servers. The diagnostic framework\nis an extension to existing error handling functionality such as the\nquickfix list."}}, diff = {binding = "diff", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"a", "b", "?opts"}, ["fnl/docstring"] = "Run diff on strings {a} and {b}. Any indices returned by this function,\neither directly or via callback arguments, are 1-based.\n\nExamples: >lua\n    vim.diff('a\\n', 'b\\nc\\n')\n    -- =>\n    -- @@ -1 +1,2 @@\n    -- -a\n    -- +b\n    -- +c\n\n    vim.diff('a\\n', 'b\\nc\\n', {result_type = 'indices'})\n    -- =>\n    -- {\n    --   {1, 1, 1, 2}\n    -- }\n<\n\nParameters: ~\n  \226\128\162 {a}     (`string`) First string to compare\n  \226\128\162 {b}     (`string`) Second string to compare\n  \226\128\162 {opts}  (`table?`) Optional parameters:\n            \226\128\162 {on_hunk}?\n              (`fun(start_a: integer, count_a: integer, start_b: integer, count_b: integer): integer?`)\n              Invoked for each hunk in the diff. Return a negative number\n              to cancel the callback for any remaining hunks. Arguments:\n              \226\128\162 `start_a` (`integer`): Start line of hunk in {a}.\n              \226\128\162 `count_a` (`integer`): Hunk size in {a}.\n              \226\128\162 `start_b` (`integer`): Start line of hunk in {b}.\n              \226\128\162 `count_b` (`integer`): Hunk size in {b}.\n            \226\128\162 {result_type}? (`'unified'|'indices'`, default: `'unified'`)\n              Form of the returned diff:\n              \226\128\162 `unified`: String in unified format.\n              \226\128\162 `indices`: Array of hunk locations. Note: This option is\n                ignored if `on_hunk` is used.\n            \226\128\162 {linematch}? (`boolean|integer`) Run linematch on the\n              resulting hunks from xdiff. When integer, only hunks upto\n              this size in lines are run through linematch. Requires\n              `result_type = indices`, ignored otherwise.\n            \226\128\162 {algorithm}? (`'myers'|'minimal'|'patience'|'histogram'`,\n              default: `'myers'`) Diff algorithm to use. Values:\n              \226\128\162 `myers`: the default algorithm\n              \226\128\162 `minimal`: spend extra time to generate the smallest\n                possible diff\n              \226\128\162 `patience`: patience diff algorithm\n              \226\128\162 `histogram`: histogram diff algorithm\n            \226\128\162 {ctxlen}? (`integer`) Context length\n            \226\128\162 {interhunkctxlen}? (`integer`) Inter hunk context length\n            \226\128\162 {ignore_whitespace}? (`boolean`) Ignore whitespace\n            \226\128\162 {ignore_whitespace_change}? (`boolean`) Ignore whitespace\n              change\n            \226\128\162 {ignore_whitespace_change_at_eol}? (`boolean`) Ignore\n              whitespace change at end-of-line.\n            \226\128\162 {ignore_cr_at_eol}? (`boolean`) Ignore carriage return at\n              end-of-line\n            \226\128\162 {ignore_blank_lines}? (`boolean`) Ignore blank lines\n            \226\128\162 {indent_heuristic}? (`boolean`) Use the indent heuristic for\n              the internal diff library.\n\nReturn: ~\n    (`string|integer[][]?`) See {opts.result_type}. `nil` if\n    {opts.on_hunk} is given."}}, empty_dict = {binding = "empty_dict", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates a special empty table (marked with a metatable), which Nvim\nconverts to an empty dictionary when translating Lua values to Vimscript\nor API types. Nvim by default converts an empty table `{}` without this\nmetatable to an list/array.\n\nNote: If numeric keys are present in the table, Nvim ignores the metatable\nmarker and converts the dict to a list/array anyway.\n\nReturn: ~\n    (`table`)"}}, endswith = {binding = "endswith", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s", "suffix"}, ["fnl/docstring"] = "Tests if `s` ends with `suffix`.\n\nParameters: ~\n  \226\128\162 {s}       (`string`) String\n  \226\128\162 {suffix}  (`string`) Suffix to match\n\nReturn: ~\n    (`boolean`) `true` if `suffix` is a suffix of `s`"}}, env = {binding = "env", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Environment variables defined in the editor session. See |expand-env| and\n|:let-environment| for the Vimscript behavior. Invalid or unset key\nreturns `nil`.\n\nExample: >lua\n    vim.env.FOO = 'bar'\n    print(vim.env.TERM)\n<"}}, filetype = {binding = "filetype", fields = {add = {binding = "add", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"filetypes"}, ["fnl/docstring"] = "Add new filetype mappings.\n\nFiletype mappings can be added either by extension or by filename (either\nthe \"tail\" or the full file path). The full file path is checked first,\nfollowed by the file name. If a match is not found using the filename,\nthen the filename is matched against the list of |lua-pattern|s (sorted by\npriority) until a match is found. Lastly, if pattern matching does not\nfind a filetype, then the file extension is used.\n\nThe filetype can be either a string (in which case it is used as the\nfiletype directly) or a function. If a function, it takes the full path\nand buffer number of the file as arguments (along with captures from the\nmatched pattern, if any) and should return a string that will be used as\nthe buffer's filetype. Optionally, the function can return a second\nfunction value which, when called, modifies the state of the buffer. This\ncan be used to, for example, set filetype-specific buffer variables. This\nfunction will be called by Nvim before setting the buffer's filetype.\n\nFilename patterns can specify an optional priority to resolve cases when a\nfile path matches multiple patterns. Higher priorities are matched first.\nWhen omitted, the priority defaults to 0. A pattern can contain\nenvironment variables of the form \"${SOME_VAR}\" that will be automatically\nexpanded. If the environment variable is not set, the pattern won't be\nmatched.\n\nSee $VIMRUNTIME/lua/vim/filetype.lua for more examples.\n\nExample: >lua\n    vim.filetype.add({\n      extension = {\n        foo = 'fooscript',\n        bar = function(path, bufnr)\n          if some_condition() then\n            return 'barscript', function(bufnr)\n              -- Set a buffer variable\n              vim.b[bufnr].barscript_version = 2\n            end\n          end\n          return 'bar'\n        end,\n      },\n      filename = {\n        ['.foorc'] = 'toml',\n        ['/etc/foo/config'] = 'toml',\n      },\n      pattern = {\n        ['.*/etc/foo/.*'] = 'fooscript',\n        -- Using an optional priority\n        ['.*/etc/foo/.*%.conf'] = { 'dosini', { priority = 10 } },\n        -- A pattern containing an environment variable\n        ['${XDG_CONFIG_HOME}/foo/git'] = 'git',\n        ['.*README.(%a+)'] = function(path, bufnr, ext)\n          if ext == 'md' then\n            return 'markdown'\n          elseif ext == 'rst' then\n            return 'rst'\n          end\n        end,\n      },\n    })\n<\n\nTo add a fallback match on contents, use >lua\n    vim.filetype.add {\n      pattern = {\n        ['.*'] = {\n          function(path, bufnr)\n            local content = vim.api.nvim_buf_get_lines(bufnr, 0, 1, false)[1] or ''\n            if vim.regex([[^#!.*\\\\<mine\\\\>]]):match_str(content) ~= nil then\n              return 'mine'\n            elseif vim.regex([[\\\\<drawing\\\\>]]):match_str(content) ~= nil then\n              return 'drawing'\n            end\n          end,\n          { priority = -math.huge },\n        },\n      },\n    }\n<\n\nParameters: ~\n  \226\128\162 {filetypes}  (`table`) A table containing new filetype maps (see\n                 example).\n                 \226\128\162 {pattern}? (`vim.filetype.mapping`)\n                 \226\128\162 {extension}? (`vim.filetype.mapping`)\n                 \226\128\162 {filename}? (`vim.filetype.mapping`)\n\n                                               "}}, get_option = {binding = "get_option", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"filetype", "option"}, ["fnl/docstring"] = "Get the default option value for a {filetype}.\n\nThe returned value is what would be set in a new buffer after 'filetype'\nis set, meaning it should respect all FileType autocmds and ftplugin\nfiles.\n\nExample: >lua\n    vim.filetype.get_option('vim', 'commentstring')\n<\n\nNote: this uses |nvim_get_option_value()| but caches the result. This\nmeans |ftplugin| and |FileType| autocommands are only triggered once and\nmay not reflect later changes.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {filetype}  (`string`) Filetype\n  \226\128\162 {option}    (`string`) Option name\n\nReturn: ~\n    (`string|boolean|integer`) Option value"}}, match = {binding = "match", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"args"}, ["fnl/docstring"] = "Perform filetype detection.\n\nThe filetype can be detected using one of three methods:\n1. Using an existing buffer\n2. Using only a file name\n3. Using only file contents\n\nOf these, option 1 provides the most accurate result as it uses both the\nbuffer's filename and (optionally) the buffer contents. Options 2 and 3\ncan be used without an existing buffer, but may not always provide a match\nin cases where the filename (or contents) cannot unambiguously determine\nthe filetype.\n\nEach of the three options is specified using a key to the single argument\nof this function. Example: >lua\n    -- Using a buffer number\n    vim.filetype.match({ buf = 42 })\n\n    -- Override the filename of the given buffer\n    vim.filetype.match({ buf = 42, filename = 'foo.c' })\n\n    -- Using a filename without a buffer\n    vim.filetype.match({ filename = 'main.lua' })\n\n    -- Using file contents\n    vim.filetype.match({ contents = {'#!/usr/bin/env bash'} })\n<\n\nParameters: ~\n  \226\128\162 {args}  (`table`) Table specifying which matching strategy to use.\n            Accepted keys are:\n            \226\128\162 {buf}? (`integer`) Buffer number to use for matching.\n              Mutually exclusive with {contents}\n            \226\128\162 {filename}? (`string`) Filename to use for matching. When\n              {buf} is given, defaults to the filename of the given buffer\n              number. The file need not actually exist in the filesystem.\n              When used without {buf} only the name of the file is used\n              for filetype matching. This may result in failure to detect\n              the filetype in cases where the filename alone is not enough\n              to disambiguate the filetype.\n            \226\128\162 {contents}? (`string[]`) An array of lines representing file\n              contents to use for matching. Can be used with {filename}.\n              Mutually exclusive with {buf}.\n\nReturn (multiple): ~\n    (`string?`) If a match was found, the matched filetype.\n    (`function?`) A function that modifies buffer state when called (for\n    example, to set some filetype specific buffer variables). The function\n    accepts a buffer number as its only argument."}}}, metadata = {["fls/itemKind"] = "Module"}}, fn = {binding = "fn", fields = {abs = {binding = "abs", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the absolute value of {expr}.  When {expr} evaluates to\na |Float| abs() returns a |Float|.  When {expr} can be\nconverted to a |Number| abs() returns a |Number|.  Otherwise\nabs() gives an error message and returns -1.\nExamples: >vim\n\techo abs(1.456)\n<\t\t\0091.456  >vim\n\techo abs(-5.456)\n<\t\t\0095.456  >vim\n\techo abs(-4)\n<\t\t\0094\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, acos = {binding = "acos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the arc cosine of {expr} measured in radians, as a\n|Float| in the range of [0, pi].\n{expr} must evaluate to a |Float| or a |Number| in the range\n[-1, 1].\nReturns NaN if {expr} is outside the range [-1, 1].  Returns\n0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo acos(0)\n<\t\t\0091.570796 >vim\n\techo acos(-0.5)\n<\t\t\0092.094395\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, add = {binding = "add", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object", "expr"}, ["fnl/docstring"] = "Append the item {expr} to |List| or |Blob| {object}.  Returns\nthe resulting |List| or |Blob|.  Examples: >vim\n\tlet alist = add([1, 2, 3], item)\n\tcall add(mylist, \"woodstock\")\n<\t\tNote that when {expr} is a |List| it is appended as a single\nitem.  Use |extend()| to concatenate |Lists|.\nWhen {object} is a |Blob| then {expr} must be a number.\nUse |insert()| to add an item at another position.\nReturns 1 if {object} is not a |List| or a |Blob|.\n\n                Parameters: ~\n                  \226\128\162 {object} (`any`)\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`) Resulting |List| or |Blob|, or 1 if {object} is not\n                  a |List| or a |Blob|."}}, ["and"] = {binding = "and", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "expr1"}, ["fnl/docstring"] = "Bitwise AND on the two arguments.  The arguments are converted\nto a number.  A List, Dict or Float argument causes an error.\nAlso see `or()` and `xor()`.\nExample: >vim\n\tlet flag = and(bits, 0x80)\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n                  \226\128\162 {expr1} (`number`)\n\n                Return: ~\n                  (`integer`)"}}, api_info = {binding = "api_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns Dictionary of |api-metadata|.\n\nView it in a nice human-readable format: >vim\n       lua vim.print(vim.fn.api_info())\n<\n\n                Return: ~\n                  (`table`)"}}, append = {binding = "append", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "text"}, ["fnl/docstring"] = "When {text} is a |List|: Append each item of the |List| as a\ntext line below line {lnum} in the current buffer.\nOtherwise append {text} as one text line below line {lnum} in\nthe current buffer.\nAny type of item is accepted and converted to a String.\n{lnum} can be zero to insert a line before the first one.\n{lnum} is used like with |getline()|.\nReturns 1 for failure ({lnum} out of range or out of memory),\n0 for success.  When {text} is an empty list zero is returned,\nno matter the value of {lnum}.  Example: >vim\n\tlet failed = append(line('$'), \"# THE END\")\n\tlet failed = append(0, [\"Chapter 1\", \"the beginning\"])\n<\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {text} (`string|string[]`)\n\n                Return: ~\n                  (`0|1`)"}}, appendbufline = {binding = "appendbufline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "lnum", "text"}, ["fnl/docstring"] = "Like |append()| but append the text in buffer {expr}.\n\nThis function works only for loaded buffers. First call\n|bufload()| if needed.\n\nFor the use of {buf}, see |bufname()|.\n\n{lnum} is the line number to append below.  Note that using\n|line()| would use the current buffer, not the one appending\nto.  Use \"$\" to append at the end of the buffer.  Other string\nvalues are not supported.\n\nOn success 0 is returned, on failure 1 is returned.\n\nIf {buf} is not a valid buffer or {lnum} is not valid, an\nerror message is given. Example: >vim\n\tlet failed = appendbufline(13, 0, \"# THE START\")\n<\t\tHowever, when {text} is an empty list then no error is given\nfor an invalid {lnum}, since {lnum} isn't actually used.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {lnum} (`integer`)\n                  \226\128\162 {text} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, argc = {binding = "argc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winid"}, ["fnl/docstring"] = "The result is the number of files in the argument list.  See\n|arglist|.\nIf {winid} is not supplied, the argument list of the current\nwindow is used.\nIf {winid} is -1, the global argument list is used.\nOtherwise {winid} specifies the window of which the argument\nlist is used: either the window number or the window ID.\nReturns -1 if the {winid} argument is invalid.\n\n                Parameters: ~\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, argidx = {binding = "argidx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is the current index in the argument list.  0 is\nthe first file.  argc() - 1 is the last one.  See |arglist|.\n\n                Return: ~\n                  (`integer`)"}}, arglistid = {binding = "arglistid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winnr", "?tabnr"}, ["fnl/docstring"] = "Return the argument list ID.  This is a number which\nidentifies the argument list being used.  Zero is used for the\nglobal argument list.  See |arglist|.\nReturns -1 if the arguments are invalid.\n\nWithout arguments use the current window.\nWith {winnr} only use this window in the current tab page.\nWith {winnr} and {tabnr} use the window in the specified tab\npage.\n{winnr} can be the window number or the |window-ID|.\n\n                Parameters: ~\n                  \226\128\162 {winnr} (`integer?`)\n                  \226\128\162 {tabnr} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, argv = {binding = "argv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?nr", "?winid"}, ["fnl/docstring"] = "The result is the {nr}th file in the argument list.  See\n|arglist|.  \"argv(0)\" is the first one.  Example: >vim\n\tlet i = 0\n\twhile i < argc()\n\t  let f = escape(fnameescape(argv(i)), '.')\n\t  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'\n\t  let i = i + 1\n\tendwhile\n<\t\tWithout the {nr} argument, or when {nr} is -1, a |List| with\nthe whole |arglist| is returned.\n\nThe {winid} argument specifies the window ID, see |argc()|.\nFor the Vim command line arguments see |v:argv|.\n\nReturns an empty string if {nr}th argument is not present in\nthe argument list.  Returns an empty List if the {winid}\nargument is invalid.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer?`)\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`string|string[]`)"}}, asin = {binding = "asin", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the arc sine of {expr} measured in radians, as a |Float|\nin the range of [-pi/2, pi/2].\n{expr} must evaluate to a |Float| or a |Number| in the range\n[-1, 1].\nReturns NaN if {expr} is outside the range [-1, 1].  Returns\n0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo asin(0.8)\n<\t\t\0090.927295 >vim\n\techo asin(-0.5)\n<\t\t\t-0.523599\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`number`)"}}, assert_beeps = {binding = "assert_beeps", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd"}, ["fnl/docstring"] = "Run {cmd} and add an error message to |v:errors| if it does\nNOT produce a beep or visual bell.\nAlso see |assert_fails()|, |assert_nobeep()| and\n|assert-return|.\n\n                Parameters: ~\n                  \226\128\162 {cmd} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_equal = {binding = "assert_equal", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expected", "actual", "?msg"}, ["fnl/docstring"] = "When {expected} and {actual} are not equal an error message is\nadded to |v:errors| and 1 is returned.  Otherwise zero is\nreturned. |assert-return|\nThe error is in the form \"Expected {expected} but got\n{actual}\".  When {msg} is present it is prefixed to that,\nalong with the location of the assert when run from a script.\n\nThere is no automatic conversion, the String \"4\" is different\nfrom the Number 4.  And the number 4 is different from the\nFloat 4.0.  The value of 'ignorecase' is not used here, case\nalways matters.\nExample: >vim\n\tcall assert_equal('foo', 'bar', 'baz')\n<\t\tWill add the following to |v:errors|:\n\ttest.vim line 12: baz: Expected 'foo' but got 'bar' ~\n\n                Parameters: ~\n                  \226\128\162 {expected} (`any`)\n                  \226\128\162 {actual} (`any`)\n                  \226\128\162 {msg} (`any?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_equalfile = {binding = "assert_equalfile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname_one", "fname_two"}, ["fnl/docstring"] = "When the files {fname_one} and {fname_two} do not contain\nexactly the same text an error message is added to |v:errors|.\nAlso see |assert-return|.\nWhen {fname_one} or {fname_two} does not exist the error will\nmention that.\n\n                Parameters: ~\n                  \226\128\162 {fname_one} (`string`)\n                  \226\128\162 {fname_two} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_exception = {binding = "assert_exception", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"error", "?msg"}, ["fnl/docstring"] = "When v:exception does not contain the string {error} an error\nmessage is added to |v:errors|.  Also see |assert-return|.\nThis can be used to assert that a command throws an exception.\nUsing the error number, followed by a colon, avoids problems\nwith translations: >vim\n\ttry\n\t  commandthatfails\n\t  call assert_false(1, 'command should have failed')\n\tcatch\n\t  call assert_exception('E492:')\n\tendtry\n<\n\n                Parameters: ~\n                  \226\128\162 {error} (`any`)\n                  \226\128\162 {msg} (`any?`)\n\n                Return: ~\n                  (`0|1`)\n\n                                                                "}}, assert_fails = {binding = "assert_fails", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "?error", "?msg", "?lnum", "?context"}, ["fnl/docstring"] = "Run {cmd} and add an error message to |v:errors| if it does\nNOT produce an error or when {error} is not found in the\nerror message.  Also see |assert-return|.\n\nWhen {error} is a string it must be found literally in the\nfirst reported error. Most often this will be the error code,\nincluding the colon, e.g. \"E123:\". >vim\n\tcall assert_fails('bad cmd', 'E987:')\n<\nWhen {error} is a |List| with one or two strings, these are\nused as patterns.  The first pattern is matched against the\nfirst reported error: >vim\n\tcall assert_fails('cmd', ['E987:.*expected bool'])\n<\t\tThe second pattern, if present, is matched against the last\nreported error.  To only match the last error use an empty\nstring for the first error: >vim\n\tcall assert_fails('cmd', ['', 'E987:'])\n<\nIf {msg} is empty then it is not used.  Do this to get the\ndefault message when passing the {lnum} argument.\n\t\t\t\t\t*E1115*\nWhen {lnum} is present and not negative, and the {error}\nargument is present and matches, then this is compared with\nthe line number at which the error was reported. That can be\nthe line number in a function or in a script.\n\t\t\t\t\t*E1116*\nWhen {context} is present it is used as a pattern and matched\nagainst the context (script name or function name) where\n{lnum} is located in.\n\nNote that beeping is not considered an error, and some failing\ncommands only beep.  Use |assert_beeps()| for those.\n\n                Parameters: ~\n                  \226\128\162 {cmd} (`string`)\n                  \226\128\162 {error} (`any?`)\n                  \226\128\162 {msg} (`any?`)\n                  \226\128\162 {lnum} (`integer?`)\n                  \226\128\162 {context} (`any?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_false = {binding = "assert_false", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"actual", "?msg"}, ["fnl/docstring"] = "When {actual} is not false an error message is added to\n|v:errors|, like with |assert_equal()|.\nThe error is in the form \"Expected False but got {actual}\".\nWhen {msg} is present it is prefixed to that, along with the\nlocation of the assert when run from a script.\nAlso see |assert-return|.\n\nA value is false when it is zero. When {actual} is not a\nnumber the assert fails.\n\n                Parameters: ~\n                  \226\128\162 {actual} (`any`)\n                  \226\128\162 {msg} (`any?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_inrange = {binding = "assert_inrange", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lower", "upper", "actual", "?msg"}, ["fnl/docstring"] = "This asserts number and |Float| values.  When {actual}  is lower\nthan {lower} or higher than {upper} an error message is added\nto |v:errors|.  Also see |assert-return|.\nThe error is in the form \"Expected range {lower} - {upper},\nbut got {actual}\".  When {msg} is present it is prefixed to\nthat.\n\n                Parameters: ~\n                  \226\128\162 {lower} (`number`)\n                  \226\128\162 {upper} (`number`)\n                  \226\128\162 {actual} (`number`)\n                  \226\128\162 {msg} (`string?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_match = {binding = "assert_match", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern", "actual", "?msg"}, ["fnl/docstring"] = "When {pattern} does not match {actual} an error message is\nadded to |v:errors|.  Also see |assert-return|.\nThe error is in the form \"Pattern {pattern} does not match\n{actual}\".  When {msg} is present it is prefixed to that,\nalong with the location of the assert when run from a script.\n\n{pattern} is used as with |expr-=~|: The matching is always done\nlike 'magic' was set and 'cpoptions' is empty, no matter what\nthe actual value of 'magic' or 'cpoptions' is.\n\n{actual} is used as a string, automatic conversion applies.\nUse \"^\" and \"$\" to match with the start and end of the text.\nUse both to match the whole text.\n\nExample: >vim\n\tcall assert_match('^f.*o$', 'foobar')\n<\t\tWill result in a string to be added to |v:errors|:\n\ttest.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~\n\n                Parameters: ~\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {actual} (`string`)\n                  \226\128\162 {msg} (`string?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_nobeep = {binding = "assert_nobeep", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd"}, ["fnl/docstring"] = "Run {cmd} and add an error message to |v:errors| if it\nproduces a beep or visual bell.\nAlso see |assert_beeps()|.\n\n                Parameters: ~\n                  \226\128\162 {cmd} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_notequal = {binding = "assert_notequal", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expected", "actual", "?msg"}, ["fnl/docstring"] = "The opposite of `assert_equal()`: add an error message to\n|v:errors| when {expected} and {actual} are equal.\nAlso see |assert-return|.\n\n                Parameters: ~\n                  \226\128\162 {expected} (`any`)\n                  \226\128\162 {actual} (`any`)\n                  \226\128\162 {msg} (`any?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_notmatch = {binding = "assert_notmatch", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern", "actual", "?msg"}, ["fnl/docstring"] = "The opposite of `assert_match()`: add an error message to\n|v:errors| when {pattern} matches {actual}.\nAlso see |assert-return|.\n\n                Parameters: ~\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {actual} (`string`)\n                  \226\128\162 {msg} (`string?`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_report = {binding = "assert_report", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg"}, ["fnl/docstring"] = "Report a test failure directly, using String {msg}.\nAlways returns one.\n\n                Parameters: ~\n                  \226\128\162 {msg} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, assert_true = {binding = "assert_true", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"actual", "?msg"}, ["fnl/docstring"] = "When {actual} is not true an error message is added to\n|v:errors|, like with |assert_equal()|.\nAlso see |assert-return|.\nA value is |TRUE| when it is a non-zero number or |v:true|.\nWhen {actual} is not a number or |v:true| the assert fails.\nWhen {msg} is given it is prefixed to the default message,\nalong with the location of the assert when run from a script.\n\n                Parameters: ~\n                  \226\128\162 {actual} (`any`)\n                  \226\128\162 {msg} (`string?`)\n\n                Return: ~\n                  (`0|1`)"}}, atan = {binding = "atan", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the principal value of the arc tangent of {expr}, in\nthe range [-pi/2, +pi/2] radians, as a |Float|.\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo atan(100)\n<\t\t\0091.560797 >vim\n\techo atan(-4.01)\n<\t\t\t-1.326405\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, atan2 = {binding = "atan2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2"}, ["fnl/docstring"] = "Return the arc tangent of {expr1} / {expr2}, measured in\nradians, as a |Float| in the range [-pi, pi].\n{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr1} or {expr2} is not a |Float| or a\n|Number|.\nExamples: >vim\n\techo atan2(-1, 1)\n<\t\t\t-0.785398 >vim\n\techo atan2(1, -1)\n<\t\t\0092.356194\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`number`)\n                  \226\128\162 {expr2} (`number`)\n\n                Return: ~\n                  (`number`)"}}, blob2list = {binding = "blob2list", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"blob"}, ["fnl/docstring"] = "Return a List containing the number value of each byte in Blob\n{blob}.  Examples: >vim\n\tblob2list(0z0102.0304)\t\" returns [1, 2, 3, 4]\n\tblob2list(0z)\t\t\" returns []\n<\t\tReturns an empty List on error.  |list2blob()| does the\nopposite.\n\n                Parameters: ~\n                  \226\128\162 {blob} (`any`)\n\n                Return: ~\n                  (`any[]`)"}}, browse = {binding = "browse", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"save", "title", "initdir", "default"}, ["fnl/docstring"] = "Put up a file requester.  This only works when \"has(\"browse\")\"\nreturns |TRUE| (only in some GUI versions).\nThe input fields are:\n    {save}\twhen |TRUE|, select file to write\n    {title}\ttitle for the requester\n    {initdir}\tdirectory to start browsing in\n    {default}\tdefault file name\nAn empty string is returned when the \"Cancel\" button is hit,\nsomething went wrong, or browsing is not possible.\n\n                Parameters: ~\n                  \226\128\162 {save} (`any`)\n                  \226\128\162 {title} (`string`)\n                  \226\128\162 {initdir} (`string`)\n                  \226\128\162 {default} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, browsedir = {binding = "browsedir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"title", "initdir"}, ["fnl/docstring"] = "Put up a directory requester.  This only works when\n\"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\nOn systems where a directory browser is not supported a file\nbrowser is used.  In that case: select a file in the directory\nto be used.\nThe input fields are:\n    {title}\ttitle for the requester\n    {initdir}\tdirectory to start browsing in\nWhen the \"Cancel\" button is hit, something went wrong, or\nbrowsing is not possible, an empty string is returned.\n\n                Parameters: ~\n                  \226\128\162 {title} (`string`)\n                  \226\128\162 {initdir} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, bufadd = {binding = "bufadd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Add a buffer to the buffer list with name {name} (must be a\nString).\nIf a buffer for file {name} already exists, return that buffer\nnumber.  Otherwise return the buffer number of the newly\ncreated buffer.  When {name} is an empty string then a new\nbuffer is always created.\nThe buffer will not have 'buflisted' set and not be loaded\nyet.  To add some text to the buffer use this: >vim\n\tlet bufnr = bufadd('someName')\n\tcall bufload(bufnr)\n\tcall setbufline(bufnr, 1, ['some', 'text'])\n<\t\tReturns 0 on error.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, bufexists = {binding = "bufexists", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| if a buffer called\n{buf} exists.\nIf the {buf} argument is a number, buffer numbers are used.\nNumber zero is the alternate buffer for the current window.\n\nIf the {buf} argument is a string it must match a buffer name\nexactly.  The name can be:\n- Relative to the current directory.\n- A full path.\n- The name of a buffer with 'buftype' set to \"nofile\".\n- A URL name.\nUnlisted buffers will be found.\nNote that help files are listed by their short name in the\noutput of |:buffers|, but bufexists() requires using their\nlong name to be able to find them.\nbufexists() may report a buffer exists, but to use the name\nwith a |:buffer| command you may need to use |expand()|.  Esp\nfor MS-Windows 8.3 names in the form \"c:\\DOCUME~1\"\nUse \"bufexists(0)\" to test for the existence of an alternate\nfile name.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`any`)\n\n                Return: ~\n                  (`0|1`)"}}, buflisted = {binding = "buflisted", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| if a buffer called\n{buf} exists and is listed (has the 'buflisted' option set).\nThe {buf} argument is used like with |bufexists()|.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`any`)\n\n                Return: ~\n                  (`0|1`)"}}, bufload = {binding = "bufload", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "Ensure the buffer {buf} is loaded.  When the buffer name\nrefers to an existing file then the file is read.  Otherwise\nthe buffer will be empty.  If the buffer was already loaded\nthen there is no change.  If the buffer is not related to a\nfile then no file is read (e.g., when 'buftype' is \"nofile\").\nIf there is an existing swap file for the file of the buffer,\nthere will be no dialog, the buffer will be loaded anyway.\nThe {buf} argument is used like with |bufexists()|.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`any`)"}}, bufloaded = {binding = "bufloaded", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| if a buffer called\n{buf} exists and is loaded (shown in a window or hidden).\nThe {buf} argument is used like with |bufexists()|.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`any`)\n\n                Return: ~\n                  (`0|1`)"}}, bufname = {binding = "bufname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?buf"}, ["fnl/docstring"] = "The result is the name of a buffer.  Mostly as it is displayed\nby the `:ls` command, but not using special names such as\n\"[No Name]\".\nIf {buf} is omitted the current buffer is used.\nIf {buf} is a Number, that buffer number's name is given.\nNumber zero is the alternate buffer for the current window.\nIf {buf} is a String, it is used as a |file-pattern| to match\nwith the buffer names.  This is always done like 'magic' is\nset and 'cpoptions' is empty.  When there is more than one\nmatch an empty string is returned.\n\"\" or \"%\" can be used for the current buffer, \"#\" for the\nalternate buffer.\nA full match is preferred, otherwise a match at the start, end\nor middle of the buffer name is accepted.  If you only want a\nfull match then put \"^\" at the start and \"$\" at the end of the\npattern.\nListed buffers are found first.  If there is a single match\nwith a listed buffer, that one is returned.  Next unlisted\nbuffers are searched for.\nIf the {buf} is a String, but you want to use it as a buffer\nnumber, force it to be a Number by adding zero to it: >vim\n\techo bufname(\"3\" + 0)\n<\t\tIf the buffer doesn't exist, or doesn't have a name, an empty\nstring is returned. >vim\n\techo bufname(\"#\")\t\" alternate buffer name\n\techo bufname(3)\t\t\" name of buffer 3\n\techo bufname(\"%\")\t\" name of current buffer\n\techo bufname(\"file2\")\t\" name of buffer where \"file2\" matches.\n<\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string?`)\n\n                Return: ~\n                  (`string`)"}}, bufnr = {binding = "bufnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?buf", "?create"}, ["fnl/docstring"] = "The result is the number of a buffer, as it is displayed by\nthe `:ls` command.  For the use of {buf}, see |bufname()|\nabove.\nIf the buffer doesn't exist, -1 is returned.  Or, if the\n{create} argument is present and TRUE, a new, unlisted,\nbuffer is created and its number is returned.\nbufnr(\"$\") is the last buffer: >vim\n\tlet last_buffer = bufnr(\"$\")\n<\t\tThe result is a Number, which is the highest buffer number\nof existing buffers.  Note that not all buffers with a smaller\nnumber necessarily exist, because \":bwipeout\" may have removed\nthem.  Use bufexists() to test for the existence of a buffer.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string?`)\n                  \226\128\162 {create} (`any?`)\n\n                Return: ~\n                  (`integer`)"}}, bufwinid = {binding = "bufwinid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "The result is a Number, which is the |window-ID| of the first\nwindow associated with buffer {buf}.  For the use of {buf},\nsee |bufname()| above.  If buffer {buf} doesn't exist or\nthere is no such window, -1 is returned.  Example: >vim\n\n\techo \"A window containing buffer 1 is \" .. (bufwinid(1))\n<\nOnly deals with the current tab page.  See |win_findbuf()| for\nfinding more.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`any`)\n\n                Return: ~\n                  (`integer`)"}}, bufwinnr = {binding = "bufwinnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "Like |bufwinid()| but return the window number instead of the\n|window-ID|.\nIf buffer {buf} doesn't exist or there is no such window, -1\nis returned.  Example: >vim\n\n\techo \"A window containing buffer 1 is \" .. (bufwinnr(1))\n\n<\t\tThe number can be used with |CTRL-W_w| and \":wincmd w\"\n|:wincmd|.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`any`)\n\n                Return: ~\n                  (`integer`)"}}, byte2line = {binding = "byte2line", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"byte"}, ["fnl/docstring"] = "Return the line number that contains the character at byte\ncount {byte} in the current buffer.  This includes the\nend-of-line character, depending on the 'fileformat' option\nfor the current buffer.  The first character has byte count\none.\nAlso see |line2byte()|, |go| and |:goto|.\n\nReturns -1 if the {byte} value is invalid.\n\n                Parameters: ~\n                  \226\128\162 {byte} (`any`)\n\n                Return: ~\n                  (`integer`)"}}, byteidx = {binding = "byteidx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "nr", "?utf16"}, ["fnl/docstring"] = "Return byte index of the {nr}th character in the String\n{expr}.  Use zero for the first character, it then returns\nzero.\nIf there are no multibyte characters the returned value is\nequal to {nr}.\nComposing characters are not counted separately, their byte\nlength is added to the preceding base character.  See\n|byteidxcomp()| below for counting composing characters\nseparately.\nWhen {utf16} is present and TRUE, {nr} is used as the UTF-16\nindex in the String {expr} instead of as the character index.\nThe UTF-16 index is the index in the string when it is encoded\nwith 16-bit words.  If the specified UTF-16 index is in the\nmiddle of a character (e.g. in a 4-byte character), then the\nbyte index of the first byte in the character is returned.\nRefer to |string-offset-encoding| for more information.\nExample : >vim\n\techo matchstr(str, \".\", byteidx(str, 3))\n<\t\twill display the fourth character.  Another way to do the\nsame: >vim\n\tlet s = strpart(str, byteidx(str, 3))\n\techo strpart(s, 0, byteidx(s, 1))\n<\t\tAlso see |strgetchar()| and |strcharpart()|.\n\nIf there are less than {nr} characters -1 is returned.\nIf there are exactly {nr} characters the length of the string\nin bytes is returned.\nSee |charidx()| and |utf16idx()| for getting the character and\nUTF-16 index respectively from the byte index.\nExamples: >vim\n\techo byteidx('a\240\159\152\138\240\159\152\138', 2)\t\" returns 5\n\techo byteidx('a\240\159\152\138\240\159\152\138', 2, 1)\t\" returns 1\n\techo byteidx('a\240\159\152\138\240\159\152\138', 3, 1)\t\" returns 5\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {utf16} (`any?`)\n\n                Return: ~\n                  (`integer`)"}}, byteidxcomp = {binding = "byteidxcomp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "nr", "?utf16"}, ["fnl/docstring"] = "Like byteidx(), except that a composing character is counted\nas a separate character.  Example: >vim\n\tlet s = 'e' .. nr2char(0x301)\n\techo byteidx(s, 1)\n\techo byteidxcomp(s, 1)\n\techo byteidxcomp(s, 2)\n<\t\tThe first and third echo result in 3 ('e' plus composing\ncharacter is 3 bytes), the second echo results in 1 ('e' is\none byte).\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {utf16} (`any?`)\n\n                Return: ~\n                  (`integer`)"}}, call = {binding = "call", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"func", "arglist", "?dict"}, ["fnl/docstring"] = "Call function {func} with the items in |List| {arglist} as\narguments.\n{func} can either be a |Funcref| or the name of a function.\na:firstline and a:lastline are set to the cursor line.\nReturns the return value of the called function.\n{dict} is for functions with the \"dict\" attribute.  It will be\nused to set the local variable \"self\". |Dictionary-function|\n\n                Parameters: ~\n                  \226\128\162 {func} (`any`)\n                  \226\128\162 {arglist} (`any`)\n                  \226\128\162 {dict} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, ceil = {binding = "ceil", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the smallest integral value greater than or equal to\n{expr} as a |Float| (round up).\n{expr} must evaluate to a |Float| or a |Number|.\nExamples: >vim\n\techo ceil(1.456)\n<\t\t\0092.0  >vim\n\techo ceil(-5.456)\n<\t\t\t-5.0  >vim\n\techo ceil(4.0)\n<\t\t\0094.0\n\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, chanclose = {binding = "chanclose", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id", "?stream"}, ["fnl/docstring"] = "Close a channel or a specific stream associated with it.\nFor a job, {stream} can be one of \"stdin\", \"stdout\",\n\"stderr\" or \"rpc\" (closes stdin/stdout for a job started\nwith `\"rpc\":v:true`) If {stream} is omitted, all streams\nare closed. If the channel is a pty, this will then close the\npty master, sending SIGHUP to the job process.\nFor a socket, there is only one stream, and {stream} should be\nomitted.\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer`)\n                  \226\128\162 {stream} (`string?`)\n\n                Return: ~\n                  (`0|1`)"}}, changenr = {binding = "changenr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the number of the most recent change.  This is the same\nnumber as what is displayed with |:undolist| and can be used\nwith the |:undo| command.\nWhen a change was made it is the number of that change.  After\nredo it is the number of the redone change.  After undo it is\none less than the number of the undone change.\nReturns 0 if the undo list is empty.\n\n                Return: ~\n                  (`integer`)"}}, chansend = {binding = "chansend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id", "data"}, ["fnl/docstring"] = "Send data to channel {id}. For a job, it writes it to the\nstdin of the process. For the stdio channel |channel-stdio|,\nit writes to Nvim's stdout.  Returns the number of bytes\nwritten if the write succeeded, 0 otherwise.\nSee |channel-bytes| for more information.\n\n{data} may be a string, string convertible, |Blob|, or a list.\nIf {data} is a list, the items will be joined by newlines; any\nnewlines in an item will be sent as NUL. To send a final\nnewline, include a final empty string. Example: >vim\n\tcall chansend(id, [\"abc\", \"123\\n456\", \"\"])\n<\t\twill send \"abc<NL>123<NUL>456<NL>\".\n\nchansend() writes raw data, not RPC messages.  If the channel\nwas created with `\"rpc\":v:true` then the channel expects RPC\nmessages, use |rpcnotify()| and |rpcrequest()| instead.\n\n                Parameters: ~\n                  \226\128\162 {id} (`number`)\n                  \226\128\162 {data} (`string|string[]`)\n\n                Return: ~\n                  (`0|1`)"}}, char2nr = {binding = "char2nr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?utf8"}, ["fnl/docstring"] = "Return Number value of the first char in {string}.\nExamples: >vim\n\techo char2nr(\" \")\t\" returns 32\n\techo char2nr(\"ABC\")\t\" returns 65\n\techo char2nr(\"\195\161\")\t\" returns 225\n\techo char2nr(\"\195\161\"[0])\t\" returns 195\n\techo char2nr(\"\\<M-x>\")\t\" returns 128\n<\t\tNon-ASCII characters are always treated as UTF-8 characters.\n{utf8} is ignored, it exists only for backwards-compatibility.\nA combining character is a separate character.\n|nr2char()| does the opposite.\n\nReturns 0 if {string} is not a |String|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {utf8} (`any?`)\n\n                Return: ~\n                  (`0|1`)"}}, charclass = {binding = "charclass", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Return the character class of the first character in {string}.\nThe character class is one of:\n\0090\tblank\n\0091\tpunctuation\n\0092\tword character (depends on 'iskeyword')\n\0093\temoji\n\tother\tspecific Unicode class\nThe class is used in patterns and word motions.\nReturns 0 if {string} is not a |String|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`0|1|2|3|'other'`)"}}, charcol = {binding = "charcol", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?winid"}, ["fnl/docstring"] = "Same as |col()| but returns the character index of the column\nposition given with {expr} instead of the byte position.\n\nExample:\nWith the cursor on '\236\132\184' in line 5 with text \"\236\151\172\235\179\180\236\132\184\236\154\148\": >vim\n\techo charcol('.')\t\" returns 3\n\techo col('.')\t\t\" returns 7\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string|any[]`)\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, charidx = {binding = "charidx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "idx", "?countcc", "?utf16"}, ["fnl/docstring"] = "Return the character index of the byte at {idx} in {string}.\nThe index of the first character is zero.\nIf there are no multibyte characters the returned value is\nequal to {idx}.\n\nWhen {countcc} is omitted or |FALSE|, then composing characters\nare not counted separately, their byte length is added to the\npreceding base character.\nWhen {countcc} is |TRUE|, then composing characters are\ncounted as separate characters.\n\nWhen {utf16} is present and TRUE, {idx} is used as the UTF-16\nindex in the String {expr} instead of as the byte index.\n\nReturns -1 if the arguments are invalid or if there are less\nthan {idx} bytes. If there are exactly {idx} bytes the length\nof the string in characters is returned.\n\nAn error is given and -1 is returned if the first argument is\nnot a string, the second argument is not a number or when the\nthird argument is present and is not zero or one.\n\nSee |byteidx()| and |byteidxcomp()| for getting the byte index\nfrom the character index and |utf16idx()| for getting the\nUTF-16 index from the character index.\nRefer to |string-offset-encoding| for more information.\nExamples: >vim\n\techo charidx('a\204\129b\204\129c\204\129', 3)\t\t\" returns 1\n\techo charidx('a\204\129b\204\129c\204\129', 6, 1)\t\" returns 4\n\techo charidx('a\204\129b\204\129c\204\129', 16)\t\t\" returns -1\n\techo charidx('a\240\159\152\138\240\159\152\138', 4, 0, 1)\t\" returns 2\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {idx} (`integer`)\n                  \226\128\162 {countcc} (`boolean?`)\n                  \226\128\162 {utf16} (`boolean?`)\n\n                Return: ~\n                  (`integer`)"}}, chdir = {binding = "chdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dir"}, ["fnl/docstring"] = "Change the current working directory to {dir}.  The scope of\nthe directory change depends on the directory of the current\nwindow:\n\t- If the current window has a window-local directory\n\t  (|:lcd|), then changes the window local directory.\n\t- Otherwise, if the current tabpage has a local\n\t  directory (|:tcd|) then changes the tabpage local\n\t  directory.\n\t- Otherwise, changes the global directory.\n{dir} must be a String.\nIf successful, returns the previous working directory.  Pass\nthis to another chdir() to restore the directory.\nOn failure, returns an empty string.\n\nExample: >vim\n\tlet save_dir = chdir(newdir)\n\tif save_dir != \"\"\n\t   \" ... do some work\n\t   call chdir(save_dir)\n\tendif\n<\n\n                Parameters: ~\n                  \226\128\162 {dir} (`string`)\n\n                Return: ~\n                  (`string`)"}}, cindent = {binding = "cindent", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Get the amount of indent for line {lnum} according the\n|C-indenting| rules, as with 'cindent'.\nThe indent is counted in spaces, the value of 'tabstop' is\nrelevant.  {lnum} is used just like in |getline()|.\nWhen {lnum} is invalid -1 is returned.\n\nTo get or set indent of lines in a string, see |vim.text.indent()|.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, clearmatches = {binding = "clearmatches", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?win"}, ["fnl/docstring"] = "Clears all matches previously defined for the current window\nby |matchadd()| and the |:match| commands.\nIf {win} is specified, use the window with this number or\nwindow ID instead of the current window.\n\n                Parameters: ~\n                  \226\128\162 {win} (`integer?`)"}}, col = {binding = "col", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?winid"}, ["fnl/docstring"] = "The result is a Number, which is the byte index of the column\nposition given with {expr}.\nFor accepted positions see |getpos()|.\nWhen {expr} is \"$\", it means the end of the cursor line, so\nthe result is the number of bytes in the cursor line plus one.\nAdditionally {expr} can be [lnum, col]: a |List| with the line\nand column number. Most useful when the column is \"$\", to get\nthe last column of a specific line.  When \"lnum\" or \"col\" is\nout of range then col() returns zero.\n\nWith the optional {winid} argument the values are obtained for\nthat window instead of the current window.\n\nTo get the line number use |line()|.  To get both use\n|getpos()|.\n\nFor the screen column position use |virtcol()|.  For the\ncharacter position use |charcol()|.\n\nNote that only marks in the current file can be used.\n\nExamples: >vim\n\techo col(\".\")\t\t\t\" column of cursor\n\techo col(\"$\")\t\t\t\" length of cursor line plus one\n\techo col(\"'t\")\t\t\t\" column of mark t\n\techo col(\"'\" .. markname)\t\" column of mark markname\n<\nThe first column is 1.  Returns 0 if {expr} is invalid or when\nthe window with ID {winid} is not found.\nFor an uppercase mark the column may actually be in another\nbuffer.\nFor the cursor position, when 'virtualedit' is active, the\ncolumn is one higher if the cursor is after the end of the\nline.  Also, when using a <Cmd> mapping the cursor isn't\nmoved, this can be used to obtain the column in Insert mode: >vim\n\timap <F2> <Cmd>echo col(\".\")..\"\\n\"<CR>\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string|any[]`)\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, complete = {binding = "complete", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"startcol", "matches"}, ["fnl/docstring"] = "Set the matches for Insert mode completion.\nCan only be used in Insert mode.  You need to use a mapping\nwith CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\nor with an expression mapping.\n{startcol} is the byte offset in the line where the completed\ntext start.  The text up to the cursor is the original text\nthat will be replaced by the matches.  Use col('.') for an\nempty string.  \"col('.') - 1\" will replace one character by a\nmatch.\n{matches} must be a |List|.  Each |List| item is one match.\nSee |complete-items| for the kind of items that are possible.\n\"longest\" in 'completeopt' is ignored.\nNote that the after calling this function you need to avoid\ninserting anything that would cause completion to stop.\nThe match can be selected with CTRL-N and CTRL-P as usual with\nInsert mode completion.  The popup menu will appear if\nspecified, see |ins-completion-menu|.\nExample: >vim\n\tinoremap <F5> <C-R>=ListMonths()<CR>\n\n\tfunc ListMonths()\n\t  call complete(col('.'), ['January', 'February', 'March',\n\t    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n\t    \\ 'October', 'November', 'December'])\n\t  return ''\n\tendfunc\n<\t\tThis isn't very useful, but it shows how it works.  Note that\nan empty string is returned to avoid a zero being inserted.\n\n                Parameters: ~\n                  \226\128\162 {startcol} (`integer`)\n                  \226\128\162 {matches} (`any[]`)"}}, complete_add = {binding = "complete_add", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Add {expr} to the list of matches.  Only to be used by the\nfunction specified with the 'completefunc' option.\nReturns 0 for failure (empty string or out of memory),\n1 when the match was added, 2 when the match was already in\nthe list.\nSee |complete-functions| for an explanation of {expr}.  It is\nthe same as one item in the list that 'omnifunc' would return.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`0|1|2`)"}}, complete_check = {binding = "complete_check", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Check for a key typed while looking for completion matches.\nThis is to be used when looking for matches takes some time.\nReturns |TRUE| when searching for matches is to be aborted,\nzero otherwise.\nOnly to be used by the function specified with the\n'completefunc' option.\n\n                Return: ~\n                  (`0|1`)"}}, complete_info = {binding = "complete_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?what"}, ["fnl/docstring"] = "Returns a |Dictionary| with information about Insert mode\ncompletion.  See |ins-completion|.\nThe items are:\n   mode\t\tCurrent completion mode name string.\n\t\tSee |complete_info_mode| for the values.\n   pum_visible\t|TRUE| if popup menu is visible.\n\t\tSee |pumvisible()|.\n   items\tList of all completion candidates.  Each item\n\t\tis a dictionary containing the entries \"word\",\n\t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n\t\tSee |complete-items|.\n   matches\tSame as \"items\", but only returns items that\n\t\tare matching current query. If both \"matches\"\n\t\tand \"items\" are in \"what\", the returned list\n\t\twill still be named \"items\", but each item\n\t\twill have an additional \"match\" field.\n   selected\tSelected item index.  First index is zero.\n\t\tIndex is -1 if no item is selected (showing\n\t\ttyped text only, or the last completion after\n\t\tno item is selected when using the <Up> or\n\t\t<Down> keys)\n   completed\tReturn a dictionary containing the entries of\n\t\tthe currently selected index item.\n   preview_winid     Info floating preview window id.\n   preview_bufnr     Info floating preview buffer id.\n\n\t\t\t\t\t*complete_info_mode*\nmode values are:\n   \"\"\t\t     Not in completion mode\n   \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n   \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n   \"scroll\"\t     Scrolling with |i_CTRL-X_CTRL-E| or\n\t\t     |i_CTRL-X_CTRL-Y|\n   \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n   \"files\"\t     File names |i_CTRL-X_CTRL-F|\n   \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n   \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n   \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n   \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n   \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n   \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n   \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n   \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n   \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n   \"eval\"\t     |complete()| completion\n   \"unknown\"\t     Other internal modes\n\nIf the optional {what} list argument is supplied, then only\nthe items listed in {what} are returned.  Unsupported items in\n{what} are silently ignored.\n\nTo get the position and size of the popup menu, see\n|pum_getpos()|. It's also available in |v:event| during the\n|CompleteChanged| event.\n\nReturns an empty |Dictionary| on error.\n\nExamples: >vim\n\t\" Get all items\n\tcall complete_info()\n\t\" Get only 'mode'\n\tcall complete_info(['mode'])\n\t\" Get only 'mode' and 'pum_visible'\n\tcall complete_info(['mode', 'pum_visible'])\n<\n\n                Parameters: ~\n                  \226\128\162 {what} (`any[]?`)\n\n                Return: ~\n                  (`table`)"}}, confirm = {binding = "confirm", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg", "?choices", "?default", "?type"}, ["fnl/docstring"] = "confirm() offers the user a dialog, from which a choice can be\nmade.  It returns the number of the choice.  For the first\nchoice this is 1.\n\n{msg} is displayed in a dialog with {choices} as the\nalternatives.  When {choices} is missing or empty, \"&OK\" is\nused (and translated).\n{msg} is a String, use '\\n' to include a newline.  Only on\nsome systems the string is wrapped when it doesn't fit.\n\n{choices} is a String, with the individual choices separated\nby '\\n', e.g. >vim\n\tconfirm(\"Save changes?\", \"&Yes\\n&No\\n&Cancel\")\n<\t\tThe letter after the '&' is the shortcut key for that choice.\nThus you can type 'c' to select \"Cancel\".  The shortcut does\nnot need to be the first letter: >vim\n\tconfirm(\"file has been modified\", \"&Save\\nSave &All\")\n<\t\tFor the console, the first letter of each choice is used as\nthe default shortcut key.  Case is ignored.\n\nThe optional {type} String argument gives the type of dialog.\nIt can be one of these values: \"Error\", \"Question\", \"Info\",\n\"Warning\" or \"Generic\".  Only the first character is relevant.\nWhen {type} is omitted, \"Generic\" is used.\n\nThe optional {type} argument gives the type of dialog.  This\nis only used for the icon of the Win32 GUI.  It can be one of\nthese values: \"Error\", \"Question\", \"Info\", \"Warning\" or\n\"Generic\".  Only the first character is relevant.\nWhen {type} is omitted, \"Generic\" is used.\n\nIf the user aborts the dialog by pressing <Esc>, CTRL-C,\nor another valid interrupt key, confirm() returns 0.\n\nAn example: >vim\n   let choice = confirm(\"What do you want?\",\n\t\t\t\\ \"&Apples\\n&Oranges\\n&Bananas\", 2)\n   if choice == 0\n\techo \"make up your mind!\"\n   elseif choice == 3\n\techo \"tasteful\"\n   else\n\techo \"I prefer bananas myself.\"\n   endif\n<\t\tIn a GUI dialog, buttons are used.  The layout of the buttons\ndepends on the 'v' flag in 'guioptions'.  If it is included,\nthe buttons are always put vertically.  Otherwise,  confirm()\ntries to put the buttons in one horizontal line.  If they\ndon't fit, a vertical layout is used anyway.  For some systems\nthe horizontal layout is always used.\n\n                Parameters: ~\n                  \226\128\162 {msg} (`string`)\n                  \226\128\162 {choices} (`string?`)\n                  \226\128\162 {default} (`integer?`)\n                  \226\128\162 {type} (`string?`)\n\n                Return: ~\n                  (`integer`)"}}, copy = {binding = "copy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Make a copy of {expr}.  For Numbers and Strings this isn't\ndifferent from using {expr} directly.\nWhen {expr} is a |List| a shallow copy is created.  This means\nthat the original |List| can be changed without changing the\ncopy, and vice versa.  But the items are identical, thus\nchanging an item changes the contents of both |Lists|.\nA |Dictionary| is copied in a similar way as a |List|.\nAlso see |deepcopy()|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`T`)\n\n                Return: ~\n                  (`T`)"}}, cos = {binding = "cos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the cosine of {expr}, measured in radians, as a |Float|.\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo cos(100)\n<\t\t\0090.862319 >vim\n\techo cos(-4.01)\n<\t\t\t-0.646043\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, cosh = {binding = "cosh", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the hyperbolic cosine of {expr} as a |Float| in the range\n[1, inf].\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo cosh(0.5)\n<\t\t\0091.127626 >vim\n\techo cosh(-0.5)\n<\t\t\t-1.127626\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, count = {binding = "count", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"comp", "expr", "?ic", "?start"}, ["fnl/docstring"] = "Return the number of times an item with value {expr} appears\nin |String|, |List| or |Dictionary| {comp}.\n\nIf {start} is given then start with the item with this index.\n{start} can only be used with a |List|.\n\nWhen {ic} is given and it's |TRUE| then case is ignored.\n\nWhen {comp} is a string then the number of not overlapping\noccurrences of {expr} is returned. Zero is returned when\n{expr} is an empty string.\n\n                Parameters: ~\n                  \226\128\162 {comp} (`string|table|any[]`)\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {ic} (`boolean?`)\n                  \226\128\162 {start} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, ctxget = {binding = "ctxget", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?index"}, ["fnl/docstring"] = "Returns a |Dictionary| representing the |context| at {index}\nfrom the top of the |context-stack| (see |context-dict|).\nIf {index} is not given, it is assumed to be 0 (i.e.: top).\n\n                Parameters: ~\n                  \226\128\162 {index} (`integer?`)\n\n                Return: ~\n                  (`table`)"}}, ctxpop = {binding = "ctxpop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Pops and restores the |context| at the top of the\n|context-stack|.\n\n                Return: ~\n                  (`any`)"}}, ctxpush = {binding = "ctxpush", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?types"}, ["fnl/docstring"] = "Pushes the current editor state (|context|) on the\n|context-stack|.\nIf {types} is given and is a |List| of |String|s, it specifies\nwhich |context-types| to include in the pushed context.\nOtherwise, all context types are included.\n\n                Parameters: ~\n                  \226\128\162 {types} (`string[]?`)\n\n                Return: ~\n                  (`any`)"}}, ctxset = {binding = "ctxset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"context", "?index"}, ["fnl/docstring"] = "Sets the |context| at {index} from the top of the\n|context-stack| to that represented by {context}.\n{context} is a Dictionary with context data (|context-dict|).\nIf {index} is not given, it is assumed to be 0 (i.e.: top).\n\n                Parameters: ~\n                  \226\128\162 {context} (`table`)\n                  \226\128\162 {index} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, ctxsize = {binding = "ctxsize", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the size of the |context-stack|.\n\n                Return: ~\n                  (`any`)"}}, cursor = {binding = "cursor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Positions the cursor at the column (byte count) {col} in the\nline {lnum}.  The first column is one.\n\nWhen there is one argument {list} this is used as a |List|\nwith two, three or four item:\n\t[{lnum}, {col}]\n\t[{lnum}, {col}, {off}]\n\t[{lnum}, {col}, {off}, {curswant}]\nThis is like the return value of |getpos()| or |getcurpos()|,\nbut without the first item.\n\nTo position the cursor using {col} as the character count, use\n|setcursorcharpos()|.\n\nDoes not change the jumplist.\n{lnum} is used like with |getline()|, except that if {lnum} is\nzero, the cursor will stay in the current line.\nIf {lnum} is greater than the number of lines in the buffer,\nthe cursor will be positioned at the last line in the buffer.\nIf {col} is greater than the number of bytes in the line,\nthe cursor will be positioned at the last character in the\nline.\nIf {col} is zero, the cursor will stay in the current column.\nIf {curswant} is given it is used to set the preferred column\nfor vertical movement.  Otherwise {col} is used.\n\nWhen 'virtualedit' is used {off} specifies the offset in\nscreen columns from the start of the character.  E.g., a\nposition within a <Tab> or after the last character.\nReturns 0 when the position could be set, -1 otherwise.\n\n                Parameters: ~\n                  \226\128\162 {list} (`integer[]`)\n\n                Return: ~\n                  (`any`)"}}, debugbreak = {binding = "debugbreak", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pid"}, ["fnl/docstring"] = "Specifically used to interrupt a program being debugged.  It\nwill cause process {pid} to get a SIGTRAP.  Behavior for other\nprocesses is undefined. See |terminal-debug|.\n(Sends a SIGINT to a process {pid} other than MS-Windows)\n\nReturns |TRUE| if successfully interrupted the program.\nOtherwise returns |FALSE|.\n\n                Parameters: ~\n                  \226\128\162 {pid} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, deepcopy = {binding = "deepcopy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?noref"}, ["fnl/docstring"] = "Make a copy of {expr}.  For Numbers and Strings this isn't\ndifferent from using {expr} directly.\nWhen {expr} is a |List| a full copy is created.  This means\nthat the original |List| can be changed without changing the\ncopy, and vice versa.  When an item is a |List|, a copy for it\nis made, recursively.  Thus changing an item in the copy does\nnot change the contents of the original |List|.\n\nWhen {noref} is omitted or zero a contained |List| or\n|Dictionary| is only copied once.  All references point to\nthis single copy.  With {noref} set to 1 every occurrence of a\n|List| or |Dictionary| results in a new copy.  This also means\nthat a cyclic reference causes deepcopy() to fail.\n\t\t\t\t\t\t*E724*\nNesting is possible up to 100 levels.  When there is an item\nthat refers back to a higher level making a deep copy with\n{noref} set to 1 will fail.\nAlso see |copy()|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`T`)\n                  \226\128\162 {noref} (`boolean?`)\n\n                Return: ~\n                  (`T`)"}}, delete = {binding = "delete", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname", "?flags"}, ["fnl/docstring"] = "Without {flags} or with {flags} empty: Deletes the file by the\nname {fname}.\n\nThis also works when {fname} is a symbolic link.  The symbolic\nlink itself is deleted, not what it points to.\n\nWhen {flags} is \"d\": Deletes the directory by the name\n{fname}.  This fails when directory {fname} is not empty.\n\nWhen {flags} is \"rf\": Deletes the directory by the name\n{fname} and everything in it, recursively.  BE CAREFUL!\nNote: on MS-Windows it is not possible to delete a directory\nthat is being used.\n\nThe result is a Number, which is 0/false if the delete\noperation was successful and -1/true when the deletion failed\nor partly failed.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n                  \226\128\162 {flags} (`string?`)\n\n                Return: ~\n                  (`integer`)"}}, deletebufline = {binding = "deletebufline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "first", "?last"}, ["fnl/docstring"] = "Delete lines {first} to {last} (inclusive) from buffer {buf}.\nIf {last} is omitted then delete line {first} only.\nOn success 0 is returned, on failure 1 is returned.\n\nThis function works only for loaded buffers. First call\n|bufload()| if needed.\n\nFor the use of {buf}, see |bufname()| above.\n\n{first} and {last} are used like with |getline()|. Note that\nwhen using |line()| this refers to the current buffer. Use \"$\"\nto refer to the last line in buffer {buf}.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {first} (`integer|string`)\n                  \226\128\162 {last} (`integer|string?`)\n\n                Return: ~\n                  (`any`)"}}, dictwatcheradd = {binding = "dictwatcheradd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict", "pattern", "callback"}, ["fnl/docstring"] = "Adds a watcher to a dictionary. A dictionary watcher is\nidentified by three components:\n\n- A dictionary({dict});\n- A key pattern({pattern}).\n- A function({callback}).\n\nAfter this is called, every change on {dict} and on keys\nmatching {pattern} will result in {callback} being invoked.\n\nFor example, to watch all global variables: >vim\n\tsilent! call dictwatcherdel(g:, '*', 'OnDictChanged')\n\tfunction! OnDictChanged(d,k,z)\n\t  echomsg string(a:k) string(a:z)\n\tendfunction\n\tcall dictwatcheradd(g:, '*', 'OnDictChanged')\n<\nFor now {pattern} only accepts very simple patterns that can\ncontain a \"*\" at the end of the string, in which case it will\nmatch every key that begins with the substring before the \"*\".\nThat means if \"*\" is not the last character of {pattern}, only\nkeys that are exactly equal as {pattern} will be matched.\n\nThe {callback} receives three arguments:\n\n- The dictionary being watched.\n- The key which changed.\n- A dictionary containing the new and old values for the key.\n\nThe type of change can be determined by examining the keys\npresent on the third argument:\n\n- If contains both `old` and `new`, the key was updated.\n- If it contains only `new`, the key was added.\n- If it contains only `old`, the key was deleted.\n\nThis function can be used by plugins to implement options with\nvalidation and parsing logic.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`table`)\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {callback} (`function`)\n\n                Return: ~\n                  (`any`)"}}, dictwatcherdel = {binding = "dictwatcherdel", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict", "pattern", "callback"}, ["fnl/docstring"] = "Removes a watcher added  with |dictwatcheradd()|. All three\narguments must match the ones passed to |dictwatcheradd()| in\norder for the watcher to be successfully deleted.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`any`)\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {callback} (`function`)\n\n                Return: ~\n                  (`any`)"}}, did_filetype = {binding = "did_filetype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns |TRUE| when autocommands are being executed and the\nFileType event has been triggered at least once.  Can be used\nto avoid triggering the FileType event again in the scripts\nthat detect the file type. |FileType|\nReturns |FALSE| when `:setf FALLBACK` was used.\nWhen editing another file, the counter is reset, thus this\nreally checks if the FileType event has been triggered for the\ncurrent buffer.  This allows an autocommand that starts\nediting another buffer to set 'filetype' and load a syntax\nfile.\n\n                Return: ~\n                  (`integer`)"}}, diff_filler = {binding = "diff_filler", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Returns the number of filler lines above line {lnum}.\nThese are the lines that were inserted at this point in\nanother diff'ed window.  These filler lines are shown in the\ndisplay but don't exist in the buffer.\n{lnum} is used like with |getline()|.  Thus \".\" is the current\nline, \"'m\" mark m, etc.\nReturns 0 if the current window is not in diff mode.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, diff_hlID = {binding = "diff_hlID", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "col"}, ["fnl/docstring"] = "Returns the highlight ID for diff mode at line {lnum} column\n{col} (byte index).  When the current line does not have a\ndiff change zero is returned.\n{lnum} is used like with |getline()|.  Thus \".\" is the current\nline, \"'m\" mark m, etc.\n{col} is 1 for the leftmost column, {lnum} is 1 for the first\nline.\nThe highlight ID can be used with |synIDattr()| to obtain\nsyntax information about the highlighting.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, digraph_get = {binding = "digraph_get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"chars"}, ["fnl/docstring"] = "Return the digraph of {chars}.  This should be a string with\nexactly two characters.  If {chars} are not just two\ncharacters, or the digraph of {chars} does not exist, an error\nis given and an empty string is returned.\n\nAlso see |digraph_getlist()|.\n\nExamples: >vim\n\" Get a built-in digraph\necho digraph_get('00')\t\t\" Returns '\226\136\158'\n\n\" Get a user-defined digraph\ncall digraph_set('aa', '\227\129\130')\necho digraph_get('aa')\t\t\" Returns '\227\129\130'\n<\n\n                Parameters: ~\n                  \226\128\162 {chars} (`string`)\n\n                Return: ~\n                  (`string`)"}}, digraph_getlist = {binding = "digraph_getlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?listall"}, ["fnl/docstring"] = "Return a list of digraphs.  If the {listall} argument is given\nand it is TRUE, return all digraphs, including the default\ndigraphs.  Otherwise, return only user-defined digraphs.\n\nAlso see |digraph_get()|.\n\nExamples: >vim\n\" Get user-defined digraphs\necho digraph_getlist()\n\n\" Get all the digraphs, including default digraphs\necho digraph_getlist(1)\n<\n\n                Parameters: ~\n                  \226\128\162 {listall} (`boolean?`)\n\n                Return: ~\n                  (`string[][]`)"}}, digraph_set = {binding = "digraph_set", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"chars", "digraph"}, ["fnl/docstring"] = "Add digraph {chars} to the list.  {chars} must be a string\nwith two characters.  {digraph} is a string with one UTF-8\nencoded character.  *E1215*\nBe careful, composing characters are NOT ignored.  This\nfunction is similar to |:digraphs| command, but useful to add\ndigraphs start with a white space.\n\nThe function result is v:true if |digraph| is registered.  If\nthis fails an error message is given and v:false is returned.\n\nIf you want to define multiple digraphs at once, you can use\n|digraph_setlist()|.\n\nExample: >vim\n\tcall digraph_set('  ', '\227\129\130')\n<\n\n                Parameters: ~\n                  \226\128\162 {chars} (`string`)\n                  \226\128\162 {digraph} (`string`)\n\n                Return: ~\n                  (`any`)"}}, digraph_setlist = {binding = "digraph_setlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"digraphlist"}, ["fnl/docstring"] = "Similar to |digraph_set()| but this function can add multiple\ndigraphs at once.  {digraphlist} is a list composed of lists,\nwhere each list contains two strings with {chars} and\n{digraph} as in |digraph_set()|. *E1216*\nExample: >vim\n    call digraph_setlist([['aa', '\227\129\130'], ['ii', '\227\129\132']])\n<\nIt is similar to the following: >vim\n    for [chars, digraph] in [['aa', '\227\129\130'], ['ii', '\227\129\132']]\n\t  call digraph_set(chars, digraph)\n    endfor\n<\t\tExcept that the function returns after the first error,\nfollowing digraphs will not be added.\n\n                Parameters: ~\n                  \226\128\162 {digraphlist} (`table<integer,string[]>`)\n\n                Return: ~\n                  (`any`)"}}, empty = {binding = "empty", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the Number 1 if {expr} is empty, zero otherwise.\n- A |List| or |Dictionary| is empty when it does not have any\n  items.\n- A |String| is empty when its length is zero.\n- A |Number| and |Float| are empty when their value is zero.\n- |v:false| and |v:null| are empty, |v:true| is not.\n- A |Blob| is empty when its length is zero.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`integer`)"}}, environ = {binding = "environ", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return all of environment variables as dictionary. You can\ncheck if an environment variable exists like this: >vim\n\techo has_key(environ(), 'HOME')\n<\t\tNote that the variable name may be CamelCase; to ignore case\nuse this: >vim\n\techo index(keys(environ()), 'HOME', 0, 1) != -1\n<\n\n                Return: ~\n                  (`any`)"}}, escape = {binding = "escape", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "chars"}, ["fnl/docstring"] = "Escape the characters in {chars} that occur in {string} with a\nbackslash.  Example: >vim\n\techo escape('c:\\program files\\vim', ' \\')\n<\t\tresults in: >\n\tc:\\\\program\\ files\\\\vim\n<\t\tAlso see |shellescape()| and |fnameescape()|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {chars} (`string`)\n\n                Return: ~\n                  (`string`)"}}, eval = {binding = "eval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Evaluate {string} and return the result.  Especially useful to\nturn the result of |string()| back into the original value.\nThis works for Numbers, Floats, Strings, Blobs and composites\nof them.  Also works for |Funcref|s that refer to existing\nfunctions.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`any`)"}}, eventhandler = {binding = "eventhandler", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns 1 when inside an event handler.  That is that Vim got\ninterrupted while waiting for the user to type a character,\ne.g., when dropping a file on Vim.  This means interactive\ncommands cannot be used.  Otherwise zero is returned.\n\n                Return: ~\n                  (`any`)"}}, executable = {binding = "executable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "This function checks if an executable with the name {expr}\nexists.  {expr} must be the name of the program without any\narguments.\n\nexecutable() uses the value of $PATH and/or the normal\nsearchpath for programs.\n\t\t\t\t\t*PATHEXT*\nOn MS-Windows the \".exe\", \".bat\", etc. can optionally be\nincluded.  Then the extensions in $PATHEXT are tried.  Thus if\n\"foo.exe\" does not exist, \"foo.exe.bat\" can be found.  If\n$PATHEXT is not set then \".com;.exe;.bat;.cmd\" is used.  A dot\nby itself can be used in $PATHEXT to try using the name\nwithout an extension.  When 'shell' looks like a Unix shell,\nthen the name is also tried without adding an extension.\nOn MS-Windows it only checks if the file exists and is not a\ndirectory, not if it's really executable.\nOn MS-Windows an executable in the same directory as the Vim\nexecutable is always found (it's added to $PATH at |startup|).\n\t\t\t*NoDefaultCurrentDirectoryInExePath*\nOn MS-Windows an executable in Vim's current working directory\nis also normally found, but this can be disabled by setting\nthe $NoDefaultCurrentDirectoryInExePath environment variable.\n\nThe result is a Number:\n\0091\texists\n\0090\tdoes not exist\n|exepath()| can be used to get the full path of an executable.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, execute = {binding = "execute", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"command", "?silent"}, ["fnl/docstring"] = "Execute {command} and capture its output.\nIf {command} is a |String|, returns {command} output.\nIf {command} is a |List|, returns concatenated outputs.\nLine continuations in {command} are not recognized.\nExamples: >vim\n\techo execute('echon \"foo\"')\n<\t\t\tfoo >vim\n\techo execute(['echon \"foo\"', 'echon \"bar\"'])\n<\t\t\tfoobar\n\nThe optional {silent} argument can have these values:\n\t\"\"\t\tno `:silent` used\n\t\"silent\"\t`:silent` used\n\t\"silent!\"\t`:silent!` used\nThe default is \"silent\".  Note that with \"silent!\", unlike\n`:redir`, error messages are dropped.\n\nTo get a list of lines use `split()` on the result: >vim\n\texecute('args')->split(\"\\n\")\n\n<\t\tThis function is not available in the |sandbox|.\nNote: If nested, an outer execute() will not observe output of\nthe inner calls.\nNote: Text attributes (highlights) are not captured.\nTo execute a command in another window than the current one\nuse `win_execute()`.\n\n                Parameters: ~\n                  \226\128\162 {command} (`string|string[]`)\n                  \226\128\162 {silent} (`''|'silent'|'silent!'?`)\n\n                Return: ~\n                  (`string`)"}}, exepath = {binding = "exepath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Returns the full path of {expr} if it is an executable and\ngiven as a (partial or full) path or is found in $PATH.\nReturns empty string otherwise.\nIf {expr} starts with \"./\" the |current-directory| is used.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`string`)"}}, exists = {binding = "exists", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| if {expr} is\ndefined, zero otherwise.\n\nFor checking for a supported feature use |has()|.\nFor checking if a file exists use |filereadable()|.\n\nThe {expr} argument is a string, which contains one of these:\n\tvarname\t\tinternal variable (see\n\tdict.key\t|internal-variables|).  Also works\n\tlist[i]\t\tfor |curly-braces-names|, |Dictionary|\n\t\t\tentries, |List| items, etc.\n\t\t\tBeware that evaluating an index may\n\t\t\tcause an error message for an invalid\n\t\t\texpression.  E.g.: >vim\n\t\t\t   let l = [1, 2, 3]\n\t\t\t   echo exists(\"l[5]\")\n<\t\t\t\t\t   0 >vim\n\t\t\t   echo exists(\"l[xx]\")\n<\t\t\t\t\t   E121: Undefined variable: xx\n\t\t\t   0\n\t&option-name\tVim option (only checks if it exists,\n\t\t\tnot if it really works)\n\t+option-name\tVim option that works.\n\t$ENVNAME\tenvironment variable (could also be\n\t\t\tdone by comparing with an empty\n\t\t\tstring)\n\t`*funcname`\tbuilt-in function (see |functions|)\n\t\t\tor user defined function (see\n\t\t\t|user-function|). Also works for a\n\t\t\tvariable that is a Funcref.\n\t:cmdname\tEx command: built-in command, user\n\t\t\tcommand or command modifier |:command|.\n\t\t\tReturns:\n\t\t\0091  for match with start of a command\n\t\t\0092  full match with a command\n\t\t\0093  matches several user commands\n\t\t\tTo check for a supported command\n\t\t\talways check the return value to be 2.\n\t:2match\t\tThe |:2match| command.\n\t:3match\t\tThe |:3match| command (but you\n\t\t\tprobably should not use it, it is\n\t\t\treserved for internal usage)\n\t#event\t\tautocommand defined for this event\n\t#event#pattern\tautocommand defined for this event and\n\t\t\tpattern (the pattern is taken\n\t\t\tliterally and compared to the\n\t\t\tautocommand patterns character by\n\t\t\tcharacter)\n\t#group\t\tautocommand group exists\n\t#group#event\tautocommand defined for this group and\n\t\t\tevent.\n\t#group#event#pattern\n\t\t\tautocommand defined for this group,\n\t\t\tevent and pattern.\n\t##event\t\tautocommand for this event is\n\t\t\tsupported.\n\nExamples: >vim\n\techo exists(\"&mouse\")\n\techo exists(\"$HOSTNAME\")\n\techo exists(\"*strftime\")\n\techo exists(\"*s:MyFunc\")\n\techo exists(\"*MyFunc\")\n\techo exists(\"*v:lua.Func\")\n\techo exists(\"bufcount\")\n\techo exists(\":Make\")\n\techo exists(\"#CursorHold\")\n\techo exists(\"#BufReadPre#*.gz\")\n\techo exists(\"#filetypeindent\")\n\techo exists(\"#filetypeindent#FileType\")\n\techo exists(\"#filetypeindent#FileType#*\")\n\techo exists(\"##ColorScheme\")\n<\t\tThere must be no space between the symbol (&/$/*/#) and the\nname.\nThere must be no extra characters after the name, although in\na few cases this is ignored.  That may become stricter in the\nfuture, thus don't count on it!\nWorking example: >vim\n\techo exists(\":make\")\n<\t\tNOT working example: >vim\n\techo exists(\":make install\")\n\n<\t\tNote that the argument must be a string, not the name of the\nvariable itself.  For example: >vim\n\techo exists(bufcount)\n<\t\tThis doesn't check for existence of the \"bufcount\" variable,\nbut gets the value of \"bufcount\", and checks if that exists.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, exp = {binding = "exp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the exponential of {expr} as a |Float| in the range\n[0, inf].\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo exp(2)\n<\t\t\0097.389056 >vim\n\techo exp(-1)\n<\t\t\0090.367879\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`any`)"}}, expand = {binding = "expand", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?nosuf", "?list"}, ["fnl/docstring"] = "Expand wildcards and the following special keywords in\n{string}.  'wildignorecase' applies.\n\nIf {list} is given and it is |TRUE|, a List will be returned.\nOtherwise the result is a String and when there are several\nmatches, they are separated by <NL> characters.\n\nIf the expansion fails, the result is an empty string.  A name\nfor a non-existing file is not included, unless {string} does\nnot start with '%', '#' or '<', see below.\n\nWhen {string} starts with '%', '#' or '<', the expansion is\ndone like for the |cmdline-special| variables with their\nassociated modifiers.  Here is a short overview:\n\n\t%\t\tcurrent file name\n\t#\t\talternate file name\n\t#n\t\talternate file name n\n\t<cfile>\t\tfile name under the cursor\n\t<afile>\t\tautocmd file name\n\t<abuf>\t\tautocmd buffer number (as a String!)\n\t<amatch>\tautocmd matched name\n\t<cexpr>\t\tC expression under the cursor\n\t<sfile>\t\tsourced script file or function name\n\t<slnum>\t\tsourced script line number or function\n\t\t\tline number\n\t<sflnum>\tscript file line number, also when in\n\t\t\ta function\n\t<SID>\t\t\"<SNR>123_\"  where \"123\" is the\n\t\t\tcurrent script ID  |<SID>|\n\t<script>\tsourced script file, or script file\n\t\t\twhere the current function was defined.\n\t\t\tUse |debug.getinfo()| in Lua scripts.\n\t<stack>\t\tcall stack\n\t<cword>\t\tword under the cursor\n\t<cWORD>\t\tWORD under the cursor\n\t<client>\tthe {clientid} of the last received\n\t\t\tmessage\nModifiers:\n\t:p\t\texpand to full path\n\t:h\t\thead (last path component removed)\n\t:t\t\ttail (last path component only)\n\t:r\t\troot (one extension removed)\n\t:e\t\textension only\n\nExample: >vim\n\tlet &tags = expand(\"%:p:h\") .. \"/tags\"\n<\t\tNote that when expanding a string that starts with '%', '#' or\n'<', any following text is ignored.  This does NOT work: >vim\n\tlet doesntwork = expand(\"%:h.bak\")\n<\t\tUse this: >vim\n\tlet doeswork = expand(\"%:h\") .. \".bak\"\n<\t\tAlso note that expanding \"<cfile>\" and others only returns the\nreferenced file name without further expansion.  If \"<cfile>\"\nis \"~/.cshrc\", you need to do another expand() to have the\n\"~/\" expanded into the path of the home directory: >vim\n\techo expand(expand(\"<cfile>\"))\n<\nThere cannot be white space between the variables and the\nfollowing modifier.  The |fnamemodify()| function can be used\nto modify normal file names.\n\nWhen using '%' or '#', and the current or alternate file name\nis not defined, an empty string is used.  Using \"%:p\" in a\nbuffer with no name, results in the current directory, with a\n'/' added.\nWhen 'verbose' is set then expanding '%', '#' and <> items\nwill result in an error message if the argument cannot be\nexpanded.\n\nWhen {string} does not start with '%', '#' or '<', it is\nexpanded like a file name is expanded on the command line.\n'suffixes' and 'wildignore' are used, unless the optional\n{nosuf} argument is given and it is |TRUE|.\nNames for non-existing files are included.  The \"**\" item can\nbe used to search in a directory tree.  For example, to find\nall \"README\" files in the current directory and below: >vim\n\techo expand(\"**/README\")\n<\nexpand() can also be used to expand variables and environment\nvariables that are only known in a shell.  But this can be\nslow, because a shell may be used to do the expansion.  See\n|expr-env-expand|.\nThe expanded variable is still handled like a list of file\nnames.  When an environment variable cannot be expanded, it is\nleft unchanged.  Thus \":echo expand('$FOOBAR')\" results in\n\"$FOOBAR\".\n\nSee |glob()| for finding existing files.  See |system()| for\ngetting the raw output of an external command.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {nosuf} (`boolean?`)\n                  \226\128\162 {list} (`nil|false?`)\n\n                Return: ~\n                  (`string`)"}}, expandcmd = {binding = "expandcmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?options"}, ["fnl/docstring"] = "Expand special items in String {string} like what is done for\nan Ex command such as `:edit`.  This expands special keywords,\nlike with |expand()|, and environment variables, anywhere in\n{string}.  \"~user\" and \"~/path\" are only expanded at the\nstart.\n\nThe following items are supported in the {options} Dict\nargument:\n    errmsg\tIf set to TRUE, error messages are displayed\n\t\tif an error is encountered during expansion.\n\t\tBy default, error messages are not displayed.\n\nReturns the expanded string.  If an error is encountered\nduring expansion, the unmodified {string} is returned.\n\nExample: >vim\n\techo expandcmd('make %<.o')\n<\t\t >\n\tmake /path/runtime/doc/builtin.o\n<\t\t >vim\n\techo expandcmd('make %<.o', {'errmsg': v:true})\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {options} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, extend = {binding = "extend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2", "?expr3"}, ["fnl/docstring"] = "{expr1} and {expr2} must be both |Lists| or both\n|Dictionaries|.\n\nIf they are |Lists|: Append {expr2} to {expr1}.\nIf {expr3} is given insert the items of {expr2} before the\nitem with index {expr3} in {expr1}.  When {expr3} is zero\ninsert before the first item.  When {expr3} is equal to\nlen({expr1}) then {expr2} is appended.\nExamples: >vim\n\techo sort(extend(mylist, [7, 5]))\n\tcall extend(mylist, [2, 3], 1)\n<\t\tWhen {expr1} is the same List as {expr2} then the number of\nitems copied is equal to the original length of the List.\nE.g., when {expr3} is 1 you get N new copies of the first item\n(where N is the original length of the List).\nUse |add()| to concatenate one item to a list.  To concatenate\ntwo lists into a new list use the + operator: >vim\n\tlet newlist = [1, 2, 3] + [4, 5]\n<\nIf they are |Dictionaries|:\nAdd all entries from {expr2} to {expr1}.\nIf a key exists in both {expr1} and {expr2} then {expr3} is\nused to decide what to do:\n{expr3} = \"keep\": keep the value of {expr1}\n{expr3} = \"force\": use the value of {expr2}\n{expr3} = \"error\": give an error message\t\t*E737*\nWhen {expr3} is omitted then \"force\" is assumed.\n\n{expr1} is changed when {expr2} is not empty.  If necessary\nmake a copy of {expr1} first or use |extendnew()| to return a\nnew List/Dictionary.\n{expr2} remains unchanged.\nWhen {expr1} is locked and {expr2} is not empty the operation\nfails.\nReturns {expr1}.  Returns 0 on error.\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`table`)\n                  \226\128\162 {expr2} (`table`)\n                  \226\128\162 {expr3} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, extendnew = {binding = "extendnew", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2", "?expr3"}, ["fnl/docstring"] = "Like |extend()| but instead of adding items to {expr1} a new\nList or Dictionary is created and returned.  {expr1} remains\nunchanged.\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`table`)\n                  \226\128\162 {expr2} (`table`)\n                  \226\128\162 {expr3} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, feedkeys = {binding = "feedkeys", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?mode"}, ["fnl/docstring"] = "Characters in {string} are queued for processing as if they\ncome from a mapping or were typed by the user.\n\nBy default the string is added to the end of the typeahead\nbuffer, thus if a mapping is still being executed the\ncharacters come after them.  Use the 'i' flag to insert before\nother characters, they will be executed next, before any\ncharacters from a mapping.\n\nThe function does not wait for processing of keys contained in\n{string}.\n\nTo include special keys into {string}, use double-quotes\nand \"\\...\" notation |expr-quote|. For example,\nfeedkeys(\"\\<CR>\") simulates pressing of the <Enter> key. But\nfeedkeys('\\<CR>') pushes 5 characters.\nThe |<Ignore>| keycode may be used to exit the\nwait-for-character without doing anything.\n\n{mode} is a String, which can contain these character flags:\n'm'\tRemap keys. This is default.  If {mode} is absent,\n\tkeys are remapped.\n'n'\tDo not remap keys.\n't'\tHandle keys as if typed; otherwise they are handled as\n\tif coming from a mapping.  This matters for undo,\n\topening folds, etc.\n'L'\tLowlevel input.  Other flags are not used.\n'i'\tInsert the string instead of appending (see above).\n'x'\tExecute commands until typeahead is empty.  This is\n\tsimilar to using \":normal!\".  You can call feedkeys()\n\tseveral times without 'x' and then one time with 'x'\n\t(possibly with an empty {string}) to execute all the\n\ttypeahead.  Note that when Vim ends in Insert mode it\n\twill behave as if <Esc> is typed, to avoid getting\n\tstuck, waiting for a character to be typed before the\n\tscript continues.\n\tNote that if you manage to call feedkeys() while\n\texecuting commands, thus calling it recursively, then\n\tall typeahead will be consumed by the last call.\n'!'\tWhen used with 'x' will not end Insert mode. Can be\n\tused in a test when a timer is set to exit Insert mode\n\ta little later.  Useful for testing CursorHoldI.\n\nReturn value is always 0.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {mode} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, filecopy = {binding = "filecopy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"from", "to"}, ["fnl/docstring"] = "Copy the file pointed to by the name {from} to {to}. The\nresult is a Number, which is |TRUE| if the file was copied\nsuccessfully, and |FALSE| when it failed.\nIf a file with name {to} already exists, it will fail.\nNote that it does not handle directories (yet).\n\nThis function is not available in the |sandbox|.\n\n                Parameters: ~\n                  \226\128\162 {from} (`string`)\n                  \226\128\162 {to} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, filereadable = {binding = "filereadable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"file"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| when a file with the\nname {file} exists, and can be read.  If {file} doesn't exist,\nor is a directory, the result is |FALSE|.  {file} is any\nexpression, which is used as a String.\nIf you don't care about the file being readable you can use\n|glob()|.\n{file} is used as-is, you may want to expand wildcards first: >vim\n\techo filereadable('~/.vimrc')\n<\t\t >\n\0090\n<\t\t >vim\n\techo filereadable(expand('~/.vimrc'))\n<\t\t >\n\0091\n<\n\n                Parameters: ~\n                  \226\128\162 {file} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, filewritable = {binding = "filewritable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"file"}, ["fnl/docstring"] = "The result is a Number, which is 1 when a file with the\nname {file} exists, and can be written.  If {file} doesn't\nexist, or is not writable, the result is 0.  If {file} is a\ndirectory, and we can write to it, the result is 2.\n\n                Parameters: ~\n                  \226\128\162 {file} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, filter = {binding = "filter", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2"}, ["fnl/docstring"] = "{expr1} must be a |List|, |String|, |Blob| or |Dictionary|.\nFor each item in {expr1} evaluate {expr2} and when the result\nis zero or false remove the item from the |List| or\n|Dictionary|.  Similarly for each byte in a |Blob| and each\ncharacter in a |String|.\n\n{expr2} must be a |string| or |Funcref|.\n\nIf {expr2} is a |string|, inside {expr2} |v:val| has the value\nof the current item.  For a |Dictionary| |v:key| has the key\nof the current item and for a |List| |v:key| has the index of\nthe current item.  For a |Blob| |v:key| has the index of the\ncurrent byte. For a |String| |v:key| has the index of the\ncurrent character.\nExamples: >vim\n\tcall filter(mylist, 'v:val !~ \"OLD\"')\n<\t\tRemoves the items where \"OLD\" appears. >vim\n\tcall filter(mydict, 'v:key >= 8')\n<\t\tRemoves the items with a key below 8. >vim\n\tcall filter(var, 0)\n<\t\tRemoves all the items, thus clears the |List| or |Dictionary|.\n\nNote that {expr2} is the result of expression and is then\nused as an expression again.  Often it is good to use a\n|literal-string| to avoid having to double backslashes.\n\nIf {expr2} is a |Funcref| it must take two arguments:\n\0091. the key or the index of the current item.\n\0092. the value of the current item.\nThe function must return |TRUE| if the item should be kept.\nExample that keeps the odd items of a list: >vim\n\tfunc Odd(idx, val)\n\t  return a:idx % 2 == 1\n\tendfunc\n\tcall filter(mylist, function('Odd'))\n<\t\tIt is shorter when using a |lambda|: >vim\n\tcall filter(myList, {idx, val -> idx * val <= 42})\n<\t\tIf you do not use \"val\" you can leave it out: >vim\n\tcall filter(myList, {idx -> idx % 2 == 1})\n<\nFor a |List| and a |Dictionary| the operation is done\nin-place.  If you want it to remain unmodified make a copy\nfirst: >vim\n\tlet l = filter(copy(mylist), 'v:val =~ \"KEEP\"')\n\n<\t\tReturns {expr1}, the |List| or |Dictionary| that was filtered,\nor a new |Blob| or |String|.\nWhen an error is encountered while evaluating {expr2} no\nfurther items in {expr1} are processed.\nWhen {expr2} is a Funcref errors inside a function are ignored,\nunless it was defined with the \"abort\" flag.\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`string|table`)\n                  \226\128\162 {expr2} (`string|function`)\n\n                Return: ~\n                  (`any`)"}}, finddir = {binding = "finddir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?path", "?count"}, ["fnl/docstring"] = "Find directory {name} in {path}.  Supports both downwards and\nupwards recursive directory searches.  See |file-searching|\nfor the syntax of {path}.\n\nReturns the path of the first found match.  When the found\ndirectory is below the current directory a relative path is\nreturned.  Otherwise a full path is returned.\nIf {path} is omitted or empty then 'path' is used.\n\nIf the optional {count} is given, find {count}'s occurrence of\n{name} in {path} instead of the first one.\nWhen {count} is negative return all the matches in a |List|.\n\nReturns an empty string if the directory is not found.\n\nThis is quite similar to the ex-command `:find`.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {path} (`string?`)\n                  \226\128\162 {count} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, findfile = {binding = "findfile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?path", "?count"}, ["fnl/docstring"] = "Just like |finddir()|, but find a file instead of a directory.\nUses 'suffixesadd'.\nExample: >vim\n\techo findfile(\"tags.vim\", \".;\")\n<\t\tSearches from the directory of the current file upwards until\nit finds the file \"tags.vim\".\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {path} (`string?`)\n                  \226\128\162 {count} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, flatten = {binding = "flatten", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?maxdepth"}, ["fnl/docstring"] = "Flatten {list} up to {maxdepth} levels.  Without {maxdepth}\nthe result is a |List| without nesting, as if {maxdepth} is\na very large number.\nThe {list} is changed in place, use |flattennew()| if you do\nnot want that.\n\t\t\t\t\t\t*E900*\n{maxdepth} means how deep in nested lists changes are made.\n{list} is not modified when {maxdepth} is 0.\n{maxdepth} must be positive number.\n\nIf there is an error the number zero is returned.\n\nExample: >vim\n\techo flatten([1, [2, [3, 4]], 5])\n<\t\t\t[1, 2, 3, 4, 5] >vim\n\techo flatten([1, [2, [3, 4]], 5], 1)\n<\t\t\t[1, 2, [3, 4], 5]\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {maxdepth} (`integer?`)\n\n                Return: ~\n                  (`any[]|0`)"}}, flattennew = {binding = "flattennew", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?maxdepth"}, ["fnl/docstring"] = "Like |flatten()| but first make a copy of {list}.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {maxdepth} (`integer?`)\n\n                Return: ~\n                  (`any[]|0`)"}}, float2nr = {binding = "float2nr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Convert {expr} to a Number by omitting the part after the\ndecimal point.\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0 if {expr} is not a |Float| or a |Number|.\nWhen the value of {expr} is out of range for a |Number| the\nresult is truncated to 0x7fffffff or -0x7fffffff (or when\n64-bit Number support is enabled, 0x7fffffffffffffff or\n-0x7fffffffffffffff).  NaN results in -0x80000000 (or when\n64-bit Number support is enabled, -0x8000000000000000).\nExamples: >vim\n\techo float2nr(3.95)\n<\t\t\0093  >vim\n\techo float2nr(-23.45)\n<\t\t\t-23  >vim\n\techo float2nr(1.0e100)\n<\t\t\0092147483647  (or 9223372036854775807) >vim\n\techo float2nr(-1.0e150)\n<\t\t\t-2147483647 (or -9223372036854775807) >vim\n\techo float2nr(1.0e-100)\n<\t\t\0090\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`any`)"}}, floor = {binding = "floor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the largest integral value less than or equal to\n{expr} as a |Float| (round down).\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo floor(1.856)\n<\t\t\0091.0  >vim\n\techo floor(-5.456)\n<\t\t\t-6.0  >vim\n\techo floor(4.0)\n<\t\t\0094.0\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`any`)"}}, fmod = {binding = "fmod", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2"}, ["fnl/docstring"] = "Return the remainder of {expr1} / {expr2}, even if the\ndivision is not representable.  Returns {expr1} - i * {expr2}\nfor some integer i such that if {expr2} is non-zero, the\nresult has the same sign as {expr1} and magnitude less than\nthe magnitude of {expr2}.  If {expr2} is zero, the value\nreturned is zero.  The value returned is a |Float|.\n{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr1} or {expr2} is not a |Float| or a\n|Number|.\nExamples: >vim\n\techo fmod(12.33, 1.22)\n<\t\t\0090.13 >vim\n\techo fmod(-12.33, 1.22)\n<\t\t\t-0.13\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`number`)\n                  \226\128\162 {expr2} (`number`)\n\n                Return: ~\n                  (`any`)"}}, fnameescape = {binding = "fnameescape", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Escape {string} for use as file name command argument.  All\ncharacters that have a special meaning, such as `'%'` and `'|'`\nare escaped with a backslash.\nFor most systems the characters escaped are\n\" \\t\\n*?[{`$\\\\%#'\\\"|!<\".  For systems where a backslash\nappears in a filename, it depends on the value of 'isfname'.\nA leading '+' and '>' is also escaped (special after |:edit|\nand |:write|).  And a \"-\" by itself (special after |:cd|).\nReturns an empty string on error.\nExample: >vim\n\tlet fname = '+some str%nge|name'\n\texe \"edit \" .. fnameescape(fname)\n<\t\tresults in executing: >vim\n\tedit \\+some\\ str\\%nge\\|name\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`string`)"}}, fnamemodify = {binding = "fnamemodify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname", "mods"}, ["fnl/docstring"] = "Modify file name {fname} according to {mods}.  {mods} is a\nstring of characters like it is used for file names on the\ncommand line.  See |filename-modifiers|.\nExample: >vim\n\techo fnamemodify(\"main.c\", \":p:h\")\n<\t\tresults in: >\n\t/home/user/vim/vim/src\n<\t\tIf {mods} is empty or an unsupported modifier is used then\n{fname} is returned.\nWhen {fname} is empty then with {mods} \":h\" returns \".\", so\nthat `:cd` can be used with it.  This is different from\nexpand('%:h') without a buffer name, which returns an empty\nstring.\nNote: Environment variables don't work in {fname}, use\n|expand()| first then.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n                  \226\128\162 {mods} (`string`)\n\n                Return: ~\n                  (`string`)"}}, foldclosed = {binding = "foldclosed", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "The result is a Number.  If the line {lnum} is in a closed\nfold, the result is the number of the first line in that fold.\nIf the line {lnum} is not in a closed fold, -1 is returned.\n{lnum} is used like with |getline()|.  Thus \".\" is the current\nline, \"'m\" mark m, etc.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, foldclosedend = {binding = "foldclosedend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "The result is a Number.  If the line {lnum} is in a closed\nfold, the result is the number of the last line in that fold.\nIf the line {lnum} is not in a closed fold, -1 is returned.\n{lnum} is used like with |getline()|.  Thus \".\" is the current\nline, \"'m\" mark m, etc.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, foldlevel = {binding = "foldlevel", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "The result is a Number, which is the foldlevel of line {lnum}\nin the current buffer.  For nested folds the deepest level is\nreturned.  If there is no fold at line {lnum}, zero is\nreturned.  It doesn't matter if the folds are open or closed.\nWhen used while updating folds (from 'foldexpr') -1 is\nreturned for lines where folds are still to be updated and the\nfoldlevel is unknown.  As a special case the level of the\nprevious line is usually available.\n{lnum} is used like with |getline()|.  Thus \".\" is the current\nline, \"'m\" mark m, etc.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, foldtext = {binding = "foldtext", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a String, to be displayed for a closed fold.  This is\nthe default function used for the 'foldtext' option and should\nonly be called from evaluating 'foldtext'.  It uses the\n|v:foldstart|, |v:foldend| and |v:folddashes| variables.\nThe returned string looks like this: >\n\t+-- 45 lines: abcdef\n<\t\tThe number of leading dashes depends on the foldlevel.  The\n\"45\" is the number of lines in the fold.  \"abcdef\" is the text\nin the first non-blank line of the fold.  Leading white space,\n\"//\" or \"/*\" and the text from the 'foldmarker' and\n'commentstring' options is removed.\nWhen used to draw the actual foldtext, the rest of the line\nwill be filled with the fold char from the 'fillchars'\nsetting.\nReturns an empty string when there is no fold.\n\n                Return: ~\n                  (`string`)"}}, foldtextresult = {binding = "foldtextresult", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Returns the text that is displayed for the closed fold at line\n{lnum}.  Evaluates 'foldtext' in the appropriate context.\nWhen there is no closed fold at {lnum} an empty string is\nreturned.\n{lnum} is used like with |getline()|.  Thus \".\" is the current\nline, \"'m\" mark m, etc.\nUseful when exporting folded text, e.g., to HTML.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`string`)"}}, foreach = {binding = "foreach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2"}, ["fnl/docstring"] = "{expr1} must be a |List|, |String|, |Blob| or |Dictionary|.\nFor each item in {expr1} execute {expr2}. {expr1} is not\nmodified; its values may be, as with |:lockvar| 1. |E741|\nSee |map()| and |filter()| to modify {expr1}.\n\n{expr2} must be a |string| or |Funcref|.\n\nIf {expr2} is a |string|, inside {expr2} |v:val| has the value\nof the current item.  For a |Dictionary| |v:key| has the key\nof the current item and for a |List| |v:key| has the index of\nthe current item.  For a |Blob| |v:key| has the index of the\ncurrent byte. For a |String| |v:key| has the index of the\ncurrent character.\nExamples: >vim\n\tcall foreach(mylist, 'let used[v:val] = v:true')\n<\t\tThis records the items that are in the {expr1} list.\n\nNote that {expr2} is the result of expression and is then used\nas a command.  Often it is good to use a |literal-string| to\navoid having to double backslashes.\n\nIf {expr2} is a |Funcref| it must take two arguments:\n\0091. the key or the index of the current item.\n\0092. the value of the current item.\nWith a lambda you don't get an error if it only accepts one\nargument.\nIf the function returns a value, it is ignored.\n\nReturns {expr1} in all cases.\nWhen an error is encountered while executing {expr2} no\nfurther items in {expr1} are processed.\nWhen {expr2} is a Funcref errors inside a function are ignored,\nunless it was defined with the \"abort\" flag.\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`string|table`)\n                  \226\128\162 {expr2} (`string|function`)\n\n                Return: ~\n                  (`string|table`)"}}, fullcommand = {binding = "fullcommand", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Get the full command name from a short abbreviated command\nname; see |20.2| for details on command abbreviations.\n\nThe string argument {name} may start with a `:` and can\ninclude a [range], these are skipped and not returned.\nReturns an empty string if a command doesn't exist or if it's\nambiguous (for user-defined commands).\n\nFor example `fullcommand('s')`, `fullcommand('sub')`,\n`fullcommand(':%substitute')` all return \"substitute\".\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n\n                Return: ~\n                  (`string`)"}}, funcref = {binding = "funcref", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?arglist", "?dict"}, ["fnl/docstring"] = "Just like |function()|, but the returned Funcref will lookup\nthe function by reference, not by name.  This matters when the\nfunction {name} is redefined later.\n\nUnlike |function()|, {name} must be an existing user function.\nIt only works for an autoloaded function if it has already\nbeen loaded (to avoid mistakenly loading the autoload script\nwhen only intending to use the function name, use |function()|\ninstead). {name} cannot be a builtin function.\nReturns 0 on error.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {arglist} (`any?`)\n                  \226\128\162 {dict} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, ["function"] = {binding = "function", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?arglist", "?dict"}, ["fnl/docstring"] = "Return a |Funcref| variable that refers to function {name}.\n{name} can be the name of a user defined function or an\ninternal function.\n\n{name} can also be a Funcref or a partial. When it is a\npartial the dict stored in it will be used and the {dict}\nargument is not allowed. E.g.: >vim\n\tlet FuncWithArg = function(dict.Func, [arg])\n\tlet Broken = function(dict.Func, [arg], dict)\n<\nWhen using the Funcref the function will be found by {name},\nalso when it was redefined later. Use |funcref()| to keep the\nsame function.\n\nWhen {arglist} or {dict} is present this creates a partial.\nThat means the argument list and/or the dictionary is stored in\nthe Funcref and will be used when the Funcref is called.\n\nThe arguments are passed to the function in front of other\narguments, but after any argument from |method|.  Example: >vim\n\tfunc Callback(arg1, arg2, name)\n\t\"...\n\tendfunc\n\tlet Partial = function('Callback', ['one', 'two'])\n\t\"...\n\tcall Partial('name')\n<\t\tInvokes the function as with: >vim\n\tcall Callback('one', 'two', 'name')\n\n<\t\tWith a |method|: >vim\n\tfunc Callback(one, two, three)\n\t\"...\n\tendfunc\n\tlet Partial = function('Callback', ['two'])\n\t\"...\n\teval 'one'->Partial('three')\n<\t\tInvokes the function as with: >vim\n\tcall Callback('one', 'two', 'three')\n\n<\t\tThe function() call can be nested to add more arguments to the\nFuncref.  The extra arguments are appended to the list of\narguments.  Example: >vim\n\tfunc Callback(arg1, arg2, name)\n\t\"...\n\tendfunc\n\tlet Func = function('Callback', ['one'])\n\tlet Func2 = function(Func, ['two'])\n\t\"...\n\tcall Func2('name')\n<\t\tInvokes the function as with: >vim\n\tcall Callback('one', 'two', 'name')\n\n<\t\tThe Dictionary is only useful when calling a \"dict\" function.\nIn that case the {dict} is passed in as \"self\". Example: >vim\n\tfunction Callback() dict\n\t   echo \"called for \" .. self.name\n\tendfunction\n\t\"...\n\tlet context = {\"name\": \"example\"}\n\tlet Func = function('Callback', context)\n\t\"...\n\tcall Func()\t\" will echo: called for example\n<\t\tThe use of function() is not needed when there are no extra\narguments, these two are equivalent, if Callback() is defined\nas context.Callback(): >vim\n\tlet Func = function('Callback', context)\n\tlet Func = context.Callback\n\n<\t\tThe argument list and the Dictionary can be combined: >vim\n\tfunction Callback(arg1, count) dict\n\t\"...\n\tendfunction\n\tlet context = {\"name\": \"example\"}\n\tlet Func = function('Callback', ['one'], context)\n\t\"...\n\tcall Func(500)\n<\t\tInvokes the function as with: >vim\n\tcall context.Callback('one', 500)\n<\nReturns 0 on error.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {arglist} (`any?`)\n                  \226\128\162 {dict} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, garbagecollect = {binding = "garbagecollect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?atexit"}, ["fnl/docstring"] = "Cleanup unused |Lists| and |Dictionaries| that have circular\nreferences.\n\nThere is hardly ever a need to invoke this function, as it is\nautomatically done when Vim runs out of memory or is waiting\nfor the user to press a key after 'updatetime'.  Items without\ncircular references are always freed when they become unused.\nThis is useful if you have deleted a very big |List| and/or\n|Dictionary| with circular references in a script that runs\nfor a long time.\n\nWhen the optional {atexit} argument is one, garbage\ncollection will also be done when exiting Vim, if it wasn't\ndone before.  This is useful when checking for memory leaks.\n\nThe garbage collection is not done immediately but only when\nit's safe to perform.  This is when waiting for the user to\ntype a character.\n\n                Parameters: ~\n                  \226\128\162 {atexit} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, get = {binding = "get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "idx", "?default"}, ["fnl/docstring"] = "Get item {idx} from |List| {list}.  When this item is not\navailable return {default}.  Return zero when {default} is\nomitted.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {idx} (`integer`)\n                  \226\128\162 {default} (`any?`)\n\n                Return: ~\n                  (`any`)\n\nget({blob}, {idx} [, {default}])                                    *get()-blob*\nGet byte {idx} from |Blob| {blob}.  When this byte is not\navailable return {default}.  Return -1 when {default} is\nomitted.\n\n                Parameters: ~\n                  \226\128\162 {blob} (`string`)\n                  \226\128\162 {idx} (`integer`)\n                  \226\128\162 {default} (`any?`)\n\n                Return: ~\n                  (`any`)\n\nget({dict}, {key} [, {default}])                                    *get()-dict*\nGet item with key {key} from |Dictionary| {dict}.  When this\nitem is not available return {default}.  Return zero when\n{default} is omitted.  Useful example: >vim\n\tlet val = get(g:, 'var_name', 'default')\n<\t\tThis gets the value of g:var_name if it exists, and uses\n\"default\" when it does not exist.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`table<string,any>`)\n                  \226\128\162 {key} (`string`)\n                  \226\128\162 {default} (`any?`)\n\n                Return: ~\n                  (`any`)\n\nget({func}, {what})                                                 *get()-func*\nGet item {what} from |Funcref| {func}.  Possible values for\n{what} are:\n  \"name\"    The function name\n  \"func\"    The function\n  \"dict\"    The dictionary\n  \"args\"    The list with arguments\n  \"arity\"   A dictionary with information about the number of\n\t    arguments accepted by the function (minus the\n\t    {arglist}) with the following fields:\n\t\trequired    the number of positional arguments\n\t\toptional    the number of optional arguments,\n\t\t\t    in addition to the required ones\n\t\tvarargs     |TRUE| if the function accepts a\n\t\t\t    variable number of arguments |...|\n\n\t\tNote: There is no error, if the {arglist} of\n\t\tthe Funcref contains more arguments than the\n\t\tFuncref expects, it's not validated.\n\nReturns zero on error.\n\n                Parameters: ~\n                  \226\128\162 {func} (`function`)\n                  \226\128\162 {what} (`string`)\n\n                Return: ~\n                  (`any`)"}}, getbufinfo = {binding = "getbufinfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?dict"}, ["fnl/docstring"] = "Get information about buffers as a List of Dictionaries.\n\nWithout an argument information about all the buffers is\nreturned.\n\nWhen the argument is a |Dictionary| only the buffers matching\nthe specified criteria are returned.  The following keys can\nbe specified in {dict}:\n\tbuflisted\tinclude only listed buffers.\n\tbufloaded\tinclude only loaded buffers.\n\tbufmodified\tinclude only modified buffers.\n\nOtherwise, {buf} specifies a particular buffer to return\ninformation for.  For the use of {buf}, see |bufname()|\nabove.  If the buffer is found the returned List has one item.\nOtherwise the result is an empty list.\n\nEach returned List item is a dictionary with the following\nentries:\n\tbufnr\t\tBuffer number.\n\tchanged\t\tTRUE if the buffer is modified.\n\tchangedtick\tNumber of changes made to the buffer.\n\tcommand\t\tTRUE if the buffer belongs to the\n\t\t\tcommand-line window |cmdwin|.\n\thidden\t\tTRUE if the buffer is hidden.\n\tlastused\tTimestamp in seconds, like\n\t\t\t|localtime()|, when the buffer was\n\t\t\tlast used.\n\tlisted\t\tTRUE if the buffer is listed.\n\tlnum\t\tLine number used for the buffer when\n\t\t\topened in the current window.\n\t\t\tOnly valid if the buffer has been\n\t\t\tdisplayed in the window in the past.\n\t\t\tIf you want the line number of the\n\t\t\tlast known cursor position in a given\n\t\t\twindow, use |line()|: >vim\n\t\t\t\techo line('.', {winid})\n<\n\tlinecount\tNumber of lines in the buffer (only\n\t\t\tvalid when loaded)\n\tloaded\t\tTRUE if the buffer is loaded.\n\tname\t\tFull path to the file in the buffer.\n\tsigns\t\tList of signs placed in the buffer.\n\t\t\tEach list item is a dictionary with\n\t\t\tthe following fields:\n\t\t\t    id\t  sign identifier\n\t\t\t    lnum  line number\n\t\t\t    name  sign name\n\tvariables\tA reference to the dictionary with\n\t\t\tbuffer-local variables.\n\twindows\t\tList of |window-ID|s that display this\n\t\t\tbuffer\n\nExamples: >vim\n\tfor buf in getbufinfo()\n\t    echo buf.name\n\tendfor\n\tfor buf in getbufinfo({'buflisted':1})\n\t    if buf.changed\n\t\t\" ....\n\t    endif\n\tendfor\n<\nTo get buffer-local options use: >vim\n\tgetbufvar({bufnr}, '&option_name')\n<\n\n                Parameters: ~\n                  \226\128\162 {dict} (`vim.fn.getbufinfo.dict?`)\n\n                Return: ~\n                  (`vim.fn.getbufinfo.ret.item[]`)"}}, getbufline = {binding = "getbufline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "lnum", "?end"}, ["fnl/docstring"] = "Return a |List| with the lines starting from {lnum} to {end}\n(inclusive) in the buffer {buf}.  If {end} is omitted, a\n|List| with only the line {lnum} is returned.  See\n`getbufoneline()` for only getting the line.\n\nFor the use of {buf}, see |bufname()| above.\n\nFor {lnum} and {end} \"$\" can be used for the last line of the\nbuffer.  Otherwise a number must be used.\n\nWhen {lnum} is smaller than 1 or bigger than the number of\nlines in the buffer, an empty |List| is returned.\n\nWhen {end} is greater than the number of lines in the buffer,\nit is treated as {end} is set to the number of lines in the\nbuffer.  When {end} is before {lnum} an empty |List| is\nreturned.\n\nThis function works only for loaded buffers.  For unloaded and\nnon-existing buffers, an empty |List| is returned.\n\nExample: >vim\n\tlet lines = getbufline(bufnr(\"myfile\"), 1, \"$\")\n<\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {lnum} (`integer`)\n                  \226\128\162 {end} (`integer?`)\n\n                Return: ~\n                  (`string[]`)"}}, getbufoneline = {binding = "getbufoneline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "lnum"}, ["fnl/docstring"] = "Just like `getbufline()` but only get one line and return it\nas a string.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {lnum} (`integer`)\n\n                Return: ~\n                  (`string`)"}}, getbufvar = {binding = "getbufvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "varname", "?def"}, ["fnl/docstring"] = "The result is the value of option or local buffer variable\n{varname} in buffer {buf}.  Note that the name without \"b:\"\nmust be used.\nThe {varname} argument is a string.\nWhen {varname} is empty returns a |Dictionary| with all the\nbuffer-local variables.\nWhen {varname} is equal to \"&\" returns a |Dictionary| with all\nthe buffer-local options.\nOtherwise, when {varname} starts with \"&\" returns the value of\na buffer-local option.\nThis also works for a global or buffer-local option, but it\ndoesn't work for a global variable, window-local variable or\nwindow-local option.\nFor the use of {buf}, see |bufname()| above.\nWhen the buffer or variable doesn't exist {def} or an empty\nstring is returned, there is no error message.\nExamples: >vim\n\tlet bufmodified = getbufvar(1, \"&mod\")\n\techo \"todo myvar = \" .. getbufvar(\"todo\", \"myvar\")\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {def} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, getcellwidths = {binding = "getcellwidths", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a |List| of cell widths of character ranges overridden\nby |setcellwidths()|.  The format is equal to the argument of\n|setcellwidths()|.  If no character ranges have their cell\nwidths overridden, an empty List is returned.\n\n                Return: ~\n                  (`any`)"}}, getchangelist = {binding = "getchangelist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?buf"}, ["fnl/docstring"] = "Returns the |changelist| for the buffer {buf}. For the use\nof {buf}, see |bufname()| above. If buffer {buf} doesn't\nexist, an empty list is returned.\n\nThe returned list contains two entries: a list with the change\nlocations and the current position in the list.  Each\nentry in the change list is a dictionary with the following\nentries:\n\tcol\t\tcolumn number\n\tcoladd\t\tcolumn offset for 'virtualedit'\n\tlnum\t\tline number\nIf buffer {buf} is the current buffer, then the current\nposition refers to the position in the list. For other\nbuffers, it is set to the length of the list.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string?`)\n\n                Return: ~\n                  (`table[]`)"}}, getchar = {binding = "getchar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?expr", "?opts"}, ["fnl/docstring"] = "Get a single character from the user or input stream.\nIf {expr} is omitted or is -1, wait until a character is\n\tavailable.\nIf {expr} is 0, only get a character when one is available.\n\tReturn zero otherwise.\nIf {expr} is 1, only check if a character is available, it is\n\tnot consumed.  Return zero if no character available.\nIf you prefer always getting a string use |getcharstr()|, or\nspecify |FALSE| as \"number\" in {opts}.\n\nWithout {expr} and when {expr} is 0 a whole character or\nspecial key is returned.  If it is a single character, the\nresult is a Number.  Use |nr2char()| to convert it to a String.\nOtherwise a String is returned with the encoded character.\nFor a special key it's a String with a sequence of bytes\nstarting with 0x80 (decimal: 128).  This is the same value as\nthe String \"\\<Key>\", e.g., \"\\<Left>\".  The returned value is\nalso a String when a modifier (shift, control, alt) was used\nthat is not included in the character.  |keytrans()| can also\nbe used to convert a returned String into a readable form.\n\nWhen {expr} is 0 and Esc is typed, there will be a short delay\nwhile Vim waits to see if this is the start of an escape\nsequence.\n\nWhen {expr} is 1 only the first byte is returned.  For a\none-byte character it is the character itself as a number.\nUse nr2char() to convert it to a String.\n\nUse getcharmod() to obtain any additional modifiers.\n\nThe optional argument {opts} is a Dict and supports the\nfollowing items:\n\n\tcursor\t\tA String specifying cursor behavior\n\t\t\twhen waiting for a character.\n\t\t\t\"hide\": hide the cursor.\n\t\t\t\"keep\": keep current cursor unchanged.\n\t\t\t\"msg\": move cursor to message area.\n\t\t\t(default: automagically decide\n\t\t\tbetween \"keep\" and \"msg\")\n\n\tnumber\t\tIf |TRUE|, return a Number when getting\n\t\t\ta single character.\n\t\t\tIf |FALSE|, the return value is always\n\t\t\tconverted to a String, and an empty\n\t\t\tString (instead of 0) is returned when\n\t\t\tno character is available.\n\t\t\t(default: |TRUE|)\n\n\tsimplify\tIf |TRUE|, include modifiers in the\n\t\t\tcharacter if possible.  E.g., return\n\t\t\tthe same value for CTRL-I and <Tab>.\n\t\t\tIf |FALSE|, don't include modifiers in\n\t\t\tthe character.\n\t\t\t(default: |TRUE|)\n\nWhen the user clicks a mouse button, the mouse event will be\nreturned.  The position can then be found in |v:mouse_col|,\n|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.\n|getmousepos()| can also be used.  Mouse move events will be\nignored.\nThis example positions the mouse as it would normally happen: >vim\n\tlet c = getchar()\n\tif c == \"\\<LeftMouse>\" && v:mouse_win > 0\n\t  exe v:mouse_win .. \"wincmd w\"\n\t  exe v:mouse_lnum\n\t  exe \"normal \" .. v:mouse_col .. \"|\"\n\tendif\n<\nThere is no prompt, you will somehow have to make clear to the\nuser that a character has to be typed.  The screen is not\nredrawn, e.g. when resizing the window.\n\nThere is no mapping for the character.\nKey codes are replaced, thus when the user presses the <Del>\nkey you get the code for the <Del> key, not the raw character\nsequence.  Examples: >vim\n\tgetchar() == \"\\<Del>\"\n\tgetchar() == \"\\<S-Left>\"\n<\t\tThis example redefines \"f\" to ignore case: >vim\n\tnmap f :call FindChar()<CR>\n\tfunction FindChar()\n\t  let c = nr2char(getchar())\n\t  while col('.') < col('$') - 1\n\t    normal l\n\t    if getline('.')[col('.') - 1] ==? c\n\t      break\n\t    endif\n\t  endwhile\n\tendfunction\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`-1|0|1?`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`integer|string`)"}}, getcharmod = {binding = "getcharmod", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number which is the state of the modifiers for\nthe last obtained character with getchar() or in another way.\nThese values are added together:\n\0092\tshift\n\0094\tcontrol\n\0098\talt (meta)\n\00916\tmeta (when it's different from ALT)\n\00932\tmouse double click\n\00964\tmouse triple click\n\00996\tmouse quadruple click (== 32 + 64)\n\009128\tcommand (Mac) or super\nOnly the modifiers that have not been included in the\ncharacter itself are obtained.  Thus Shift-a results in \"A\"\nwithout a modifier.  Returns 0 if no modifiers are used.\n\n                Return: ~\n                  (`integer`)"}}, getcharpos = {binding = "getcharpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Get the position for String {expr}. Same as |getpos()| but the\ncolumn number in the returned List is a character index\ninstead of a byte index.\nIf |getpos()| returns a very large column number, equal to\n|v:maxcol|, then getcharpos() will return the character index\nof the last character.\n\nExample:\nWith the cursor on '\236\132\184' in line 5 with text \"\236\151\172\235\179\180\236\132\184\236\154\148\": >vim\n\tgetcharpos('.')\t\treturns [0, 5, 3, 0]\n\tgetpos('.')\t\treturns [0, 5, 7, 0]\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`integer[]`)"}}, getcharsearch = {binding = "getcharsearch", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the current character search information as a {dict}\nwith the following entries:\n\n    char\tcharacter previously used for a character\n\t\tsearch (|t|, |f|, |T|, or |F|); empty string\n\t\tif no character search has been performed\n    forward\tdirection of character search; 1 for forward,\n\t\0090 for backward\n    until\ttype of character search; 1 for a |t| or |T|\n\t\tcharacter search, 0 for an |f| or |F|\n\t\tcharacter search\n\nThis can be useful to always have |;| and |,| search\nforward/backward regardless of the direction of the previous\ncharacter search: >vim\n\tnnoremap <expr> ; getcharsearch().forward ? ';' : ','\n\tnnoremap <expr> , getcharsearch().forward ? ',' : ';'\n<\t\tAlso see |setcharsearch()|.\n\n                Return: ~\n                  (`table`)"}}, getcharstr = {binding = "getcharstr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?expr", "?opts"}, ["fnl/docstring"] = "The same as |getchar()|, except that this always returns a\nString, and \"number\" isn't allowed in {opts}.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`-1|0|1?`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`string`)"}}, getcmdcomplpat = {binding = "getcmdcomplpat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return completion pattern of the current command-line.\nOnly works when the command line is being edited, thus\nrequires use of |c_CTRL-\\_e| or |c_CTRL-R_=|.\nAlso see |getcmdtype()|, |setcmdpos()|, |getcmdline()|,\n|getcmdprompt()|, |getcmdcompltype()| and |setcmdline()|.\nReturns an empty string when completion is not defined.\n\n                Return: ~\n                  (`string`)"}}, getcmdcompltype = {binding = "getcmdcompltype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the type of the current command-line completion.\nOnly works when the command line is being edited, thus\nrequires use of |c_CTRL-\\_e| or |c_CTRL-R_=|.\nSee |:command-completion| for the return string.\nAlso see |getcmdtype()|, |setcmdpos()|, |getcmdline()|,\n|getcmdprompt()|, |getcmdcomplpat()| and |setcmdline()|.\nReturns an empty string when completion is not defined.\n\n                Return: ~\n                  (`string`)"}}, getcmdline = {binding = "getcmdline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the current command-line input.  Only works when the\ncommand line is being edited, thus requires use of\n|c_CTRL-\\_e| or |c_CTRL-R_=|.\nExample: >vim\n\tcmap <F7> <C-\\>eescape(getcmdline(), ' \\')<CR>\n<\t\tAlso see |getcmdtype()|, |getcmdpos()|, |setcmdpos()|,\n|getcmdprompt()| and |setcmdline()|.\nReturns an empty string when entering a password or using\n|inputsecret()|.\n\n                Return: ~\n                  (`string`)"}}, getcmdpos = {binding = "getcmdpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the position of the cursor in the command line as a\nbyte count.  The first column is 1.\nOnly works when editing the command line, thus requires use of\n|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\nReturns 0 otherwise.\nAlso see |getcmdtype()|, |setcmdpos()|, |getcmdline()|,\n|getcmdprompt()| and |setcmdline()|.\n\n                Return: ~\n                  (`integer`)"}}, getcmdprompt = {binding = "getcmdprompt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the current command-line prompt when using functions\nlike |input()| or |confirm()|.\nOnly works when the command line is being edited, thus\nrequires use of |c_CTRL-\\_e| or |c_CTRL-R_=|.\nAlso see |getcmdtype()|, |getcmdline()|, |getcmdpos()|,\n|setcmdpos()| and |setcmdline()|.\n\n                Return: ~\n                  (`string`)"}}, getcmdscreenpos = {binding = "getcmdscreenpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the screen position of the cursor in the command line\nas a byte count.  The first column is 1.\nInstead of |getcmdpos()|, it adds the prompt position.\nOnly works when editing the command line, thus requires use of\n|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\nReturns 0 otherwise.\nAlso see |getcmdpos()|, |setcmdpos()|, |getcmdline()| and\n|setcmdline()|.\n\n                Return: ~\n                  (`integer`)"}}, getcmdtype = {binding = "getcmdtype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the current command-line type. Possible return values\nare:\n    :\tnormal Ex command\n    >\tdebug mode command |debug-mode|\n    /\tforward search command\n    ?\tbackward search command\n    @\t|input()| command\n    `-`\t|:insert| or |:append| command\n    =\t|i_CTRL-R_=|\nOnly works when editing the command line, thus requires use of\n|c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\nReturns an empty string otherwise.\nAlso see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.\n\n                Return: ~\n                  (`':'|'>'|'/'|'?'|'@'|'-'|'='`)"}}, getcmdwintype = {binding = "getcmdwintype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the current |command-line-window| type. Possible return\nvalues are the same as |getcmdtype()|. Returns an empty string\nwhen not in the command-line window.\n\n                Return: ~\n                  (`':'|'>'|'/'|'?'|'@'|'-'|'='`)"}}, getcompletion = {binding = "getcompletion", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pat", "type", "?filtered"}, ["fnl/docstring"] = "Return a list of command-line completion matches. The String\n{type} argument specifies what for.  The following completion\ntypes are supported:\n\narglist\t\tfile names in argument list\naugroup\t\tautocmd groups\nbuffer\t\tbuffer names\nbreakpoint\t|:breakadd| and |:breakdel| suboptions\ncmdline\t\t|cmdline-completion| result\ncolor\t\tcolor schemes\ncommand\t\tEx command\ncompiler\tcompilers\ncustom,{func}\tcustom completion, defined via {func}\ncustomlist,{func} custom completion, defined via {func}\ndiff_buffer\t|:diffget| and |:diffput| completion\ndir\t\tdirectory names\ndir_in_path\tdirectory names in |'cdpath'|\nenvironment\tenvironment variable names\nevent\t\tautocommand events\nexpression\tVim expression\nfile\t\tfile and directory names\nfile_in_path\tfile and directory names in |'path'|\nfiletype\tfiletype names |'filetype'|\nfunction\tfunction name\nhelp\t\thelp subjects\nhighlight\thighlight groups\nhistory\t\t|:history| suboptions\nkeymap\t\tkeyboard mappings\nlocale\t\tlocale names (as output of locale -a)\nmapclear\tbuffer argument\nmapping\t\tmapping name\nmenu\t\tmenus\nmessages\t|:messages| suboptions\noption\t\toptions\npackadd\t\toptional package |pack-add| names\nruntime\t\t|:runtime| completion\nscriptnames\tsourced script names |:scriptnames|\nshellcmd\tShell command\nshellcmdline\tShell command line with filename arguments\nsign\t\t|:sign| suboptions\nsyntax\t\tsyntax file names |'syntax'|\nsyntime\t\t|:syntime| suboptions\ntag\t\ttags\ntag_listfiles\ttags, file names\nuser\t\tuser names\nvar\t\tuser variables\n\nIf {pat} is an empty string, then all the matches are\nreturned.  Otherwise only items matching {pat} are returned.\nSee |wildcards| for the use of special characters in {pat}.\n\nIf the optional {filtered} flag is set to 1, then 'wildignore'\nis applied to filter the results.  Otherwise all the matches\nare returned. The 'wildignorecase' option always applies.\n\nIf the 'wildoptions' option contains \"fuzzy\", then fuzzy\nmatching is used to get the completion matches. Otherwise\nregular expression matching is used.  Thus this function\nfollows the user preference, what happens on the command line.\nIf you do not want this you can make 'wildoptions' empty\nbefore calling getcompletion() and restore it afterwards.\n\nIf {type} is \"cmdline\", then the |cmdline-completion| result is\nreturned.  For example, to complete the possible values after\na \":call\" command: >vim\n\techo getcompletion('call ', 'cmdline')\n<\nIf there are no matches, an empty list is returned.  An\ninvalid value for {type} produces an error.\n\n                Parameters: ~\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {type} (`string`)\n                  \226\128\162 {filtered} (`boolean?`)\n\n                Return: ~\n                  (`string[]`)"}}, getcurpos = {binding = "getcurpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winid"}, ["fnl/docstring"] = "Get the position of the cursor.  This is like getpos('.'), but\nincludes an extra \"curswant\" item in the list:\n    [0, lnum, col, off, curswant] ~\nThe \"curswant\" number is the preferred column when moving the\ncursor vertically.  After |$| command it will be a very large\nnumber equal to |v:maxcol|.  Also see |getcursorcharpos()| and\n|getpos()|.\nThe first \"bufnum\" item is always zero. The byte position of\nthe cursor is returned in \"col\". To get the character\nposition, use |getcursorcharpos()|.\n\nThe optional {winid} argument can specify the window.  It can\nbe the window number or the |window-ID|.  The last known\ncursor position is returned, this may be invalid for the\ncurrent value of the buffer if it is not the current window.\nIf {winid} is invalid a list with zeroes is returned.\n\nThis can be used to save and restore the cursor position: >vim\n\tlet save_cursor = getcurpos()\n\tMoveTheCursorAround\n\tcall setpos('.', save_cursor)\n<\t\tNote that this only works within the window.  See\n|winrestview()| for restoring more state.\n\n                Parameters: ~\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, getcursorcharpos = {binding = "getcursorcharpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winid"}, ["fnl/docstring"] = "Same as |getcurpos()| but the column number in the returned\nList is a character index instead of a byte index.\n\nExample:\nWith the cursor on '\235\179\180' in line 3 with text \"\236\151\172\235\179\180\236\132\184\236\154\148\": >vim\n\tgetcursorcharpos()\t\" returns [0, 3, 2, 0, 3]\n\tgetcurpos()\t\t\" returns [0, 3, 4, 0, 3]\n<\n\n                Parameters: ~\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, getcwd = {binding = "getcwd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winnr", "?tabnr"}, ["fnl/docstring"] = "With no arguments, returns the name of the effective\n|current-directory|. With {winnr} or {tabnr} the working\ndirectory of that scope is returned, and 'autochdir' is\nignored.\nTabs and windows are identified by their respective numbers,\n0 means current tab or window. Missing tab number implies 0.\nThus the following are equivalent: >vim\n\tgetcwd(0)\n\tgetcwd(0, 0)\n<\t\tIf {winnr} is -1 it is ignored, only the tab is resolved.\n{winnr} can be the window number or the |window-ID|.\nIf both {winnr} and {tabnr} are -1 the global working\ndirectory is returned.\nThrow error if the arguments are invalid. |E5000| |E5001| |E5002|\n\n                Parameters: ~\n                  \226\128\162 {winnr} (`integer?`)\n                  \226\128\162 {tabnr} (`integer?`)\n\n                Return: ~\n                  (`string`)"}}, getenv = {binding = "getenv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Return the value of environment variable {name}.  The {name}\nargument is a string, without a leading '$'.  Example: >vim\n\tmyHome = getenv('HOME')\n\n<\t\tWhen the variable does not exist |v:null| is returned.  That\nis different from a variable set to an empty string.\nSee also |expr-env|.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n\n                Return: ~\n                  (`string`)"}}, getfontname = {binding = "getfontname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?name"}, ["fnl/docstring"] = "Without an argument returns the name of the normal font being\nused.  Like what is used for the Normal highlight group\n|hl-Normal|.\nWith an argument a check is done whether String {name} is a\nvalid font name.  If not then an empty string is returned.\nOtherwise the actual font name is returned, or {name} if the\nGUI does not support obtaining the real name.\nOnly works when the GUI is running, thus not in your vimrc or\ngvimrc file.  Use the |GUIEnter| autocommand to use this\nfunction just after the GUI has started.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string?`)\n\n                Return: ~\n                  (`string`)"}}, getfperm = {binding = "getfperm", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname"}, ["fnl/docstring"] = "The result is a String, which is the read, write, and execute\npermissions of the given file {fname}.\nIf {fname} does not exist or its directory cannot be read, an\nempty string is returned.\nThe result is of the form \"rwxrwxrwx\", where each group of\n\"rwx\" flags represent, in turn, the permissions of the owner\nof the file, the group the file belongs to, and other users.\nIf a user does not have a given permission the flag for this\nis replaced with the string \"-\".  Examples: >vim\n\techo getfperm(\"/etc/passwd\")\n\techo getfperm(expand(\"~/.config/nvim/init.vim\"))\n<\t\tThis will hopefully (from a security point of view) display\nthe string \"rw-r--r--\" or even \"rw-------\".\n\nFor setting permissions use |setfperm()|.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n\n                Return: ~\n                  (`string`)"}}, getfsize = {binding = "getfsize", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname"}, ["fnl/docstring"] = "The result is a Number, which is the size in bytes of the\ngiven file {fname}.\nIf {fname} is a directory, 0 is returned.\nIf the file {fname} can't be found, -1 is returned.\nIf the size of {fname} is too big to fit in a Number then -2\nis returned.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, getftime = {binding = "getftime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname"}, ["fnl/docstring"] = "The result is a Number, which is the last modification time of\nthe given file {fname}.  The value is measured as seconds\nsince 1st Jan 1970, and may be passed to strftime().  See also\n|localtime()| and |strftime()|.\nIf the file {fname} can't be found -1 is returned.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, getftype = {binding = "getftype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname"}, ["fnl/docstring"] = "The result is a String, which is a description of the kind of\nfile of the given file {fname}.\nIf {fname} does not exist an empty string is returned.\nHere is a table over different kinds of files and their\nresults:\n\tNormal file\t\t\"file\"\n\tDirectory\t\t\"dir\"\n\tSymbolic link\t\t\"link\"\n\tBlock device\t\t\"bdev\"\n\tCharacter device\t\"cdev\"\n\tSocket\t\t\t\"socket\"\n\tFIFO\t\t\t\"fifo\"\n\tAll other\t\t\"other\"\nExample: >vim\n\tgetftype(\"/home\")\n<\t\tNote that a type such as \"link\" will only be returned on\nsystems that support it.  On some systems only \"dir\" and\n\"file\" are returned.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n\n                Return: ~\n                  (`'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'`)"}}, getjumplist = {binding = "getjumplist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winnr", "?tabnr"}, ["fnl/docstring"] = "Returns the |jumplist| for the specified window.\n\nWithout arguments use the current window.\nWith {winnr} only use this window in the current tab page.\n{winnr} can also be a |window-ID|.\nWith {winnr} and {tabnr} use the window in the specified tab\npage.  If {winnr} or {tabnr} is invalid, an empty list is\nreturned.\n\nThe returned list contains two entries: a list with the jump\nlocations and the last used jump position number in the list.\nEach entry in the jump location list is a dictionary with\nthe following entries:\n\tbufnr\t\tbuffer number\n\tcol\t\tcolumn number\n\tcoladd\t\tcolumn offset for 'virtualedit'\n\tfilename\tfilename if available\n\tlnum\t\tline number\n\n                Parameters: ~\n                  \226\128\162 {winnr} (`integer?`)\n                  \226\128\162 {tabnr} (`integer?`)\n\n                Return: ~\n                  (`vim.fn.getjumplist.ret`)"}}, getline = {binding = "getline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "?end"}, ["fnl/docstring"] = "Without {end} the result is a String, which is line {lnum}\nfrom the current buffer.  Example: >vim\n\tgetline(1)\n<\t\tWhen {lnum} is a String that doesn't start with a\ndigit, |line()| is called to translate the String into a Number.\nTo get the line under the cursor: >vim\n\tgetline(\".\")\n<\t\tWhen {lnum} is a number smaller than 1 or bigger than the\nnumber of lines in the buffer, an empty string is returned.\n\nWhen {end} is given the result is a |List| where each item is\na line from the current buffer in the range {lnum} to {end},\nincluding line {end}.\n{end} is used in the same way as {lnum}.\nNon-existing lines are silently omitted.\nWhen {end} is before {lnum} an empty |List| is returned.\nExample: >vim\n\tlet start = line('.')\n\tlet end = search(\"^$\") - 1\n\tlet lines = getline(start, end)\n\n<\t\tTo get lines from another buffer see |getbufline()| and\n|getbufoneline()|\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {end} (`nil|false?`)\n\n                Return: ~\n                  (`string`)"}}, getloclist = {binding = "getloclist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "?what"}, ["fnl/docstring"] = "Returns a |List| with all the entries in the location list for\nwindow {nr}.  {nr} can be the window number or the |window-ID|.\nWhen {nr} is zero the current window is used.\n\nFor a location list window, the displayed location list is\nreturned.  For an invalid window number {nr}, an empty list is\nreturned. Otherwise, same as |getqflist()|.\n\nIf the optional {what} dictionary argument is supplied, then\nreturns the items listed in {what} as a dictionary. Refer to\n|getqflist()| for the supported items in {what}.\n\nIn addition to the items supported by |getqflist()| in {what},\nthe following item is supported by |getloclist()|:\n\n\tfilewinid\tid of the window used to display files\n\t\t\tfrom the location list. This field is\n\t\t\tapplicable only when called from a\n\t\t\tlocation list window. See\n\t\t\t|location-list-file-window| for more\n\t\t\tdetails.\n\nReturns a |Dictionary| with default values if there is no\nlocation list for the window {nr}.\nReturns an empty Dictionary if window {nr} does not exist.\n\nExamples (See also |getqflist-examples|): >vim\n\techo getloclist(3, {'all': 0})\n\techo getloclist(5, {'filewinid': 0})\n<\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {what} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, getmarklist = {binding = "getmarklist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?buf"}, ["fnl/docstring"] = "Without the {buf} argument returns a |List| with information\nabout all the global marks. |mark|\n\nIf the optional {buf} argument is specified, returns the\nlocal marks defined in buffer {buf}.  For the use of {buf},\nsee |bufname()|.  If {buf} is invalid, an empty list is\nreturned.\n\nEach item in the returned List is a |Dict| with the following:\n    mark   name of the mark prefixed by \"'\"\n    pos\t   a |List| with the position of the mark:\n\t\t[bufnum, lnum, col, off]\n\t   Refer to |getpos()| for more information.\n    file   file name\n\nRefer to |getpos()| for getting information about a specific\nmark.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer??`)\n\n                Return: ~\n                  (`vim.fn.getmarklist.ret.item[]`)"}}, getmatches = {binding = "getmatches", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?win"}, ["fnl/docstring"] = "Returns a |List| with all matches previously defined for the\ncurrent window by |matchadd()| and the |:match| commands.\n|getmatches()| is useful in combination with |setmatches()|,\nas |setmatches()| can restore a list of matches saved by\n|getmatches()|.\nIf {win} is specified, use the window with this number or\nwindow ID instead of the current window.  If {win} is invalid,\nan empty list is returned.\nExample: >vim\n\techo getmatches()\n<\t\t >\n\t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n\t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n\t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n<\t\t >vim\n\tlet m = getmatches()\n\tcall clearmatches()\n\techo getmatches()\n<\t\t >\n\t[]\n<\t\t >vim\n\tcall setmatches(m)\n\techo getmatches()\n<\t\t >\n\t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n\t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n\t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n<\t\t >vim\n\tunlet m\n<\n\n                Parameters: ~\n                  \226\128\162 {win} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, getmousepos = {binding = "getmousepos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a |Dictionary| with the last known position of the\nmouse.  This can be used in a mapping for a mouse click.  The\nitems are:\n\tscreenrow\tscreen row\n\tscreencol\tscreen column\n\twinid\t\tWindow ID of the click\n\twinrow\t\trow inside \"winid\"\n\twincol\t\tcolumn inside \"winid\"\n\tline\t\ttext line inside \"winid\"\n\tcolumn\t\ttext column inside \"winid\"\n\tcoladd\t\toffset (in screen columns) from the\n\t\t\tstart of the clicked char\nAll numbers are 1-based.\n\nIf not over a window, e.g. when in the command line, then only\n\"screenrow\" and \"screencol\" are valid, the others are zero.\n\nWhen on the status line below a window or the vertical\nseparator right of a window, the \"line\" and \"column\" values\nare zero.\n\nWhen the position is after the text then \"column\" is the\nlength of the text in bytes plus one.\n\nIf the mouse is over a focusable floating window then that\nwindow is used.\n\nWhen using |getchar()| the Vim variables |v:mouse_lnum|,\n|v:mouse_col| and |v:mouse_winid| also provide these values.\n\n                Return: ~\n                  (`vim.fn.getmousepos.ret`)"}}, getpid = {binding = "getpid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return a Number which is the process ID of the Vim process.\nThis is a unique number, until Vim exits.\n\n                Return: ~\n                  (`integer`)"}}, getpos = {binding = "getpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Get the position for String {expr}.\nThe accepted values for {expr} are:\n    .\t    The cursor position.\n    $\t    The last line in the current buffer.\n    'x\t    Position of mark x (if the mark is not set, 0 is\n\t    returned for all values).\n    w0\t    First line visible in current window (one if the\n\t    display isn't updated, e.g. in silent Ex mode).\n    w$\t    Last line visible in current window (this is one\n\t    less than \"w0\" if no lines are visible).\n    v\t    When not in Visual mode, returns the cursor\n\t    position.  In Visual mode, returns the other end\n\t    of the Visual area.  A good way to think about\n\t    this is that in Visual mode \"v\" and \".\" complement\n\t    each other.  While \".\" refers to the cursor\n\t    position, \"v\" refers to where |v_o| would move the\n\t    cursor.  As a result, you can use \"v\" and \".\"\n\t    together to work on all of a selection in\n\t    characterwise Visual mode.  If the cursor is at\n\t    the end of a characterwise Visual area, \"v\" refers\n\t    to the start of the same Visual area.  And if the\n\t    cursor is at the start of a characterwise Visual\n\t    area, \"v\" refers to the end of the same Visual\n\t    area.  \"v\" differs from |'<| and |'>| in that it's\n\t    updated right away.\nNote that a mark in another file can be used.  The line number\nthen applies to another buffer.\n\nThe result is a |List| with four numbers:\n    [bufnum, lnum, col, off]\n\"bufnum\" is zero, unless a mark like '0 or 'A is used, then it\nis the buffer number of the mark.\n\"lnum\" and \"col\" are the position in the buffer.  The first\ncolumn is 1.\nThe \"off\" number is zero, unless 'virtualedit' is used.  Then\nit is the offset in screen columns from the start of the\ncharacter.  E.g., a position within a <Tab> or after the last\ncharacter.\n\nFor getting the cursor position see |getcurpos()|.\nThe column number in the returned List is the byte position\nwithin the line. To get the character position in the line,\nuse |getcharpos()|.\n\nNote that for '< and '> Visual mode matters: when it is \"V\"\n(visual line mode) the column of '< is zero and the column of\n'> is a large number equal to |v:maxcol|.\nA very large column number equal to |v:maxcol| can be returned,\nin which case it means \"after the end of the line\".\nIf {expr} is invalid, returns a list with all zeros.\n\nThis can be used to save and restore the position of a mark: >vim\n\tlet save_a_mark = getpos(\"'a\")\n\t\" ...\n\tcall setpos(\"'a\", save_a_mark)\n<\nAlso see |getcharpos()|, |getcurpos()| and |setpos()|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`integer[]`)"}}, getqflist = {binding = "getqflist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?what"}, ["fnl/docstring"] = "Returns a |List| with all the current quickfix errors.  Each\nlist item is a dictionary with these entries:\n\tbufnr\tnumber of buffer that has the file name, use\n\t\tbufname() to get the name\n\tmodule\tmodule name\n\tlnum\tline number in the buffer (first line is 1)\n\tend_lnum\n\t\tend of line number if the item is multiline\n\tcol\tcolumn number (first column is 1)\n\tend_col\tend of column number if the item has range\n\tvcol\t|TRUE|: \"col\" is visual column\n\t\t|FALSE|: \"col\" is byte index\n\tnr\terror number\n\tpattern\tsearch pattern used to locate the error\n\ttext\tdescription of the error\n\ttype\ttype of the error, 'E', '1', etc.\n\tvalid\t|TRUE|: recognized error message\n\tuser_data\n\t\tcustom data associated with the item, can be\n\t\tany type.\n\nWhen there is no error list or it's empty, an empty list is\nreturned. Quickfix list entries with a non-existing buffer\nnumber are returned with \"bufnr\" set to zero (Note: some\nfunctions accept buffer number zero for the alternate buffer,\nyou may need to explicitly check for zero).\n\nUseful application: Find pattern matches in multiple files and\ndo something with them: >vim\n\tvimgrep /theword/jg *.c\n\tfor d in getqflist()\n\t   echo bufname(d.bufnr) ':' d.lnum '=' d.text\n\tendfor\n<\nIf the optional {what} dictionary argument is supplied, then\nreturns only the items listed in {what} as a dictionary. The\nfollowing string items are supported in {what}:\n\tchangedtick\tget the total number of changes made\n\t\t\tto the list |quickfix-changedtick|\n\tcontext\tget the |quickfix-context|\n\tefm\terrorformat to use when parsing \"lines\". If\n\t\tnot present, then the 'errorformat' option\n\t\tvalue is used.\n\tid\tget information for the quickfix list with\n\t\t|quickfix-ID|; zero means the id for the\n\t\tcurrent list or the list specified by \"nr\"\n\tidx\tget information for the quickfix entry at this\n\t\tindex in the list specified by \"id\" or \"nr\".\n\t\tIf set to zero, then uses the current entry.\n\t\tSee |quickfix-index|\n\titems\tquickfix list entries\n\tlines\tparse a list of lines using 'efm' and return\n\t\tthe resulting entries.  Only a |List| type is\n\t\taccepted.  The current quickfix list is not\n\t\tmodified. See |quickfix-parse|.\n\tnr\tget information for this quickfix list; zero\n\t\tmeans the current quickfix list and \"$\" means\n\t\tthe last quickfix list\n\tqfbufnr number of the buffer displayed in the quickfix\n\t\twindow. Returns 0 if the quickfix buffer is\n\t\tnot present. See |quickfix-buffer|.\n\tsize\tnumber of entries in the quickfix list\n\ttitle\tget the list title |quickfix-title|\n\twinid\tget the quickfix |window-ID|\n\tall\tall of the above quickfix properties\nNon-string items in {what} are ignored. To get the value of a\nparticular item, set it to zero.\nIf \"nr\" is not present then the current quickfix list is used.\nIf both \"nr\" and a non-zero \"id\" are specified, then the list\nspecified by \"id\" is used.\nTo get the number of lists in the quickfix stack, set \"nr\" to\n\"$\" in {what}. The \"nr\" value in the returned dictionary\ncontains the quickfix stack size.\nWhen \"lines\" is specified, all the other items except \"efm\"\nare ignored.  The returned dictionary contains the entry\n\"items\" with the list of entries.\n\nThe returned dictionary contains the following entries:\n\tchangedtick\ttotal number of changes made to the\n\t\t\tlist |quickfix-changedtick|\n\tcontext\tquickfix list context. See |quickfix-context|\n\t\tIf not present, set to \"\".\n\tid\tquickfix list ID |quickfix-ID|. If not\n\t\tpresent, set to 0.\n\tidx\tindex of the quickfix entry in the list. If not\n\t\tpresent, set to 0.\n\titems\tquickfix list entries. If not present, set to\n\t\tan empty list.\n\tnr\tquickfix list number. If not present, set to 0\n\tqfbufnr\tnumber of the buffer displayed in the quickfix\n\t\twindow. If not present, set to 0.\n\tsize\tnumber of entries in the quickfix list. If not\n\t\tpresent, set to 0.\n\ttitle\tquickfix list title text. If not present, set\n\t\tto \"\".\n\twinid\tquickfix |window-ID|. If not present, set to 0\n\nExamples (See also |getqflist-examples|): >vim\n\techo getqflist({'all': 1})\n\techo getqflist({'nr': 2, 'title': 1})\n\techo getqflist({'lines' : [\"F1:10:L10\"]})\n<\n\n                Parameters: ~\n                  \226\128\162 {what} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, getreg = {binding = "getreg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?regname", "?list"}, ["fnl/docstring"] = "The result is a String, which is the contents of register\n{regname}.  Example: >vim\n\tlet cliptext = getreg('*')\n<\t\tWhen register {regname} was not set the result is an empty\nstring.\nThe {regname} argument must be a string.\n\ngetreg('=') returns the last evaluated value of the expression\nregister.  (For use in maps.)\ngetreg('=', 1) returns the expression itself, so that it can\nbe restored with |setreg()|.  For other registers the extra\nargument is ignored, thus you can always give it.\n\nIf {list} is present and |TRUE|, the result type is changed\nto |List|. Each list item is one text line. Use it if you care\nabout zero bytes possibly present inside register: without\nthird argument both NLs and zero bytes are represented as NLs\n(see |NL-used-for-Nul|).\nWhen the register was not set an empty list is returned.\n\nIf {regname} is not specified, |v:register| is used.\n\n                Parameters: ~\n                  \226\128\162 {regname} (`string?`)\n                  \226\128\162 {list} (`nil|false?`)\n\n                Return: ~\n                  (`string`)"}}, getreginfo = {binding = "getreginfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?regname"}, ["fnl/docstring"] = "Returns detailed information about register {regname} as a\nDictionary with the following entries:\n\tregcontents\tList of lines contained in register\n\t\t\t{regname}, like\n\t\t\tgetreg({regname}, 1, 1).\n\tregtype\t\tthe type of register {regname}, as in\n\t\t\t|getregtype()|.\n\tisunnamed\tBoolean flag, v:true if this register\n\t\t\tis currently pointed to by the unnamed\n\t\t\tregister.\n\tpoints_to\tfor the unnamed register, gives the\n\t\t\tsingle letter name of the register\n\t\t\tcurrently pointed to (see |quotequote|).\n\t\t\tFor example, after deleting a line\n\t\t\twith `dd`, this field will be \"1\",\n\t\t\twhich is the register that got the\n\t\t\tdeleted text.\n\nThe {regname} argument is a string.  If {regname} is invalid\nor not set, an empty Dictionary will be returned.\nIf {regname} is not specified, |v:register| is used.\nThe returned Dictionary can be passed to |setreg()|.\n\n                Parameters: ~\n                  \226\128\162 {regname} (`string?`)\n\n                Return: ~\n                  (`table`)"}}, getregion = {binding = "getregion", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pos1", "pos2", "?opts"}, ["fnl/docstring"] = "Returns the list of strings from {pos1} to {pos2} from a\nbuffer.\n\n{pos1} and {pos2} must both be |List|s with four numbers.\nSee |getpos()| for the format of the list.  It's possible\nto specify positions from a different buffer, but please\nnote the limitations at |getregion-notes|.\n\nThe optional argument {opts} is a Dict and supports the\nfollowing items:\n\n\ttype\t\tSpecify the region's selection type.\n\t\t\tSee |getregtype()| for possible values,\n\t\t\texcept that the width can be omitted\n\t\t\tand an empty string cannot be used.\n\t\t\t(default: \"v\")\n\n\texclusive\tIf |TRUE|, use exclusive selection\n\t\t\tfor the end position.\n\t\t\t(default: follow 'selection')\n\nYou can get the last selection type by |visualmode()|.\nIf Visual mode is active, use |mode()| to get the Visual mode\n(e.g., in a |:vmap|).\nThis function is useful to get text starting and ending in\ndifferent columns, such as a |charwise-visual| selection.\n\n\t\t\t\t\t*getregion-notes*\nNote that:\n- Order of {pos1} and {pos2} doesn't matter, it will always\n  return content from the upper left position to the lower\n  right position.\n- If 'virtualedit' is enabled and the region is past the end\n  of the lines, resulting lines are padded with spaces.\n- If the region is blockwise and it starts or ends in the\n  middle of a multi-cell character, it is not included but\n  its selected part is substituted with spaces.\n- If {pos1} and {pos2} are not in the same buffer, an empty\n  list is returned.\n- {pos1} and {pos2} must belong to a |bufloaded()| buffer.\n- It is evaluated in current window context, which makes a\n  difference if the buffer is displayed in a window with\n  different 'virtualedit' or 'list' values.\n- When specifying an exclusive selection and {pos1} and {pos2}\n  are equal, the returned list contains a single character as\n  if selection is inclusive, to match the behavior of an empty\n  exclusive selection in Visual mode.\n\nExamples: >vim\n\txnoremap <CR>\n\t\\ <Cmd>echom getregion(\n\t\\ getpos('v'), getpos('.'), #{ type: mode() })<CR>\n<\n\n                Parameters: ~\n                  \226\128\162 {pos1} (`table`)\n                  \226\128\162 {pos2} (`table`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`string[]`)"}}, getregionpos = {binding = "getregionpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pos1", "pos2", "?opts"}, ["fnl/docstring"] = "Same as |getregion()|, but returns a list of positions\ndescribing the buffer text segments bound by {pos1} and\n{pos2}.\nThe segments are a pair of positions for every line: >\n\t[[{start_pos}, {end_pos}], ...]\n<\nThe position is a |List| with four numbers:\n    [bufnum, lnum, col, off]\n\"bufnum\" is the buffer number.\n\"lnum\" and \"col\" are the position in the buffer.  The first\ncolumn is 1.\nIf the \"off\" number of a starting position is non-zero, it is\nthe offset in screen columns from the start of the character.\nE.g., a position within a <Tab> or after the last character.\nIf the \"off\" number of an ending position is non-zero, it is\nthe offset of the character's first cell not included in the\nselection, otherwise all its cells are included.\n\nApart from the options supported by |getregion()|, {opts} also\nsupports the following:\n\n\teol\t\tIf |TRUE|, indicate positions beyond\n\t\t\tthe end of a line with \"col\" values\n\t\t\tone more than the length of the line.\n\t\t\tIf |FALSE|, positions are limited\n\t\t\twithin their lines, and if a line is\n\t\t\tempty or the selection is entirely\n\t\t\tbeyond the end of a line, a \"col\"\n\t\t\tvalue of 0 is used for both positions.\n\t\t\t(default: |FALSE|)\n\n                Parameters: ~\n                  \226\128\162 {pos1} (`table`)\n                  \226\128\162 {pos2} (`table`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`integer[][][]`)"}}, getregtype = {binding = "getregtype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?regname"}, ["fnl/docstring"] = "The result is a String, which is type of register {regname}.\nThe value will be one of:\n    \"v\"\t\t\tfor |charwise| text\n    \"V\"\t\t\tfor |linewise| text\n    \"<CTRL-V>{width}\"\tfor |blockwise-visual| text\n    \"\"\t\t\tfor an empty or unknown register\n<CTRL-V> is one character with value 0x16.\nThe {regname} argument is a string.  If {regname} is not\nspecified, |v:register| is used.\n\n                Parameters: ~\n                  \226\128\162 {regname} (`string?`)\n\n                Return: ~\n                  (`string`)"}}, getscriptinfo = {binding = "getscriptinfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Returns a |List| with information about all the sourced Vim\nscripts in the order they were sourced, like what\n`:scriptnames` shows.\n\nThe optional Dict argument {opts} supports the following\noptional items:\n    name\tScript name match pattern. If specified,\n\t\tand \"sid\" is not specified, information about\n\t\tscripts with a name that match the pattern\n\t\t\"name\" are returned.\n    sid\t\tScript ID |<SID>|.  If specified, only\n\t\tinformation about the script with ID \"sid\" is\n\t\treturned and \"name\" is ignored.\n\nEach item in the returned List is a |Dict| with the following\nitems:\n    autoload\tAlways set to FALSE.\n    functions   List of script-local function names defined in\n\t\tthe script.  Present only when a particular\n\t\tscript is specified using the \"sid\" item in\n\t\t{opts}.\n    name\tVim script file name.\n    sid\t\tScript ID |<SID>|.\n    variables   A dictionary with the script-local variables.\n\t\tPresent only when a particular script is\n\t\tspecified using the \"sid\" item in {opts}.\n\t\tNote that this is a copy, the value of\n\t\tscript-local variables cannot be changed using\n\t\tthis dictionary.\n    version\tVim script version, always 1\n\nExamples: >vim\n\techo getscriptinfo({'name': 'myscript'})\n\techo getscriptinfo({'sid': 15})[0].variables\n<\n\n                Parameters: ~\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`vim.fn.getscriptinfo.ret[]`)"}}, getstacktrace = {binding = "getstacktrace", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current stack trace of Vim scripts.\nStack trace is a |List|, of which each item is a |Dictionary|\nwith the following items:\n    funcref\tThe funcref if the stack is at a function,\n\t\totherwise this item is omitted.\n    event\tThe string of the event description if the\n\t\tstack is at an autocmd event, otherwise this\n\t\titem is omitted.\n    lnum\tThe line number in the script on the stack.\n    filepath\tThe file path of the script on the stack.\n\n                Return: ~\n                  (`table[]`)"}}, gettabinfo = {binding = "gettabinfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?tabnr"}, ["fnl/docstring"] = "If {tabnr} is not specified, then information about all the\ntab pages is returned as a |List|. Each List item is a\n|Dictionary|.  Otherwise, {tabnr} specifies the tab page\nnumber and information about that one is returned.  If the tab\npage does not exist an empty List is returned.\n\nEach List item is a |Dictionary| with the following entries:\n\ttabnr\t\ttab page number.\n\tvariables\ta reference to the dictionary with\n\t\t\ttabpage-local variables\n\twindows\t\tList of |window-ID|s in the tab page.\n\n                Parameters: ~\n                  \226\128\162 {tabnr} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, gettabvar = {binding = "gettabvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabnr", "varname", "?def"}, ["fnl/docstring"] = "Get the value of a tab-local variable {varname} in tab page\n{tabnr}. |t:var|\nTabs are numbered starting with one.\nThe {varname} argument is a string.  When {varname} is empty a\ndictionary with all tab-local variables is returned.\nNote that the name without \"t:\" must be used.\nWhen the tab or variable doesn't exist {def} or an empty\nstring is returned, there is no error message.\n\n                Parameters: ~\n                  \226\128\162 {tabnr} (`integer`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {def} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, gettabwinvar = {binding = "gettabwinvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabnr", "winnr", "varname", "?def"}, ["fnl/docstring"] = "Get the value of window-local variable {varname} in window\n{winnr} in tab page {tabnr}.\nThe {varname} argument is a string.  When {varname} is empty a\ndictionary with all window-local variables is returned.\nWhen {varname} is equal to \"&\" get the values of all\nwindow-local options in a |Dictionary|.\nOtherwise, when {varname} starts with \"&\" get the value of a\nwindow-local option.\nNote that {varname} must be the name without \"w:\".\nTabs are numbered starting with one.  For the current tabpage\nuse |getwinvar()|.\n{winnr} can be the window number or the |window-ID|.\nWhen {winnr} is zero the current window is used.\nThis also works for a global option, buffer-local option and\nwindow-local option, but it doesn't work for a global variable\nor buffer-local variable.\nWhen the tab, window or variable doesn't exist {def} or an\nempty string is returned, there is no error message.\nExamples: >vim\n\tlet list_is_on = gettabwinvar(1, 2, '&list')\n\techo \"myvar = \" .. gettabwinvar(3, 1, 'myvar')\n<\nTo obtain all window-local variables use: >vim\n\tgettabwinvar({tabnr}, {winnr}, '&')\n<\n\n                Parameters: ~\n                  \226\128\162 {tabnr} (`integer`)\n                  \226\128\162 {winnr} (`integer`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {def} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, gettagstack = {binding = "gettagstack", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winnr"}, ["fnl/docstring"] = "The result is a Dict, which is the tag stack of window {winnr}.\n{winnr} can be the window number or the |window-ID|.\nWhen {winnr} is not specified, the current window is used.\nWhen window {winnr} doesn't exist, an empty Dict is returned.\n\nThe returned dictionary contains the following entries:\n\tcuridx\t\tCurrent index in the stack. When at\n\t\t\ttop of the stack, set to (length + 1).\n\t\t\tIndex of bottom of the stack is 1.\n\titems\t\tList of items in the stack. Each item\n\t\t\tis a dictionary containing the\n\t\t\tentries described below.\n\tlength\t\tNumber of entries in the stack.\n\nEach item in the stack is a dictionary with the following\nentries:\n\tbufnr\t\tbuffer number of the current jump\n\tfrom\t\tcursor position before the tag jump.\n\t\t\tSee |getpos()| for the format of the\n\t\t\treturned list.\n\tmatchnr\t\tcurrent matching tag number. Used when\n\t\t\tmultiple matching tags are found for a\n\t\t\tname.\n\ttagname\t\tname of the tag\n\nSee |tagstack| for more information about the tag stack.\n\n                Parameters: ~\n                  \226\128\162 {winnr} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, gettext = {binding = "gettext", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"text"}, ["fnl/docstring"] = "Translate String {text} if possible.\nThis is mainly for use in the distributed Vim scripts.  When\ngenerating message translations the {text} is extracted by\nxgettext, the translator can add the translated message in the\n.po file and Vim will lookup the translation when gettext() is\ncalled.\nFor {text} double quoted strings are preferred, because\nxgettext does not understand escaping in single quoted\nstrings.\n\n                Parameters: ~\n                  \226\128\162 {text} (`string`)\n\n                Return: ~\n                  (`string`)"}}, getwininfo = {binding = "getwininfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winid"}, ["fnl/docstring"] = "Returns information about windows as a |List| with Dictionaries.\n\nIf {winid} is given Information about the window with that ID\nis returned, as a |List| with one item.  If the window does not\nexist the result is an empty list.\n\nWithout {winid} information about all the windows in all the\ntab pages is returned.\n\nEach List item is a |Dictionary| with the following entries:\n\tbotline\t\tlast complete displayed buffer line\n\tbufnr\t\tnumber of buffer in the window\n\theight\t\twindow height (excluding winbar)\n\tleftcol\t\tfirst column displayed; only used when\n\t\t\t'wrap' is off\n\tloclist\t\0091 if showing a location list\n\tquickfix\0091 if quickfix or location list window\n\tterminal\0091 if a terminal window\n\ttabnr\t\ttab page number\n\ttopline\t\tfirst displayed buffer line\n\tvariables\ta reference to the dictionary with\n\t\t\twindow-local variables\n\twidth\t\twindow width\n\twinbar\t\0091 if the window has a toolbar, 0\n\t\t\totherwise\n\twincol\t\tleftmost screen column of the window;\n\t\t\t\"col\" from |win_screenpos()|\n\ttextoff\t\tnumber of columns occupied by any\n\t\t\t'foldcolumn', 'signcolumn' and line\n\t\t\tnumber in front of the text\n\twinid\t\t|window-ID|\n\twinnr\t\twindow number\n\twinrow\t\ttopmost screen line of the window;\n\t\t\t\"row\" from |win_screenpos()|\n\n                Parameters: ~\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`vim.fn.getwininfo.ret.item[]`)"}}, getwinpos = {binding = "getwinpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?timeout"}, ["fnl/docstring"] = "The result is a |List| with two numbers, the result of\n|getwinposx()| and |getwinposy()| combined:\n\t[x-pos, y-pos]\n{timeout} can be used to specify how long to wait in msec for\na response from the terminal.  When omitted 100 msec is used.\n\nUse a longer time for a remote terminal.\nWhen using a value less than 10 and no response is received\nwithin that time, a previously reported position is returned,\nif available.  This can be used to poll for the position and\ndo some work in the meantime: >vim\n\twhile 1\n\t  let res = getwinpos(1)\n\t  if res[0] >= 0\n\t    break\n\t  endif\n\t  \" Do some work here\n\tendwhile\n<\n\n                Parameters: ~\n                  \226\128\162 {timeout} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, getwinposx = {binding = "getwinposx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number, which is the X coordinate in pixels of\nthe left hand side of the GUI Vim window.  The result will be\n-1 if the information is not available.\nThe value can be used with `:winpos`.\n\n                Return: ~\n                  (`integer`)"}}, getwinposy = {binding = "getwinposy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number, which is the Y coordinate in pixels of\nthe top of the GUI Vim window.  The result will be -1 if the\ninformation is not available.\nThe value can be used with `:winpos`.\n\n                Return: ~\n                  (`integer`)"}}, getwinvar = {binding = "getwinvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"winnr", "varname", "?def"}, ["fnl/docstring"] = "Like |gettabwinvar()| for the current tabpage.\nExamples: >vim\n\tlet list_is_on = getwinvar(2, '&list')\n\techo \"myvar = \" .. getwinvar(1, 'myvar')\n\n                Parameters: ~\n                  \226\128\162 {winnr} (`integer`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {def} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, glob = {binding = "glob", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?nosuf", "?list", "?alllinks"}, ["fnl/docstring"] = "Expand the file wildcards in {expr}.  See |wildcards| for the\nuse of special characters.\n\nUnless the optional {nosuf} argument is given and is |TRUE|,\nthe 'suffixes' and 'wildignore' options apply: Names matching\none of the patterns in 'wildignore' will be skipped and\n'suffixes' affect the ordering of matches.\n'wildignorecase' always applies.\n\nWhen {list} is present and it is |TRUE| the result is a |List|\nwith all matching files. The advantage of using a List is,\nyou also get filenames containing newlines correctly.\nOtherwise the result is a String and when there are several\nmatches, they are separated by <NL> characters.\n\nIf the expansion fails, the result is an empty String or List.\n\nYou can also use |readdir()| if you need to do complicated\nthings, such as limiting the number of matches.\n\nA name for a non-existing file is not included.  A symbolic\nlink is only included if it points to an existing file.\nHowever, when the {alllinks} argument is present and it is\n|TRUE| then all symbolic links are included.\n\nFor most systems backticks can be used to get files names from\nany external command.  Example: >vim\n\tlet tagfiles = glob(\"`find . -name tags -print`\")\n\tlet &tags = substitute(tagfiles, \"\\n\", \",\", \"g\")\n<\t\tThe result of the program inside the backticks should be one\nitem per line.  Spaces inside an item are allowed.\n\nSee |expand()| for expanding special Vim variables.  See\n|system()| for getting the raw output of an external command.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n                  \226\128\162 {nosuf} (`boolean?`)\n                  \226\128\162 {list} (`boolean?`)\n                  \226\128\162 {alllinks} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, glob2regpat = {binding = "glob2regpat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Convert a file pattern, as used by glob(), into a search\npattern.  The result can be used to match with a string that\nis a file name.  E.g. >vim\n\tif filename =~ glob2regpat('Make*.mak')\n\t  \" ...\n\tendif\n<\t\tThis is equivalent to: >vim\n\tif filename =~ '^Make.*\\.mak$'\n\t  \" ...\n\tendif\n<\t\tWhen {string} is an empty string the result is \"^$\", match an\nempty string.\nNote that the result depends on the system.  On MS-Windows\na backslash usually means a path separator.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`string`)"}}, globpath = {binding = "globpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "expr", "?nosuf", "?list", "?allinks"}, ["fnl/docstring"] = "Perform glob() for String {expr} on all directories in {path}\nand concatenate the results.  Example: >vim\n\techo globpath(&rtp, \"syntax/c.vim\")\n<\n{path} is a comma-separated list of directory names.  Each\ndirectory name is prepended to {expr} and expanded like with\n|glob()|.  A path separator is inserted when needed.\nTo add a comma inside a directory name escape it with a\nbackslash.  Note that on MS-Windows a directory may have a\ntrailing backslash, remove it if you put a comma after it.\nIf the expansion fails for one of the directories, there is no\nerror message.\n\nUnless the optional {nosuf} argument is given and is |TRUE|,\nthe 'suffixes' and 'wildignore' options apply: Names matching\none of the patterns in 'wildignore' will be skipped and\n'suffixes' affect the ordering of matches.\n\nWhen {list} is present and it is |TRUE| the result is a |List|\nwith all matching files. The advantage of using a List is, you\nalso get filenames containing newlines correctly. Otherwise\nthe result is a String and when there are several matches,\nthey are separated by <NL> characters.  Example: >vim\n\techo globpath(&rtp, \"syntax/c.vim\", 0, 1)\n<\n{allinks} is used as with |glob()|.\n\nThe \"**\" item can be used to search in a directory tree.\nFor example, to find all \"README.txt\" files in the directories\nin 'runtimepath' and below: >vim\n\techo globpath(&rtp, \"**/README.txt\")\n<\t\tUpwards search and limiting the depth of \"**\" is not\nsupported, thus using 'path' will not always work properly.\n\n                Parameters: ~\n                  \226\128\162 {path} (`string`)\n                  \226\128\162 {expr} (`string`)\n                  \226\128\162 {nosuf} (`boolean?`)\n                  \226\128\162 {list} (`boolean?`)\n                  \226\128\162 {allinks} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, has = {binding = "has", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"feature"}, ["fnl/docstring"] = "Returns 1 if {feature} is supported, 0 otherwise.  The\n{feature} argument is a feature name like \"nvim-0.2.1\" or\n\"win32\", see below.  See also |exists()|.\n\nTo get the system name use |vim.uv|.os_uname() in Lua: >lua\n\tprint(vim.uv.os_uname().sysname)\n\n<\t\tIf the code has a syntax error then Vimscript may skip the\nrest of the line.  Put |:if| and |:endif| on separate lines to\navoid the syntax error: >vim\n\tif has('feature')\n\t  let x = this_breaks_without_the_feature()\n\tendif\n<\nVim's compile-time feature-names (prefixed with \"+\") are not\nrecognized because Nvim is always compiled with all possible\nfeatures. |feature-compile|\n\nFeature names can be:\n1.  Nvim version. For example the \"nvim-0.2.1\" feature means\n    that Nvim is version 0.2.1 or later: >vim\n\tif has(\"nvim-0.2.1\")\n\t  \" ...\n\tendif\n\n<\t\0092.  Runtime condition or other pseudo-feature. For example the\n    \"win32\" feature checks if the current system is Windows: >vim\n\tif has(\"win32\")\n\t  \" ...\n\tendif\n<\t\t\t\t\t\t\t*feature-list*\n    List of supported pseudo-feature names:\n\tacl\t\t|ACL| support.\n\tbsd\t\tBSD system (not macOS, use \"mac\" for that).\n\tclipboard\t|clipboard| provider is available.\n\tfname_case\tCase in file names matters (for Darwin and MS-Windows\n\t\t\tthis is not present).\n\tgui_running\tNvim has a GUI.\n\thurd\t\tGNU/Hurd system.\n\ticonv\t\tCan use |iconv()| for conversion.\n\tlinux\t\tLinux system.\n\tmac\t\tMacOS system.\n\tnvim\t\tThis is Nvim.\n\tpython3\t\tLegacy Vim |python3| interface. |has-python|\n\tpythonx\t\tLegacy Vim |python_x| interface. |has-pythonx|\n\tsun\t\tSunOS system.\n\tttyin\t\tinput is a terminal (tty).\n\tttyout\t\toutput is a terminal (tty).\n\tunix\t\tUnix system.\n\t*vim_starting*\tTrue during |startup|.\n\twin32\t\tWindows system (32 or 64 bit).\n\twin64\t\tWindows system (64 bit).\n\twsl\t\tWSL (Windows Subsystem for Linux) system.\n\n\t\t\t\t\t*has-patch*\n3.  Vim patch. For example the \"patch123\" feature means that\n    Vim patch 123 at the current |v:version| was included: >vim\n\tif v:version > 602 || v:version == 602 && has(\"patch148\")\n\t  \" ...\n\tendif\n\n<\t\0094.  Vim version. For example the \"patch-7.4.237\" feature means\n    that Nvim is Vim-compatible to version 7.4.237 or later. >vim\n\tif has(\"patch-7.4.237\")\n\t  \" ...\n\tendif\n<\n\n                Parameters: ~\n                  \226\128\162 {feature} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, has_key = {binding = "has_key", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict", "key"}, ["fnl/docstring"] = "The result is a Number, which is TRUE if |Dictionary| {dict}\nhas an entry with key {key}.  FALSE otherwise. The {key}\nargument is a string.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`table`)\n                  \226\128\162 {key} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, haslocaldir = {binding = "haslocaldir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winnr", "?tabnr"}, ["fnl/docstring"] = "The result is a Number, which is 1 when the window has set a\nlocal path via |:lcd| or when {winnr} is -1 and the tabpage\nhas set a local path via |:tcd|, otherwise 0.\n\nTabs and windows are identified by their respective numbers,\n0 means current tab or window. Missing argument implies 0.\nThus the following are equivalent: >vim\n\techo haslocaldir()\n\techo haslocaldir(0)\n\techo haslocaldir(0, 0)\n<\t\tWith {winnr} use that window in the current tabpage.\nWith {winnr} and {tabnr} use the window in that tabpage.\n{winnr} can be the window number or the |window-ID|.\nIf {winnr} is -1 it is ignored, only the tab is resolved.\nThrow error if the arguments are invalid. |E5000| |E5001| |E5002|\n\n                Parameters: ~\n                  \226\128\162 {winnr} (`integer?`)\n                  \226\128\162 {tabnr} (`integer?`)\n\n                Return: ~\n                  (`0|1`)"}}, hasmapto = {binding = "hasmapto", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"what", "?mode", "?abbr"}, ["fnl/docstring"] = "The result is a Number, which is TRUE if there is a mapping\nthat contains {what} in somewhere in the rhs (what it is\nmapped to) and this mapping exists in one of the modes\nindicated by {mode}.\nThe arguments {what} and {mode} are strings.\nWhen {abbr} is there and it is |TRUE| use abbreviations\ninstead of mappings.  Don't forget to specify Insert and/or\nCommand-line mode.\nBoth the global mappings and the mappings local to the current\nbuffer are checked for a match.\nIf no matching mapping is found FALSE is returned.\nThe following characters are recognized in {mode}:\n\tn\tNormal mode\n\tv\tVisual and Select mode\n\tx\tVisual mode\n\ts\tSelect mode\n\to\tOperator-pending mode\n\ti\tInsert mode\n\tl\tLanguage-Argument (\"r\", \"f\", \"t\", etc.)\n\tc\tCommand-line mode\nWhen {mode} is omitted, \"nvo\" is used.\n\nThis function is useful to check if a mapping already exists\nto a function in a Vim script.  Example: >vim\n\tif !hasmapto('\\ABCdoit')\n\t   map <Leader>d \\ABCdoit\n\tendif\n<\t\tThis installs the mapping to \"\\ABCdoit\" only if there isn't\nalready a mapping to \"\\ABCdoit\".\n\n                Parameters: ~\n                  \226\128\162 {what} (`any`)\n                  \226\128\162 {mode} (`string?`)\n                  \226\128\162 {abbr} (`boolean?`)\n\n                Return: ~\n                  (`0|1`)"}}, histadd = {binding = "histadd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"history", "item"}, ["fnl/docstring"] = "Add the String {item} to the history {history} which can be\none of:\t\t\t\t\t*hist-names*\n\t\"cmd\"\t or \":\"\t  command line history\n\t\"search\" or \"/\"   search pattern history\n\t\"expr\"\t or \"=\"   typed expression history\n\t\"input\"  or \"@\"\t  input line history\n\t\"debug\"  or \">\"   debug command history\n\tempty\t\t  the current or last used history\nThe {history} string does not need to be the whole name, one\ncharacter is sufficient.\nIf {item} does already exist in the history, it will be\nshifted to become the newest entry.\nThe result is a Number: TRUE if the operation was successful,\notherwise FALSE is returned.\n\nExample: >vim\n\tcall histadd(\"input\", strftime(\"%Y %b %d\"))\n\tlet date=input(\"Enter date: \")\n<\t\tThis function is not available in the |sandbox|.\n\n                Parameters: ~\n                  \226\128\162 {history} (`string`)\n                  \226\128\162 {item} (`any`)\n\n                Return: ~\n                  (`0|1`)"}}, histdel = {binding = "histdel", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"history", "?item"}, ["fnl/docstring"] = "Clear {history}, i.e. delete all its entries.  See |hist-names|\nfor the possible values of {history}.\n\nIf the parameter {item} evaluates to a String, it is used as a\nregular expression.  All entries matching that expression will\nbe removed from the history (if there are any).\nUpper/lowercase must match, unless \"\\c\" is used |/\\c|.\nIf {item} evaluates to a Number, it will be interpreted as\nan index, see |:history-indexing|.  The respective entry will\nbe removed if it exists.\n\nThe result is TRUE for a successful operation, otherwise FALSE\nis returned.\n\nExamples:\nClear expression register history: >vim\n\tcall histdel(\"expr\")\n<\nRemove all entries starting with \"*\" from the search history: >vim\n\tcall histdel(\"/\", '^\\*')\n<\nThe following three are equivalent: >vim\n\tcall histdel(\"search\", histnr(\"search\"))\n\tcall histdel(\"search\", -1)\n\tcall histdel(\"search\", '^' .. histget(\"search\", -1) .. '$')\n<\nTo delete the last search pattern and use the last-but-one for\nthe \"n\" command and 'hlsearch': >vim\n\tcall histdel(\"search\", -1)\n\tlet @/ = histget(\"search\", -1)\n<\n\n                Parameters: ~\n                  \226\128\162 {history} (`string`)\n                  \226\128\162 {item} (`any?`)\n\n                Return: ~\n                  (`0|1`)"}}, histget = {binding = "histget", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"history", "?index"}, ["fnl/docstring"] = "The result is a String, the entry with Number {index} from\n{history}.  See |hist-names| for the possible values of\n{history}, and |:history-indexing| for {index}.  If there is\nno such entry, an empty String is returned.  When {index} is\nomitted, the most recent item from the history is used.\n\nExamples:\nRedo the second last search from history. >vim\n\texecute '/' .. histget(\"search\", -2)\n\n<\t\tDefine an Ex command \":H {num}\" that supports re-execution of\nthe {num}th entry from the output of |:history|. >vim\n\tcommand -nargs=1 H execute histget(\"cmd\", 0+<args>)\n<\n\n                Parameters: ~\n                  \226\128\162 {history} (`string`)\n                  \226\128\162 {index} (`integer|string?`)\n\n                Return: ~\n                  (`string`)"}}, histnr = {binding = "histnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"history"}, ["fnl/docstring"] = "The result is the Number of the current entry in {history}.\nSee |hist-names| for the possible values of {history}.\nIf an error occurred, -1 is returned.\n\nExample: >vim\n\tlet inp_index = histnr(\"expr\")\n<\n\n                Parameters: ~\n                  \226\128\162 {history} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, hlID = {binding = "hlID", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "The result is a Number, which is the ID of the highlight group\nwith name {name}.  When the highlight group doesn't exist,\nzero is returned.\nThis can be used to retrieve information about the highlight\ngroup.  For example, to get the background color of the\n\"Comment\" group: >vim\n\techo synIDattr(synIDtrans(hlID(\"Comment\")), \"bg\")\n<\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, hlexists = {binding = "hlexists", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "The result is a Number, which is TRUE if a highlight group\ncalled {name} exists.  This is when the group has been\ndefined in some way.  Not necessarily when highlighting has\nbeen defined for it, it may also have been used for a syntax\nitem.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, hostname = {binding = "hostname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a String, which is the name of the machine on\nwhich Vim is currently running.  Machine names greater than\n256 characters long are truncated.\n\n                Return: ~\n                  (`string`)"}}, iconv = {binding = "iconv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "from", "to"}, ["fnl/docstring"] = "The result is a String, which is the text {string} converted\nfrom encoding {from} to encoding {to}.\nWhen the conversion completely fails an empty string is\nreturned.  When some characters could not be converted they\nare replaced with \"?\".\nThe encoding names are whatever the iconv() library function\ncan accept, see \":!man 3 iconv\".\nNote that Vim uses UTF-8 for all Unicode encodings, conversion\nfrom/to UCS-2 is automatically changed to use UTF-8.  You\ncannot use UCS-2 in a string anyway, because of the NUL bytes.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {from} (`string`)\n                  \226\128\162 {to} (`string`)\n\n                Return: ~\n                  (`string`)"}}, id = {binding = "id", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Returns a |String| which is a unique identifier of the\ncontainer type (|List|, |Dict|, |Blob| and |Partial|). It is\nguaranteed that for the mentioned types `id(v1) ==# id(v2)`\nreturns true iff `type(v1) == type(v2) && v1 is v2`.\nNote that `v:_null_string`, `v:_null_list`, `v:_null_dict` and\n`v:_null_blob` have the same `id()` with different types\nbecause they are internally represented as NULL pointers.\n`id()` returns a hexadecimal representation of the pointers to\nthe containers (i.e. like `0x994a40`), same as `printf(\"%p\",\n{expr})`, but it is advised against counting on the exact\nformat of the return value.\n\nIt is not guaranteed that `id(no_longer_existing_container)`\nwill not be equal to some other `id()`: new containers may\nreuse identifiers of the garbage-collected ones.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`string`)"}}, indent = {binding = "indent", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "The result is a Number, which is indent of line {lnum} in the\ncurrent buffer.  The indent is counted in spaces, the value\nof 'tabstop' is relevant.  {lnum} is used just like in\n|getline()|.\nWhen {lnum} is invalid -1 is returned.\n\nTo get or set indent of lines in a string, see |vim.text.indent()|.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, index = {binding = "index", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object", "expr", "?start", "?ic"}, ["fnl/docstring"] = "Find {expr} in {object} and return its index.  See\n|indexof()| for using a lambda to select the item.\n\nIf {object} is a |List| return the lowest index where the item\nhas a value equal to {expr}.  There is no automatic\nconversion, so the String \"4\" is different from the Number 4.\nAnd the Number 4 is different from the Float 4.0.  The value\nof 'ignorecase' is not used here, case matters as indicated by\nthe {ic} argument.\n\nIf {object} is a |Blob| return the lowest index where the byte\nvalue is equal to {expr}.\n\nIf {start} is given then start looking at the item with index\n{start} (may be negative for an item relative to the end).\n\nWhen {ic} is given and it is |TRUE|, ignore case.  Otherwise\ncase must match.\n\n-1 is returned when {expr} is not found in {object}.\nExample: >vim\n\tlet idx = index(words, \"the\")\n\tif index(numbers, 123) >= 0\n\t  \" ...\n\tendif\n<\n\n                Parameters: ~\n                  \226\128\162 {object} (`any`)\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {start} (`integer?`)\n                  \226\128\162 {ic} (`boolean?`)\n\n                Return: ~\n                  (`integer`)"}}, indexof = {binding = "indexof", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object", "expr", "?opts"}, ["fnl/docstring"] = "Returns the index of an item in {object} where {expr} is\nv:true.  {object} must be a |List| or a |Blob|.\n\nIf {object} is a |List|, evaluate {expr} for each item in the\nList until the expression is v:true and return the index of\nthis item.\n\nIf {object} is a |Blob| evaluate {expr} for each byte in the\nBlob until the expression is v:true and return the index of\nthis byte.\n\n{expr} must be a |string| or |Funcref|.\n\nIf {expr} is a |string|: If {object} is a |List|, inside\n{expr} |v:key| has the index of the current List item and\n|v:val| has the value of the item.  If {object} is a |Blob|,\ninside {expr} |v:key| has the index of the current byte and\n|v:val| has the byte value.\n\nIf {expr} is a |Funcref| it must take two arguments:\n\0091. the key or the index of the current item.\n\0092. the value of the current item.\nThe function must return |TRUE| if the item is found and the\nsearch should stop.\n\nThe optional argument {opts} is a Dict and supports the\nfollowing items:\n    startidx\tstart evaluating {expr} at the item with this\n\t\tindex; may be negative for an item relative to\n\t\tthe end\nReturns -1 when {expr} evaluates to v:false for all the items.\nExample: >vim\n\tlet l = [#{n: 10}, #{n: 20}, #{n: 30}]\n\techo indexof(l, \"v:val.n == 20\")\n\techo indexof(l, {i, v -> v.n == 30})\n\techo indexof(l, \"v:val.n == 20\", #{startidx: 1})\n<\n\n                Parameters: ~\n                  \226\128\162 {object} (`any`)\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`integer`)"}}, input = {binding = "input", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"prompt", "?text", "?completion"}, ["fnl/docstring"] = "Parameters: ~\n  \226\128\162 {prompt} (`string`)\n  \226\128\162 {text} (`string?`)\n  \226\128\162 {completion} (`string?`)\n\nReturn: ~\n  (`string`)\n\ninput({opts})\n\t\tThe result is a String, which is whatever the user typed on\n\t\tthe command-line.  The {prompt} argument is either a prompt\n\t\tstring, or a blank string (for no prompt).  A '\\n' can be used\n\t\tin the prompt to start a new line.\n\n\t\tIn the second form it accepts a single dictionary with the\n\t\tfollowing keys, any of which may be omitted:\n\n\t\tKey           Default  Description ~\n\t\tprompt        \"\"       Same as {prompt} in the first form.\n\t\tdefault       \"\"       Same as {text} in the first form.\n\t\tcompletion    nothing  Same as {completion} in the first form.\n\t\tcancelreturn  \"\"       The value returned when the dialog is\n\t\t                       cancelled.\n\t\thighlight     nothing  Highlight handler: |Funcref|.\n\n\t\tThe highlighting set with |:echohl| is used for the prompt.\n\t\tThe input is entered just like a command-line, with the same\n\t\tediting commands and mappings.  There is a separate history\n\t\tfor lines typed for input().\n\t\tExample: >vim\n\t\t\tif input(\"Coffee or beer? \") == \"beer\"\n\t\t\t  echo \"Cheers!\"\n\t\t\tendif\n<\n\t\tIf the optional {text} argument is present and not empty, this\n\t\tis used for the default reply, as if the user typed this.\n\t\tExample: >vim\n\t\t\tlet color = input(\"Color? \", \"white\")\n\n<\t\tThe optional {completion} argument specifies the type of\n\t\tcompletion supported for the input.  Without it completion is\n\t\tnot performed.  The supported completion types are the same as\n\t\tthat can be supplied to a user-defined command using the\n\t\t\"-complete=\" argument.  Refer to |:command-completion| for\n\t\tmore information.  Example: >vim\n\t\t\tlet fname = input(\"File: \", \"\", \"file\")\n\n<\t\t\t\t\t*input()-highlight* *E5400* *E5402*\n\t\tThe optional `highlight` key allows specifying function which\n\t\twill be used for highlighting user input.  This function\n\t\treceives user input as its only argument and must return\n\t\ta list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]\n\t\twhere\n\t\t\thl_start_col is the first highlighted column,\n\t\t\thl_end_col is the last highlighted column (+ 1!),\n\t\t\thl_group is |:hi| group used for highlighting.\n\t\t\t\t\t      *E5403* *E5404* *E5405* *E5406*\n\t\tBoth hl_start_col and hl_end_col + 1 must point to the start\n\t\tof the multibyte character (highlighting must not break\n\t\tmultibyte characters), hl_end_col + 1 may be equal to the\n\t\tinput length.  Start column must be in range [0, len(input)),\n\t\tend column must be in range (hl_start_col, len(input)],\n\t\tsections must be ordered so that next hl_start_col is greater\n\t\tthen or equal to previous hl_end_col.\n\n\t\tExample (try some input with parentheses): >vim\n\t\t\thighlight RBP1 guibg=Red ctermbg=red\n\t\t\thighlight RBP2 guibg=Yellow ctermbg=yellow\n\t\t\thighlight RBP3 guibg=Green ctermbg=green\n\t\t\thighlight RBP4 guibg=Blue ctermbg=blue\n\t\t\tlet g:rainbow_levels = 4\n\t\t\tfunction! RainbowParens(cmdline)\n\t\t\t  let ret = []\n\t\t\t  let i = 0\n\t\t\t  let lvl = 0\n\t\t\t  while i < len(a:cmdline)\n\t\t\t    if a:cmdline[i] is# '('\n\t\t\t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n\t\t\t      let lvl += 1\n\t\t\t    elseif a:cmdline[i] is# ')'\n\t\t\t      let lvl -= 1\n\t\t\t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n\t\t\t    endif\n\t\t\t    let i += 1\n\t\t\t  endwhile\n\t\t\t  return ret\n\t\t\tendfunction\n\t\t\tcall input({'prompt':'>','highlight':'RainbowParens'})\n<\n\t\tHighlight function is called at least once for each new\n\t\tdisplayed input string, before command-line is redrawn.  It is\n\t\texpected that function is pure for the duration of one input()\n\t\tcall, i.e. it produces the same output for the same input, so\n\t\toutput may be memoized.  Function is run like under |:silent|\n\t\tmodifier. If the function causes any errors, it will be\n\t\tskipped for the duration of the current input() call.\n\n\t\tHighlighting is disabled if command-line contains arabic\n\t\tcharacters.\n\n\t\tNOTE: This function must not be used in a startup file, for\n\t\tthe versions that only run in GUI mode (e.g., the Win32 GUI).\n\t\tNote: When input() is called from within a mapping it will\n\t\tconsume remaining characters from that mapping, because a\n\t\tmapping is handled like the characters were typed.\n\t\tUse |inputsave()| before input() and |inputrestore()|\n\t\tafter input() to avoid that.  Another solution is to avoid\n\t\tthat further characters follow in the mapping, e.g., by using\n\t\t|:execute| or |:normal|.\n\n\t\tExample with a mapping: >vim\n\t\t\tnmap \\x :call GetFoo()<CR>:exe \"/\" .. Foo<CR>\n\t\t\tfunction GetFoo()\n\t\t\t  call inputsave()\n\t\t\t  let g:Foo = input(\"enter search pattern: \")\n\t\t\t  call inputrestore()\n\t\t\tendfunction\n<\n\nParameters: ~\n  \226\128\162 {opts} (`table`)\n\nReturn: ~\n  (`string`)"}}, inputlist = {binding = "inputlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"textlist"}, ["fnl/docstring"] = "{textlist} must be a |List| of strings.  This |List| is\ndisplayed, one string per line.  The user will be prompted to\nenter a number, which is returned.\nThe user can also select an item by clicking on it with the\nmouse, if the mouse is enabled in the command line ('mouse' is\n\"a\" or includes \"c\").  For the first string 0 is returned.\nWhen clicking above the first item a negative number is\nreturned.  When clicking on the prompt one more than the\nlength of {textlist} is returned.\nMake sure {textlist} has less than 'lines' entries, otherwise\nit won't work.  It's a good idea to put the entry number at\nthe start of the string.  And put a prompt in the first item.\nExample: >vim\n\tlet color = inputlist(['Select color:', '1. red',\n\t\t\\ '2. green', '3. blue'])\n\n                Parameters: ~\n                  \226\128\162 {textlist} (`string[]`)\n\n                Return: ~\n                  (`any`)"}}, inputrestore = {binding = "inputrestore", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Restore typeahead that was saved with a previous |inputsave()|.\nShould be called the same number of times inputsave() is\ncalled.  Calling it more often is harmless though.\nReturns TRUE when there is nothing to restore, FALSE otherwise.\n\n                Return: ~\n                  (`integer`)"}}, inputsave = {binding = "inputsave", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Preserve typeahead (also from mappings) and clear it, so that\na following prompt gets input from the user.  Should be\nfollowed by a matching inputrestore() after the prompt.  Can\nbe used several times, in which case there must be just as\nmany inputrestore() calls.\nReturns TRUE when out of memory, FALSE otherwise.\n\n                Return: ~\n                  (`integer`)"}}, inputsecret = {binding = "inputsecret", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"prompt", "?text"}, ["fnl/docstring"] = "This function acts much like the |input()| function with but\ntwo exceptions:\na) the user's response will be displayed as a sequence of\nasterisks (\"*\") thereby keeping the entry secret, and\nb) the user's response will not be recorded on the input\n|history| stack.\nThe result is a String, which is whatever the user actually\ntyped on the command-line in response to the issued prompt.\nNOTE: Command-line completion is not supported.\n\n                Parameters: ~\n                  \226\128\162 {prompt} (`string`)\n                  \226\128\162 {text} (`string?`)\n\n                Return: ~\n                  (`string`)"}}, insert = {binding = "insert", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object", "item", "?idx"}, ["fnl/docstring"] = "When {object} is a |List| or a |Blob| insert {item} at the start\nof it.\n\nIf {idx} is specified insert {item} before the item with index\n{idx}.  If {idx} is zero it goes before the first item, just\nlike omitting {idx}.  A negative {idx} is also possible, see\n|list-index|.  -1 inserts just before the last item.\n\nReturns the resulting |List| or |Blob|.  Examples: >vim\n\tlet mylist = insert([2, 3, 5], 1)\n\tcall insert(mylist, 4, -1)\n\tcall insert(mylist, 6, len(mylist))\n<\t\tThe last example can be done simpler with |add()|.\nNote that when {item} is a |List| it is inserted as a single\nitem.  Use |extend()| to concatenate |Lists|.\n\n                Parameters: ~\n                  \226\128\162 {object} (`any`)\n                  \226\128\162 {item} (`any`)\n                  \226\128\162 {idx} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, interrupt = {binding = "interrupt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Interrupt script execution.  It works more or less like the\nuser typing CTRL-C, most commands won't execute and control\nreturns to the user.  This is useful to abort execution\nfrom lower down, e.g. in an autocommand.  Example: >vim\nfunction s:check_typoname(file)\n   if fnamemodify(a:file, ':t') == '['\n       echomsg 'Maybe typo'\n       call interrupt()\n   endif\nendfunction\nau BufWritePre * call s:check_typoname(expand('<amatch>'))\n<\n\n                Return: ~\n                  (`any`)"}}, invert = {binding = "invert", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Bitwise invert.  The argument is converted to a number.  A\nList, Dict or Float argument causes an error.  Example: >vim\n\tlet bits = invert(bits)\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, isabsolutepath = {binding = "isabsolutepath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| when {path} is an\nabsolute path.\nOn Unix, a path is considered absolute when it starts with '/'.\nOn MS-Windows, it is considered absolute when it starts with an\noptional drive prefix and is followed by a '\\' or '/'. UNC paths\nare always absolute.\nExample: >vim\n\techo isabsolutepath('/usr/share/')\t\" 1\n\techo isabsolutepath('./foobar')\t\t\" 0\n\techo isabsolutepath('C:\\Windows')\t\" 1\n\techo isabsolutepath('foobar')\t\t\" 0\n\techo isabsolutepath('\\\\remote\\file')\t\" 1\n<\n\n                Parameters: ~\n                  \226\128\162 {path} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, isdirectory = {binding = "isdirectory", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"directory"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| when a directory\nwith the name {directory} exists.  If {directory} doesn't\nexist, or isn't a directory, the result is |FALSE|.  {directory}\nis any expression, which is used as a String.\n\n                Parameters: ~\n                  \226\128\162 {directory} (`string`)\n\n                Return: ~\n                  (`0|1`)"}}, isinf = {binding = "isinf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return 1 if {expr} is a positive infinity, or -1 a negative\ninfinity, otherwise 0. >vim\n\techo isinf(1.0 / 0.0)\n<\t\t\0091 >vim\n\techo isinf(-1.0 / 0.0)\n<\t\t\t-1\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`1|0|-1`)"}}, islocked = {binding = "islocked", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "The result is a Number, which is |TRUE| when {expr} is the\nname of a locked variable.\nThe string argument {expr} must be the name of a variable,\n|List| item or |Dictionary| entry, not the variable itself!\nExample: >vim\n\tlet alist = [0, ['a', 'b'], 2, 3]\n\tlockvar 1 alist\n\techo islocked('alist')\t\t\" 1\n\techo islocked('alist[1]')\t\" 0\n\n<\t\tWhen {expr} is a variable that does not exist you get an error\nmessage.  Use |exists()| to check for existence.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`0|1`)"}}, isnan = {binding = "isnan", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return |TRUE| if {expr} is a float with value NaN. >vim\n\techo isnan(0.0 / 0.0)\n<\t\t\0091\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`0|1`)"}}, items = {binding = "items", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Return a |List| with all the key-value pairs of {dict}.  Each\n|List| item is a list with two items: the key of a {dict}\nentry and the value of this entry.  The |List| is in arbitrary\norder.  Also see |keys()| and |values()|.\nExample: >vim\n\tfor [key, value] in items(mydict)\n\t   echo key .. ': ' .. value\n\tendfor\n<\nA List or a String argument is also supported.  In these\ncases, items() returns a List with the index and the value at\nthe index.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`table`)\n\n                Return: ~\n                  (`any`)"}}, jobpid = {binding = "jobpid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"job"}, ["fnl/docstring"] = "Return the PID (process id) of |job-id| {job}.\n\n                Parameters: ~\n                  \226\128\162 {job} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, jobresize = {binding = "jobresize", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"job", "width", "height"}, ["fnl/docstring"] = "Resize the pseudo terminal window of |job-id| {job} to {width}\ncolumns and {height} rows.\nFails if the job was not started with `\"pty\":v:true`.\n\n                Parameters: ~\n                  \226\128\162 {job} (`integer`)\n                  \226\128\162 {width} (`integer`)\n                  \226\128\162 {height} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, jobstart = {binding = "jobstart", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "?opts"}, ["fnl/docstring"] = "Note: Prefer |vim.system()| in Lua (unless using `rpc`, `pty`, or `term`).\n\nSpawns {cmd} as a job.\nIf {cmd} is a List it runs directly (no 'shell').\nIf {cmd} is a String it runs in the 'shell', like this: >vim\n  call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n<\t\t(See |shell-unquoting| for details.)\n\nExample: start a job and handle its output: >vim\n  call jobstart(['nvim', '-h'], {'on_stdout':{j,d,e->append(line('.'),d)}})\n<\nExample: start a job in a |terminal| connected to the current buffer: >vim\n  call jobstart(['nvim', '-h'], {'term':v:true})\n<\nReturns |job-id| on success, 0 on invalid arguments (or job\ntable is full), -1 if {cmd}[0] or 'shell' is not executable.\nThe returned job-id is a valid |channel-id| representing the\njob's stdio streams. Use |chansend()| (or |rpcnotify()| and\n|rpcrequest()| if \"rpc\" was enabled) to send data to stdin and\n|chanclose()| to close the streams without stopping the job.\n\nSee |job-control| and |RPC|.\n\nNOTE: on Windows if {cmd} is a List:\n  - cmd[0] must be an executable (not a \"built-in\"). If it is\n    in $PATH it can be called by name, without an extension: >vim\n      call jobstart(['ping', 'neovim.io'])\n<\t\t    If it is a full or partial path, extension is required: >vim\n      call jobstart(['System32\\ping.exe', 'neovim.io'])\n<\t\t  - {cmd} is collapsed to a string of quoted args as expected\n    by CommandLineToArgvW https://msdn.microsoft.com/bb776391\n    unless cmd[0] is some form of \"cmd.exe\".\n\n\t\t\t\t\t*jobstart-env*\nThe job environment is initialized as follows:\n  $NVIM                is set to |v:servername| of the parent Nvim\n  $NVIM_LISTEN_ADDRESS is unset\n  $NVIM_LOG_FILE       is unset\n  $VIM                 is unset\n  $VIMRUNTIME          is unset\nYou can set these with the `env` option.\n\n\t\t\t\t\t*jobstart-options*\n{opts} is a dictionary with these keys:\n  clear_env:  (boolean) `env` defines the job environment\n\t      exactly, instead of merging current environment.\n  cwd:\t      (string, default=|current-directory|) Working\n\t      directory of the job.\n  detach:     (boolean) Detach the job process: it will not be\n\t      killed when Nvim exits. If the process exits\n\t      before Nvim, `on_exit` will be invoked.\n  env:\t      (dict) Map of environment variable name:value\n\t      pairs extending (or replace with \"clear_env\")\n\t      the current environment. |jobstart-env|\n  height:     (number) Height of the `pty` terminal.\n  |on_exit|:    (function) Callback invoked when the job exits.\n  |on_stdout|:  (function) Callback invoked when the job emits\n\t      stdout data.\n  |on_stderr|:  (function) Callback invoked when the job emits\n\t      stderr data.\n  overlapped: (boolean) Sets FILE_FLAG_OVERLAPPED for the\n\t      stdio passed to the child process. Only on\n\t      MS-Windows; ignored on other platforms.\n  pty:\t      (boolean) Connect the job to a new pseudo\n\t      terminal, and its streams to the master file\n\t      descriptor. `on_stdout` receives all output,\n\t      `on_stderr` is ignored. |terminal-start|\n  rpc:\t      (boolean) Use |msgpack-rpc| to communicate with\n\t      the job over stdio. Then `on_stdout` is ignored,\n\t      but `on_stderr` can still be used.\n  stderr_buffered: (boolean) Collect data until EOF (stream closed)\n\t      before invoking `on_stderr`. |channel-buffered|\n  stdout_buffered: (boolean) Collect data until EOF (stream\n\t      closed) before invoking `on_stdout`. |channel-buffered|\n  stdin:      (string) Either \"pipe\" (default) to connect the\n\t      job's stdin to a channel or \"null\" to disconnect\n\t      stdin.\n  term:\t    (boolean) Spawns {cmd} in a new pseudo-terminal session\n          connected to the current (unmodified) buffer. Implies \"pty\".\n          Default \"height\" and \"width\" are set to the current window\n          dimensions. |jobstart()|. Defaults $TERM to \"xterm-256color\".\n  width:      (number) Width of the `pty` terminal.\n\n{opts} is passed as |self| dictionary to the callback; the\ncaller may set other keys to pass application-specific data.\n\nReturns:\n  - |channel-id| on success\n  - 0 on invalid arguments\n  - -1 if {cmd}[0] is not executable.\nSee also |job-control|, |channel|, |msgpack-rpc|.\n\n                Parameters: ~\n                  \226\128\162 {cmd} (`string|string[]`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`integer`)"}}, jobstop = {binding = "jobstop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id"}, ["fnl/docstring"] = "Stop |job-id| {id} by sending SIGTERM to the job process. If\nthe process does not terminate after a timeout then SIGKILL\nwill be sent. When the job terminates its |on_exit| handler\n(if any) will be invoked.\nSee |job-control|.\n\nReturns 1 for valid job id, 0 for invalid id, including jobs have\nexited or stopped.\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, jobwait = {binding = "jobwait", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"jobs", "?timeout"}, ["fnl/docstring"] = "Waits for jobs and their |on_exit| handlers to complete.\n\n{jobs} is a List of |job-id|s to wait for.\n{timeout} is the maximum waiting time in milliseconds. If\nomitted or -1, wait forever.\n\nTimeout of 0 can be used to check the status of a job: >vim\n\tlet running = jobwait([{job-id}], 0)[0] == -1\n<\nDuring jobwait() callbacks for jobs not in the {jobs} list may\nbe invoked. The screen will not redraw unless |:redraw| is\ninvoked by a callback.\n\nReturns a list of len({jobs}) integers, where each integer is\nthe status of the corresponding job:\n\tExit-code, if the job exited\n\t-1 if the timeout was exceeded\n\t-2 if the job was interrupted (by |CTRL-C|)\n\t-3 if the job-id is invalid\n\n                Parameters: ~\n                  \226\128\162 {jobs} (`integer[]`)\n                  \226\128\162 {timeout} (`integer?`)\n\n                Return: ~\n                  (`integer[]`)"}}, join = {binding = "join", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?sep"}, ["fnl/docstring"] = "Join the items in {list} together into one String.\nWhen {sep} is specified it is put in between the items.  If\n{sep} is omitted a single space is used.\nNote that {sep} is not added at the end.  You might want to\nadd it there too: >vim\n\tlet lines = join(mylist, \"\\n\") .. \"\\n\"\n<\t\tString items are used as-is.  |Lists| and |Dictionaries| are\nconverted into a string like with |string()|.\nThe opposite function is |split()|.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {sep} (`string?`)\n\n                Return: ~\n                  (`string`)"}}, json_decode = {binding = "json_decode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Convert {expr} from JSON object.  Accepts |readfile()|-style\nlist as the input, as well as regular string.  May output any\nVim value. In the following cases it will output\n|msgpack-special-dict|:\n1. Dictionary contains duplicate key.\n2. String contains NUL byte.  Two special dictionaries: for\n   dictionary and for string will be emitted in case string\n   with NUL byte was a dictionary key.\n\nNote: function treats its input as UTF-8 always.  The JSON\nstandard allows only a few encodings, of which UTF-8 is\nrecommended and the only one required to be supported.\nNon-UTF-8 characters are an error.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`)"}}, json_encode = {binding = "json_encode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Convert {expr} into a JSON string.  Accepts\n|msgpack-special-dict| as the input.  Will not convert\n|Funcref|s, mappings with non-string keys (can be created as\n|msgpack-special-dict|), values with self-referencing\ncontainers, strings which contain non-UTF-8 characters,\npseudo-UTF-8 strings which contain codepoints reserved for\nsurrogate pairs (such strings are not valid UTF-8 strings).\nNon-printable characters are converted into \"\\u1234\" escapes\nor special escapes like \"\\t\", other are dumped as-is.\n|Blob|s are converted to arrays of the individual bytes.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`string`)"}}, keys = {binding = "keys", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Return a |List| with all the keys of {dict}.  The |List| is in\narbitrary order.  Also see |items()| and |values()|.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`table`)\n\n                Return: ~\n                  (`string[]`)"}}, keytrans = {binding = "keytrans", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Turn the internal byte representation of keys into a form that\ncan be used for |:map|.  E.g. >vim\n\tlet xx = \"\\<C-Home>\"\n\techo keytrans(xx)\n<\t\t\t<C-Home>\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`string`)"}}, len = {binding = "len", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "The result is a Number, which is the length of the argument.\nWhen {expr} is a String or a Number the length in bytes is\nused, as with |strlen()|.\nWhen {expr} is a |List| the number of items in the |List| is\nreturned.\nWhen {expr} is a |Blob| the number of bytes is returned.\nWhen {expr} is a |Dictionary| the number of entries in the\n|Dictionary| is returned.\nOtherwise an error is given and returns zero.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any[]`)\n\n                Return: ~\n                  (`integer`)"}}, libcall = {binding = "libcall", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"libname", "funcname", "argument"}, ["fnl/docstring"] = "Call function {funcname} in the run-time library {libname}\nwith single argument {argument}.\nThis is useful to call functions in a library that you\nespecially made to be used with Vim.  Since only one argument\nis possible, calling standard library functions is rather\nlimited.\nThe result is the String returned by the function.  If the\nfunction returns NULL, this will appear as an empty string \"\"\nto Vim.\nIf the function returns a number, use libcallnr()!\nIf {argument} is a number, it is passed to the function as an\nint; if {argument} is a string, it is passed as a\nnull-terminated string.\n\nlibcall() allows you to write your own 'plug-in' extensions to\nVim without having to recompile the program.  It is NOT a\nmeans to call system functions!  If you try to do so Vim will\nvery probably crash.\n\nFor Win32, the functions you write must be placed in a DLL\nand use the normal C calling convention (NOT Pascal which is\nused in Windows System DLLs).  The function must take exactly\none parameter, either a character pointer or a long integer,\nand must return a character pointer or NULL.  The character\npointer returned must point to memory that will remain valid\nafter the function has returned (e.g. in static data in the\nDLL).  If it points to allocated memory, that memory will\nleak away.  Using a static buffer in the function should work,\nit's then freed when the DLL is unloaded.\n\nWARNING: If the function returns a non-valid pointer, Vim may\ncrash!\tThis also happens if the function returns a number,\nbecause Vim thinks it's a pointer.\nFor Win32 systems, {libname} should be the filename of the DLL\nwithout the \".DLL\" suffix.  A full path is only required if\nthe DLL is not in the usual places.\nFor Unix: When compiling your own plugins, remember that the\nobject code must be compiled as position-independent ('PIC').\nExamples: >vim\n\techo libcall(\"libc.so\", \"getenv\", \"HOME\")\n\n                Parameters: ~\n                  \226\128\162 {libname} (`string`)\n                  \226\128\162 {funcname} (`string`)\n                  \226\128\162 {argument} (`any`)\n\n                Return: ~\n                  (`any`)"}}, libcallnr = {binding = "libcallnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"libname", "funcname", "argument"}, ["fnl/docstring"] = "Just like |libcall()|, but used for a function that returns an\nint instead of a string.\nExamples: >vim\n\techo libcallnr(\"/usr/lib/libc.so\", \"getpid\", \"\")\n\tcall libcallnr(\"libc.so\", \"printf\", \"Hello World!\\n\")\n\tcall libcallnr(\"libc.so\", \"sleep\", 10)\n<\n\n                Parameters: ~\n                  \226\128\162 {libname} (`string`)\n                  \226\128\162 {funcname} (`string`)\n                  \226\128\162 {argument} (`any`)\n\n                Return: ~\n                  (`any`)"}}, line = {binding = "line", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?winid"}, ["fnl/docstring"] = "See |getpos()| for accepted positions.\n\nTo get the column number use |col()|.  To get both use\n|getpos()|.\n\nWith the optional {winid} argument the values are obtained for\nthat window instead of the current window.\n\nReturns 0 for invalid values of {expr} and {winid}.\n\nExamples: >vim\n\techo line(\".\")\t\t\t\" line number of the cursor\n\techo line(\".\", winid)\t\t\" idem, in window \"winid\"\n\techo line(\"'t\")\t\t\t\" line number of mark t\n\techo line(\"'\" .. marker)\t\" line number of mark marker\n<\nTo jump to the last known position when opening a file see\n|last-position-jump|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string|integer[]`)\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, line2byte = {binding = "line2byte", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Return the byte count from the start of the buffer for line\n{lnum}.  This includes the end-of-line character, depending on\nthe 'fileformat' option for the current buffer.  The first\nline returns 1. UTF-8 encoding is used, 'fileencoding' is\nignored.  This can also be used to get the byte count for the\nline just below the last line: >vim\n\techo line2byte(line(\"$\") + 1)\n<\t\tThis is the buffer size plus one.  If 'fileencoding' is empty\nit is the file size plus one.  {lnum} is used like with\n|getline()|.  When {lnum} is invalid -1 is returned.\nAlso see |byte2line()|, |go| and |:goto|.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, lispindent = {binding = "lispindent", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Get the amount of indent for line {lnum} according the lisp\nindenting rules, as with 'lisp'.\nThe indent is counted in spaces, the value of 'tabstop' is\nrelevant.  {lnum} is used just like in |getline()|.\nWhen {lnum} is invalid, -1 is returned.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, list2blob = {binding = "list2blob", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Return a Blob concatenating all the number values in {list}.\nExamples: >vim\n\techo list2blob([1, 2, 3, 4])\t\" returns 0z01020304\n\techo list2blob([])\t\t\" returns 0z\n<\t\tReturns an empty Blob on error.  If one of the numbers is\nnegative or more than 255 error *E1239* is given.\n\n|blob2list()| does the opposite.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n\n                Return: ~\n                  (`string`)"}}, list2str = {binding = "list2str", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?utf8"}, ["fnl/docstring"] = "Convert each number in {list} to a character string can\nconcatenate them all.  Examples: >vim\n\techo list2str([32])\t\t\" returns \" \"\n\techo list2str([65, 66, 67])\t\" returns \"ABC\"\n<\t\tThe same can be done (slowly) with: >vim\n\techo join(map(list, {nr, val -> nr2char(val)}), '')\n<\t\t|str2list()| does the opposite.\n\nUTF-8 encoding is always used, {utf8} option has no effect,\nand exists only for backwards-compatibility.\nWith UTF-8 composing characters work as expected: >vim\n\techo list2str([97, 769])\t\" returns \"a\204\129\"\n<\nReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {utf8} (`boolean?`)\n\n                Return: ~\n                  (`string`)"}}, localtime = {binding = "localtime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Return the current time, measured as seconds since 1st Jan\n1970.  See also |strftime()|, |strptime()| and |getftime()|.\n\n                Return: ~\n                  (`integer`)"}}, log = {binding = "log", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the natural logarithm (base e) of {expr} as a |Float|.\n{expr} must evaluate to a |Float| or a |Number| in the range\n(0, inf].\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo log(10)\n<\t\t\0092.302585 >vim\n\techo log(exp(5))\n<\t\t\0095.0\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, log10 = {binding = "log10", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the logarithm of Float {expr} to base 10 as a |Float|.\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo log10(1000)\n<\t\t\0093.0 >vim\n\techo log10(0.01)\n<\t\t\t-2.0\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, luaeval = {binding = "luaeval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?expr1"}, ["fnl/docstring"] = "Evaluate Lua expression {expr} and return its result converted\nto Vim data structures. See |lua-eval| for details.\n\nSee also |v:lua-call|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n                  \226\128\162 {expr1} (`any[]?`)\n\n                Return: ~\n                  (`any`)"}}, map = {binding = "map", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2"}, ["fnl/docstring"] = "{expr1} must be a |List|, |String|, |Blob| or |Dictionary|.\nWhen {expr1} is a |List| or |Dictionary|, replace each\nitem in {expr1} with the result of evaluating {expr2}.\nFor a |Blob| each byte is replaced.\nFor a |String|, each character, including composing\ncharacters, is replaced.\nIf the item type changes you may want to use |mapnew()| to\ncreate a new List or Dictionary.\n\n{expr2} must be a |String| or |Funcref|.\n\nIf {expr2} is a |String|, inside {expr2} |v:val| has the value\nof the current item.  For a |Dictionary| |v:key| has the key\nof the current item and for a |List| |v:key| has the index of\nthe current item.  For a |Blob| |v:key| has the index of the\ncurrent byte. For a |String| |v:key| has the index of the\ncurrent character.\nExample: >vim\n\tcall map(mylist, '\"> \" .. v:val .. \" <\"')\n<\t\tThis puts \"> \" before and \" <\" after each item in \"mylist\".\n\nNote that {expr2} is the result of an expression and is then\nused as an expression again.  Often it is good to use a\n|literal-string| to avoid having to double backslashes.  You\nstill have to double ' quotes\n\nIf {expr2} is a |Funcref| it is called with two arguments:\n\0091. The key or the index of the current item.\n\0092. the value of the current item.\nThe function must return the new value of the item. Example\nthat changes each value by \"key-value\": >vim\n\tfunc KeyValue(key, val)\n\t  return a:key .. '-' .. a:val\n\tendfunc\n\tcall map(myDict, function('KeyValue'))\n<\t\tIt is shorter when using a |lambda|: >vim\n\tcall map(myDict, {key, val -> key .. '-' .. val})\n<\t\tIf you do not use \"val\" you can leave it out: >vim\n\tcall map(myDict, {key -> 'item: ' .. key})\n<\t\tIf you do not use \"key\" you can use a short name: >vim\n\tcall map(myDict, {_, val -> 'item: ' .. val})\n<\nThe operation is done in-place for a |List| and |Dictionary|.\nIf you want it to remain unmodified make a copy first: >vim\n\tlet tlist = map(copy(mylist), ' v:val .. \"\\t\"')\n\n<\t\tReturns {expr1}, the |List| or |Dictionary| that was filtered,\nor a new |Blob| or |String|.\nWhen an error is encountered while evaluating {expr2} no\nfurther items in {expr1} are processed.\nWhen {expr2} is a Funcref errors inside a function are ignored,\nunless it was defined with the \"abort\" flag.\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`string|table|any[]`)\n                  \226\128\162 {expr2} (`string|function`)\n\n                Return: ~\n                  (`any`)"}}, maparg = {binding = "maparg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?mode", "?abbr", "?dict"}, ["fnl/docstring"] = "When {dict} is omitted or zero: Return the rhs of mapping\n{name} in mode {mode}.  The returned String has special\ncharacters translated like in the output of the \":map\" command\nlisting. When {dict} is TRUE a dictionary is returned, see\nbelow. To get a list of all mappings see |maplist()|.\n\nWhen there is no mapping for {name}, an empty String is\nreturned if {dict} is FALSE, otherwise returns an empty Dict.\nWhen the mapping for {name} is empty, then \"<Nop>\" is\nreturned.\n\nThe {name} can have special key names, like in the \":map\"\ncommand.\n\n{mode} can be one of these strings:\n\t\"n\"\tNormal\n\t\"v\"\tVisual (including Select)\n\t\"o\"\tOperator-pending\n\t\"i\"\tInsert\n\t\"c\"\tCmd-line\n\t\"s\"\tSelect\n\t\"x\"\tVisual\n\t\"l\"\tlangmap |language-mapping|\n\t\"t\"\tTerminal\n\t\"\"\tNormal, Visual and Operator-pending\nWhen {mode} is omitted, the modes for \"\" are used.\n\nWhen {abbr} is there and it is |TRUE| use abbreviations\ninstead of mappings.\n\nWhen {dict} is |TRUE|, return a dictionary describing the\nmapping, with these items:\t\t*mapping-dict*\n  \"lhs\"\t     The {lhs} of the mapping as it would be typed\n  \"lhsraw\"   The {lhs} of the mapping as raw bytes\n  \"lhsrawalt\" The {lhs} of the mapping as raw bytes, alternate\n\t      form, only present when it differs from \"lhsraw\"\n  \"rhs\"\t     The {rhs} of the mapping as typed.\n  \"callback\" Lua function, if RHS was defined as such.\n  \"silent\"   1 for a |:map-silent| mapping, else 0.\n  \"noremap\"  1 if the {rhs} of the mapping is not remappable.\n  \"script\"   1 if mapping was defined with <script>.\n  \"expr\"     1 for an expression mapping (|:map-<expr>|).\n  \"buffer\"   1 for a buffer local mapping (|:map-local|).\n  \"mode\"     Modes for which the mapping is defined. In\n\t     addition to the modes mentioned above, these\n\t     characters will be used:\n\t     \" \"     Normal, Visual and Operator-pending\n\t     \"!\"     Insert and Commandline mode\n\t\t     (|mapmode-ic|)\n  \"sid\"\t     The script local ID, used for <sid> mappings\n\t     (|<SID>|).  Negative for special contexts.\n  \"scriptversion\"  The version of the script, always 1.\n  \"lnum\"     The line number in \"sid\", zero if unknown.\n  \"nowait\"   Do not wait for other, longer mappings.\n\t     (|:map-<nowait>|).\n  \"abbr\"     True if this is an |abbreviation|.\n  \"mode_bits\" Nvim's internal binary representation of \"mode\".\n\t     |mapset()| ignores this; only \"mode\" is used.\n\t     See |maplist()| for usage examples. The values\n\t     are from src/nvim/state_defs.h and may change in\n\t     the future.\n\nThe dictionary can be used to restore a mapping with\n|mapset()|.\n\nThe mappings local to the current buffer are checked first,\nthen the global mappings.\nThis function can be used to map a key even when it's already\nmapped, and have it do the original mapping too.  Sketch: >vim\n\texe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')\n<\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {mode} (`string?`)\n                  \226\128\162 {abbr} (`boolean?`)\n                  \226\128\162 {dict} (`false?`)\n\n                Return: ~\n                  (`string`)"}}, mapcheck = {binding = "mapcheck", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?mode", "?abbr"}, ["fnl/docstring"] = "Check if there is a mapping that matches with {name} in mode\n{mode}.  See |maparg()| for {mode} and special names in\n{name}.\nWhen {abbr} is there and it is non-zero use abbreviations\ninstead of mappings.\nA match happens with a mapping that starts with {name} and\nwith a mapping which is equal to the start of {name}.\n\n\tmatches mapping \"a\"\t\"ab\"\t\"abc\" ~\n   mapcheck(\"a\")\tyes\tyes\t yes\n   mapcheck(\"abc\")\tyes\tyes\t yes\n   mapcheck(\"ax\")\tyes\tno\t no\n   mapcheck(\"b\")\tno\tno\t no\n\nThe difference with maparg() is that mapcheck() finds a\nmapping that matches with {name}, while maparg() only finds a\nmapping for {name} exactly.\nWhen there is no mapping that starts with {name}, an empty\nString is returned.  If there is one, the RHS of that mapping\nis returned.  If there are several mappings that start with\n{name}, the RHS of one of them is returned.  This will be\n\"<Nop>\" if the RHS is empty.\nThe mappings local to the current buffer are checked first,\nthen the global mappings.\nThis function can be used to check if a mapping can be added\nwithout being ambiguous.  Example: >vim\n\tif mapcheck(\"_vv\") == \"\"\n\t   map _vv :set guifont=7x13<CR>\n\tendif\n<\t\tThis avoids adding the \"_vv\" mapping when there already is a\nmapping for \"_v\" or for \"_vvv\".\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {mode} (`string?`)\n                  \226\128\162 {abbr} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, maplist = {binding = "maplist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?abbr"}, ["fnl/docstring"] = "Returns a |List| of all mappings.  Each List item is a |Dict|,\nthe same as what is returned by |maparg()|, see\n|mapping-dict|.  When {abbr} is there and it is |TRUE| use\nabbreviations instead of mappings.\n\nExample to show all mappings with \"MultiMatch\" in rhs: >vim\n\techo maplist()->filter({_, m ->\n\t\t\\ match(get(m, 'rhs', ''), 'MultiMatch') >= 0\n\t\t\\ })\n<\t\tIt can be tricky to find mappings for particular |:map-modes|.\n|mapping-dict|'s \"mode_bits\" can simplify this. For example,\nthe mode_bits for Normal, Insert or Command-line modes are\n0x19. To find all the mappings available in those modes you\ncan do: >vim\n\tlet saved_maps = []\n\tfor m in maplist()\n\t    if and(m.mode_bits, 0x19) != 0\n\t\teval saved_maps->add(m)\n\t    endif\n\tendfor\n\techo saved_maps->mapnew({_, m -> m.lhs})\n<\t\tThe values of the mode_bits are defined in Nvim's\nsrc/nvim/state_defs.h file and they can be discovered at\nruntime using |:map-commands| and \"maplist()\". Example: >vim\n\tomap xyzzy <Nop>\n\tlet op_bit = maplist()->filter(\n\t    \\ {_, m -> m.lhs == 'xyzzy'})[0].mode_bits\n\tounmap xyzzy\n\techo printf(\"Operator-pending mode bit: 0x%x\", op_bit)\n<\n\n                Parameters: ~\n                  \226\128\162 {abbr} (`0|1?`)\n\n                Return: ~\n                  (`table[]`)"}}, mapnew = {binding = "mapnew", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr1", "expr2"}, ["fnl/docstring"] = "Like |map()| but instead of replacing items in {expr1} a new\nList or Dictionary is created and returned.  {expr1} remains\nunchanged.  Items can still be changed by {expr2}, if you\ndon't want that use |deepcopy()| first.\n\n                Parameters: ~\n                  \226\128\162 {expr1} (`any`)\n                  \226\128\162 {expr2} (`any`)\n\n                Return: ~\n                  (`any`)"}}, mapset = {binding = "mapset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Restore a mapping from a dictionary, possibly returned by\n|maparg()| or |maplist()|.  A buffer mapping, when dict.buffer\nis true, is set on the current buffer; it is up to the caller\nto ensure that the intended buffer is the current buffer. This\nfeature allows copying mappings from one buffer to another.\nThe dict.mode value may restore a single mapping that covers\nmore than one mode, like with mode values of '!', ' ', \"nox\",\nor 'v'. *E1276*\n\nIn the first form, {mode} and {abbr} should be the same as\nfor the call to |maparg()|. *E460*\n{mode} is used to define the mode in which the mapping is set,\nnot the \"mode\" entry in {dict}.\nExample for saving and restoring a mapping: >vim\n\tlet save_map = maparg('K', 'n', 0, 1)\n\tnnoremap K somethingelse\n\t\" ...\n\tcall mapset('n', 0, save_map)\n<\t\tNote that if you are going to replace a map in several modes,\ne.g. with `:map!`, you need to save/restore the mapping for\nall of them, when they might differ.\n\nIn the second form, with {dict} as the only argument, mode\nand abbr are taken from the dict.\nExample: >vim\n\tlet save_maps = maplist()->filter(\n\t\t\t\t\\ {_, m -> m.lhs == 'K'})\n\tnnoremap K somethingelse\n\tcnoremap K somethingelse2\n\t\" ...\n\tunmap K\n\tfor d in save_maps\n\t    call mapset(d)\n\tendfor\n<\n\n                Parameters: ~\n                  \226\128\162 {dict} (`table<string,any>`)\n\n                Return: ~\n                  (`any`)"}}, match = {binding = "match", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "pat", "?start", "?count"}, ["fnl/docstring"] = "When {expr} is a |List| then this returns the index of the\nfirst item where {pat} matches.  Each item is used as a\nString, |Lists| and |Dictionaries| are used as echoed.\n\nOtherwise, {expr} is used as a String.  The result is a\nNumber, which gives the index (byte offset) in {expr} where\n{pat} matches.\n\nA match at the first character or |List| item returns zero.\nIf there is no match -1 is returned.\n\nFor getting submatches see |matchlist()|.\nExample: >vim\n\techo match(\"testing\", \"ing\")\t\" results in 4\n\techo match([1, 'x'], '\\a')\t\" results in 1\n<\t\tSee |string-match| for how {pat} is used.\n\t\t\t\t\t\t*strpbrk()*\nVim doesn't have a strpbrk() function.  But you can do: >vim\n\tlet sepidx = match(line, '[.,;: \\t]')\n<\t\t\t\t\t\t\t\t*strcasestr()*\nVim doesn't have a strcasestr() function.  But you can add\n\"\\c\" to the pattern to ignore case: >vim\n\tlet idx = match(haystack, '\\cneedle')\n<\nIf {start} is given, the search starts from byte index\n{start} in a String or item {start} in a |List|.\nThe result, however, is still the index counted from the\nfirst character/item.  Example: >vim\n\techo match(\"testing\", \"ing\", 2)\n<\t\tresult is again \"4\". >vim\n\techo match(\"testing\", \"ing\", 4)\n<\t\tresult is again \"4\". >vim\n\techo match(\"testing\", \"t\", 2)\n<\t\tresult is \"3\".\nFor a String, if {start} > 0 then it is like the string starts\n{start} bytes later, thus \"^\" will match at {start}.  Except\nwhen {count} is given, then it's like matches before the\n{start} byte are ignored (this is a bit complicated to keep it\nbackwards compatible).\nFor a String, if {start} < 0, it will be set to 0.  For a list\nthe index is counted from the end.\nIf {start} is out of range ({start} > strlen({expr}) for a\nString or {start} > len({expr}) for a |List|) -1 is returned.\n\nWhen {count} is given use the {count}th match.  When a match\nis found in a String the search for the next one starts one\ncharacter further.  Thus this example results in 1: >vim\n\techo match(\"testing\", \"..\", 0, 2)\n<\t\tIn a |List| the search continues in the next item.\nNote that when {count} is added the way {start} works changes,\nsee above.\n\n\t\t\t\t*match-pattern*\nSee |pattern| for the patterns that are accepted.\nThe 'ignorecase' option is used to set the ignore-caseness of\nthe pattern.  'smartcase' is NOT used.  The matching is always\ndone like 'magic' is set and 'cpoptions' is empty.\nNote that a match at the start is preferred, thus when the\npattern is using \"*\" (any number of matches) it tends to find\nzero matches at the start instead of a number of matches\nfurther down in the text.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string|any[]`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {start} (`integer?`)\n                  \226\128\162 {count} (`integer?`)\n\n                Return: ~\n                  (`any`)\n\n                                                "}}, matchadd = {binding = "matchadd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"group", "pattern", "?priority", "?id", "?dict"}, ["fnl/docstring"] = "Defines a pattern to be highlighted in the current window (a\n\"match\").  It will be highlighted with {group}.  Returns an\nidentification number (ID), which can be used to delete the\nmatch using |matchdelete()|.  The ID is bound to the window.\nMatching is case sensitive and magic, unless case sensitivity\nor magicness are explicitly overridden in {pattern}.  The\n'magic', 'smartcase' and 'ignorecase' options are not used.\nThe \"Conceal\" value is special, it causes the match to be\nconcealed.\n\nThe optional {priority} argument assigns a priority to the\nmatch.  A match with a high priority will have its\nhighlighting overrule that of a match with a lower priority.\nA priority is specified as an integer (negative numbers are no\nexception).  If the {priority} argument is not specified, the\ndefault priority is 10.  The priority of 'hlsearch' is zero,\nhence all matches with a priority greater than zero will\noverrule it.  Syntax highlighting (see 'syntax') is a separate\nmechanism, and regardless of the chosen priority a match will\nalways overrule syntax highlighting.\n\nThe optional {id} argument allows the request for a specific\nmatch ID.  If a specified ID is already taken, an error\nmessage will appear and the match will not be added.  An ID\nis specified as a positive integer (zero excluded).  IDs 1, 2\nand 3 are reserved for |:match|, |:2match| and |:3match|,\nrespectively.  3 is reserved for use by the |matchparen|\nplugin.\nIf the {id} argument is not specified or -1, |matchadd()|\nautomatically chooses a free ID, which is at least 1000.\n\nThe optional {dict} argument allows for further custom\nvalues. Currently this is used to specify a match specific\nconceal character that will be shown for |hl-Conceal|\nhighlighted matches. The dict can have the following members:\n\n\tconceal\t    Special character to show instead of the\n\t\t    match (only for |hl-Conceal| highlighted\n\t\t    matches, see |:syn-cchar|)\n\twindow\t    Instead of the current window use the\n\t\t    window with this number or window ID.\n\nThe number of matches is not limited, as it is the case with\nthe |:match| commands.\n\nReturns -1 on error.\n\nExample: >vim\n\thighlight MyGroup ctermbg=green guibg=green\n\tlet m = matchadd(\"MyGroup\", \"TODO\")\n<\t\tDeletion of the pattern: >vim\n\tcall matchdelete(m)\n\n<\t\tA list of matches defined by |matchadd()| and |:match| are\navailable from |getmatches()|.  All matches can be deleted in\none operation by |clearmatches()|.\n\n                Parameters: ~\n                  \226\128\162 {group} (`integer|string`)\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {priority} (`integer?`)\n                  \226\128\162 {id} (`integer?`)\n                  \226\128\162 {dict} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, matchaddpos = {binding = "matchaddpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"group", "pos", "?priority", "?id", "?dict"}, ["fnl/docstring"] = "Same as |matchadd()|, but requires a list of positions {pos}\ninstead of a pattern. This command is faster than |matchadd()|\nbecause it does not handle regular expressions and it sets\nbuffer line boundaries to redraw screen. It is supposed to be\nused when fast match additions and deletions are required, for\nexample to highlight matching parentheses.\n\t\t\t\t\t*E5030* *E5031*\n{pos} is a list of positions.  Each position can be one of\nthese:\n- A number.  This whole line will be highlighted.  The first\n  line has number 1.\n- A list with one number, e.g., [23]. The whole line with this\n  number will be highlighted.\n- A list with two numbers, e.g., [23, 11]. The first number is\n  the line number, the second one is the column number (first\n  column is 1, the value must correspond to the byte index as\n  |col()| would return).  The character at this position will\n  be highlighted.\n- A list with three numbers, e.g., [23, 11, 3]. As above, but\n  the third number gives the length of the highlight in bytes.\n\nEntries with zero and negative line numbers are silently\nignored, as well as entries with negative column numbers and\nlengths.\n\nReturns -1 on error.\n\nExample: >vim\n\thighlight MyGroup ctermbg=green guibg=green\n\tlet m = matchaddpos(\"MyGroup\", [[23, 24], 34])\n<\t\tDeletion of the pattern: >vim\n\tcall matchdelete(m)\n\n<\t\tMatches added by |matchaddpos()| are returned by\n|getmatches()|.\n\n                Parameters: ~\n                  \226\128\162 {group} (`integer|string`)\n                  \226\128\162 {pos} (`any[]`)\n                  \226\128\162 {priority} (`integer?`)\n                  \226\128\162 {id} (`integer?`)\n                  \226\128\162 {dict} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, matcharg = {binding = "matcharg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr"}, ["fnl/docstring"] = "Selects the {nr} match item, as set with a |:match|,\n|:2match| or |:3match| command.\nReturn a |List| with two elements:\n\tThe name of the highlight group used\n\tThe pattern used.\nWhen {nr} is not 1, 2 or 3 returns an empty |List|.\nWhen there is no match item set returns ['', ''].\nThis is useful to save and restore a |:match|.\nHighlighting matches using the |:match| commands are limited\nto three matches. |matchadd()| does not have this limitation.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, matchbufline = {binding = "matchbufline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "pat", "lnum", "end", "?dict"}, ["fnl/docstring"] = "Returns the |List| of matches in lines from {lnum} to {end} in\nbuffer {buf} where {pat} matches.\n\n{lnum} and {end} can either be a line number or the string \"$\"\nto refer to the last line in {buf}.\n\nThe {dict} argument supports following items:\n    submatches\tinclude submatch information (|/\\(|)\n\nFor each match, a |Dict| with the following items is returned:\n    byteidx\tstarting byte index of the match\n    lnum\tline number where there is a match\n    text\tmatched string\nNote that there can be multiple matches in a single line.\n\nThis function works only for loaded buffers. First call\n|bufload()| if needed.\n\nSee |match-pattern| for information about the effect of some\noption settings on the pattern.\n\nWhen {buf} is not a valid buffer, the buffer is not loaded or\n{lnum} or {end} is not valid then an error is given and an\nempty |List| is returned.\n\nExamples: >vim\n    \" Assuming line 3 in buffer 5 contains \"a\"\n    echo matchbufline(5, '\\<\\k\\+\\>', 3, 3)\n<\t\t    `[{'lnum': 3, 'byteidx': 0, 'text': 'a'}]` >vim\n    \" Assuming line 4 in buffer 10 contains \"tik tok\"\n    echo matchbufline(10, '\\<\\k\\+\\>', 1, 4)\n<\t\t    `[{'lnum': 4, 'byteidx': 0, 'text': 'tik'}, {'lnum': 4, 'byteidx': 4, 'text': 'tok'}]`\n\nIf {submatch} is present and is v:true, then submatches like\n\"\\1\", \"\\2\", etc. are also returned.  Example: >vim\n    \" Assuming line 2 in buffer 2 contains \"acd\"\n    echo matchbufline(2, '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)', 2, 2\n\t\t\t\t\\ {'submatches': v:true})\n<\t\t    `[{'lnum': 2, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]`\nThe \"submatches\" List always contains 9 items.  If a submatch\nis not found, then an empty string is returned for that\nsubmatch.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`string|integer`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {lnum} (`string|integer`)\n                  \226\128\162 {end} (`string|integer`)\n                  \226\128\162 {dict} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, matchdelete = {binding = "matchdelete", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id", "?win"}, ["fnl/docstring"] = "Deletes a match with ID {id} previously defined by |matchadd()|\nor one of the |:match| commands.  Returns 0 if successful,\notherwise -1.  See example for |matchadd()|.  All matches can\nbe deleted in one operation by |clearmatches()|.\nIf {win} is specified, use the window with this number or\nwindow ID instead of the current window.\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer`)\n                  \226\128\162 {win} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, matchend = {binding = "matchend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "pat", "?start", "?count"}, ["fnl/docstring"] = "Same as |match()|, but return the index of first character\nafter the match.  Example: >vim\n\techo matchend(\"testing\", \"ing\")\n<\t\tresults in \"7\".\n\t\t\t\t\t*strspn()* *strcspn()*\nVim doesn't have a strspn() or strcspn() function, but you can\ndo it with matchend(): >vim\n\tlet span = matchend(line, '[a-zA-Z]')\n\tlet span = matchend(line, '[^a-zA-Z]')\n<\t\tExcept that -1 is returned when there are no matches.\n\nThe {start}, if given, has the same meaning as for |match()|. >vim\n\techo matchend(\"testing\", \"ing\", 2)\n<\t\tresults in \"7\". >vim\n\techo matchend(\"testing\", \"ing\", 5)\n<\t\tresult is \"-1\".\nWhen {expr} is a |List| the result is equal to |match()|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {start} (`integer?`)\n                  \226\128\162 {count} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, matchfuzzy = {binding = "matchfuzzy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "str", "?dict"}, ["fnl/docstring"] = "If {list} is a list of strings, then returns a |List| with all\nthe strings in {list} that fuzzy match {str}. The strings in\nthe returned list are sorted based on the matching score.\n\nThe optional {dict} argument always supports the following\nitems:\n    matchseq\tWhen this item is present return only matches\n\t\tthat contain the characters in {str} in the\n\t\tgiven sequence.\n    limit\tMaximum number of matches in {list} to be\n\t\treturned.  Zero means no limit.\n\nIf {list} is a list of dictionaries, then the optional {dict}\nargument supports the following additional items:\n    key\t\tKey of the item which is fuzzy matched against\n\t\t{str}. The value of this item should be a\n\t\tstring.\n    text_cb\t|Funcref| that will be called for every item\n\t\tin {list} to get the text for fuzzy matching.\n\t\tThis should accept a dictionary item as the\n\t\targument and return the text for that item to\n\t\tuse for fuzzy matching.\n\n{str} is treated as a literal string and regular expression\nmatching is NOT supported.  The maximum supported {str} length\nis 256.\n\nWhen {str} has multiple words each separated by white space,\nthen the list of strings that have all the words is returned.\n\nIf there are no matching strings or there is an error, then an\nempty list is returned. If length of {str} is greater than\n256, then returns an empty list.\n\nWhen {limit} is given, matchfuzzy() will find up to this\nnumber of matches in {list} and return them in sorted order.\n\nRefer to |fuzzy-matching| for more information about fuzzy\nmatching strings.\n\nExample: >vim\n   echo matchfuzzy([\"clay\", \"crow\"], \"cay\")\n<\t\tresults in [\"clay\"]. >vim\n   echo getbufinfo()->map({_, v -> v.name})->matchfuzzy(\"ndl\")\n<\t\tresults in a list of buffer names fuzzy matching \"ndl\". >vim\n   echo getbufinfo()->matchfuzzy(\"ndl\", {'key' : 'name'})\n<\t\tresults in a list of buffer information dicts with buffer\nnames fuzzy matching \"ndl\". >vim\n   echo getbufinfo()->matchfuzzy(\"spl\",\n\t\t\t\t\\ {'text_cb' : {v -> v.name}})\n<\t\tresults in a list of buffer information dicts with buffer\nnames fuzzy matching \"spl\". >vim\n   echo v:oldfiles->matchfuzzy(\"test\")\n<\t\tresults in a list of file names fuzzy matching \"test\". >vim\n   let l = readfile(\"buffer.c\")->matchfuzzy(\"str\")\n<\t\tresults in a list of lines in \"buffer.c\" fuzzy matching \"str\". >vim\n   echo ['one two', 'two one']->matchfuzzy('two one')\n<\t\tresults in `['two one', 'one two']` . >vim\n   echo ['one two', 'two one']->matchfuzzy('two one',\n\t\t\t\t\\ {'matchseq': 1})\n<\t\tresults in `['two one']`.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {str} (`string`)\n                  \226\128\162 {dict} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, matchfuzzypos = {binding = "matchfuzzypos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "str", "?dict"}, ["fnl/docstring"] = "Same as |matchfuzzy()|, but returns the list of matched\nstrings, the list of character positions where characters\nin {str} matches and a list of matching scores.  You can\nuse |byteidx()| to convert a character position to a byte\nposition.\n\nIf {str} matches multiple times in a string, then only the\npositions for the best match is returned.\n\nIf there are no matching strings or there is an error, then a\nlist with three empty list items is returned.\n\nExample: >vim\n\techo matchfuzzypos(['testing'], 'tsg')\n<\t\tresults in [[\"testing\"], [[0, 2, 6]], [99]] >vim\n\techo matchfuzzypos(['clay', 'lacy'], 'la')\n<\t\tresults in [[\"lacy\", \"clay\"], [[0, 1], [1, 2]], [153, 133]] >vim\n\techo [{'text': 'hello', 'id' : 10}]\n\t\t\\ ->matchfuzzypos('ll', {'key' : 'text'})\n<\t\tresults in `[[{\"id\": 10, \"text\": \"hello\"}], [[2, 3]], [127]]`\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {str} (`string`)\n                  \226\128\162 {dict} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, matchlist = {binding = "matchlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "pat", "?start", "?count"}, ["fnl/docstring"] = "Same as |match()|, but return a |List|.  The first item in the\nlist is the matched string, same as what matchstr() would\nreturn.  Following items are submatches, like \"\\1\", \"\\2\", etc.\nin |:substitute|.  When an optional submatch didn't match an\nempty string is used.  Example: >vim\n\techo matchlist('acd', '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)')\n<\t\tResults in: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']\nWhen there is no match an empty list is returned.\n\nYou can pass in a List, but that is not very useful.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {start} (`integer?`)\n                  \226\128\162 {count} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, matchstr = {binding = "matchstr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "pat", "?start", "?count"}, ["fnl/docstring"] = "Same as |match()|, but return the matched string.  Example: >vim\n\techo matchstr(\"testing\", \"ing\")\n<\t\tresults in \"ing\".\nWhen there is no match \"\" is returned.\nThe {start}, if given, has the same meaning as for |match()|. >vim\n\techo matchstr(\"testing\", \"ing\", 2)\n<\t\tresults in \"ing\". >vim\n\techo matchstr(\"testing\", \"ing\", 5)\n<\t\tresult is \"\".\nWhen {expr} is a |List| then the matching item is returned.\nThe type isn't changed, it's not necessarily a String.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {start} (`integer?`)\n                  \226\128\162 {count} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, matchstrlist = {binding = "matchstrlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "pat", "?dict"}, ["fnl/docstring"] = "Returns the |List| of matches in {list} where {pat} matches.\n{list} is a |List| of strings.  {pat} is matched against each\nstring in {list}.\n\nThe {dict} argument supports following items:\n    submatches\tinclude submatch information (|/\\(|)\n\nFor each match, a |Dict| with the following items is returned:\n    byteidx\tstarting byte index of the match.\n    idx\t\tindex in {list} of the match.\n    text\tmatched string\n    submatches\ta List of submatches.  Present only if\n\t\t\"submatches\" is set to v:true in {dict}.\n\nSee |match-pattern| for information about the effect of some\noption settings on the pattern.\n\nExample: >vim\n    echo matchstrlist(['tik tok'], '\\<\\k\\+\\>')\n<\t\t    `[{'idx': 0, 'byteidx': 0, 'text': 'tik'}, {'idx': 0, 'byteidx': 4, 'text': 'tok'}]` >vim\n    echo matchstrlist(['a', 'b'], '\\<\\k\\+\\>')\n<\t\t    `[{'idx': 0, 'byteidx': 0, 'text': 'a'}, {'idx': 1, 'byteidx': 0, 'text': 'b'}]`\n\nIf \"submatches\" is present and is v:true, then submatches like\n\"\\1\", \"\\2\", etc. are also returned.  Example: >vim\n    echo matchstrlist(['acd'], '\\(a\\)\\?\\(b\\)\\?\\(c\\)\\?\\(.*\\)',\n\t\t\t\t\\ #{submatches: v:true})\n<\t\t    `[{'idx': 0, 'byteidx': 0, 'text': 'acd', 'submatches': ['a', '', 'c', 'd', '', '', '', '', '']}]`\nThe \"submatches\" List always contains 9 items.  If a submatch\nis not found, then an empty string is returned for that\nsubmatch.\n\n                Parameters: ~\n                  \226\128\162 {list} (`string[]`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {dict} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, matchstrpos = {binding = "matchstrpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "pat", "?start", "?count"}, ["fnl/docstring"] = "Same as |matchstr()|, but return the matched string, the start\nposition and the end position of the match.  Example: >vim\n\techo matchstrpos(\"testing\", \"ing\")\n<\t\tresults in [\"ing\", 4, 7].\nWhen there is no match [\"\", -1, -1] is returned.\nThe {start}, if given, has the same meaning as for |match()|. >vim\n\techo matchstrpos(\"testing\", \"ing\", 2)\n<\t\tresults in [\"ing\", 4, 7]. >vim\n\techo matchstrpos(\"testing\", \"ing\", 5)\n<\t\tresult is [\"\", -1, -1].\nWhen {expr} is a |List| then the matching item, the index\nof first item where {pat} matches, the start position and the\nend position of the match are returned. >vim\n\techo matchstrpos([1, '__x'], '\\a')\n<\t\tresult is [\"x\", 1, 2, 3].\nThe type isn't changed, it's not necessarily a String.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {start} (`integer?`)\n                  \226\128\162 {count} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, max = {binding = "max", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the maximum value of all items in {expr}. Example: >vim\n\techo max([apples, pears, oranges])\n\n<\t\t{expr} can be a |List| or a |Dictionary|.  For a Dictionary,\nit returns the maximum of all values in the Dictionary.\nIf {expr} is neither a List nor a Dictionary, or one of the\nitems in {expr} cannot be used as a Number this results in\nan error.  An empty |List| or |Dictionary| results in zero.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`number`)"}}, menu_get = {binding = "menu_get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "?modes"}, ["fnl/docstring"] = "Returns a |List| of |Dictionaries| describing |menus| (defined\nby |:menu|, |:amenu|, \226\128\166), including |hidden-menus|.\n\n{path} matches a menu by name, or all menus if {path} is an\nempty string.  Example: >vim\n\techo menu_get('File','')\n\techo menu_get('')\n<\n{modes} is a string of zero or more modes (see |maparg()| or\n|creating-menus| for the list of modes). \"a\" means \"all\".\n\nExample: >vim\n\tnnoremenu &Test.Test inormal\n\tinoremenu Test.Test insert\n\tvnoremenu Test.Test x\n\techo menu_get(\"\")\n\n<\t\treturns something like this: >\n\n\t[ {\n\t  \"hidden\": 0,\n\t  \"name\": \"Test\",\n\t  \"priority\": 500,\n\t  \"shortcut\": 84,\n\t  \"submenus\": [ {\n\t    \"hidden\": 0,\n\t    \"mappings\": {\n\t      i\": {\n\t\t\"enabled\": 1,\n\t\t\"noremap\": 1,\n\t\t\"rhs\": \"insert\",\n\t\t\"sid\": 1,\n\t\t\"silent\": 0\n\t      },\n\t      n\": { ... },\n\t      s\": { ... },\n\t      v\": { ... }\n\t    },\n\t    \"name\": \"Test\",\n\t    \"priority\": 500,\n\t    \"shortcut\": 0\n\t  } ]\n\t} ]\n<\n\n                Parameters: ~\n                  \226\128\162 {path} (`string`)\n                  \226\128\162 {modes} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, menu_info = {binding = "menu_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?mode"}, ["fnl/docstring"] = "Return information about the specified menu {name} in\nmode {mode}. The menu name should be specified without the\nshortcut character ('&'). If {name} is \"\", then the top-level\nmenu names are returned.\n\n{mode} can be one of these strings:\n\t\"n\"\tNormal\n\t\"v\"\tVisual (including Select)\n\t\"o\"\tOperator-pending\n\t\"i\"\tInsert\n\t\"c\"\tCmd-line\n\t\"s\"\tSelect\n\t\"x\"\tVisual\n\t\"t\"\tTerminal-Job\n\t\"\"\tNormal, Visual and Operator-pending\n\t\"!\"\tInsert and Cmd-line\nWhen {mode} is omitted, the modes for \"\" are used.\n\nReturns a |Dictionary| containing the following items:\n  accel\t\tmenu item accelerator text |menu-text|\n  display\tdisplay name (name without '&')\n  enabled\tv:true if this menu item is enabled\n\t\tRefer to |:menu-enable|\n  icon\t\tname of the icon file (for toolbar)\n\t\t|toolbar-icon|\n  iconidx\tindex of a built-in icon\n  modes\t\tmodes for which the menu is defined. In\n\t\taddition to the modes mentioned above, these\n\t\tcharacters will be used:\n\t\t\" \"\tNormal, Visual and Operator-pending\n  name\t\tmenu item name.\n  noremenu\tv:true if the {rhs} of the menu item is not\n\t\tremappable else v:false.\n  priority\tmenu order priority |menu-priority|\n  rhs\t\tright-hand-side of the menu item. The returned\n\t\tstring has special characters translated like\n\t\tin the output of the \":menu\" command listing.\n\t\tWhen the {rhs} of a menu item is empty, then\n\t\t\"<Nop>\" is returned.\n  script\tv:true if script-local remapping of {rhs} is\n\t\tallowed else v:false.  See |:menu-script|.\n  shortcut\tshortcut key (character after '&' in\n\t\tthe menu name) |menu-shortcut|\n  silent\tv:true if the menu item is created\n\t\twith <silent> argument |:menu-silent|\n  submenus\t|List| containing the names of\n\t\tall the submenus.  Present only if the menu\n\t\titem has submenus.\n\nReturns an empty dictionary if the menu item is not found.\n\nExamples: >vim\n\techo menu_info('Edit.Cut')\n\techo menu_info('File.Save', 'n')\n\n\t\" Display the entire menu hierarchy in a buffer\n\tfunc ShowMenu(name, pfx)\n\t  let m = menu_info(a:name)\n\t  call append(line('$'), a:pfx .. m.display)\n\t  for child in m->get('submenus', [])\n\t    call ShowMenu(a:name .. '.' .. escape(child, '.'),\n\t\t\t\t\t\\ a:pfx .. '    ')\n\t  endfor\n\tendfunc\n\tnew\n\tfor topmenu in menu_info('').submenus\n\t  call ShowMenu(topmenu, '')\n\tendfor\n<\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {mode} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, min = {binding = "min", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the minimum value of all items in {expr}. Example: >vim\n\techo min([apples, pears, oranges])\n\n<\t\t{expr} can be a |List| or a |Dictionary|.  For a Dictionary,\nit returns the minimum of all values in the Dictionary.\nIf {expr} is neither a List nor a Dictionary, or one of the\nitems in {expr} cannot be used as a Number this results in\nan error.  An empty |List| or |Dictionary| results in zero.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`number`)"}}, mkdir = {binding = "mkdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?flags", "?prot"}, ["fnl/docstring"] = "Create directory {name}.\n\nWhen {flags} is present it must be a string.  An empty string\nhas no effect.\n\n{flags} can contain these character flags:\n \"p\"\tintermediate directories will be created as necessary\n \"D\"\t{name} will be deleted at the end of the current\n\tfunction, but not recursively |:defer|\n \"R\"\t{name} will be deleted recursively at the end of the\n\tcurrent function |:defer|\n\nNote that when {name} has more than one part and \"p\" is used\nsome directories may already exist.  Only the first one that\nis created and what it contains is scheduled to be deleted.\nE.g. when using: >vim\n\tcall mkdir('subdir/tmp/autoload', 'pR')\n<\t\tand \"subdir\" already exists then \"subdir/tmp\" will be\nscheduled for deletion, like with: >vim\n\tdefer delete('subdir/tmp', 'rf')\n<\nIf {prot} is given it is used to set the protection bits of\nthe new directory.  The default is 0o755 (rwxr-xr-x: r/w for\nthe user, readable for others).  Use 0o700 to make it\nunreadable for others.  This is used for the newly created\ndirectories.  Note: umask is applied to {prot} (on Unix).\nExample: >vim\n\tcall mkdir($HOME .. \"/tmp/foo/bar\", \"p\", 0o700)\n\n<\t\tThis function is not available in the |sandbox|.\n\nIf you try to create an existing directory with {flags} set to\n\"p\" mkdir() will silently exit.\n\nThe function result is a Number, which is TRUE if the call was\nsuccessful or FALSE if the directory creation failed or partly\nfailed.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {flags} (`string?`)\n                  \226\128\162 {prot} (`string?`)\n\n                Return: ~\n                  (`integer`)"}}, mode = {binding = "mode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?expr"}, ["fnl/docstring"] = "Return a string that indicates the current mode.\nIf {expr} is supplied and it evaluates to a non-zero Number or\na non-empty String (|non-zero-arg|), then the full mode is\nreturned, otherwise only the first letter is returned.\nAlso see |state()|.\n\n   n\t    Normal\n   no\t    Operator-pending\n   nov\t    Operator-pending (forced charwise |o_v|)\n   noV\t    Operator-pending (forced linewise |o_V|)\n   noCTRL-V Operator-pending (forced blockwise |o_CTRL-V|)\n\t\tCTRL-V is one character\n   niI\t    Normal using |i_CTRL-O| in |Insert-mode|\n   niR\t    Normal using |i_CTRL-O| in |Replace-mode|\n   niV\t    Normal using |i_CTRL-O| in |Virtual-Replace-mode|\n   nt\t    Normal in |terminal-emulator| (insert goes to\n\t\tTerminal mode)\n   ntT\t    Normal using |t_CTRL-\\_CTRL-O| in |Terminal-mode|\n   v\t    Visual by character\n   vs\t    Visual by character using |v_CTRL-O| in Select mode\n   V\t    Visual by line\n   Vs\t    Visual by line using |v_CTRL-O| in Select mode\n   CTRL-V   Visual blockwise\n   CTRL-Vs  Visual blockwise using |v_CTRL-O| in Select mode\n   s\t    Select by character\n   S\t    Select by line\n   CTRL-S   Select blockwise\n   i\t    Insert\n   ic\t    Insert mode completion |compl-generic|\n   ix\t    Insert mode |i_CTRL-X| completion\n   R\t    Replace |R|\n   Rc\t    Replace mode completion |compl-generic|\n   Rx\t    Replace mode |i_CTRL-X| completion\n   Rv\t    Virtual Replace |gR|\n   Rvc\t    Virtual Replace mode completion |compl-generic|\n   Rvx\t    Virtual Replace mode |i_CTRL-X| completion\n   c\t    Command-line editing\n   cr\t    Command-line editing overstrike mode |c_<Insert>|\n   cv\t    Vim Ex mode |gQ|\n   cvr\t    Vim Ex mode while in overstrike mode |c_<Insert>|\n   r\t    Hit-enter prompt\n   rm\t    The -- more -- prompt\n   r?\t    A |:confirm| query of some sort\n   !\t    Shell or external command is executing\n   t\t    Terminal mode: keys go to the job\n\nThis is useful in the 'statusline' option or RPC calls. In\nmost other places it always returns \"c\" or \"n\".\nNote that in the future more modes and more specific modes may\nbe added. It's better not to compare the whole string but only\nthe leading character(s).\nAlso see |visualmode()|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, msgpackdump = {binding = "msgpackdump", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?type"}, ["fnl/docstring"] = "Convert a list of Vimscript objects to msgpack. Returned value is a\n|readfile()|-style list. When {type} contains \"B\", a |Blob| is\nreturned instead. Example: >vim\n\tcall writefile(msgpackdump([{}]), 'fname.mpack', 'b')\n<\t\tor, using a |Blob|: >vim\n\tcall writefile(msgpackdump([{}], 'B'), 'fname.mpack')\n<\nThis will write the single 0x80 byte to a `fname.mpack` file\n(dictionary with zero items is represented by 0x80 byte in\nmessagepack).\n\nLimitations:\t\t\t\t*E5004* *E5005*\n1. |Funcref|s cannot be dumped.\n2. Containers that reference themselves cannot be dumped.\n3. Dictionary keys are always dumped as STR strings.\n4. Other strings and |Blob|s are always dumped as BIN strings.\n5. Points 3. and 4. do not apply to |msgpack-special-dict|s.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any`)\n                  \226\128\162 {type} (`any?`)\n\n                Return: ~\n                  (`any`)"}}, msgpackparse = {binding = "msgpackparse", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"data"}, ["fnl/docstring"] = "Convert a |readfile()|-style list or a |Blob| to a list of\nVimscript objects.\nExample: >vim\n\tlet fname = expand('~/.config/nvim/shada/main.shada')\n\tlet mpack = readfile(fname, 'b')\n\tlet shada_objects = msgpackparse(mpack)\n<\t\tThis will read ~/.config/nvim/shada/main.shada file to\n`shada_objects` list.\n\nLimitations:\n1. Mapping ordering is not preserved unless messagepack\n   mapping is dumped using generic mapping\n   (|msgpack-special-map|).\n2. Since the parser aims to preserve all data untouched\n   (except for 1.) some strings are parsed to\n   |msgpack-special-dict| format which is not convenient to\n   use.\n\t\t\t\t\t*msgpack-special-dict*\nSome messagepack strings may be parsed to special\ndictionaries. Special dictionaries are dictionaries which\n\n1. Contain exactly two keys: `_TYPE` and `_VAL`.\n2. `_TYPE` key is one of the types found in |v:msgpack_types|\n   variable.\n3. Value for `_VAL` has the following format (Key column\n   contains name of the key from |v:msgpack_types|):\n\nKey\tValue ~\nnil\tZero, ignored when dumping.  Not returned by\n\t|msgpackparse()| since |v:null| was introduced.\nboolean\tOne or zero.  When dumping it is only checked that\n\tvalue is a |Number|.  Not returned by |msgpackparse()|\n\tsince |v:true| and |v:false| were introduced.\ninteger\t|List| with four numbers: sign (-1 or 1), highest two\n\tbits, number with bits from 62nd to 31st, lowest 31\n\tbits. I.e. to get actual number one will need to use\n\tcode like >\n\t\t_VAL[0] * ((_VAL[1] << 62)\n\t\t           & (_VAL[2] << 31)\n\t\t           & _VAL[3])\n<\t\t\tSpecial dictionary with this type will appear in\n\t|msgpackparse()| output under one of the following\n\tcircumstances:\n\0091. |Number| is 32-bit and value is either above\n\t   INT32_MAX or below INT32_MIN.\n\0092. |Number| is 64-bit and value is above INT64_MAX. It\n\t   cannot possibly be below INT64_MIN because msgpack\n\t   C parser does not support such values.\nfloat\t|Float|. This value cannot possibly appear in\n\t|msgpackparse()| output.\nstring\t|String|, or |Blob| if binary string contains zero\n\tbyte. This value cannot appear in |msgpackparse()|\n\toutput since blobs were introduced.\narray\t|List|. This value cannot appear in |msgpackparse()|\n\toutput.\n\t\t\t\t\t*msgpack-special-map*\nmap\t|List| of |List|s with two items (key and value) each.\n\tThis value will appear in |msgpackparse()| output if\n\tparsed mapping contains one of the following keys:\n\0091. Any key that is not a string (including keys which\n\t   are binary strings).\n\0092. String with NUL byte inside.\n\0093. Duplicate key.\next\t|List| with two values: first is a signed integer\n\trepresenting extension type. Second is\n\t|readfile()|-style list of strings.\n\n                Parameters: ~\n                  \226\128\162 {data} (`any`)\n\n                Return: ~\n                  (`any`)"}}, nextnonblank = {binding = "nextnonblank", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Return the line number of the first line at or below {lnum}\nthat is not blank.  Example: >vim\n\tif getline(nextnonblank(1)) =~ \"Java\" | endif\n<\t\tWhen {lnum} is invalid or there is no non-blank line at or\nbelow it, zero is returned.\n{lnum} is used like with |getline()|.\nSee also |prevnonblank()|.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, nr2char = {binding = "nr2char", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?utf8"}, ["fnl/docstring"] = "Return a string with a single character, which has the number\nvalue {expr}.  Examples: >vim\n\techo nr2char(64)\t\t\" returns '@'\n\techo nr2char(32)\t\t\" returns ' '\n<\t\tExample for \"utf-8\": >vim\n\techo nr2char(300)\t\t\" returns I with bow character\n<\nUTF-8 encoding is always used, {utf8} option has no effect,\nand exists only for backwards-compatibility.\nNote that a NUL character in the file is specified with\nnr2char(10), because NULs are represented with newline\ncharacters.  nr2char(0) is a real NUL and terminates the\nstring, thus results in an empty string.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`integer`)\n                  \226\128\162 {utf8} (`boolean?`)\n\n                Return: ~\n                  (`string`)"}}, nvim_ = {binding = "nvim_", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"..."}, ["fnl/docstring"] = "Call nvim |api| functions. The type checking of arguments will\nbe stricter than for most other builtins. For instance,\nif Integer is expected, a |Number| must be passed in, a\n|String| will not be autoconverted.\nBuffer numbers, as returned by |bufnr()| could be used as\nfirst argument to nvim_buf_... functions.  All functions\nexpecting an object (buffer, window or tabpage) can\nalso take the numerical value 0 to indicate the current\n(focused) object.\n\n                Parameters: ~\n                  \226\128\162 {...} (`any`)\n\n                Return: ~\n                  (`any`)"}}, ["or"] = {binding = "or", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "expr1"}, ["fnl/docstring"] = "Bitwise OR on the two arguments.  The arguments are converted\nto a number.  A List, Dict or Float argument causes an error.\nAlso see `and()` and `xor()`.\nExample: >vim\n\tlet bits = or(bits, 0x80)\n\n<\t\tRationale: The reason this is a function and not using the \"|\"\ncharacter like many languages, is that Vi has always used \"|\"\nto separate commands.  In many places it would not be clear if\n\"|\" is an operator or a command separator.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n                  \226\128\162 {expr1} (`number`)\n\n                Return: ~\n                  (`any`)"}}, pathshorten = {binding = "pathshorten", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "?len"}, ["fnl/docstring"] = "Shorten directory names in the path {path} and return the\nresult.  The tail, the file name, is kept as-is.  The other\ncomponents in the path are reduced to {len} letters in length.\nIf {len} is omitted or smaller than 1 then 1 is used (single\nletters).  Leading '~' and '.' characters are kept.  Examples: >vim\n\techo pathshorten('~/.config/nvim/autoload/file1.vim')\n<\t\t\t~/.c/n/a/file1.vim ~\n>vim\n\techo pathshorten('~/.config/nvim/autoload/file2.vim', 2)\n<\t\t\t~/.co/nv/au/file2.vim ~\nIt doesn't matter if the path exists or not.\nReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {path} (`string`)\n                  \226\128\162 {len} (`integer?`)\n\n                Return: ~\n                  (`string`)"}}, perleval = {binding = "perleval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Evaluate |perl| expression {expr} and return its result\nconverted to Vim data structures.\nNumbers and strings are returned as they are (strings are\ncopied though).\nLists are represented as Vim |List| type.\nDictionaries are represented as Vim |Dictionary| type,\nnon-string keys result in error.\n\nNote: If you want an array or hash, {expr} must return a\nreference to it.\nExample: >vim\n\techo perleval('[1 .. 4]')\n<\t\t\t[1, 2, 3, 4]\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`)"}}, pow = {binding = "pow", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"x", "y"}, ["fnl/docstring"] = "Return the power of {x} to the exponent {y} as a |Float|.\n{x} and {y} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {x} or {y} is not a |Float| or a |Number|.\nExamples: >vim\n\techo pow(3, 3)\n<\t\t\00927.0 >vim\n\techo pow(2, 16)\n<\t\t\00965536.0 >vim\n\techo pow(32, 0.20)\n<\t\t\0092.0\n\n                Parameters: ~\n                  \226\128\162 {x} (`number`)\n                  \226\128\162 {y} (`number`)\n\n                Return: ~\n                  (`number`)"}}, prevnonblank = {binding = "prevnonblank", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Return the line number of the first line at or above {lnum}\nthat is not blank.  Example: >vim\n\tlet ind = indent(prevnonblank(v:lnum - 1))\n<\t\tWhen {lnum} is invalid or there is no non-blank line at or\nabove it, zero is returned.\n{lnum} is used like with |getline()|.\nAlso see |nextnonblank()|.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, printf = {binding = "printf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fmt", "?expr1"}, ["fnl/docstring"] = "Return a String with {fmt}, where \"%\" items are replaced by\nthe formatted form of their respective arguments.  Example: >vim\n\techo printf(\"%4d: E%d %.30s\", lnum, errno, msg)\n<\t\tMay result in:\n\t\"  99: E42 asdfasdfasdfasdfasdfasdfasdfas\" ~\n\nWhen used as a |method| the base is passed as the second\nargument: >vim\n\tCompute()->printf(\"result: %d\")\n<\nYou can use `call()` to pass the items as a list.\n\nOften used items are:\n  %s\tstring\n  %6S\tstring right-aligned in 6 display cells\n  %6s\tstring right-aligned in 6 bytes\n  %.9s\tstring truncated to 9 bytes\n  %c\tsingle byte\n  %d\tdecimal number\n  %5d\tdecimal number padded with spaces to 5 characters\n  %b\tbinary number\n  %08b\tbinary number padded with zeros to at least 8 characters\n  %B\tbinary number using upper case letters\n  %x\thex number\n  %04x\thex number padded with zeros to at least 4 characters\n  %X\thex number using upper case letters\n  %o\toctal number\n  %f\tfloating point number as 12.23, inf, -inf or nan\n  %F\tfloating point number as 12.23, INF, -INF or NAN\n  %e\tfloating point number as 1.23e3, inf, -inf or nan\n  %E\tfloating point number as 1.23E3, INF, -INF or NAN\n  %g\tfloating point number, as %f or %e depending on value\n  %G\tfloating point number, as %F or %E depending on value\n  %%\tthe % character itself\n  %p\trepresentation of the pointer to the container\n\nConversion specifications start with '%' and end with the\nconversion type.  All other characters are copied unchanged to\nthe result.\n\nThe \"%\" starts a conversion specification.  The following\narguments appear in sequence:\n\n\t% [pos-argument] [flags] [field-width] [.precision] type\n\npos-argument\n\tAt most one positional argument specifier. These\n\ttake the form {n$}, where n is >= 1.\n\nflags\n\tZero or more of the following flags:\n\n    #\t      The value should be converted to an \"alternate\n\t      form\".  For c, d, and s conversions, this option\n\t      has no effect.  For o conversions, the precision\n\t      of the number is increased to force the first\n\t      character of the output string to a zero (except\n\t      if a zero value is printed with an explicit\n\t      precision of zero).\n\t      For x and X conversions, a non-zero result has\n\t      the string \"0x\" (or \"0X\" for X conversions)\n\t      prepended to it.\n\n    0 (zero)  Zero padding.  For all conversions the converted\n\t      value is padded on the left with zeros rather\n\t      than blanks.  If a precision is given with a\n\t      numeric conversion (d, o, x, and X), the 0 flag\n\t      is ignored.\n\n    -\t      A negative field width flag; the converted value\n\t      is to be left adjusted on the field boundary.\n\t      The converted value is padded on the right with\n\t      blanks, rather than on the left with blanks or\n\t      zeros.  A - overrides a 0 if both are given.\n\n    ' ' (space)  A blank should be left before a positive\n\t      number produced by a signed conversion (d).\n\n    +\t      A sign must always be placed before a number\n\t      produced by a signed conversion.  A + overrides\n\t      a space if both are used.\n\nfield-width\n\tAn optional decimal digit string specifying a minimum\n\tfield width.  If the converted value has fewer bytes\n\tthan the field width, it will be padded with spaces on\n\tthe left (or right, if the left-adjustment flag has\n\tbeen given) to fill out the field width.  For the S\n\tconversion the count is in cells.\n\n.precision\n\tAn optional precision, in the form of a period '.'\n\tfollowed by an optional digit string.  If the digit\n\tstring is omitted, the precision is taken as zero.\n\tThis gives the minimum number of digits to appear for\n\td, o, x, and X conversions, the maximum number of\n\tbytes to be printed from a string for s conversions,\n\tor the maximum number of cells to be printed from a\n\tstring for S conversions.\n\tFor floating point it is the number of digits after\n\tthe decimal point.\n\ntype\n\tA character that specifies the type of conversion to\n\tbe applied, see below.\n\nA field width or precision, or both, may be indicated by an\nasterisk \"*\" instead of a digit string.  In this case, a\nNumber argument supplies the field width or precision.  A\nnegative field width is treated as a left adjustment flag\nfollowed by a positive field width; a negative precision is\ntreated as though it were missing.  Example: >vim\n\techo printf(\"%d: %.*s\", nr, width, line)\n<\t\tThis limits the length of the text used from \"line\" to\n\"width\" bytes.\n\nIf the argument to be formatted is specified using a\npositional argument specifier, and a '*' is used to indicate\nthat a number argument is to be used to specify the width or\nprecision, the argument(s) to be used must also be specified\nusing a {n$} positional argument specifier. See |printf-$|.\n\nThe conversion specifiers and their meanings are:\n\n\t\t*printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X*\ndbBoxX\tThe Number argument is converted to signed decimal (d),\n\tunsigned binary (b and B), unsigned octal (o), or\n\tunsigned hexadecimal (x and X) notation.  The letters\n\t\"abcdef\" are used for x conversions; the letters\n\t\"ABCDEF\" are used for X conversions.  The precision, if\n\tany, gives the minimum number of digits that must\n\tappear; if the converted value requires fewer digits, it\n\tis padded on the left with zeros.  In no case does a\n\tnon-existent or small field width cause truncation of a\n\tnumeric field; if the result of a conversion is wider\n\tthan the field width, the field is expanded to contain\n\tthe conversion result.\n\tThe 'h' modifier indicates the argument is 16 bits.\n\tThe 'l' modifier indicates the argument is a long\n\tinteger.  The size will be 32 bits or 64 bits\n\tdepending on your platform.\n\tThe \"ll\" modifier indicates the argument is 64 bits.\n\tThe b and B conversion specifiers never take a width\n\tmodifier and always assume their argument is a 64 bit\n\tinteger.\n\tGenerally, these modifiers are not useful. They are\n\tignored when type is known from the argument.\n\ni\talias for d\nD\talias for ld\nU\talias for lu\nO\talias for lo\n\n\t\t\t\t\t*printf-c*\nc\tThe Number argument is converted to a byte, and the\n\tresulting character is written.\n\n\t\t\t\t\t*printf-s*\ns\tThe text of the String argument is used.  If a\n\tprecision is specified, no more bytes than the number\n\tspecified are used.\n\tIf the argument is not a String type, it is\n\tautomatically converted to text with the same format\n\tas \":echo\".\n\t\t\t\t\t*printf-S*\nS\tThe text of the String argument is used.  If a\n\tprecision is specified, no more display cells than the\n\tnumber specified are used.\n\n\t\t\t\t\t*printf-f* *E807*\nf F\tThe Float argument is converted into a string of the\n\tform 123.456.  The precision specifies the number of\n\tdigits after the decimal point.  When the precision is\n\tzero the decimal point is omitted.  When the precision\n\tis not specified 6 is used.  A really big number\n\t(out of range or dividing by zero) results in \"inf\"\n\t or \"-inf\" with %f (INF or -INF with %F).\n\t \"0.0 / 0.0\" results in \"nan\" with %f (NAN with %F).\n\tExample: >vim\n\t\techo printf(\"%.2f\", 12.115)\n<\t\t\t\00912.12\n\tNote that roundoff depends on the system libraries.\n\tUse |round()| when in doubt.\n\n\t\t\t\t\t*printf-e* *printf-E*\ne E\tThe Float argument is converted into a string of the\n\tform 1.234e+03 or 1.234E+03 when using 'E'.  The\n\tprecision specifies the number of digits after the\n\tdecimal point, like with 'f'.\n\n\t\t\t\t\t*printf-g* *printf-G*\ng G\tThe Float argument is converted like with 'f' if the\n\tvalue is between 0.001 (inclusive) and 10000000.0\n\t(exclusive).  Otherwise 'e' is used for 'g' and 'E'\n\tfor 'G'.  When no precision is specified superfluous\n\tzeroes and '+' signs are removed, except for the zero\n\timmediately after the decimal point.  Thus 10000000.0\n\tresults in 1.0e7.\n\n\t\t\t\t\t*printf-%*\n%\tA '%' is written.  No argument is converted.  The\n\tcomplete conversion specification is \"%%\".\n\nWhen a Number argument is expected a String argument is also\naccepted and automatically converted.\nWhen a Float or String argument is expected a Number argument\nis also accepted and automatically converted.\nAny other argument type results in an error message.\n\n\t\t\t\t\t*E766* *E767*\nThe number of {exprN} arguments must exactly match the number\nof \"%\" items.  If there are not sufficient or too many\narguments an error is given.  Up to 18 arguments can be used.\n\n\t\t\t\t\t*printf-$*\nIn certain languages, error and informative messages are\nmore readable when the order of words is different from the\ncorresponding message in English. To accommodate translations\nhaving a different word order, positional arguments may be\nused to indicate this. For instance: >vim\n\n    #, c-format\n    msgid \"%s returning %s\"\n    msgstr \"waarde %2$s komt terug van %1$s\"\n<\nIn this example, the sentence has its 2 string arguments\nreversed in the output. >vim\n\n    echo printf(\n\t\"In The Netherlands, vim's creator's name is: %1$s %2$s\",\n\t\"Bram\", \"Moolenaar\")\n<\t\t    In The Netherlands, vim's creator's name is: Bram Moolenaar >vim\n\n    echo printf(\n\t\"In Belgium, vim's creator's name is: %2$s %1$s\",\n\t\"Bram\", \"Moolenaar\")\n<\t\t    In Belgium, vim's creator's name is: Moolenaar Bram\n\nWidth (and precision) can be specified using the '*' specifier.\nIn this case, you must specify the field width position in the\nargument list. >vim\n\n    echo printf(\"%1$*2$.*3$d\", 1, 2, 3)\n<\t\t    001 >vim\n    echo printf(\"%2$*3$.*1$d\", 1, 2, 3)\n<\t\t      2 >vim\n    echo printf(\"%3$*1$.*2$d\", 1, 2, 3)\n<\t\t    03 >vim\n    echo printf(\"%1$*2$.*3$g\", 1.4142, 2, 3)\n<\t\t    1.414\n\nYou can mix specifying the width and/or precision directly\nand via positional arguments: >vim\n\n    echo printf(\"%1$4.*2$f\", 1.4142135, 6)\n<\t\t    1.414214 >vim\n    echo printf(\"%1$*2$.4f\", 1.4142135, 6)\n<\t\t    1.4142 >vim\n    echo printf(\"%1$*2$.*3$f\", 1.4142135, 6, 2)\n<\t\t      1.41\n\nYou will get an overflow error |E1510|, when the field-width\nor precision will result in a string longer than 1 MB\n(1024*1024 = 1048576) chars.\n\n\t\t\t\t\t*E1500*\nYou cannot mix positional and non-positional arguments: >vim\n    echo printf(\"%s%1$s\", \"One\", \"Two\")\n<\t\t    E1500: Cannot mix positional and non-positional arguments:\n    %s%1$s\n\n\t\t\t\t\t*E1501*\nYou cannot skip a positional argument in a format string: >vim\n    echo printf(\"%3$s%1$s\", \"One\", \"Two\", \"Three\")\n<\t\t    E1501: format argument 2 unused in $-style format:\n    %3$s%1$s\n\n\t\t\t\t\t*E1502*\nYou can re-use a [field-width] (or [precision]) argument: >vim\n    echo printf(\"%1$d at width %2$d is: %01$*2$d\", 1, 2)\n<\t\t    1 at width 2 is: 01\n\nHowever, you can't use it as a different type: >vim\n    echo printf(\"%1$d at width %2$ld is: %01$*2$d\", 1, 2)\n<\t\t    E1502: Positional argument 2 used as field width reused as\n    different type: long int/int\n\n\t\t\t\t\t*E1503*\nWhen a positional argument is used, but not the correct number\nor arguments is given, an error is raised: >vim\n    echo printf(\"%1$d at width %2$d is: %01$*2$.*3$d\", 1, 2)\n<\t\t    E1503: Positional argument 3 out of bounds: %1$d at width\n    %2$d is: %01$*2$.*3$d\n\nOnly the first error is reported: >vim\n    echo printf(\"%01$*2$.*3$d %4$d\", 1, 2)\n<\t\t    E1503: Positional argument 3 out of bounds: %01$*2$.*3$d\n    %4$d\n\n\t\t\t\t\t*E1504*\nA positional argument can be used more than once: >vim\n    echo printf(\"%1$s %2$s %1$s\", \"One\", \"Two\")\n<\t\t    One Two One\n\nHowever, you can't use a different type the second time: >vim\n    echo printf(\"%1$s %2$s %1$d\", \"One\", \"Two\")\n<\t\t    E1504: Positional argument 1 type used inconsistently:\n    int/string\n\n\t\t\t\t\t*E1505*\nVarious other errors that lead to a format string being\nwrongly formatted lead to: >vim\n    echo printf(\"%1$d at width %2$d is: %01$*2$.3$d\", 1, 2)\n<\t\t    E1505: Invalid format specifier: %1$d at width %2$d is:\n    %01$*2$.3$d\n\n\t\t\t\t\t*E1507*\nThis internal error indicates that the logic to parse a\npositional format argument ran into a problem that couldn't be\notherwise reported.  Please file a bug against Vim if you run\ninto this, copying the exact format string and parameters that\nwere used.\n\n                Parameters: ~\n                  \226\128\162 {fmt} (`string`)\n                  \226\128\162 {expr1} (`any?`)\n\n                Return: ~\n                  (`string`)"}}, prompt_getprompt = {binding = "prompt_getprompt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "Returns the effective prompt text for buffer {buf}.  {buf} can\nbe a buffer name or number.  See |prompt-buffer|.\n\nIf the buffer doesn't exist or isn't a prompt buffer, an empty\nstring is returned.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n\n                Return: ~\n                  (`any`)"}}, prompt_setcallback = {binding = "prompt_setcallback", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "expr"}, ["fnl/docstring"] = "Set prompt callback for buffer {buf} to {expr}.  When {expr}\nis an empty string the callback is removed.  This has only\neffect if {buf} has 'buftype' set to \"prompt\".\n\nThe callback is invoked when pressing Enter.  The current\nbuffer will always be the prompt buffer.  A new line for a\nprompt is added before invoking the callback, thus the prompt\nfor which the callback was invoked will be in the last but one\nline.\nIf the callback wants to add text to the buffer, it must\ninsert it above the last line, since that is where the current\nprompt is.  This can also be done asynchronously.\nThe callback is invoked with one argument, which is the text\nthat was entered at the prompt.  This can be an empty string\nif the user only typed Enter.\nExample: >vim\n   func s:TextEntered(text)\n     if a:text == 'exit' || a:text == 'quit'\n       stopinsert\n       \" Reset 'modified' to allow the buffer to be closed.\n       \" We assume there is nothing useful to be saved.\n       set nomodified\n       close\n     else\n       \" Do something useful with \"a:text\".  In this example\n       \" we just repeat it.\n       call append(line('$') - 1, 'Entered: \"' .. a:text .. '\"')\n     endif\n   endfunc\n   call prompt_setcallback(bufnr(), function('s:TextEntered'))\n<\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {expr} (`string|function`)\n\n                Return: ~\n                  (`any`)"}}, prompt_setinterrupt = {binding = "prompt_setinterrupt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "expr"}, ["fnl/docstring"] = "Set a callback for buffer {buf} to {expr}.  When {expr} is an\nempty string the callback is removed.  This has only effect if\n{buf} has 'buftype' set to \"prompt\".\n\nThis callback will be invoked when pressing CTRL-C in Insert\nmode.  Without setting a callback Vim will exit Insert mode,\nas in any buffer.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {expr} (`string|function`)\n\n                Return: ~\n                  (`any`)"}}, prompt_setprompt = {binding = "prompt_setprompt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "text"}, ["fnl/docstring"] = "Set prompt for buffer {buf} to {text}.  You most likely want\n{text} to end in a space.\nThe result is only visible if {buf} has 'buftype' set to\n\"prompt\".  Example: >vim\n\tcall prompt_setprompt(bufnr(''), 'command: ')\n<\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {text} (`string`)\n\n                Return: ~\n                  (`any`)"}}, pum_getpos = {binding = "pum_getpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "If the popup menu (see |ins-completion-menu|) is not visible,\nreturns an empty |Dictionary|, otherwise, returns a\n|Dictionary| with the following keys:\n\theight\t\tnr of items visible\n\twidth\t\tscreen cells\n\trow\t\ttop screen row (0 first row)\n\tcol\t\tleftmost screen column (0 first col)\n\tsize\t\ttotal nr of items\n\tscrollbar\t|TRUE| if scrollbar is visible\n\nThe values are the same as in |v:event| during |CompleteChanged|.\n\n                Return: ~\n                  (`any`)"}}, pumvisible = {binding = "pumvisible", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns non-zero when the popup menu is visible, zero\notherwise.  See |ins-completion-menu|.\nThis can be used to avoid some things that would remove the\npopup menu.\n\n                Return: ~\n                  (`any`)"}}, py3eval = {binding = "py3eval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Evaluate Python expression {expr} and return its result\nconverted to Vim data structures.\nNumbers and strings are returned as they are (strings are\ncopied though, Unicode strings are additionally converted to\nUTF-8).\nLists are represented as Vim |List| type.\nDictionaries are represented as Vim |Dictionary| type with\nkeys converted to strings.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`)"}}, pyeval = {binding = "pyeval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Evaluate Python expression {expr} and return its result\nconverted to Vim data structures.\nNumbers and strings are returned as they are (strings are\ncopied though).\nLists are represented as Vim |List| type.\nDictionaries are represented as Vim |Dictionary| type,\nnon-string keys result in error.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`)"}}, pyxeval = {binding = "pyxeval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Evaluate Python expression {expr} and return its result\nconverted to Vim data structures.\nUses Python 2 or 3, see |python_x| and 'pyxversion'.\nSee also: |pyeval()|, |py3eval()|\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`)"}}, rand = {binding = "rand", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?expr"}, ["fnl/docstring"] = "Return a pseudo-random Number generated with an xoshiro128**\nalgorithm using seed {expr}.  The returned number is 32 bits,\nalso on 64 bits systems, for consistency.\n{expr} can be initialized by |srand()| and will be updated by\nrand().  If {expr} is omitted, an internal seed value is used\nand updated.\nReturns -1 if {expr} is invalid.\n\nExamples: >vim\n\techo rand()\n\tlet seed = srand()\n\techo rand(seed)\n\techo rand(seed) % 16  \" random number 0 - 15\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number?`)\n\n                Return: ~\n                  (`any`)"}}, range = {binding = "range", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?max", "?stride"}, ["fnl/docstring"] = "Returns a |List| with Numbers:\n- If only {expr} is specified: [0, 1, ..., {expr} - 1]\n- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]\n- If {stride} is specified: [{expr}, {expr} + {stride}, ...,\n  {max}] (increasing {expr} with {stride} each time, not\n  producing a value past {max}).\nWhen the maximum is one before the start the result is an\nempty list.  When the maximum is more than one before the\nstart this is an error.\nExamples: >vim\n\techo range(4)\t\t\" [0, 1, 2, 3]\n\techo range(2, 4)\t\" [2, 3, 4]\n\techo range(2, 9, 3)\t\" [2, 5, 8]\n\techo range(2, -2, -1)\t\" [2, 1, 0, -1, -2]\n\techo range(0)\t\t\" []\n\techo range(2, 0)\t\" error!\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {max} (`integer?`)\n                  \226\128\162 {stride} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, readblob = {binding = "readblob", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname", "?offset", "?size"}, ["fnl/docstring"] = "Read file {fname} in binary mode and return a |Blob|.\nIf {offset} is specified, read the file from the specified\noffset.  If it is a negative value, it is used as an offset\nfrom the end of the file.  E.g., to read the last 12 bytes: >vim\n\techo readblob('file.bin', -12)\n<\t\tIf {size} is specified, only the specified size will be read.\nE.g. to read the first 100 bytes of a file: >vim\n\techo readblob('file.bin', 0, 100)\n<\t\tIf {size} is -1 or omitted, the whole data starting from\n{offset} will be read.\nThis can be also used to read the data from a character device\non Unix when {size} is explicitly set.  Only if the device\nsupports seeking {offset} can be used.  Otherwise it should be\nzero.  E.g. to read 10 bytes from a serial console: >vim\n\techo readblob('/dev/ttyS0', 0, 10)\n<\t\tWhen the file can't be opened an error message is given and\nthe result is an empty |Blob|.\nWhen the offset is beyond the end of the file the result is an\nempty blob.\nWhen trying to read more bytes than are available the result\nis truncated.\nAlso see |readfile()| and |writefile()|.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n                  \226\128\162 {offset} (`integer?`)\n                  \226\128\162 {size} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, readdir = {binding = "readdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"directory", "?expr"}, ["fnl/docstring"] = "Return a list with file and directory names in {directory}.\nYou can also use |glob()| if you don't need to do complicated\nthings, such as limiting the number of matches.\n\nWhen {expr} is omitted all entries are included.\nWhen {expr} is given, it is evaluated to check what to do:\n\tIf {expr} results in -1 then no further entries will\n\tbe handled.\n\tIf {expr} results in 0 then this entry will not be\n\tadded to the list.\n\tIf {expr} results in 1 then this entry will be added\n\tto the list.\nEach time {expr} is evaluated |v:val| is set to the entry name.\nWhen {expr} is a function the name is passed as the argument.\nFor example, to get a list of files ending in \".txt\": >vim\n  echo readdir(dirname, {n -> n =~ '.txt$'})\n<\t\tTo skip hidden and backup files: >vim\n  echo readdir(dirname, {n -> n !~ '^\\.\\|\\~$'})\n\n<\t\tIf you want to get a directory tree: >vim\n  function! s:tree(dir)\n      return {a:dir : map(readdir(a:dir),\n      \\ {_, x -> isdirectory(x) ?\n      \\          {x : s:tree(a:dir .. '/' .. x)} : x})}\n  endfunction\n  echo s:tree(\".\")\n<\nReturns an empty List on error.\n\n                Parameters: ~\n                  \226\128\162 {directory} (`string`)\n                  \226\128\162 {expr} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, readfile = {binding = "readfile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname", "?type", "?max"}, ["fnl/docstring"] = "Read file {fname} and return a |List|, each line of the file\nas an item.  Lines are broken at NL characters.  Macintosh\nfiles separated with CR will result in a single long line\n(unless a NL appears somewhere).\nAll NUL characters are replaced with a NL character.\nWhen {type} contains \"b\" binary mode is used:\n- When the last line ends in a NL an extra empty list item is\n  added.\n- No CR characters are removed.\nOtherwise:\n- CR characters that appear before a NL are removed.\n- Whether the last line ends in a NL or not does not matter.\n- Any UTF-8 byte order mark is removed from the text.\nWhen {max} is given this specifies the maximum number of lines\nto be read.  Useful if you only want to check the first ten\nlines of a file: >vim\n\tfor line in readfile(fname, '', 10)\n\t  if line =~ 'Date' | echo line | endif\n\tendfor\n<\t\tWhen {max} is negative -{max} lines from the end of the file\nare returned, or as many as there are.\nWhen {max} is zero the result is an empty list.\nNote that without {max} the whole file is read into memory.\nAlso note that there is no recognition of encoding.  Read a\nfile into a buffer if you need to.\nDeprecated (use |readblob()| instead): When {type} contains\n\"B\" a |Blob| is returned with the binary data of the file\nunmodified.\nWhen the file can't be opened an error message is given and\nthe result is an empty list.\nAlso see |writefile()|.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n                  \226\128\162 {type} (`string?`)\n                  \226\128\162 {max} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, reduce = {binding = "reduce", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object", "func", "?initial"}, ["fnl/docstring"] = "{func} is called for every item in {object}, which can be a\n|String|, |List| or a |Blob|.  {func} is called with two\narguments: the result so far and current item.  After\nprocessing all items the result is returned.\n\n{initial} is the initial result.  When omitted, the first item\nin {object} is used and {func} is first called for the second\nitem.  If {initial} is not given and {object} is empty no\nresult can be computed, an E998 error is given.\n\nExamples: >vim\n\techo reduce([1, 3, 5], { acc, val -> acc + val })\n\techo reduce(['x', 'y'], { acc, val -> acc .. val }, 'a')\n\techo reduce(0z1122, { acc, val -> 2 * acc + val })\n\techo reduce('xyz', { acc, val -> acc .. ',' .. val })\n<\n\n                Parameters: ~\n                  \226\128\162 {object} (`any`)\n                  \226\128\162 {func} (`fun(accumulator: T, current: any): any`)\n                  \226\128\162 {initial} (`any?`)\n\n                Return: ~\n                  (`T`)"}}, reg_executing = {binding = "reg_executing", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the single letter name of the register being executed.\nReturns an empty string when no register is being executed.\nSee |@|.\n\n                Return: ~\n                  (`any`)"}}, reg_recorded = {binding = "reg_recorded", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the single letter name of the last recorded register.\nReturns an empty string when nothing was recorded yet.\nSee |q| and |Q|.\n\n                Return: ~\n                  (`any`)"}}, reg_recording = {binding = "reg_recording", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the single letter name of the register being recorded.\nReturns an empty string when not recording.  See |q|.\n\n                Return: ~\n                  (`any`)"}}, reltime = {binding = "reltime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?start", "?end"}, ["fnl/docstring"] = "reltime({start}, {end})\n\t\tReturn an item that represents a time value.  The item is a\n\t\tlist with items that depend on the system.\n\t\tThe item can be passed to |reltimestr()| to convert it to a\n\t\tstring or |reltimefloat()| to convert to a Float.\n\t\tWithout an argument it returns the current \"relative time\", an\n\t\timplementation-defined value meaningful only when used as an\n\t\targument to |reltime()|, |reltimestr()| and |reltimefloat()|.\n\t\tWith one argument it returns the time passed since the time\n\t\tspecified in the argument.\n\t\tWith two arguments it returns the time passed between {start}\n\t\tand {end}.\n\t\tThe {start} and {end} arguments must be values returned by\n\t\treltime().  Returns zero on error.\n\t\tNote: |localtime()| returns the current (non-relative) time.\n                Parameters: ~\n                  \226\128\162 {start} (`any?`)\n                  \226\128\162 {end} (`any?`)\n                Return: ~\n                  (`any`)"}}, reltimefloat = {binding = "reltimefloat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"time"}, ["fnl/docstring"] = "Return a Float that represents the time value of {time}.\nUnit of time is seconds.\nExample:\n\tlet start = reltime()\n\tcall MyFunction()\n\tlet seconds = reltimefloat(reltime(start))\nSee the note of reltimestr() about overhead.\nAlso see |profiling|.\nIf there is an error an empty string is returned\n\n                Parameters: ~\n                  \226\128\162 {time} (`any`)\n\n                Return: ~\n                  (`any`)"}}, reltimestr = {binding = "reltimestr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"time"}, ["fnl/docstring"] = "Return a String that represents the time value of {time}.\nThis is the number of seconds, a dot and the number of\nmicroseconds.  Example: >vim\n\tlet start = reltime()\n\tcall MyFunction()\n\techo reltimestr(reltime(start))\n<\t\tNote that overhead for the commands will be added to the time.\nLeading spaces are used to make the string align nicely.  You\ncan use split() to remove it. >vim\n\techo split(reltimestr(reltime(start)))[0]\n<\t\tAlso see |profiling|.\nIf there is an error an empty string is returned\n\n                Parameters: ~\n                  \226\128\162 {time} (`any`)\n\n                Return: ~\n                  (`any`)"}}, remove = {binding = "remove", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "idx", "?end"}, ["fnl/docstring"] = "Without {end}: Remove the item at {idx} from |List| {list} and\nreturn the item.\nWith {end}: Remove items from {idx} to {end} (inclusive) and\nreturn a |List| with these items.  When {idx} points to the same\nitem as {end} a list with one item is returned.  When {end}\npoints to an item before {idx} this is an error.\nSee |list-index| for possible values of {idx} and {end}.\nReturns zero on error.\nExample: >vim\n\techo \"last item: \" .. remove(mylist, -1)\n\tcall remove(mylist, 0, 9)\n<\nUse |delete()| to remove a file.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n                  \226\128\162 {idx} (`integer`)\n                  \226\128\162 {end} (`integer?`)\n\n                Return: ~\n                  (`any`)\n\nremove({blob}, {idx})\nremove({blob}, {idx}, {end})\nWithout {end}: Remove the byte at {idx} from |Blob| {blob} and\nreturn the byte.\nWith {end}: Remove bytes from {idx} to {end} (inclusive) and\nreturn a |Blob| with these bytes.  When {idx} points to the same\nbyte as {end} a |Blob| with one byte is returned.  When {end}\npoints to a byte before {idx} this is an error.\nReturns zero on error.\nExample: >vim\n\techo \"last byte: \" .. remove(myblob, -1)\n\tcall remove(mylist, 0, 9)\n<\n\n                Parameters: ~\n                  \226\128\162 {blob} (`any`)\n                  \226\128\162 {idx} (`integer`)\n                  \226\128\162 {end} (`integer?`)\n\n                Return: ~\n                  (`any`)\n\nremove({dict}, {key})\nRemove the entry from {dict} with key {key} and return it.\nExample: >vim\n\techo \"removed \" .. remove(dict, \"one\")\n<\t\tIf there is no {key} in {dict} this is an error.\nReturns zero on error.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`any`)\n                  \226\128\162 {key} (`string`)\n\n                Return: ~\n                  (`any`)"}}, rename = {binding = "rename", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"from", "to"}, ["fnl/docstring"] = "Rename the file by the name {from} to the name {to}.  This\nshould also work to move files across file systems.  The\nresult is a Number, which is 0 if the file was renamed\nsuccessfully, and non-zero when the renaming failed.\nNOTE: If {to} exists it is overwritten without warning.\nThis function is not available in the |sandbox|.\n\n                Parameters: ~\n                  \226\128\162 {from} (`string`)\n                  \226\128\162 {to} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, ["repeat"] = {binding = "repeat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "count"}, ["fnl/docstring"] = "Repeat {expr} {count} times and return the concatenated\nresult.  Example: >vim\n\tlet separator = repeat('-', 80)\n<\t\tWhen {count} is zero or negative the result is empty.\nWhen {expr} is a |List| or a |Blob| the result is {expr}\nconcatenated {count} times.  Example: >vim\n\tlet longlist = repeat(['a', 'b'], 3)\n<\t\tResults in ['a', 'b', 'a', 'b', 'a', 'b'].\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {count} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, resolve = {binding = "resolve", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"filename"}, ["fnl/docstring"] = "On MS-Windows, when {filename} is a shortcut (a .lnk file),\nreturns the path the shortcut points to in a simplified form.\nOn Unix, repeat resolving symbolic links in all path\ncomponents of {filename} and return the simplified result.\nTo cope with link cycles, resolving of symbolic links is\nstopped after 100 iterations.\nOn other systems, return the simplified {filename}.\nThe simplification step is done as by |simplify()|.\nresolve() keeps a leading path component specifying the\ncurrent directory (provided the result is still a relative\npath name) and also keeps a trailing path separator.\n\n                Parameters: ~\n                  \226\128\162 {filename} (`string`)\n\n                Return: ~\n                  (`string`)"}}, reverse = {binding = "reverse", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object"}, ["fnl/docstring"] = "Reverse the order of items in {object}.  {object} can be a\n|List|, a |Blob| or a |String|.  For a List and a Blob the\nitems are reversed in-place and {object} is returned.\nFor a String a new String is returned.\nReturns zero if {object} is not a List, Blob or a String.\nIf you want a List or Blob to remain unmodified make a copy\nfirst: >vim\n\tlet revlist = reverse(copy(mylist))\n<\n\n                Parameters: ~\n                  \226\128\162 {object} (`T[]`)\n\n                Return: ~\n                  (`T[]`)"}}, round = {binding = "round", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Round off {expr} to the nearest integral value and return it\nas a |Float|.  If {expr} lies halfway between two integral\nvalues, then use the larger one (away from zero).\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo round(0.456)\n<\t\t\0090.0  >vim\n\techo round(4.5)\n<\t\t\0095.0 >vim\n\techo round(-4.5)\n<\t\t\t-5.0\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, rpcnotify = {binding = "rpcnotify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"channel", "event", "..."}, ["fnl/docstring"] = "Sends {event} to {channel} via |RPC| and returns immediately.\nIf {channel} is 0, the event is broadcast to all channels.\nExample: >vim\n\tau VimLeave call rpcnotify(0, \"leaving\")\n<\n\n                Parameters: ~\n                  \226\128\162 {channel} (`integer`)\n                  \226\128\162 {event} (`string`)\n                  \226\128\162 {...} (`any`)\n\n                Return: ~\n                  (`integer`)"}}, rpcrequest = {binding = "rpcrequest", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"channel", "method", "..."}, ["fnl/docstring"] = "Sends a request to {channel} to invoke {method} via\n|RPC| and blocks until a response is received.\nExample: >vim\n\tlet result = rpcrequest(rpc_chan, \"func\", 1, 2, 3)\n<\n\n                Parameters: ~\n                  \226\128\162 {channel} (`integer`)\n                  \226\128\162 {method} (`string`)\n                  \226\128\162 {...} (`any`)\n\n                Return: ~\n                  (`any`)"}}, rubyeval = {binding = "rubyeval", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Evaluate Ruby expression {expr} and return its result\nconverted to Vim data structures.\nNumbers, floats and strings are returned as they are (strings\nare copied though).\nArrays are represented as Vim |List| type.\nHashes are represented as Vim |Dictionary| type.\nOther objects are represented as strings resulted from their\n\"Object#to_s\" method.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`any`)"}}, screenattr = {binding = "screenattr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"row", "col"}, ["fnl/docstring"] = "Like |screenchar()|, but return the attribute.  This is a rather\narbitrary number that can only be used to compare to the\nattribute at other positions.\nReturns -1 when row or col is out of range.\n\n                Parameters: ~\n                  \226\128\162 {row} (`integer`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, screenchar = {binding = "screenchar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"row", "col"}, ["fnl/docstring"] = "The result is a Number, which is the character at position\n[row, col] on the screen.  This works for every possible\nscreen position, also status lines, window separators and the\ncommand line.  The top left position is row one, column one\nThe character excludes composing characters.  For double-byte\nencodings it may only be the first byte.\nThis is mainly to be used for testing.\nReturns -1 when row or col is out of range.\n\n                Parameters: ~\n                  \226\128\162 {row} (`integer`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, screenchars = {binding = "screenchars", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"row", "col"}, ["fnl/docstring"] = "The result is a |List| of Numbers.  The first number is the same\nas what |screenchar()| returns.  Further numbers are\ncomposing characters on top of the base character.\nThis is mainly to be used for testing.\nReturns an empty List when row or col is out of range.\n\n                Parameters: ~\n                  \226\128\162 {row} (`integer`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`integer[]`)"}}, screencol = {binding = "screencol", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number, which is the current screen column of\nthe cursor. The leftmost column has number 1.\nThis function is mainly used for testing.\n\nNote: Always returns the current screen column, thus if used\nin a command (e.g. \":echo screencol()\") it will return the\ncolumn inside the command line, which is 1 when the command is\nexecuted. To get the cursor position in the file use one of\nthe following mappings: >vim\n\tnnoremap <expr> GG \":echom \" .. screencol() .. \"\\n\"\n\tnnoremap <silent> GG :echom screencol()<CR>\n\tnoremap GG <Cmd>echom screencol()<CR>\n<\n\n                Return: ~\n                  (`integer[]`)"}}, screenpos = {binding = "screenpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"winid", "lnum", "col"}, ["fnl/docstring"] = "The result is a Dict with the screen position of the text\ncharacter in window {winid} at buffer line {lnum} and column\n{col}.  {col} is a one-based byte index.\nThe Dict has these members:\n\trow\tscreen row\n\tcol\tfirst screen column\n\tendcol\tlast screen column\n\tcurscol\tcursor screen column\nIf the specified position is not visible, all values are zero.\nThe \"endcol\" value differs from \"col\" when the character\noccupies more than one screen cell.  E.g. for a Tab \"col\" can\nbe 1 and \"endcol\" can be 8.\nThe \"curscol\" value is where the cursor would be placed.  For\na Tab it would be the same as \"endcol\", while for a double\nwidth character it would be the same as \"col\".\nThe |conceal| feature is ignored here, the column numbers are\nas if 'conceallevel' is zero.  You can set the cursor to the\nright position and use |screencol()| to get the value with\n|conceal| taken into account.\nIf the position is in a closed fold the screen position of the\nfirst character is returned, {col} is not used.\nReturns an empty Dict if {winid} is invalid.\n\n                Parameters: ~\n                  \226\128\162 {winid} (`integer`)\n                  \226\128\162 {lnum} (`integer`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, screenrow = {binding = "screenrow", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number, which is the current screen row of the\ncursor.  The top line has number one.\nThis function is mainly used for testing.\nAlternatively you can use |winline()|.\n\nNote: Same restrictions as with |screencol()|.\n\n                Return: ~\n                  (`integer`)"}}, screenstring = {binding = "screenstring", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"row", "col"}, ["fnl/docstring"] = "The result is a String that contains the base character and\nany composing characters at position [row, col] on the screen.\nThis is like |screenchars()| but returning a String with the\ncharacters.\nThis is mainly to be used for testing.\nReturns an empty String when row or col is out of range.\n\n                Parameters: ~\n                  \226\128\162 {row} (`integer`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`string`)"}}, search = {binding = "search", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern", "?flags", "?stopline", "?timeout", "?skip"}, ["fnl/docstring"] = "Search for regexp pattern {pattern}.  The search starts at the\ncursor position (you can use |cursor()| to set it).\n\nWhen a match has been found its line number is returned.\nIf there is no match a 0 is returned and the cursor doesn't\nmove.  No error message is given.\nTo get the matched string, use |matchbufline()|.\n\n{flags} is a String, which can contain these character flags:\n'b'\tsearch Backward instead of forward\n'c'\taccept a match at the Cursor position\n'e'\tmove to the End of the match\n'n'\tdo Not move the cursor\n'p'\treturn number of matching sub-Pattern (see below)\n's'\tSet the ' mark at the previous location of the cursor\n'w'\tWrap around the end of the file\n'W'\tdon't Wrap around the end of the file\n'z'\tstart searching at the cursor column instead of Zero\nIf neither 'w' or 'W' is given, the 'wrapscan' option applies.\n\nIf the 's' flag is supplied, the ' mark is set, only if the\ncursor is moved. The 's' flag cannot be combined with the 'n'\nflag.\n\n'ignorecase', 'smartcase' and 'magic' are used.\n\nWhen the 'z' flag is not given, forward searching always\nstarts in column zero and then matches before the cursor are\nskipped.  When the 'c' flag is present in 'cpo' the next\nsearch starts after the match.  Without the 'c' flag the next\nsearch starts one column after the start of the match.  This\nmatters for overlapping matches.  See |cpo-c|.  You can also\ninsert \"\\ze\" to change where the match ends, see  |/\\ze|.\n\nWhen searching backwards and the 'z' flag is given then the\nsearch starts in column zero, thus no match in the current\nline will be found (unless wrapping around the end of the\nfile).\n\nWhen the {stopline} argument is given then the search stops\nafter searching this line.  This is useful to restrict the\nsearch to a range of lines.  Examples: >vim\n\tlet match = search('(', 'b', line(\"w0\"))\n\tlet end = search('END', '', line(\"w$\"))\n<\t\tWhen {stopline} is used and it is not zero this also implies\nthat the search does not wrap around the end of the file.\nA zero value is equal to not giving the argument.\n\nWhen the {timeout} argument is given the search stops when\nmore than this many milliseconds have passed.  Thus when\n{timeout} is 500 the search stops after half a second.\nThe value must not be negative.  A zero value is like not\ngiving the argument.\n\nNote: the timeout is only considered when searching, not\nwhile evaluating the {skip} expression.\n\nIf the {skip} expression is given it is evaluated with the\ncursor positioned on the start of a match.  If it evaluates to\nnon-zero this match is skipped.  This can be used, for\nexample, to skip a match in a comment or a string.\n{skip} can be a string, which is evaluated as an expression, a\nfunction reference or a lambda.\nWhen {skip} is omitted or empty, every match is accepted.\nWhen evaluating {skip} causes an error the search is aborted\nand -1 returned.\n\t\t\t\t\t*search()-sub-match*\nWith the 'p' flag the returned value is one more than the\nfirst sub-match in \\(\\).  One if none of them matched but the\nwhole pattern did match.\nTo get the column number too use |searchpos()|.\n\nThe cursor will be positioned at the match, unless the 'n'\nflag is used.\n\nExample (goes over all files in the argument list): >vim\n    let n = 1\n    while n <= argc()\t    \" loop over all files in arglist\n      exe \"argument \" .. n\n      \" start at the last char in the file and wrap for the\n      \" first search to find match at start of file\n      normal G$\n      let flags = \"w\"\n      while search(\"foo\", flags) > 0\n        s/foo/bar/g\n        let flags = \"W\"\n      endwhile\n      update\t\t    \" write the file if modified\n      let n = n + 1\n    endwhile\n<\nExample for using some flags: >vim\n    echo search('\\<if\\|\\(else\\)\\|\\(endif\\)', 'ncpe')\n<\t\tThis will search for the keywords \"if\", \"else\", and \"endif\"\nunder or after the cursor.  Because of the 'p' flag, it\nreturns 1, 2, or 3 depending on which keyword is found, or 0\nif the search fails.  With the cursor on the first word of the\nline:\n    if (foo == 0) | let foo = foo + 1 | endif ~\nthe function returns 1.  Without the 'c' flag, the function\nfinds the \"endif\" and returns 3.  The same thing happens\nwithout the 'e' flag if the cursor is on the \"f\" of \"if\".\nThe 'n' flag tells the function not to move the cursor.\n\n                Parameters: ~\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {flags} (`string?`)\n                  \226\128\162 {stopline} (`integer?`)\n                  \226\128\162 {timeout} (`integer?`)\n                  \226\128\162 {skip} (`string|function?`)\n\n                Return: ~\n                  (`integer`)"}}, searchcount = {binding = "searchcount", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?options"}, ["fnl/docstring"] = "Get or update the last search count, like what is displayed\nwithout the \"S\" flag in 'shortmess'.  This works even if\n'shortmess' does contain the \"S\" flag.\n\nThis returns a |Dictionary|. The dictionary is empty if the\nprevious pattern was not set and \"pattern\" was not specified.\n\n  key\t\ttype\t\tmeaning ~\n  current\t|Number|\tcurrent position of match;\n\t\t\t\0090 if the cursor position is\n\t\t\t\tbefore the first match\n  exact_match\t|Boolean|\0091 if \"current\" is matched on\n\t\t\t\t\"pos\", otherwise 0\n  total\t\t|Number|\ttotal count of matches found\n  incomplete\t|Number|\0090: search was fully completed\n\t\t\t\0091: recomputing was timed out\n\t\t\t\0092: max count exceeded\n\nFor {options} see further down.\n\nTo get the last search count when |n| or |N| was pressed, call\nthis function with `recompute: 0` . This sometimes returns\nwrong information because |n| and |N|'s maximum count is 99.\nIf it exceeded 99 the result must be max count + 1 (100). If\nyou want to get correct information, specify `recompute: 1`: >vim\n\n\t\" result == maxcount + 1 (100) when many matches\n\tlet result = searchcount(#{recompute: 0})\n\n\t\" Below returns correct result (recompute defaults\n\t\" to 1)\n\tlet result = searchcount()\n<\nThe function is useful to add the count to 'statusline': >vim\n\tfunction! LastSearchCount() abort\n\t  let result = searchcount(#{recompute: 0})\n\t  if empty(result)\n\t    return ''\n\t  endif\n\t  if result.incomplete ==# 1     \" timed out\n\t    return printf(' /%s [?/??]', @/)\n\t  elseif result.incomplete ==# 2 \" max count exceeded\n\t    if result.total > result.maxcount &&\n\t    \\  result.current > result.maxcount\n\t      return printf(' /%s [>%d/>%d]', @/,\n\t      \\             result.current, result.total)\n\t    elseif result.total > result.maxcount\n\t      return printf(' /%s [%d/>%d]', @/,\n\t      \\             result.current, result.total)\n\t    endif\n\t  endif\n\t  return printf(' /%s [%d/%d]', @/,\n\t  \\             result.current, result.total)\n\tendfunction\n\tlet &statusline ..= '%{LastSearchCount()}'\n\n\t\" Or if you want to show the count only when\n\t\" 'hlsearch' was on\n\t\" let &statusline ..=\n\t\" \\   '%{v:hlsearch ? LastSearchCount() : \"\"}'\n<\nYou can also update the search count, which can be useful in a\n|CursorMoved| or |CursorMovedI| autocommand: >vim\n\n\tautocmd CursorMoved,CursorMovedI *\n\t  \\ let s:searchcount_timer = timer_start(\n\t  \\   200, function('s:update_searchcount'))\n\tfunction! s:update_searchcount(timer) abort\n\t  if a:timer ==# s:searchcount_timer\n\t    call searchcount(#{\n\t    \\ recompute: 1, maxcount: 0, timeout: 100})\n\t    redrawstatus\n\t  endif\n\tendfunction\n<\nThis can also be used to count matched texts with specified\npattern in the current buffer using \"pattern\":  >vim\n\n\t\" Count '\\<foo\\>' in this buffer\n\t\" (Note that it also updates search count)\n\tlet result = searchcount(#{pattern: '\\<foo\\>'})\n\n\t\" To restore old search count by old pattern,\n\t\" search again\n\tcall searchcount()\n<\n{options} must be a |Dictionary|. It can contain:\n  key\t\ttype\t\tmeaning ~\n  recompute\t|Boolean|\tif |TRUE|, recompute the count\n\t\t\t\tlike |n| or |N| was executed.\n\t\t\t\totherwise returns the last\n\t\t\t\tcomputed result (when |n| or\n\t\t\t\t|N| was used when \"S\" is not\n\t\t\t\tin 'shortmess', or this\n\t\t\t\tfunction was called).\n\t\t\t\t(default: |TRUE|)\n  pattern\t|String|\trecompute if this was given\n\t\t\t\tand different with |@/|.\n\t\t\t\tthis works as same as the\n\t\t\t\tbelow command is executed\n\t\t\t\tbefore calling this function >vim\n\t\t\t\t  let @/ = pattern\n<\t\t\t\t\t\t(default: |@/|)\n  timeout\t|Number|\0090 or negative number is no\n\t\t\t\ttimeout. timeout milliseconds\n\t\t\t\tfor recomputing the result\n\t\t\t\t(default: 0)\n  maxcount\t|Number|\0090 or negative number is no\n\t\t\t\tlimit. max count of matched\n\t\t\t\ttext while recomputing the\n\t\t\t\tresult.  if search exceeded\n\t\t\t\ttotal count, \"total\" value\n\t\t\t\tbecomes `maxcount + 1`\n\t\t\t\t(default: 0)\n  pos\t\t|List|\t\t`[lnum, col, off]` value\n\t\t\t\twhen recomputing the result.\n\t\t\t\tthis changes \"current\" result\n\t\t\t\tvalue. see |cursor()|, |getpos()|\n\t\t\t\t(default: cursor's position)\n\n                Parameters: ~\n                  \226\128\162 {options} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, searchdecl = {binding = "searchdecl", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?global", "?thisblock"}, ["fnl/docstring"] = "Search for the declaration of {name}.\n\nWith a non-zero {global} argument it works like |gD|, find\nfirst match in the file.  Otherwise it works like |gd|, find\nfirst match in the function.\n\nWith a non-zero {thisblock} argument matches in a {} block\nthat ends before the cursor position are ignored.  Avoids\nfinding variable declarations only valid in another scope.\n\nMoves the cursor to the found match.\nReturns zero for success, non-zero for failure.\nExample: >vim\n\tif searchdecl('myvar') == 0\n\t   echo getline('.')\n\tendif\n<\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {global} (`boolean?`)\n                  \226\128\162 {thisblock} (`boolean?`)\n\n                Return: ~\n                  (`any`)\n\n                                                                  "}}, searchpair = {binding = "searchpair", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"start", "middle", "end", "?flags", "?skip", "?stopline", "?timeout"}, ["fnl/docstring"] = "Search for the match of a nested start-end pair.  This can be\nused to find the \"endif\" that matches an \"if\", while other\nif/endif pairs in between are ignored.\nThe search starts at the cursor.  The default is to search\nforward, include 'b' in {flags} to search backward.\nIf a match is found, the cursor is positioned at it and the\nline number is returned.  If no match is found 0 or -1 is\nreturned and the cursor doesn't move.  No error message is\ngiven.\n\n{start}, {middle} and {end} are patterns, see |pattern|.  They\nmust not contain \\( \\) pairs.  Use of \\%( \\) is allowed.  When\n{middle} is not empty, it is found when searching from either\ndirection, but only when not in a nested start-end pair.  A\ntypical use is: >vim\n\techo searchpair('\\<if\\>', '\\<else\\>', '\\<endif\\>')\n<\t\tBy leaving {middle} empty the \"else\" is skipped.\n\n{flags} 'b', 'c', 'n', 's', 'w' and 'W' are used like with\n|search()|.  Additionally:\n'r'\tRepeat until no more matches found; will find the\n\touter pair.  Implies the 'W' flag.\n'm'\tReturn number of matches instead of line number with\n\tthe match; will be > 1 when 'r' is used.\nNote: it's nearly always a good idea to use the 'W' flag, to\navoid wrapping around the end of the file.\n\nWhen a match for {start}, {middle} or {end} is found, the\n{skip} expression is evaluated with the cursor positioned on\nthe start of the match.  It should return non-zero if this\nmatch is to be skipped.  E.g., because it is inside a comment\nor a string.\nWhen {skip} is omitted or empty, every match is accepted.\nWhen evaluating {skip} causes an error the search is aborted\nand -1 returned.\n{skip} can be a string, a lambda, a funcref or a partial.\nAnything else makes the function fail.\n\nFor {stopline} and {timeout} see |search()|.\n\nThe value of 'ignorecase' is used.  'magic' is ignored, the\npatterns are used like it's on.\n\nThe search starts exactly at the cursor.  A match with\n{start}, {middle} or {end} at the next character, in the\ndirection of searching, is the first one found.  Example: >vim\n\tif 1\n\t  if 2\n\t  endif 2\n\tendif 1\n<\t\tWhen starting at the \"if 2\", with the cursor on the \"i\", and\nsearching forwards, the \"endif 2\" is found.  When starting on\nthe character just before the \"if 2\", the \"endif 1\" will be\nfound.  That's because the \"if 2\" will be found first, and\nthen this is considered to be a nested if/endif from \"if 2\" to\n\"endif 2\".\nWhen searching backwards and {end} is more than one character,\nit may be useful to put \"\\zs\" at the end of the pattern, so\nthat when the cursor is inside a match with the end it finds\nthe matching start.\n\nExample, to find the \"endif\" command in a Vim script: >vim\n\n\techo searchpair('\\<if\\>', '\\<el\\%[seif]\\>', '\\<en\\%[dif]\\>', 'W',\n\t\\ 'getline(\".\") =~ \"^\\\\s*\\\"\"')\n\n<\t\tThe cursor must be at or after the \"if\" for which a match is\nto be found.  Note that single-quote strings are used to avoid\nhaving to double the backslashes.  The skip expression only\ncatches comments at the start of a line, not after a command.\nAlso, a word \"en\" or \"if\" halfway through a line is considered\na match.\nAnother example, to search for the matching \"{\" of a \"}\": >vim\n\n\techo searchpair('{', '', '}', 'bW')\n\n<\t\tThis works when the cursor is at or before the \"}\" for which a\nmatch is to be found.  To reject matches that syntax\nhighlighting recognized as strings: >vim\n\n\techo searchpair('{', '', '}', 'bW',\n\t     \\ 'synIDattr(synID(line(\".\"), col(\".\"), 0), \"name\") =~? \"string\"')\n<\n\n                Parameters: ~\n                  \226\128\162 {start} (`string`)\n                  \226\128\162 {middle} (`string`)\n                  \226\128\162 {end} (`string`)\n                  \226\128\162 {flags} (`string?`)\n                  \226\128\162 {skip} (`string|function?`)\n                  \226\128\162 {stopline} (`integer?`)\n                  \226\128\162 {timeout} (`integer?`)\n\n                Return: ~\n                  (`integer`)\n\n                                                               "}}, searchpairpos = {binding = "searchpairpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"start", "middle", "end", "?flags", "?skip", "?stopline", "?timeout"}, ["fnl/docstring"] = "Same as |searchpair()|, but returns a |List| with the line and\ncolumn position of the match. The first element of the |List|\nis the line number and the second element is the byte index of\nthe column position of the match.  If no match is found,\nreturns [0, 0]. >vim\n\n\tlet [lnum,col] = searchpairpos('{', '', '}', 'n')\n<\nSee |match-parens| for a bigger and more useful example.\n\n                Parameters: ~\n                  \226\128\162 {start} (`string`)\n                  \226\128\162 {middle} (`string`)\n                  \226\128\162 {end} (`string`)\n                  \226\128\162 {flags} (`string?`)\n                  \226\128\162 {skip} (`string|function?`)\n                  \226\128\162 {stopline} (`integer?`)\n                  \226\128\162 {timeout} (`integer?`)\n\n                Return: ~\n                  (`[integer, integer]`)\n\n                                                                   "}}, searchpos = {binding = "searchpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern", "?flags", "?stopline", "?timeout", "?skip"}, ["fnl/docstring"] = "Same as |search()|, but returns a |List| with the line and\ncolumn position of the match. The first element of the |List|\nis the line number and the second element is the byte index of\nthe column position of the match. If no match is found,\nreturns [0, 0].\nExample: >vim\n\tlet [lnum, col] = searchpos('mypattern', 'n')\n\n<\t\tWhen the 'p' flag is given then there is an extra item with\nthe sub-pattern match number |search()-sub-match|.  Example: >vim\n\tlet [lnum, col, submatch] = searchpos('\\(\\l\\)\\|\\(\\u\\)', 'np')\n<\t\tIn this example \"submatch\" is 2 when a lowercase letter is\nfound |/\\l|, 3 when an uppercase letter is found |/\\u|.\n\n                Parameters: ~\n                  \226\128\162 {pattern} (`string`)\n                  \226\128\162 {flags} (`string?`)\n                  \226\128\162 {stopline} (`integer?`)\n                  \226\128\162 {timeout} (`integer?`)\n                  \226\128\162 {skip} (`string|function?`)\n\n                Return: ~\n                  (`any`)"}}, serverlist = {binding = "serverlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a list of server addresses, or empty if all servers\nwere stopped. |serverstart()| |serverstop()|\nExample: >vim\n\techo serverlist()\n<\n\n                Return: ~\n                  (`string[]`)"}}, serverstart = {binding = "serverstart", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?address"}, ["fnl/docstring"] = "Opens a socket or named pipe at {address} and listens for\n|RPC| messages. Clients can send |API| commands to the\nreturned address to control Nvim.\n\nReturns the address string (which may differ from the\n{address} argument, see below).\n\n- If {address} has a colon (\":\") it is a TCP/IPv4/IPv6 address\n  where the last \":\" separates host and port (empty or zero\n  assigns a random port).\n- Else {address} is the path to a named pipe (except on Windows).\n  - If {address} has no slashes (\"/\") it is treated as the\n    \"name\" part of a generated path in this format: >vim\n\tstdpath(\"run\")..\"/{name}.{pid}.{counter}\"\n<\t\t  - If {address} is omitted the name is \"nvim\". >vim\n\techo serverstart()\n<\t\t >\n\t=> /tmp/nvim.bram/oknANW/nvim.15430.5\n<\nExample bash command to list all Nvim servers: >bash\n\tls ${XDG_RUNTIME_DIR:-${TMPDIR}nvim.${USER}}/*/nvim.*.0\n\n<\t\tExample named pipe: >vim\n\tif has('win32')\n\t  echo serverstart('\\\\.\\pipe\\nvim-pipe-1234')\n\telse\n\t  echo serverstart('nvim.sock')\n\tendif\n<\nExample TCP/IP address: >vim\n\techo serverstart('::1:12345')\n<\n\n                Parameters: ~\n                  \226\128\162 {address} (`string?`)\n\n                Return: ~\n                  (`string`)"}}, serverstop = {binding = "serverstop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"address"}, ["fnl/docstring"] = "Closes the pipe or socket at {address}.\nReturns TRUE if {address} is valid, else FALSE.\nIf |v:servername| is stopped it is set to the next available\naddress in |serverlist()|.\n\n                Parameters: ~\n                  \226\128\162 {address} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, setbufline = {binding = "setbufline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "lnum", "text"}, ["fnl/docstring"] = "Set line {lnum} to {text} in buffer {buf}.  This works like\n|setline()| for the specified buffer.\n\nThis function works only for loaded buffers. First call\n|bufload()| if needed.\n\nTo insert lines use |appendbufline()|.\n\n{text} can be a string to set one line, or a List of strings\nto set multiple lines.  If the List extends below the last\nline then those lines are added.  If the List is empty then\nnothing is changed and zero is returned.\n\nFor the use of {buf}, see |bufname()| above.\n\n{lnum} is used like with |setline()|.\nUse \"$\" to refer to the last line in buffer {buf}.\nWhen {lnum} is just below the last line the {text} will be\nadded below the last line.\nOn success 0 is returned, on failure 1 is returned.\n\nIf {buf} is not a valid buffer or {lnum} is not valid, an\nerror message is given.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {lnum} (`integer`)\n                  \226\128\162 {text} (`string|string[]`)\n\n                Return: ~\n                  (`integer`)"}}, setbufvar = {binding = "setbufvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "varname", "val"}, ["fnl/docstring"] = "Set option or local variable {varname} in buffer {buf} to\n{val}.\nThis also works for a global or local window option, but it\ndoesn't work for a global or local window variable.\nFor a local window option the global value is unchanged.\nFor the use of {buf}, see |bufname()| above.\nThe {varname} argument is a string.\nNote that the variable name without \"b:\" must be used.\nExamples: >vim\n\tcall setbufvar(1, \"&mod\", 1)\n\tcall setbufvar(\"todo\", \"myvar\", \"foobar\")\n<\t\tThis function is not available in the |sandbox|.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {val} (`any`)\n\n                Return: ~\n                  (`any`)"}}, setcellwidths = {binding = "setcellwidths", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Specify overrides for cell widths of character ranges.  This\ntells Vim how wide characters are when displayed in the\nterminal, counted in screen cells.  The values override\n'ambiwidth'.  Example: >vim\n   call setcellwidths([\n\t\t\\ [0x111, 0x111, 1],\n\t\t\\ [0x2194, 0x2199, 2],\n\t\t\\ ])\n\n<\t\tThe {list} argument is a List of Lists with each three\nnumbers: [{low}, {high}, {width}].\t*E1109* *E1110*\n{low} and {high} can be the same, in which case this refers to\none character.  Otherwise it is the range of characters from\n{low} to {high} (inclusive).\t\t*E1111* *E1114*\nOnly characters with value 0x80 and higher can be used.\n\n{width} must be either 1 or 2, indicating the character width\nin screen cells.\t\t\t*E1112*\nAn error is given if the argument is invalid, also when a\nrange overlaps with another.\t\t*E1113*\n\nIf the new value causes 'fillchars' or 'listchars' to become\ninvalid it is rejected and an error is given.\n\nTo clear the overrides pass an empty {list}: >vim\n   call setcellwidths([])\n\n<\t\tYou can use the script $VIMRUNTIME/scripts/emoji_list.lua to see\nthe effect for known emoji characters.  Move the cursor\nthrough the text to check if the cell widths of your terminal\nmatch with what Vim knows about each emoji.  If it doesn't\nlook right you need to adjust the {list} argument.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any[]`)\n\n                Return: ~\n                  (`any`)"}}, setcharpos = {binding = "setcharpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "list"}, ["fnl/docstring"] = "Same as |setpos()| but uses the specified column number as the\ncharacter index instead of the byte index in the line.\n\nExample:\nWith the text \"\236\151\172\235\179\180\236\132\184\236\154\148\" in line 8: >vim\n\tcall setcharpos('.', [0, 8, 4, 0])\n<\t\tpositions the cursor on the fourth character '\236\154\148'. >vim\n\tcall setpos('.', [0, 8, 4, 0])\n<\t\tpositions the cursor on the second character '\235\179\180'.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n                  \226\128\162 {list} (`integer[]`)\n\n                Return: ~\n                  (`any`)"}}, setcharsearch = {binding = "setcharsearch", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Set the current character search information to {dict},\nwhich contains one or more of the following entries:\n\n    char\tcharacter which will be used for a subsequent\n\t\t|,| or |;| command; an empty string clears the\n\t\tcharacter search\n    forward\tdirection of character search; 1 for forward,\n\t\0090 for backward\n    until\ttype of character search; 1 for a |t| or |T|\n\t\tcharacter search, 0 for an |f| or |F|\n\t\tcharacter search\n\nThis can be useful to save/restore a user's character search\nfrom a script: >vim\n\tlet prevsearch = getcharsearch()\n\t\" Perform a command which clobbers user's search\n\tcall setcharsearch(prevsearch)\n<\t\tAlso see |getcharsearch()|.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`string`)\n\n                Return: ~\n                  (`any`)"}}, setcmdline = {binding = "setcmdline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "?pos"}, ["fnl/docstring"] = "Set the command line to {str} and set the cursor position to\n{pos}.\nIf {pos} is omitted, the cursor is positioned after the text.\nReturns 0 when successful, 1 when not editing the command\nline.\n\n                Parameters: ~\n                  \226\128\162 {str} (`string`)\n                  \226\128\162 {pos} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, setcmdpos = {binding = "setcmdpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pos"}, ["fnl/docstring"] = "Set the cursor position in the command line to byte position\n{pos}.  The first position is 1.\nUse |getcmdpos()| to obtain the current position.\nOnly works while editing the command line, thus you must use\n|c_CTRL-\\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with '='.  For\n|c_CTRL-\\_e| and |c_CTRL-R_CTRL-R| with '=' the position is\nset after the command line is set to the expression.  For\n|c_CTRL-R_=| it is set after evaluating the expression but\nbefore inserting the resulting text.\nWhen the number is too big the cursor is put at the end of the\nline.  A number smaller than one has undefined results.\nReturns 0 when successful, 1 when not editing the command\nline.\n\n                Parameters: ~\n                  \226\128\162 {pos} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, setcursorcharpos = {binding = "setcursorcharpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Same as |cursor()| but uses the specified column number as the\ncharacter index instead of the byte index in the line.\n\nExample:\nWith the text \"\236\151\172\235\179\180\236\132\184\236\154\148\" in line 4: >vim\n\tcall setcursorcharpos(4, 3)\n<\t\tpositions the cursor on the third character '\236\132\184'. >vim\n\tcall cursor(4, 3)\n<\t\tpositions the cursor on the first character '\236\151\172'.\n\n                Parameters: ~\n                  \226\128\162 {list} (`integer[]`)\n\n                Return: ~\n                  (`any`)"}}, setenv = {binding = "setenv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "val"}, ["fnl/docstring"] = "Set environment variable {name} to {val}.  Example: >vim\n\tcall setenv('HOME', '/home/myhome')\n\n<\t\tWhen {val} is |v:null| the environment variable is deleted.\nSee also |expr-env|.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {val} (`string`)\n\n                Return: ~\n                  (`any`)"}}, setfperm = {binding = "setfperm", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname", "mode"}, ["fnl/docstring"] = "Set the file permissions for {fname} to {mode}.\n{mode} must be a string with 9 characters.  It is of the form\n\"rwxrwxrwx\", where each group of \"rwx\" flags represent, in\nturn, the permissions of the owner of the file, the group the\nfile belongs to, and other users.  A '-' character means the\npermission is off, any other character means on.  Multi-byte\ncharacters are not supported.\n\nFor example \"rw-r-----\" means read-write for the user,\nreadable by the group, not accessible by others.  \"xx-x-----\"\nwould do the same thing.\n\nReturns non-zero for success, zero for failure.\n\nTo read permissions see |getfperm()|.\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n                  \226\128\162 {mode} (`string`)\n\n                Return: ~\n                  (`any`)"}}, setline = {binding = "setline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "text"}, ["fnl/docstring"] = "Set line {lnum} of the current buffer to {text}.  To insert\nlines use |append()|. To set lines in another buffer use\n|setbufline()|.\n\n{lnum} is used like with |getline()|.\nWhen {lnum} is just below the last line the {text} will be\nadded below the last line.\n{text} can be any type or a List of any type, each item is\nconverted to a String.  When {text} is an empty List then\nnothing is changed and FALSE is returned.\n\nIf this succeeds, FALSE is returned.  If this fails (most likely\nbecause {lnum} is invalid) TRUE is returned.\n\nExample: >vim\n\tcall setline(5, strftime(\"%c\"))\n\n<\t\tWhen {text} is a |List| then line {lnum} and following lines\nwill be set to the items in the list.  Example: >vim\n\tcall setline(5, ['aaa', 'bbb', 'ccc'])\n<\t\tThis is equivalent to: >vim\n\tfor [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]\n\t  call setline(n, l)\n\tendfor\n\n<\t\tNote: The '[ and '] marks are not set.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {text} (`any`)\n\n                Return: ~\n                  (`any`)"}}, setloclist = {binding = "setloclist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "list", "?action", "?what"}, ["fnl/docstring"] = "Create or replace or add to the location list for window {nr}.\n{nr} can be the window number or the |window-ID|.\nWhen {nr} is zero the current window is used.\n\nFor a location list window, the displayed location list is\nmodified.  For an invalid window number {nr}, -1 is returned.\nOtherwise, same as |setqflist()|.\nAlso see |location-list|.\n\nFor {action} see |setqflist-action|.\n\nIf the optional {what} dictionary argument is supplied, then\nonly the items listed in {what} are set. Refer to |setqflist()|\nfor the list of supported keys in {what}.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {list} (`any`)\n                  \226\128\162 {action} (`string?`)\n                  \226\128\162 {what} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, setmatches = {binding = "setmatches", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?win"}, ["fnl/docstring"] = "Restores a list of matches saved by |getmatches()| for the\ncurrent window.  Returns 0 if successful, otherwise -1.  All\ncurrent matches are cleared before the list is restored.  See\nexample for |getmatches()|.\nIf {win} is specified, use the window with this number or\nwindow ID instead of the current window.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any`)\n                  \226\128\162 {win} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, setpos = {binding = "setpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "list"}, ["fnl/docstring"] = "Set the position for String {expr}.  Possible values:\n\t.\tthe cursor\n\t'x\tmark x\n\n{list} must be a |List| with four or five numbers:\n    [bufnum, lnum, col, off]\n    [bufnum, lnum, col, off, curswant]\n\n\"bufnum\" is the buffer number.\tZero can be used for the\ncurrent buffer.  When setting an uppercase mark \"bufnum\" is\nused for the mark position.  For other marks it specifies the\nbuffer to set the mark in.  You can use the |bufnr()| function\nto turn a file name into a buffer number.\nFor setting the cursor and the ' mark \"bufnum\" is ignored,\nsince these are associated with a window, not a buffer.\nDoes not change the jumplist.\n\n\"lnum\" and \"col\" are the position in the buffer.  The first\ncolumn is 1.  Use a zero \"lnum\" to delete a mark.  If \"col\" is\nsmaller than 1 then 1 is used. To use the character count\ninstead of the byte count, use |setcharpos()|.\n\nThe \"off\" number is only used when 'virtualedit' is set. Then\nit is the offset in screen columns from the start of the\ncharacter.  E.g., a position within a <Tab> or after the last\ncharacter.\n\nThe \"curswant\" number is only used when setting the cursor\nposition.  It sets the preferred column for when moving the\ncursor vertically.  When the \"curswant\" number is missing the\npreferred column is not set.  When it is present and setting a\nmark position it is not used.\n\nNote that for '< and '> changing the line number may result in\nthe marks to be effectively be swapped, so that '< is always\nbefore '>.\n\nReturns 0 when the position could be set, -1 otherwise.\nAn error message is given if {expr} is invalid.\n\nAlso see |setcharpos()|, |getpos()| and |getcurpos()|.\n\nThis does not restore the preferred column for moving\nvertically; if you set the cursor position with this, |j| and\n|k| motions will jump to previous columns!  Use |cursor()| to\nalso set the preferred column.  Also see the \"curswant\" key in\n|winrestview()|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n                  \226\128\162 {list} (`integer[]`)\n\n                Return: ~\n                  (`any`)"}}, setqflist = {binding = "setqflist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?action", "?what"}, ["fnl/docstring"] = "Create or replace or add to the quickfix list.\n\nIf the optional {what} dictionary argument is supplied, then\nonly the items listed in {what} are set. The first {list}\nargument is ignored.  See below for the supported items in\n{what}.\n\t\t\t\t\t*setqflist-what*\nWhen {what} is not present, the items in {list} are used.  Each\nitem must be a dictionary.  Non-dictionary items in {list} are\nignored.  Each dictionary item can contain the following\nentries:\n\n    bufnr\tbuffer number; must be the number of a valid\n\t\tbuffer\n    filename\tname of a file; only used when \"bufnr\" is not\n\t\tpresent or it is invalid.\n    module\tname of a module; if given it will be used in\n\t\tquickfix error window instead of the filename.\n    lnum\tline number in the file\n    end_lnum\tend of lines, if the item spans multiple lines\n    pattern\tsearch pattern used to locate the error\n    col\t\tcolumn number\n    vcol\twhen non-zero: \"col\" is visual column\n\t\twhen zero: \"col\" is byte index\n    end_col\tend column, if the item spans multiple columns\n    nr\t\terror number\n    text\tdescription of the error\n    type\tsingle-character error type, 'E', 'W', etc.\n    valid\trecognized error message\n    user_data\n\t\tcustom data associated with the item, can be\n\t\tany type.\n\nThe \"col\", \"vcol\", \"nr\", \"type\" and \"text\" entries are\noptional.  Either \"lnum\" or \"pattern\" entry can be used to\nlocate a matching error line.\nIf the \"filename\" and \"bufnr\" entries are not present or\nneither the \"lnum\" or \"pattern\" entries are present, then the\nitem will not be handled as an error line.\nIf both \"pattern\" and \"lnum\" are present then \"pattern\" will\nbe used.\nIf the \"valid\" entry is not supplied, then the valid flag is\nset when \"bufnr\" is a valid buffer or \"filename\" exists.\nIf you supply an empty {list}, the quickfix list will be\ncleared.\nNote that the list is not exactly the same as what\n|getqflist()| returns.\n\n{action} values:\t\t*setqflist-action* *E927*\n'a'\tThe items from {list} are added to the existing\n\tquickfix list. If there is no existing list, then a\n\tnew list is created.\n\n'r'\tThe items from the current quickfix list are replaced\n\twith the items from {list}.  This can also be used to\n\tclear the list: >vim\n\t\tcall setqflist([], 'r')\n<\n'u'\tLike 'r', but tries to preserve the current selection\n\tin the quickfix list.\n'f'\tAll the quickfix lists in the quickfix stack are\n\tfreed.\n\nIf {action} is not present or is set to ' ', then a new list\nis created. The new quickfix list is added after the current\nquickfix list in the stack and all the following lists are\nfreed. To add a new quickfix list at the end of the stack,\nset \"nr\" in {what} to \"$\".\n\nThe following items can be specified in dictionary {what}:\n    context\tquickfix list context. See |quickfix-context|\n    efm\t\terrorformat to use when parsing text from\n\t\t\"lines\". If this is not present, then the\n\t\t'errorformat' option value is used.\n\t\tSee |quickfix-parse|\n    id\t\tquickfix list identifier |quickfix-ID|\n    idx\t\tindex of the current entry in the quickfix\n\t\tlist specified by \"id\" or \"nr\". If set to '$',\n\t\tthen the last entry in the list is set as the\n\t\tcurrent entry.  See |quickfix-index|\n    items\tlist of quickfix entries. Same as the {list}\n\t\targument.\n    lines\tuse 'errorformat' to parse a list of lines and\n\t\tadd the resulting entries to the quickfix list\n\t\t{nr} or {id}.  Only a |List| value is supported.\n\t\tSee |quickfix-parse|\n    nr\t\tlist number in the quickfix stack; zero\n\t\tmeans the current quickfix list and \"$\" means\n\t\tthe last quickfix list.\n    quickfixtextfunc\n\t\tfunction to get the text to display in the\n\t\tquickfix window.  The value can be the name of\n\t\ta function or a funcref or a lambda.  Refer to\n\t\t|quickfix-window-function| for an explanation\n\t\tof how to write the function and an example.\n    title\tquickfix list title text. See |quickfix-title|\nUnsupported keys in {what} are ignored.\nIf the \"nr\" item is not present, then the current quickfix list\nis modified. When creating a new quickfix list, \"nr\" can be\nset to a value one greater than the quickfix stack size.\nWhen modifying a quickfix list, to guarantee that the correct\nlist is modified, \"id\" should be used instead of \"nr\" to\nspecify the list.\n\nExamples (See also |setqflist-examples|): >vim\n   call setqflist([], 'r', {'title': 'My search'})\n   call setqflist([], 'r', {'nr': 2, 'title': 'Errors'})\n   call setqflist([], 'a', {'id':qfid, 'lines':[\"F1:10:L10\"]})\n<\nReturns zero for success, -1 for failure.\n\nThis function can be used to create a quickfix list\nindependent of the 'errorformat' setting.  Use a command like\n`:cc 1` to jump to the first position.\n\n                Parameters: ~\n                  \226\128\162 {list} (`vim.quickfix.entry[]`)\n                  \226\128\162 {action} (`string?`)\n                  \226\128\162 {what} (`vim.fn.setqflist.what?`)\n\n                Return: ~\n                  (`integer`)"}}, setreg = {binding = "setreg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"regname", "value", "?options"}, ["fnl/docstring"] = "Set the register {regname} to {value}.\nIf {regname} is \"\" or \"@\", the unnamed register '\"' is used.\nThe {regname} argument is a string.\n\n{value} may be any value returned by |getreg()| or\n|getreginfo()|, including a |List| or |Dict|.\nIf {options} contains \"a\" or {regname} is upper case,\nthen the value is appended.\n\n{options} can also contain a register type specification:\n    \"c\" or \"v\"\t      |charwise| mode\n    \"l\" or \"V\"\t      |linewise| mode\n    \"b\" or \"<CTRL-V>\" |blockwise-visual| mode\nIf a number immediately follows \"b\" or \"<CTRL-V>\" then this is\nused as the width of the selection - if it is not specified\nthen the width of the block is set to the number of characters\nin the longest line (counting a <Tab> as 1 character).\nIf {options} contains \"u\" or '\"', then the unnamed register is\nset to point to register {regname}.\n\nIf {options} contains no register settings, then the default\nis to use character mode unless {value} ends in a <NL> for\nstring {value} and linewise mode for list {value}. Blockwise\nmode is never selected automatically.\nReturns zero for success, non-zero for failure.\n\n\t\t\t\t\t*E883*\nNote: you may not use |List| containing more than one item to\n      set search and expression registers. Lists containing no\n      items act like empty strings.\n\nExamples: >vim\n\tcall setreg(v:register, @*)\n\tcall setreg('*', @%, 'ac')\n\tcall setreg('a', \"1\\n2\\n3\", 'b5')\n\tcall setreg('\"', { 'points_to': 'a'})\n\n<\t\tThis example shows using the functions to save and restore a\nregister: >vim\n\tlet var_a = getreginfo()\n\tcall setreg('a', var_a)\n<\t\tor: >vim\n\tlet var_a = getreg('a', 1, 1)\n\tlet var_amode = getregtype('a')\n\t\" ....\n\tcall setreg('a', var_a, var_amode)\n<\t\tNote: you may not reliably restore register value\nwithout using the third argument to |getreg()| as without it\nnewlines are represented as newlines AND Nul bytes are\nrepresented as newlines as well, see |NL-used-for-Nul|.\n\nYou can also change the type of a register by appending\nnothing: >vim\n\tcall setreg('a', '', 'al')\n\n                Parameters: ~\n                  \226\128\162 {regname} (`string`)\n                  \226\128\162 {value} (`any`)\n                  \226\128\162 {options} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, settabvar = {binding = "settabvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabnr", "varname", "val"}, ["fnl/docstring"] = "Set tab-local variable {varname} to {val} in tab page {tabnr}.\n|t:var|\nThe {varname} argument is a string.\nNote that the variable name without \"t:\" must be used.\nTabs are numbered starting with one.\nThis function is not available in the |sandbox|.\n\n                Parameters: ~\n                  \226\128\162 {tabnr} (`integer`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {val} (`any`)\n\n                Return: ~\n                  (`any`)"}}, settabwinvar = {binding = "settabwinvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabnr", "winnr", "varname", "val"}, ["fnl/docstring"] = "Set option or local variable {varname} in window {winnr} to\n{val}.\nTabs are numbered starting with one.  For the current tabpage\nuse |setwinvar()|.\n{winnr} can be the window number or the |window-ID|.\nWhen {winnr} is zero the current window is used.\nThis also works for a global or local buffer option, but it\ndoesn't work for a global or local buffer variable.\nFor a local buffer option the global value is unchanged.\nNote that the variable name without \"w:\" must be used.\nExamples: >vim\n\tcall settabwinvar(1, 1, \"&list\", 0)\n\tcall settabwinvar(3, 2, \"myvar\", \"foobar\")\n<\t\tThis function is not available in the |sandbox|.\n\n                Parameters: ~\n                  \226\128\162 {tabnr} (`integer`)\n                  \226\128\162 {winnr} (`integer`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {val} (`any`)\n\n                Return: ~\n                  (`any`)"}}, settagstack = {binding = "settagstack", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "dict", "?action"}, ["fnl/docstring"] = "Modify the tag stack of the window {nr} using {dict}.\n{nr} can be the window number or the |window-ID|.\n\nFor a list of supported items in {dict}, refer to\n|gettagstack()|. \"curidx\" takes effect before changing the tag\nstack.\n\t\t\t\t\t*E962*\nHow the tag stack is modified depends on the {action}\nargument:\n- If {action} is not present or is set to 'r', then the tag\n  stack is replaced.\n- If {action} is set to 'a', then new entries from {dict} are\n  pushed (added) onto the tag stack.\n- If {action} is set to 't', then all the entries from the\n  current entry in the tag stack or \"curidx\" in {dict} are\n  removed and then new entries are pushed to the stack.\n\nThe current index is set to one after the length of the tag\nstack after the modification.\n\nReturns zero for success, -1 for failure.\n\nExamples (for more examples see |tagstack-examples|):\n    Empty the tag stack of window 3: >vim\n\tcall settagstack(3, {'items' : []})\n\n<\t\t    Save and restore the tag stack: >vim\n\tlet stack = gettagstack(1003)\n\t\" do something else\n\tcall settagstack(1003, stack)\n\tunlet stack\n<\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {dict} (`any`)\n                  \226\128\162 {action} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, setwinvar = {binding = "setwinvar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "varname", "val"}, ["fnl/docstring"] = "Like |settabwinvar()| for the current tab page.\nExamples: >vim\n\tcall setwinvar(1, \"&list\", 0)\n\tcall setwinvar(2, \"myvar\", \"foobar\")\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {varname} (`string`)\n                  \226\128\162 {val} (`any`)\n\n                Return: ~\n                  (`any`)"}}, sha256 = {binding = "sha256", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Returns a String with 64 hex characters, which is the SHA256\nchecksum of {string}.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`string`)"}}, shellescape = {binding = "shellescape", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?special"}, ["fnl/docstring"] = "Escape {string} for use as a shell command argument.\n\nOn Windows when 'shellslash' is not set, encloses {string} in\ndouble-quotes and doubles all double-quotes within {string}.\nOtherwise encloses {string} in single-quotes and replaces all\n\"'\" with \"'\\''\".\n\nThe {special} argument adds additional escaping of keywords\nused in Vim commands. If it is a |non-zero-arg|:\n- Special items such as \"!\", \"%\", \"#\" and \"<cword>\" (as listed\n  in |expand()|) will be preceded by a backslash.\n  The backslash will be removed again by the |:!| command.\n- The <NL> character is escaped.\n\nIf 'shell' contains \"csh\" in the tail:\n- The \"!\" character will be escaped. This is because csh and\n  tcsh use \"!\" for history replacement even in single-quotes.\n- The <NL> character is escaped (twice if {special} is\n  a |non-zero-arg|).\n\nIf 'shell' contains \"fish\" in the tail, the \"\\\" character will\nbe escaped because in fish it is used as an escape character\ninside single quotes.\n\nExample of use with a |:!| command: >vim\n    exe '!dir ' .. shellescape(expand('<cfile>'), 1)\n<\t\tThis results in a directory listing for the file under the\ncursor.  Example of use with |system()|: >vim\n    call system(\"chmod +w -- \" .. shellescape(expand(\"%\")))\n<\t\tSee also |::S|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {special} (`boolean?`)\n\n                Return: ~\n                  (`string`)"}}, shiftwidth = {binding = "shiftwidth", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?col"}, ["fnl/docstring"] = "Returns the effective value of 'shiftwidth'. This is the\n'shiftwidth' value unless it is zero, in which case it is the\n'tabstop' value.  To be backwards compatible in indent\nplugins, use this: >vim\n\tif exists('*shiftwidth')\n\t  func s:sw()\n\t    return shiftwidth()\n\t  endfunc\n\telse\n\t  func s:sw()\n\t    return &sw\n\t  endfunc\n\tendif\n<\t\tAnd then use s:sw() instead of &sw.\n\nWhen there is one argument {col} this is used as column number\nfor which to return the 'shiftwidth' value. This matters for the\n'vartabstop' feature. If no {col} argument is given, column 1\nwill be assumed.\n\n                Parameters: ~\n                  \226\128\162 {col} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, sign_define = {binding = "sign_define", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Define a new sign named {name} or modify the attributes of an\nexisting sign.  This is similar to the |:sign-define| command.\n\nPrefix {name} with a unique text to avoid name collisions.\nThere is no {group} like with placing signs.\n\nThe {name} can be a String or a Number.  The optional {dict}\nargument specifies the sign attributes.  The following values\nare supported:\n   icon\t\tfull path to the bitmap file for the sign.\n   linehl\thighlight group used for the whole line the\n\t\tsign is placed in.\n   priority\tdefault priority value of the sign\n   numhl\thighlight group used for the line number where\n\t\tthe sign is placed.\n   text\t\ttext that is displayed when there is no icon\n\t\tor the GUI is not being used.\n   texthl\thighlight group used for the text item\n   culhl\thighlight group used for the text item when\n\t\tthe cursor is on the same line as the sign and\n\t\t'cursorline' is enabled.\n\nIf the sign named {name} already exists, then the attributes\nof the sign are updated.\n\nThe one argument {list} can be used to define a list of signs.\nEach list item is a dictionary with the above items in {dict}\nand a \"name\" item for the sign name.\n\nReturns 0 on success and -1 on failure.  When the one argument\n{list} is used, then returns a List of values one for each\ndefined sign.\n\nExamples: >vim\n\tcall sign_define(\"mySign\", {\n\t\t\\ \"text\" : \"=>\",\n\t\t\\ \"texthl\" : \"Error\",\n\t\t\\ \"linehl\" : \"Search\"})\n\tcall sign_define([\n\t\t\\ {'name' : 'sign1',\n\t\t\\  'text' : '=>'},\n\t\t\\ {'name' : 'sign2',\n\t\t\\  'text' : '!!'}\n\t\t\\ ])\n<\n\n                Parameters: ~\n                  \226\128\162 {list} (`vim.fn.sign_define.dict[]`)\n\n                Return: ~\n                  (`(0|-1)[]`)"}}, sign_getdefined = {binding = "sign_getdefined", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?name"}, ["fnl/docstring"] = "Get a list of defined signs and their attributes.\nThis is similar to the |:sign-list| command.\n\nIf the {name} is not supplied, then a list of all the defined\nsigns is returned. Otherwise the attribute of the specified\nsign is returned.\n\nEach list item in the returned value is a dictionary with the\nfollowing entries:\n   icon\t\tfull path to the bitmap file of the sign\n   linehl\thighlight group used for the whole line the\n\t\tsign is placed in; not present if not set.\n   name\t\tname of the sign\n   priority\tdefault priority value of the sign\n   numhl\thighlight group used for the line number where\n\t\tthe sign is placed; not present if not set.\n   text\t\ttext that is displayed when there is no icon\n\t\tor the GUI is not being used.\n   texthl\thighlight group used for the text item; not\n\t\tpresent if not set.\n   culhl\thighlight group used for the text item when\n\t\tthe cursor is on the same line as the sign and\n\t\t'cursorline' is enabled; not present if not\n\t\tset.\n\nReturns an empty List if there are no signs and when {name} is\nnot found.\n\nExamples: >vim\n\t\" Get a list of all the defined signs\n\techo sign_getdefined()\n\n\t\" Get the attribute of the sign named mySign\n\techo sign_getdefined(\"mySign\")\n<\n\n                Parameters: ~\n                  \226\128\162 {name} (`string?`)\n\n                Return: ~\n                  (`vim.fn.sign_getdefined.ret.item[]`)"}}, sign_getplaced = {binding = "sign_getplaced", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?buf", "?dict"}, ["fnl/docstring"] = "Return a list of signs placed in a buffer or all the buffers.\nThis is similar to the |:sign-place-list| command.\n\nIf the optional buffer name {buf} is specified, then only the\nlist of signs placed in that buffer is returned.  For the use\nof {buf}, see |bufname()|. The optional {dict} can contain\nthe following entries:\n   group\tselect only signs in this group\n   id\t\tselect sign with this identifier\n   lnum\t\tselect signs placed in this line. For the use\n\t\tof {lnum}, see |line()|.\nIf {group} is \"*\", then signs in all the groups including the\nglobal group are returned. If {group} is not supplied or is an\nempty string, then only signs in the global group are\nreturned.  If no arguments are supplied, then signs in the\nglobal group placed in all the buffers are returned.\nSee |sign-group|.\n\nEach list item in the returned value is a dictionary with the\nfollowing entries:\n\tbufnr\tnumber of the buffer with the sign\n\tsigns\tlist of signs placed in {bufnr}. Each list\n\t\titem is a dictionary with the below listed\n\t\tentries\n\nThe dictionary for each sign contains the following entries:\n\tgroup\t sign group. Set to '' for the global group.\n\tid\t identifier of the sign\n\tlnum\t line number where the sign is placed\n\tname\t name of the defined sign\n\tpriority sign priority\n\nThe returned signs in a buffer are ordered by their line\nnumber and priority.\n\nReturns an empty list on failure or if there are no placed\nsigns.\n\nExamples: >vim\n\t\" Get a List of signs placed in eval.c in the\n\t\" global group\n\techo sign_getplaced(\"eval.c\")\n\n\t\" Get a List of signs in group 'g1' placed in eval.c\n\techo sign_getplaced(\"eval.c\", {'group' : 'g1'})\n\n\t\" Get a List of signs placed at line 10 in eval.c\n\techo sign_getplaced(\"eval.c\", {'lnum' : 10})\n\n\t\" Get sign with identifier 10 placed in a.py\n\techo sign_getplaced(\"a.py\", {'id' : 10})\n\n\t\" Get sign with id 20 in group 'g1' placed in a.py\n\techo sign_getplaced(\"a.py\", {'group' : 'g1',\n\t\t\t\t\t\\  'id' : 20})\n\n\t\" Get a List of all the placed signs\n\techo sign_getplaced()\n<\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string?`)\n                  \226\128\162 {dict} (`vim.fn.sign_getplaced.dict?`)\n\n                Return: ~\n                  (`vim.fn.sign_getplaced.ret.item[]`)"}}, sign_jump = {binding = "sign_jump", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id", "group", "buf"}, ["fnl/docstring"] = "Open the buffer {buf} or jump to the window that contains\n{buf} and position the cursor at sign {id} in group {group}.\nThis is similar to the |:sign-jump| command.\n\nIf {group} is an empty string, then the global group is used.\nFor the use of {buf}, see |bufname()|.\n\nReturns the line number of the sign. Returns -1 if the\narguments are invalid.\n\nExample: >vim\n\t\" Jump to sign 10 in the current buffer\n\tcall sign_jump(10, '', '')\n<\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer`)\n                  \226\128\162 {group} (`string`)\n                  \226\128\162 {buf} (`integer|string`)\n\n                Return: ~\n                  (`integer`)"}}, sign_place = {binding = "sign_place", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id", "group", "name", "buf", "?dict"}, ["fnl/docstring"] = "Place the sign defined as {name} at line {lnum} in file or\nbuffer {buf} and assign {id} and {group} to sign.  This is\nsimilar to the |:sign-place| command.\n\nIf the sign identifier {id} is zero, then a new identifier is\nallocated.  Otherwise the specified number is used. {group} is\nthe sign group name. To use the global sign group, use an\nempty string.  {group} functions as a namespace for {id}, thus\ntwo groups can use the same IDs. Refer to |sign-identifier|\nand |sign-group| for more information.\n\n{name} refers to a defined sign.\n{buf} refers to a buffer name or number. For the accepted\nvalues, see |bufname()|.\n\nThe optional {dict} argument supports the following entries:\n\tlnum\t\tline number in the file or buffer\n\t\t\t{buf} where the sign is to be placed.\n\t\t\tFor the accepted values, see |line()|.\n\tpriority\tpriority of the sign. See\n\t\t\t|sign-priority| for more information.\n\nIf the optional {dict} is not specified, then it modifies the\nplaced sign {id} in group {group} to use the defined sign\n{name}.\n\nReturns the sign identifier on success and -1 on failure.\n\nExamples: >vim\n\t\" Place a sign named sign1 with id 5 at line 20 in\n\t\" buffer json.c\n\tcall sign_place(5, '', 'sign1', 'json.c',\n\t\t\t\t\t\\ {'lnum' : 20})\n\n\t\" Updates sign 5 in buffer json.c to use sign2\n\tcall sign_place(5, '', 'sign2', 'json.c')\n\n\t\" Place a sign named sign3 at line 30 in\n\t\" buffer json.c with a new identifier\n\tlet id = sign_place(0, '', 'sign3', 'json.c',\n\t\t\t\t\t\\ {'lnum' : 30})\n\n\t\" Place a sign named sign4 with id 10 in group 'g3'\n\t\" at line 40 in buffer json.c with priority 90\n\tcall sign_place(10, 'g3', 'sign4', 'json.c',\n\t\t\t\\ {'lnum' : 40, 'priority' : 90})\n<\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer`)\n                  \226\128\162 {group} (`string`)\n                  \226\128\162 {name} (`string`)\n                  \226\128\162 {buf} (`integer|string`)\n                  \226\128\162 {dict} (`vim.fn.sign_place.dict?`)\n\n                Return: ~\n                  (`integer`)"}}, sign_placelist = {binding = "sign_placelist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Place one or more signs.  This is similar to the\n|sign_place()| function.  The {list} argument specifies the\nList of signs to place. Each list item is a dict with the\nfollowing sign attributes:\n    buffer\tBuffer name or number. For the accepted\n\t\tvalues, see |bufname()|.\n    group\tSign group. {group} functions as a namespace\n\t\tfor {id}, thus two groups can use the same\n\t\tIDs. If not specified or set to an empty\n\t\tstring, then the global group is used.   See\n\t\t|sign-group| for more information.\n    id\t\tSign identifier. If not specified or zero,\n\t\tthen a new unique identifier is allocated.\n\t\tOtherwise the specified number is used. See\n\t\t|sign-identifier| for more information.\n    lnum\tLine number in the buffer where the sign is to\n\t\tbe placed. For the accepted values, see\n\t\t|line()|.\n    name\tName of the sign to place. See |sign_define()|\n\t\tfor more information.\n    priority\tPriority of the sign. When multiple signs are\n\t\tplaced on a line, the sign with the highest\n\t\tpriority is used. If not specified, the\n\t\tdefault value of 10 is used, unless specified\n\t\totherwise by the sign definition. See\n\t\t|sign-priority| for more information.\n\nIf {id} refers to an existing sign, then the existing sign is\nmodified to use the specified {name} and/or {priority}.\n\nReturns a List of sign identifiers. If failed to place a\nsign, the corresponding list item is set to -1.\n\nExamples: >vim\n\t\" Place sign s1 with id 5 at line 20 and id 10 at line\n\t\" 30 in buffer a.c\n\tlet [n1, n2] = sign_placelist([\n\t\t\\ {'id' : 5,\n\t\t\\  'name' : 's1',\n\t\t\\  'buffer' : 'a.c',\n\t\t\\  'lnum' : 20},\n\t\t\\ {'id' : 10,\n\t\t\\  'name' : 's1',\n\t\t\\  'buffer' : 'a.c',\n\t\t\\  'lnum' : 30}\n\t\t\\ ])\n\n\t\" Place sign s1 in buffer a.c at line 40 and 50\n\t\" with auto-generated identifiers\n\tlet [n1, n2] = sign_placelist([\n\t\t\\ {'name' : 's1',\n\t\t\\  'buffer' : 'a.c',\n\t\t\\  'lnum' : 40},\n\t\t\\ {'name' : 's1',\n\t\t\\  'buffer' : 'a.c',\n\t\t\\  'lnum' : 50}\n\t\t\\ ])\n<\n\n                Parameters: ~\n                  \226\128\162 {list} (`vim.fn.sign_placelist.list.item[]`)\n\n                Return: ~\n                  (`integer[]`)"}}, sign_undefine = {binding = "sign_undefine", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?list"}, ["fnl/docstring"] = "Deletes a previously defined sign {name}. This is similar to\nthe |:sign-undefine| command. If {name} is not supplied, then\ndeletes all the defined signs.\n\nThe one argument {list} can be used to undefine a list of\nsigns. Each list item is the name of a sign.\n\nReturns 0 on success and -1 on failure.  For the one argument\n{list} call, returns a list of values one for each undefined\nsign.\n\nExamples: >vim\n\t\" Delete a sign named mySign\n\tcall sign_undefine(\"mySign\")\n\n\t\" Delete signs 'sign1' and 'sign2'\n\tcall sign_undefine([\"sign1\", \"sign2\"])\n\n\t\" Delete all the signs\n\tcall sign_undefine()\n<\n\n                Parameters: ~\n                  \226\128\162 {list} (`string[]?`)\n\n                Return: ~\n                  (`integer[]`)"}}, sign_unplace = {binding = "sign_unplace", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"group", "?dict"}, ["fnl/docstring"] = "Remove a previously placed sign in one or more buffers.  This\nis similar to the |:sign-unplace| command.\n\n{group} is the sign group name. To use the global sign group,\nuse an empty string.  If {group} is set to \"*\", then all the\ngroups including the global group are used.\nThe signs in {group} are selected based on the entries in\n{dict}.  The following optional entries in {dict} are\nsupported:\n\tbuffer\tbuffer name or number. See |bufname()|.\n\tid\tsign identifier\nIf {dict} is not supplied, then all the signs in {group} are\nremoved.\n\nReturns 0 on success and -1 on failure.\n\nExamples: >vim\n\t\" Remove sign 10 from buffer a.vim\n\tcall sign_unplace('', {'buffer' : \"a.vim\", 'id' : 10})\n\n\t\" Remove sign 20 in group 'g1' from buffer 3\n\tcall sign_unplace('g1', {'buffer' : 3, 'id' : 20})\n\n\t\" Remove all the signs in group 'g2' from buffer 10\n\tcall sign_unplace('g2', {'buffer' : 10})\n\n\t\" Remove sign 30 in group 'g3' from all the buffers\n\tcall sign_unplace('g3', {'id' : 30})\n\n\t\" Remove all the signs placed in buffer 5\n\tcall sign_unplace('*', {'buffer' : 5})\n\n\t\" Remove the signs in group 'g4' from all the buffers\n\tcall sign_unplace('g4')\n\n\t\" Remove sign 40 from all the buffers\n\tcall sign_unplace('*', {'id' : 40})\n\n\t\" Remove all the placed signs from all the buffers\n\tcall sign_unplace('*')\n\n                Parameters: ~\n                  \226\128\162 {group} (`string`)\n                  \226\128\162 {dict} (`vim.fn.sign_unplace.dict?`)\n\n                Return: ~\n                  (`0|-1`)"}}, sign_unplacelist = {binding = "sign_unplacelist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list"}, ["fnl/docstring"] = "Remove previously placed signs from one or more buffers.  This\nis similar to the |sign_unplace()| function.\n\nThe {list} argument specifies the List of signs to remove.\nEach list item is a dict with the following sign attributes:\n    buffer\tbuffer name or number. For the accepted\n\t\tvalues, see |bufname()|. If not specified,\n\t\tthen the specified sign is removed from all\n\t\tthe buffers.\n    group\tsign group name. If not specified or set to an\n\t\tempty string, then the global sign group is\n\t\tused. If set to \"*\", then all the groups\n\t\tincluding the global group are used.\n    id\t\tsign identifier. If not specified, then all\n\t\tthe signs in the specified group are removed.\n\nReturns a List where an entry is set to 0 if the corresponding\nsign was successfully removed or -1 on failure.\n\nExample: >vim\n\t\" Remove sign with id 10 from buffer a.vim and sign\n\t\" with id 20 from buffer b.vim\n\tcall sign_unplacelist([\n\t\t\\ {'id' : 10, 'buffer' : \"a.vim\"},\n\t\t\\ {'id' : 20, 'buffer' : 'b.vim'},\n\t\t\\ ])\n<\n\n                Parameters: ~\n                  \226\128\162 {list} (`vim.fn.sign_unplacelist.list.item`)\n\n                Return: ~\n                  (`(0|-1)[]`)"}}, simplify = {binding = "simplify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"filename"}, ["fnl/docstring"] = "Simplify the file name as much as possible without changing\nthe meaning.  Shortcuts (on MS-Windows) or symbolic links (on\nUnix) are not resolved.  If the first path component in\n{filename} designates the current directory, this will be\nvalid for the result as well.  A trailing path separator is\nnot removed either. On Unix \"//path\" is unchanged, but\n\"///path\" is simplified to \"/path\" (this follows the Posix\nstandard).\nExample: >vim\n\tsimplify(\"./dir/.././/file/\") == \"./file/\"\n<\t\tNote: The combination \"dir/..\" is only removed if \"dir\" is\na searchable directory or does not exist.  On Unix, it is also\nremoved when \"dir\" is a symbolic link within the same\ndirectory.  In order to resolve all the involved symbolic\nlinks before simplifying the path name, use |resolve()|.\n\n                Parameters: ~\n                  \226\128\162 {filename} (`string`)\n\n                Return: ~\n                  (`string`)"}}, sin = {binding = "sin", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the sine of {expr}, measured in radians, as a |Float|.\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo sin(100)\n<\t\t\t-0.506366 >vim\n\techo sin(-4.01)\n<\t\t\0090.763301\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, sinh = {binding = "sinh", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the hyperbolic sine of {expr} as a |Float| in the range\n[-inf, inf].\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo sinh(0.5)\n<\t\t\0090.521095 >vim\n\techo sinh(-0.9)\n<\t\t\t-1.026517\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`any`)"}}, slice = {binding = "slice", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "start", "?end"}, ["fnl/docstring"] = "Similar to using a |slice| \"expr[start : end]\", but \"end\" is\nused exclusive.  And for a string the indexes are used as\ncharacter indexes instead of byte indexes.\nAlso, composing characters are treated as a part of the\npreceding base character.\nWhen {end} is omitted the slice continues to the last item.\nWhen {end} is -1 the last item is omitted.\nReturns an empty value if {start} or {end} are invalid.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {start} (`integer`)\n                  \226\128\162 {end} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, sockconnect = {binding = "sockconnect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"mode", "address", "?opts"}, ["fnl/docstring"] = "Connect a socket to an address. If {mode} is \"pipe\" then\n{address} should be the path of a local domain socket (on\nunix) or named pipe (on Windows). If {mode} is \"tcp\" then\n{address} should be of the form \"host:port\" where the host\nshould be an ip address or host name, and port the port\nnumber.\n\nFor \"pipe\" mode, see |luv-pipe-handle|. For \"tcp\" mode, see\n|luv-tcp-handle|.\n\nReturns a |channel| ID. Close the socket with |chanclose()|.\nUse |chansend()| to send data over a bytes socket, and\n|rpcrequest()| and |rpcnotify()| to communicate with a RPC\nsocket.\n\n{opts} is an optional dictionary with these keys:\n  |on_data| : callback invoked when data was read from socket\n  data_buffered : read socket data in |channel-buffered| mode.\n  rpc     : If set, |msgpack-rpc| will be used to communicate\n\t    over the socket.\nReturns:\n  - The channel ID on success (greater than zero)\n  - 0 on invalid arguments or connection failure.\n\n                Parameters: ~\n                  \226\128\162 {mode} (`string`)\n                  \226\128\162 {address} (`string`)\n                  \226\128\162 {opts} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, sort = {binding = "sort", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?how", "?dict"}, ["fnl/docstring"] = "Sort the items in {list} in-place.  Returns {list}.\n\nIf you want a list to remain unmodified make a copy first: >vim\n\tlet sortedlist = sort(copy(mylist))\n\n<\t\tWhen {how} is omitted or is a string, then sort() uses the\nstring representation of each item to sort on.  Numbers sort\nafter Strings, |Lists| after Numbers.  For sorting text in the\ncurrent buffer use |:sort|.\n\nWhen {how} is given and it is 'i' then case is ignored.\nFor backwards compatibility, the value one can be used to\nignore case.  Zero means to not ignore case.\n\nWhen {how} is given and it is 'l' then the current collation\nlocale is used for ordering. Implementation details: strcoll()\nis used to compare strings. See |:language| check or set the\ncollation locale. |v:collate| can also be used to check the\ncurrent locale. Sorting using the locale typically ignores\ncase. Example: >vim\n\t\" \195\182 is sorted similarly to o with English locale.\n\tlanguage collate en_US.UTF8\n\techo sort(['n', 'o', 'O', '\195\182', 'p', 'z'], 'l')\n<\t\t\t['n', 'o', 'O', '\195\182', 'p', 'z'] ~\n>vim\n\t\" \195\182 is sorted after z with Swedish locale.\n\tlanguage collate sv_SE.UTF8\n\techo sort(['n', 'o', 'O', '\195\182', 'p', 'z'], 'l')\n<\t\t\t['n', 'o', 'O', 'p', 'z', '\195\182'] ~\nThis does not work properly on Mac.\n\nWhen {how} is given and it is 'n' then all items will be\nsorted numerical (Implementation detail: this uses the\nstrtod() function to parse numbers, Strings, Lists, Dicts and\nFuncrefs will be considered as being 0).\n\nWhen {how} is given and it is 'N' then all items will be\nsorted numerical. This is like 'n' but a string containing\ndigits will be used as the number they represent.\n\nWhen {how} is given and it is 'f' then all items will be\nsorted numerical. All values must be a Number or a Float.\n\nWhen {how} is a |Funcref| or a function name, this function\nis called to compare items.  The function is invoked with two\nitems as argument and must return zero if they are equal, 1 or\nbigger if the first one sorts after the second one, -1 or\nsmaller if the first one sorts before the second one.\n\n{dict} is for functions with the \"dict\" attribute.  It will be\nused to set the local variable \"self\". |Dictionary-function|\n\nThe sort is stable, items which compare equal (as number or as\nstring) will keep their relative position. E.g., when sorting\non numbers, text strings will sort next to each other, in the\nsame order as they were originally.\n\n\nExample: >vim\n\tfunc MyCompare(i1, i2)\n\t   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1\n\tendfunc\n\teval mylist->sort(\"MyCompare\")\n<\t\tA shorter compare version for this specific simple case, which\nignores overflow: >vim\n\tfunc MyCompare(i1, i2)\n\t   return a:i1 - a:i2\n\tendfunc\n<\t\tFor a simple expression you can use a lambda: >vim\n\teval mylist->sort({i1, i2 -> i1 - i2})\n<\n\n                Parameters: ~\n                  \226\128\162 {list} (`T[]`)\n                  \226\128\162 {how} (`string|function?`)\n                  \226\128\162 {dict} (`any?`)\n\n                Return: ~\n                  (`T[]`)"}}, soundfold = {binding = "soundfold", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"word"}, ["fnl/docstring"] = "Return the sound-folded equivalent of {word}.  Uses the first\nlanguage in 'spelllang' for the current window that supports\nsoundfolding.  'spell' must be set.  When no sound folding is\npossible the {word} is returned unmodified.\nThis can be used for making spelling suggestions.  Note that\nthe method can be quite slow.\n\n                Parameters: ~\n                  \226\128\162 {word} (`string`)\n\n                Return: ~\n                  (`string`)"}}, spellbadword = {binding = "spellbadword", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?sentence"}, ["fnl/docstring"] = "Without argument: The result is the badly spelled word under\nor after the cursor.  The cursor is moved to the start of the\nbad word.  When no bad word is found in the cursor line the\nresult is an empty string and the cursor doesn't move.\n\nWith argument: The result is the first word in {sentence} that\nis badly spelled.  If there are no spelling mistakes the\nresult is an empty string.\n\nThe return value is a list with two items:\n- The badly spelled word or an empty string.\n- The type of the spelling error:\n\t\"bad\"\t\tspelling mistake\n\t\"rare\"\t\trare word\n\t\"local\"\t\tword only valid in another region\n\t\"caps\"\t\tword should start with Capital\nExample: >vim\n\techo spellbadword(\"the quik brown fox\")\n<\t\t\t['quik', 'bad'] ~\n\nThe spelling information for the current window and the value\nof 'spelllang' are used.\n\n                Parameters: ~\n                  \226\128\162 {sentence} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, spellsuggest = {binding = "spellsuggest", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"word", "?max", "?capital"}, ["fnl/docstring"] = "Return a |List| with spelling suggestions to replace {word}.\nWhen {max} is given up to this number of suggestions are\nreturned.  Otherwise up to 25 suggestions are returned.\n\nWhen the {capital} argument is given and it's non-zero only\nsuggestions with a leading capital will be given.  Use this\nafter a match with 'spellcapcheck'.\n\n{word} can be a badly spelled word followed by other text.\nThis allows for joining two words that were split.  The\nsuggestions also include the following text, thus you can\nreplace a line.\n\n{word} may also be a good word.  Similar words will then be\nreturned.  {word} itself is not included in the suggestions,\nalthough it may appear capitalized.\n\nThe spelling information for the current window is used.  The\nvalues of 'spelllang' and 'spellsuggest' are used.\n\n                Parameters: ~\n                  \226\128\162 {word} (`string`)\n                  \226\128\162 {max} (`integer?`)\n                  \226\128\162 {capital} (`boolean?`)\n\n                Return: ~\n                  (`string[]`)"}}, split = {binding = "split", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?pattern", "?keepempty"}, ["fnl/docstring"] = "Make a |List| out of {string}.  When {pattern} is omitted or\nempty each white space separated sequence of characters\nbecomes an item.\nOtherwise the string is split where {pattern} matches,\nremoving the matched characters. 'ignorecase' is not used\nhere, add \\c to ignore case. |/\\c|\nWhen the first or last item is empty it is omitted, unless the\n{keepempty} argument is given and it's non-zero.\nOther empty items are kept when {pattern} matches at least one\ncharacter or when {keepempty} is non-zero.\nExample: >vim\n\tlet words = split(getline('.'), '\\W\\+')\n<\t\tTo split a string in individual characters: >vim\n\tfor c in split(mystring, '\\zs') | endfor\n<\t\tIf you want to keep the separator you can also use '\\zs' at\nthe end of the pattern: >vim\n\techo split('abc:def:ghi', ':\\zs')\n<\t\t >\n\t['abc:', 'def:', 'ghi']\n<\nSplitting a table where the first element can be empty: >vim\n\tlet items = split(line, ':', 1)\n<\t\tThe opposite function is |join()|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {pattern} (`string?`)\n                  \226\128\162 {keepempty} (`boolean?`)\n\n                Return: ~\n                  (`string[]`)"}}, sqrt = {binding = "sqrt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the non-negative square root of Float {expr} as a\n|Float|.\n{expr} must evaluate to a |Float| or a |Number|.  When {expr}\nis negative the result is NaN (Not a Number).  Returns 0.0 if\n{expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo sqrt(100)\n<\t\t\00910.0 >vim\n\techo sqrt(-4.01)\n<\t\t\tstr2float(\"nan\")\nNaN may be different, it depends on system libraries.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`any`)"}}, srand = {binding = "srand", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?expr"}, ["fnl/docstring"] = "Initialize seed used by |rand()|:\n- If {expr} is not given, seed values are initialized by\n  reading from /dev/urandom, if possible, or using time(NULL)\n  a.k.a. epoch time otherwise; this only has second accuracy.\n- If {expr} is given it must be a Number.  It is used to\n  initialize the seed values.  This is useful for testing or\n  when a predictable sequence is intended.\n\nExamples: >vim\n\tlet seed = srand()\n\tlet seed = srand(userinput)\n\techo rand(seed)\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number?`)\n\n                Return: ~\n                  (`any`)"}}, state = {binding = "state", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?what"}, ["fnl/docstring"] = "Return a string which contains characters indicating the\ncurrent state.  Mostly useful in callbacks that want to do\nwork that may not always be safe.  Roughly this works like:\n- callback uses state() to check if work is safe to do.\n  Yes: then do it right away.\n  No:  add to work queue and add a |SafeState| autocommand.\n- When SafeState is triggered and executes your autocommand,\n  check with `state()` if the work can be done now, and if yes\n  remove it from the queue and execute.\n  Remove the autocommand if the queue is now empty.\nAlso see |mode()|.\n\nWhen {what} is given only characters in this string will be\nadded.  E.g, this checks if the screen has scrolled: >vim\n\tif state('s') == ''\n\t   \" screen has not scrolled\n<\nThese characters indicate the state, generally indicating that\nsomething is busy:\n    m\thalfway a mapping, :normal command, feedkeys() or\n\tstuffed command\n    o\toperator pending, e.g. after |d|\n    a\tInsert mode autocomplete active\n    x\texecuting an autocommand\n    S\tnot triggering SafeState, e.g. after |f| or a count\n    c\tcallback invoked, including timer (repeats for\n\trecursiveness up to \"ccc\")\n    s\tscreen has scrolled for messages\n\n                Parameters: ~\n                  \226\128\162 {what} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, stdioopen = {binding = "stdioopen", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts"}, ["fnl/docstring"] = "With |--headless| this opens stdin and stdout as a |channel|.\nMay be called only once. See |channel-stdio|. stderr is not\nhandled by this function, see |v:stderr|.\n\nClose the stdio handles with |chanclose()|. Use |chansend()|\nto send data to stdout, and |rpcrequest()| and |rpcnotify()|\nto communicate over RPC.\n\n{opts} is a dictionary with these keys:\n  |on_stdin| : callback invoked when stdin is written to.\n  on_print : callback invoked when Nvim needs to print a\n\t     message, with the message (whose type is string)\n\t     as sole argument.\n  stdin_buffered : read stdin in |channel-buffered| mode.\n  rpc      : If set, |msgpack-rpc| will be used to communicate\n\t     over stdio\nReturns:\n  - |channel-id| on success (value is always 1)\n  - 0 on invalid arguments\n\n                Parameters: ~\n                  \226\128\162 {opts} (`table`)\n\n                Return: ~\n                  (`any`)"}}, stdpath = {binding = "stdpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"what"}, ["fnl/docstring"] = "Returns |standard-path| locations of various default files and\ndirectories. The locations are driven by |base-directories|\nwhich you can configure via |$NVIM_APPNAME| or the `$XDG_\226\128\166`\nenvironment variables.\n\n{what}       Type    Description ~\ncache        String  Cache directory: arbitrary temporary\n                     storage for plugins, etc.\nconfig       String  User configuration directory. |init.vim|\n                     is stored here.\nconfig_dirs  List    Other configuration directories.\ndata         String  User data directory.\ndata_dirs    List    Other data directories.\nlog          String  Logs directory (for use by plugins too).\nrun          String  Run directory: temporary, local storage\n\t\t     for sockets, named pipes, etc.\nstate        String  Session state directory: storage for file\n\t\t     drafts, swap, undo, |shada|.\n\nExample: >vim\n\techo stdpath(\"config\")\n<\n\n                Parameters: ~\n                  \226\128\162 {what}\n                    (`'cache'|'config'|'config_dirs'|'data'|'data_dirs'|'log'|'run'|'state'`)\n\n                Return: ~\n                  (`string|string[]`)"}}, str2float = {binding = "str2float", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?quoted"}, ["fnl/docstring"] = "Convert String {string} to a Float.  This mostly works the\nsame as when using a floating point number in an expression,\nsee |floating-point-format|.  But it's a bit more permissive.\nE.g., \"1e40\" is accepted, while in an expression you need to\nwrite \"1.0e40\".  The hexadecimal form \"0x123\" is also\naccepted, but not others, like binary or octal.\nWhen {quoted} is present and non-zero then embedded single\nquotes before the dot are ignored, thus \"1'000.0\" is a\nthousand.\nText after the number is silently ignored.\nThe decimal point is always '.', no matter what the locale is\nset to.  A comma ends the number: \"12,345.67\" is converted to\n12.0.  You can strip out thousands separators with\n|substitute()|: >vim\n\tlet f = str2float(substitute(text, ',', '', 'g'))\n<\nReturns 0.0 if the conversion fails.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {quoted} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, str2list = {binding = "str2list", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?utf8"}, ["fnl/docstring"] = "Return a list containing the number values which represent\neach character in String {string}.  Examples: >vim\n\techo str2list(\" \")\t\t\" returns [32]\n\techo str2list(\"ABC\")\t\t\" returns [65, 66, 67]\n<\t\t|list2str()| does the opposite.\n\nUTF-8 encoding is always used, {utf8} option has no effect,\nand exists only for backwards-compatibility.\nWith UTF-8 composing characters are handled properly: >vim\n\techo str2list(\"a\204\129\")\t\t\" returns [97, 769]\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {utf8} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, str2nr = {binding = "str2nr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?base"}, ["fnl/docstring"] = "Convert string {string} to a number.\n{base} is the conversion base, it can be 2, 8, 10 or 16.\nWhen {quoted} is present and non-zero then embedded single\nquotes are ignored, thus \"1'000'000\" is a million.\n\nWhen {base} is omitted base 10 is used.  This also means that\na leading zero doesn't cause octal conversion to be used, as\nwith the default String to Number conversion.  Example: >vim\n\tlet nr = str2nr('0123')\n<\nWhen {base} is 16 a leading \"0x\" or \"0X\" is ignored.  With a\ndifferent base the result will be zero. Similarly, when\n{base} is 8 a leading \"0\", \"0o\" or \"0O\" is ignored, and when\n{base} is 2 a leading \"0b\" or \"0B\" is ignored.\nText after the number is silently ignored.\n\nReturns 0 if {string} is empty or on error.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {base} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, strcharlen = {binding = "strcharlen", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "The result is a Number, which is the number of characters\nin String {string}.  Composing characters are ignored.\n|strchars()| can count the number of characters, counting\ncomposing characters separately.\n\nReturns 0 if {string} is empty or on error.\n\nAlso see |strlen()|, |strdisplaywidth()| and |strwidth()|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`any`)"}}, strcharpart = {binding = "strcharpart", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"src", "start", "?len", "?skipcc"}, ["fnl/docstring"] = "Like |strpart()| but using character index and length instead\nof byte index and length.\nWhen {skipcc} is omitted or zero, composing characters are\ncounted separately.\nWhen {skipcc} set to 1, composing characters are treated as a\npart of the preceding base character, similar to |slice()|.\nWhen a character index is used where a character does not\nexist it is omitted and counted as one character.  For\nexample: >vim\n\techo strcharpart('abc', -1, 2)\n<\t\tresults in 'a'.\n\nReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {src} (`string`)\n                  \226\128\162 {start} (`integer`)\n                  \226\128\162 {len} (`integer?`)\n                  \226\128\162 {skipcc} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, strchars = {binding = "strchars", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?skipcc"}, ["fnl/docstring"] = "The result is a Number, which is the number of characters\nin String {string}.\nWhen {skipcc} is omitted or zero, composing characters are\ncounted separately.\nWhen {skipcc} set to 1, composing characters are ignored.\n|strcharlen()| always does this.\n\nReturns zero on error.\n\nAlso see |strlen()|, |strdisplaywidth()| and |strwidth()|.\n\n{skipcc} is only available after 7.4.755.  For backward\ncompatibility, you can define a wrapper function: >vim\n    if has(\"patch-7.4.755\")\n      function s:strchars(str, skipcc)\n\treturn strchars(a:str, a:skipcc)\n      endfunction\n    else\n      function s:strchars(str, skipcc)\n\tif a:skipcc\n\t  return strlen(substitute(a:str, \".\", \"x\", \"g\"))\n\telse\n\t  return strchars(a:str)\n\tendif\n      endfunction\n    endif\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {skipcc} (`boolean?`)\n\n                Return: ~\n                  (`integer`)"}}, strdisplaywidth = {binding = "strdisplaywidth", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?col"}, ["fnl/docstring"] = "The result is a Number, which is the number of display cells\nString {string} occupies on the screen when it starts at {col}\n(first column is zero).  When {col} is omitted zero is used.\nOtherwise it is the screen column where to start.  This\nmatters for Tab characters.\nThe option settings of the current window are used.  This\nmatters for anything that's displayed differently, such as\n'tabstop' and 'display'.\nWhen {string} contains characters with East Asian Width Class\nAmbiguous, this function's return value depends on 'ambiwidth'.\nReturns zero on error.\nAlso see |strlen()|, |strwidth()| and |strchars()|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {col} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, strftime = {binding = "strftime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"format", "?time"}, ["fnl/docstring"] = "The result is a String, which is a formatted date and time, as\nspecified by the {format} string.  The given {time} is used,\nor the current time if no time is given.  The accepted\n{format} depends on your system, thus this is not portable!\nSee the manual page of the C function strftime() for the\nformat.  The maximum length of the result is 80 characters.\nSee also |localtime()|, |getftime()| and |strptime()|.\nThe language can be changed with the |:language| command.\nExamples: >vim\n  echo strftime(\"%c\")\t\t   \" Sun Apr 27 11:49:23 1997\n  echo strftime(\"%Y %b %d %X\")\t   \" 1997 Apr 27 11:53:25\n  echo strftime(\"%y%m%d %T\")\t   \" 970427 11:53:55\n  echo strftime(\"%H:%M\")\t\t   \" 11:55\n  echo strftime(\"%c\", getftime(\"file.c\"))\n\t\t\t\t   \" Show mod time of file.c.\n\n                Parameters: ~\n                  \226\128\162 {format} (`string`)\n                  \226\128\162 {time} (`number?`)\n\n                Return: ~\n                  (`string`)"}}, strgetchar = {binding = "strgetchar", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "index"}, ["fnl/docstring"] = "Get a Number corresponding to the character at {index} in\n{str}.  This uses a zero-based character index, not a byte\nindex.  Composing characters are considered separate\ncharacters here.  Use |nr2char()| to convert the Number to a\nString.\nReturns -1 if {index} is invalid.\nAlso see |strcharpart()| and |strchars()|.\n\n                Parameters: ~\n                  \226\128\162 {str} (`string`)\n                  \226\128\162 {index} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, stridx = {binding = "stridx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"haystack", "needle", "?start"}, ["fnl/docstring"] = "The result is a Number, which gives the byte index in\n{haystack} of the first occurrence of the String {needle}.\nIf {start} is specified, the search starts at index {start}.\nThis can be used to find a second match: >vim\n\tlet colon1 = stridx(line, \":\")\n\tlet colon2 = stridx(line, \":\", colon1 + 1)\n<\t\tThe search is done case-sensitive.\nFor pattern searches use |match()|.\n-1 is returned if the {needle} does not occur in {haystack}.\nSee also |strridx()|.\nExamples: >vim\n  echo stridx(\"An Example\", \"Example\")     \" 3\n  echo stridx(\"Starting point\", \"Start\")   \" 0\n  echo stridx(\"Starting point\", \"start\")   \" -1\n<\t\t\t\t\t\t*strstr()* *strchr()*\nstridx() works similar to the C function strstr().  When used\nwith a single character it works similar to strchr().\n\n                Parameters: ~\n                  \226\128\162 {haystack} (`string`)\n                  \226\128\162 {needle} (`string`)\n                  \226\128\162 {start} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, string = {binding = "string", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return {expr} converted to a String.  If {expr} is a Number,\nFloat, String, Blob or a composition of them, then the result\ncan be parsed back with |eval()|.\n\t{expr} type\tresult ~\n\tString\t\t'string'\n\tNumber\t\009123\n\tFloat\t\009123.123456 or 1.123456e8 or\n\t\t\t`str2float('inf')`\n\tFuncref\t\t`function('name')`\n\tBlob\t\0090z00112233.44556677.8899\n\tList\t\t[item, item]\n\tDictionary\t`{key: value, key: value}`\nNote that in String values the ' character is doubled.\nAlso see |strtrans()|.\nNote 2: Output format is mostly compatible with YAML, except\nfor infinite and NaN floating-point values representations\nwhich use |str2float()|.  Strings are also dumped literally,\nonly single quote is escaped, which does not allow using YAML\nfor parsing back binary strings.  |eval()| should always work\nfor strings and floats though, and this is the only official\nmethod.  Use |msgpackdump()| or |json_encode()| if you need to\nshare data with other applications.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`string`)"}}, strlen = {binding = "strlen", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "The result is a Number, which is the length of the String\n{string} in bytes.\nIf the argument is a Number it is first converted to a String.\nFor other types an error is given and zero is returned.\nIf you want to count the number of multibyte characters use\n|strchars()|.\nAlso see |len()|, |strdisplaywidth()| and |strwidth()|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, strpart = {binding = "strpart", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"src", "start", "?len", "?chars"}, ["fnl/docstring"] = "The result is a String, which is part of {src}, starting from\nbyte {start}, with the byte length {len}.\nWhen {chars} is present and TRUE then {len} is the number of\ncharacters positions (composing characters are not counted\nseparately, thus \"1\" means one base character and any\nfollowing composing characters).\nTo count {start} as characters instead of bytes use\n|strcharpart()|.\n\nWhen bytes are selected which do not exist, this doesn't\nresult in an error, the bytes are simply omitted.\nIf {len} is missing, the copy continues from {start} till the\nend of the {src}. >vim\n\techo strpart(\"abcdefg\", 3, 2)    \" returns 'de'\n\techo strpart(\"abcdefg\", -2, 4)   \" returns 'ab'\n\techo strpart(\"abcdefg\", 5, 4)    \" returns 'fg'\n\techo strpart(\"abcdefg\", 3)\t \" returns 'defg'\n\n<\t\tNote: To get the first character, {start} must be 0.  For\nexample, to get the character under the cursor: >vim\n\tstrpart(getline(\".\"), col(\".\") - 1, 1, v:true)\n<\nReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {src} (`string`)\n                  \226\128\162 {start} (`integer`)\n                  \226\128\162 {len} (`integer?`)\n                  \226\128\162 {chars} (`0|1?`)\n\n                Return: ~\n                  (`string`)"}}, strptime = {binding = "strptime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"format", "timestring"}, ["fnl/docstring"] = "The result is a Number, which is a unix timestamp representing\nthe date and time in {timestring}, which is expected to match\nthe format specified in {format}.\n\nThe accepted {format} depends on your system, thus this is not\nportable!  See the manual page of the C function strptime()\nfor the format.  Especially avoid \"%c\".  The value of $TZ also\nmatters.\n\nIf the {timestring} cannot be parsed with {format} zero is\nreturned.  If you do not know the format of {timestring} you\ncan try different {format} values until you get a non-zero\nresult.\n\nSee also |strftime()|.\nExamples: >vim\n  echo strptime(\"%Y %b %d %X\", \"1997 Apr 27 11:49:23\")\n<\t\t  862156163 >vim\n  echo strftime(\"%c\", strptime(\"%y%m%d %T\", \"970427 11:53:55\"))\n<\t\t  Sun Apr 27 11:53:55 1997 >vim\n  echo strftime(\"%c\", strptime(\"%Y%m%d%H%M%S\", \"19970427115355\") + 3600)\n<\t\t  Sun Apr 27 12:53:55 1997\n\n                Parameters: ~\n                  \226\128\162 {format} (`string`)\n                  \226\128\162 {timestring} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, strridx = {binding = "strridx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"haystack", "needle", "?start"}, ["fnl/docstring"] = "The result is a Number, which gives the byte index in\n{haystack} of the last occurrence of the String {needle}.\nWhen {start} is specified, matches beyond this index are\nignored.  This can be used to find a match before a previous\nmatch: >vim\n\tlet lastcomma = strridx(line, \",\")\n\tlet comma2 = strridx(line, \",\", lastcomma - 1)\n<\t\tThe search is done case-sensitive.\nFor pattern searches use |match()|.\n-1 is returned if the {needle} does not occur in {haystack}.\nIf the {needle} is empty the length of {haystack} is returned.\nSee also |stridx()|.  Examples: >vim\n  echo strridx(\"an angry armadillo\", \"an\")\t     3\n<\t\t\t\t\t\t\t*strrchr()*\nWhen used with a single character it works similar to the C\nfunction strrchr().\n\n                Parameters: ~\n                  \226\128\162 {haystack} (`string`)\n                  \226\128\162 {needle} (`string`)\n                  \226\128\162 {start} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, strtrans = {binding = "strtrans", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "The result is a String, which is {string} with all unprintable\ncharacters translated into printable characters |'isprint'|.\nLike they are shown in a window.  Example: >vim\n\techo strtrans(@a)\n<\t\tThis displays a newline in register a as \"^@\" instead of\nstarting a new line.\n\nReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`string`)"}}, strutf16len = {binding = "strutf16len", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?countcc"}, ["fnl/docstring"] = "The result is a Number, which is the number of UTF-16 code\nunits in String {string} (after converting it to UTF-16).\n\nWhen {countcc} is TRUE, composing characters are counted\nseparately.\nWhen {countcc} is omitted or FALSE, composing characters are\nignored.\n\nReturns zero on error.\n\nAlso see |strlen()| and |strcharlen()|.\nExamples: >vim\n    echo strutf16len('a')\t\t\" returns 1\n    echo strutf16len('\194\169')\t\t\" returns 1\n    echo strutf16len('\240\159\152\138')\t\t\" returns 2\n    echo strutf16len('a\204\168\204\129')\t\t\" returns 1\n    echo strutf16len('a\204\168\204\129', v:true)\t\" returns 3\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {countcc} (`0|1?`)\n\n                Return: ~\n                  (`integer`)"}}, strwidth = {binding = "strwidth", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "The result is a Number, which is the number of display cells\nString {string} occupies.  A Tab character is counted as one\ncell, alternatively use |strdisplaywidth()|.\nWhen {string} contains characters with East Asian Width Class\nAmbiguous, this function's return value depends on 'ambiwidth'.\nReturns zero on error.\nAlso see |strlen()|, |strdisplaywidth()| and |strchars()|.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n\n                Return: ~\n                  (`integer`)"}}, submatch = {binding = "submatch", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "?list"}, ["fnl/docstring"] = "Only for an expression in a |:substitute| command or\nsubstitute() function.\nReturns the {nr}th submatch of the matched text.  When {nr}\nis 0 the whole matched text is returned.\nNote that a NL in the string can stand for a line break of a\nmulti-line match or a NUL character in the text.\nAlso see |sub-replace-expression|.\n\nIf {list} is present and non-zero then submatch() returns\na list of strings, similar to |getline()| with two arguments.\nNL characters in the text represent NUL characters in the\ntext.\nOnly returns more than one item for |:substitute|, inside\n|substitute()| this list will always contain one or zero\nitems, since there are no real line breaks.\n\nWhen substitute() is used recursively only the submatches in\nthe current (deepest) call can be obtained.\n\nReturns an empty string or list on error.\n\nExamples: >vim\n\ts/\\d\\+/\\=submatch(0) + 1/\n\techo substitute(text, '\\d\\+', '\\=submatch(0) + 1', '')\n<\t\tThis finds the first number in the line and adds one to it.\nA line break is included as a newline character.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {list} (`nil?`)\n\n                Return: ~\n                  (`string`)"}}, substitute = {binding = "substitute", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "pat", "sub", "flags"}, ["fnl/docstring"] = "The result is a String, which is a copy of {string}, in which\nthe first match of {pat} is replaced with {sub}.\nWhen {flags} is \"g\", all matches of {pat} in {string} are\nreplaced.  Otherwise {flags} should be \"\".\n\nThis works like the \":substitute\" command (without any flags).\nBut the matching with {pat} is always done like the 'magic'\noption is set and 'cpoptions' is empty (to make scripts\nportable).  'ignorecase' is still relevant, use |/\\c| or |/\\C|\nif you want to ignore or match case and ignore 'ignorecase'.\n'smartcase' is not used.  See |string-match| for how {pat} is\nused.\n\nA \"~\" in {sub} is not replaced with the previous {sub}.\nNote that some codes in {sub} have a special meaning\n|sub-replace-special|.  For example, to replace something with\n\"\\n\" (two characters), use \"\\\\\\\\n\" or '\\\\n'.\n\nWhen {pat} does not match in {string}, {string} is returned\nunmodified.\n\nExample: >vim\n\tlet &path = substitute(&path, \",\\\\=[^,]*$\", \"\", \"\")\n<\t\tThis removes the last component of the 'path' option. >vim\n\techo substitute(\"testing\", \".*\", \"\\\\U\\\\0\", \"\")\n<\t\tresults in \"TESTING\".\n\nWhen {sub} starts with \"\\=\", the remainder is interpreted as\nan expression. See |sub-replace-expression|.  Example: >vim\n\techo substitute(s, '%\\(\\x\\x\\)',\n\t   \\ '\\=nr2char(\"0x\" .. submatch(1))', 'g')\n\n<\t\tWhen {sub} is a Funcref that function is called, with one\noptional argument.  Example: >vim\n   echo substitute(s, '%\\(\\x\\x\\)', SubNr, 'g')\n<\t\tThe optional argument is a list which contains the whole\nmatched string and up to nine submatches, like what\n|submatch()| returns.  Example: >vim\n   echo substitute(s, '%\\(\\x\\x\\)', {m -> '0x' .. m[1]}, 'g')\n\n<\t\tReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {pat} (`string`)\n                  \226\128\162 {sub} (`string`)\n                  \226\128\162 {flags} (`string`)\n\n                Return: ~\n                  (`string`)"}}, swapfilelist = {binding = "swapfilelist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a list of swap file names, like what \"vim -r\" shows.\nSee the |-r| command argument.  The 'directory' option is used\nfor the directories to inspect.  If you only want to get a\nlist of swap files in the current directory then temporarily\nset 'directory' to a dot: >vim\n\tlet save_dir = &directory\n\tlet &directory = '.'\n\tlet swapfiles = swapfilelist()\n\tlet &directory = save_dir\n\n                Return: ~\n                  (`string[]`)"}}, swapinfo = {binding = "swapinfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fname"}, ["fnl/docstring"] = "The result is a dictionary, which holds information about the\nswapfile {fname}. The available fields are:\n\tversion Vim version\n\tuser\tuser name\n\thost\thost name\n\tfname\toriginal file name\n\tpid\tPID of the Nvim process that created the swap\n\t\tfile, or zero if not running.\n\tmtime\tlast modification time in seconds\n\tinode\tOptional: INODE number of the file\n\tdirty\0091 if file was modified, 0 if not\nIn case of failure an \"error\" item is added with the reason:\n\tCannot open file: file not found or in accessible\n\tCannot read file: cannot read first block\n\tNot a swap file: does not contain correct block ID\n\tMagic number mismatch: Info in first block is invalid\n\n                Parameters: ~\n                  \226\128\162 {fname} (`string`)\n\n                Return: ~\n                  (`any`)"}}, swapname = {binding = "swapname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf"}, ["fnl/docstring"] = "The result is the swap file path of the buffer {buf}.\nFor the use of {buf}, see |bufname()| above.\nIf buffer {buf} is the current buffer, the result is equal to\n|:swapname| (unless there is no swap file).\nIf buffer {buf} has no swap file, returns an empty string.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string`)\n\n                Return: ~\n                  (`string`)"}}, synID = {binding = "synID", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "col", "trans"}, ["fnl/docstring"] = "The result is a Number, which is the syntax ID at the position\n{lnum} and {col} in the current window.\nThe syntax ID can be used with |synIDattr()| and\n|synIDtrans()| to obtain syntax information about text.\n\n{col} is 1 for the leftmost column, {lnum} is 1 for the first\nline.  'synmaxcol' applies, in a longer line zero is returned.\nNote that when the position is after the last character,\nthat's where the cursor can be in Insert mode, synID() returns\nzero.  {lnum} is used like with |getline()|.\n\nWhen {trans} is |TRUE|, transparent items are reduced to the\nitem that they reveal.  This is useful when wanting to know\nthe effective color.  When {trans} is |FALSE|, the transparent\nitem is returned.  This is useful when wanting to know which\nsyntax item is effective (e.g. inside parens).\nWarning: This function can be very slow.  Best speed is\nobtained by going through the file in forward direction.\n\nReturns zero on error.\n\nExample (echoes the name of the syntax item under the cursor): >vim\n\techo synIDattr(synID(line(\".\"), col(\".\"), 1), \"name\")\n<\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {col} (`integer`)\n                  \226\128\162 {trans} (`0|1`)\n\n                Return: ~\n                  (`integer`)"}}, synIDattr = {binding = "synIDattr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"synID", "what", "?mode"}, ["fnl/docstring"] = "The result is a String, which is the {what} attribute of\nsyntax ID {synID}.  This can be used to obtain information\nabout a syntax item.\n{mode} can be \"gui\" or \"cterm\", to get the attributes\nfor that mode.  When {mode} is omitted, or an invalid value is\nused, the attributes for the currently active highlighting are\nused (GUI or cterm).\nUse synIDtrans() to follow linked highlight groups.\n{what}\t\tresult\n\"name\"\t\tthe name of the syntax item\n\"fg\"\t\tforeground color (GUI: color name used to set\n\t\tthe color, cterm: color number as a string,\n\t\tterm: empty string)\n\"bg\"\t\tbackground color (as with \"fg\")\n\"font\"\t\tfont name (only available in the GUI)\n\t\t|highlight-font|\n\"sp\"\t\tspecial color (as with \"fg\") |guisp|\n\"fg#\"\t\tlike \"fg\", but for the GUI and the GUI is\n\t\trunning the name in \"#RRGGBB\" form\n\"bg#\"\t\tlike \"fg#\" for \"bg\"\n\"sp#\"\t\tlike \"fg#\" for \"sp\"\n\"bold\"\t\t\"1\" if bold\n\"italic\"\t\"1\" if italic\n\"reverse\"\t\"1\" if reverse\n\"inverse\"\t\"1\" if inverse (= reverse)\n\"standout\"\t\"1\" if standout\n\"underline\"\t\"1\" if underlined\n\"undercurl\"\t\"1\" if undercurled\n\"underdouble\"\t\"1\" if double underlined\n\"underdotted\"\t\"1\" if dotted underlined\n\"underdashed\"\t\"1\" if dashed underlined\n\"strikethrough\"\t\"1\" if struckthrough\n\"altfont\"\t\"1\" if alternative font\n\"nocombine\"\t\"1\" if nocombine\n\nReturns an empty string on error.\n\nExample (echoes the color of the syntax item under the\ncursor): >vim\n\techo synIDattr(synIDtrans(synID(line(\".\"), col(\".\"), 1)), \"fg\")\n<\nCan also be used as a |method|: >vim\n\techo synID(line(\".\"), col(\".\"), 1)->synIDtrans()->synIDattr(\"fg\")\n<\n\n                Parameters: ~\n                  \226\128\162 {synID} (`integer`)\n                  \226\128\162 {what} (`string`)\n                  \226\128\162 {mode} (`string?`)\n\n                Return: ~\n                  (`string`)"}}, synIDtrans = {binding = "synIDtrans", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"synID"}, ["fnl/docstring"] = "The result is a Number, which is the translated syntax ID of\n{synID}.  This is the syntax group ID of what is being used to\nhighlight the character.  Highlight links given with\n\":highlight link\" are followed.\n\nReturns zero on error.\n\n                Parameters: ~\n                  \226\128\162 {synID} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, synconcealed = {binding = "synconcealed", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "col"}, ["fnl/docstring"] = "The result is a |List| with currently three items:\n1. The first item in the list is 0 if the character at the\n   position {lnum} and {col} is not part of a concealable\n   region, 1 if it is.  {lnum} is used like with |getline()|.\n2. The second item in the list is a string. If the first item\n   is 1, the second item contains the text which will be\n   displayed in place of the concealed text, depending on the\n   current setting of 'conceallevel' and 'listchars'.\n3. The third and final item in the list is a number\n   representing the specific syntax region matched in the\n   line. When the character is not concealed the value is\n   zero. This allows detection of the beginning of a new\n   concealable region if there are two consecutive regions\n   with the same replacement character.  For an example, if\n   the text is \"123456\" and both \"23\" and \"45\" are concealed\n   and replaced by the character \"X\", then:\n\tcall\t\t\treturns ~\n\tsynconcealed(lnum, 1)   [0, '', 0]\n\tsynconcealed(lnum, 2)   [1, 'X', 1]\n\tsynconcealed(lnum, 3)   [1, 'X', 1]\n\tsynconcealed(lnum, 4)   [1, 'X', 2]\n\tsynconcealed(lnum, 5)   [1, 'X', 2]\n\tsynconcealed(lnum, 6)   [0, '', 0]\n\nNote: Doesn't consider |matchadd()| highlighting items,\nsince syntax and matching highlighting are two different\nmechanisms |syntax-vs-match|.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`[integer, string, integer]`)"}}, synstack = {binding = "synstack", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum", "col"}, ["fnl/docstring"] = "Return a |List|, which is the stack of syntax items at the\nposition {lnum} and {col} in the current window.  {lnum} is\nused like with |getline()|.  Each item in the List is an ID\nlike what |synID()| returns.\nThe first item in the List is the outer region, following are\nitems contained in that one.  The last one is what |synID()|\nreturns, unless not the whole item is highlighted or it is a\ntransparent item.\nThis function is useful for debugging a syntax file.\nExample that shows the syntax stack under the cursor: >vim\n\tfor id in synstack(line(\".\"), col(\".\"))\n\t   echo synIDattr(id, \"name\")\n\tendfor\n<\t\tWhen the position specified with {lnum} and {col} is invalid\nan empty list is returned.  The position just after the last\ncharacter in a line and the first column in an empty line are\nvalid positions.\n\n                Parameters: ~\n                  \226\128\162 {lnum} (`integer|string`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`integer[]`)"}}, system = {binding = "system", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "?input"}, ["fnl/docstring"] = "Note: Prefer |vim.system()| in Lua.\n\nGets the output of {cmd} as a |string| (|systemlist()| returns\na |List|) and sets |v:shell_error| to the error code.\n{cmd} is treated as in |jobstart()|:\nIf {cmd} is a List it runs directly (no 'shell').\nIf {cmd} is a String it runs in the 'shell', like this: >vim\n  call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n\n<\t\tNot to be used for interactive commands.\n\nResult is a String, filtered to avoid platform-specific quirks:\n- <CR><NL> is replaced with <NL>\n- NUL characters are replaced with SOH (0x01)\n\nExample: >vim\n    echo system(['ls', expand('%:h')])\n\n<\t\tIf {input} is a string it is written to a pipe and passed as\nstdin to the command.  The string is written as-is, line\nseparators are not changed.\nIf {input} is a |List| it is written to the pipe as\n|writefile()| does with {binary} set to \"b\" (i.e. with\na newline between each list item, and newlines inside list\nitems converted to NULs).\nWhen {input} is given and is a valid buffer id, the content of\nthe buffer is written to the file line by line, each line\nterminated by NL (and NUL where the text has NL).\n\t\t\t\t\t\t*E5677*\nNote: system() cannot write to or read from backgrounded (\"&\")\nshell commands, e.g.: >vim\n    echo system(\"cat - &\", \"foo\")\n<\t\twhich is equivalent to: >\n    $ echo foo | bash -c 'cat - &'\n<\t\tThe pipes are disconnected (unless overridden by shell\nredirection syntax) before input can reach it. Use\n|jobstart()| instead.\n\nNote: Use |shellescape()| or |::S| with |expand()| or\n|fnamemodify()| to escape special characters in a command\nargument. 'shellquote' and 'shellxquote' must be properly\nconfigured. Example: >vim\n    echo system('ls '..shellescape(expand('%:h')))\n    echo system('ls '..expand('%:h:S'))\n\n<\t\tUnlike \":!cmd\" there is no automatic check for changed files.\nUse |:checktime| to force a check.\n\n                Parameters: ~\n                  \226\128\162 {cmd} (`string|string[]`)\n                  \226\128\162 {input} (`string|string[]|integer?`)\n\n                Return: ~\n                  (`string`)"}}, systemlist = {binding = "systemlist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "?input", "?keepempty"}, ["fnl/docstring"] = "Same as |system()|, but returns a |List| with lines (parts of\noutput separated by NL) with NULs transformed into NLs. Output\nis the same as |readfile()| will output with {binary} argument\nset to \"b\", except that a final newline is not preserved,\nunless {keepempty} is non-zero.\nNote that on MS-Windows you may get trailing CR characters.\n\nTo see the difference between \"echo hello\" and \"echo -n hello\"\nuse |system()| and |split()|: >vim\n\techo split(system('echo hello'), '\\n', 1)\n<\nReturns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {cmd} (`string|string[]`)\n                  \226\128\162 {input} (`string|string[]|integer?`)\n                  \226\128\162 {keepempty} (`integer?`)\n\n                Return: ~\n                  (`string[]`)"}}, tabpagebuflist = {binding = "tabpagebuflist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?arg"}, ["fnl/docstring"] = "The result is a |List|, where each item is the number of the\nbuffer associated with each window in the current tab page.\n{arg} specifies the number of the tab page to be used. When\nomitted the current tab page is used.\nWhen {arg} is invalid the number zero is returned.\nTo get a list of all buffers in all tabs use this: >vim\n\tlet buflist = []\n\tfor i in range(tabpagenr('$'))\n\t   call extend(buflist, tabpagebuflist(i + 1))\n\tendfor\n<\t\tNote that a buffer may appear in more than one window.\n\n                Parameters: ~\n                  \226\128\162 {arg} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, tabpagenr = {binding = "tabpagenr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?arg"}, ["fnl/docstring"] = "The result is a Number, which is the number of the current\ntab page.  The first tab page has number 1.\n\nThe optional argument {arg} supports the following values:\n\t$\tthe number of the last tab page (the tab page\n\t\tcount).\n\t#\tthe number of the last accessed tab page\n\t\t(where |g<Tab>| goes to).  If there is no\n\t\tprevious tab page, 0 is returned.\nThe number can be used with the |:tab| command.\n\nReturns zero on error.\n\n                Parameters: ~\n                  \226\128\162 {arg} (`'$'|'#'?`)\n\n                Return: ~\n                  (`integer`)"}}, tabpagewinnr = {binding = "tabpagewinnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tabarg", "?arg"}, ["fnl/docstring"] = "Like |winnr()| but for tab page {tabarg}.\n{tabarg} specifies the number of tab page to be used.\n{arg} is used like with |winnr()|:\n- When omitted the current window number is returned.  This is\n  the window which will be used when going to this tab page.\n- When \"$\" the number of windows is returned.\n- When \"#\" the previous window nr is returned.\nUseful examples: >vim\n    tabpagewinnr(1)\t    \" current window of tab page 1\n    tabpagewinnr(4, '$')    \" number of windows in tab page 4\n<\t\tWhen {tabarg} is invalid zero is returned.\n\n                Parameters: ~\n                  \226\128\162 {tabarg} (`integer`)\n                  \226\128\162 {arg} (`'$'|'#'?`)\n\n                Return: ~\n                  (`integer`)"}}, tagfiles = {binding = "tagfiles", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a |List| with the file names used to search for tags\nfor the current buffer.  This is the 'tags' option expanded.\n\n                Return: ~\n                  (`string[]`)"}}, taglist = {binding = "taglist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?filename"}, ["fnl/docstring"] = "Returns a |List| of tags matching the regular expression {expr}.\n\nIf {filename} is passed it is used to prioritize the results\nin the same way that |:tselect| does. See |tag-priority|.\n{filename} should be the full path of the file.\n\nEach list item is a dictionary with at least the following\nentries:\n\tname\t\tName of the tag.\n\tfilename\tName of the file where the tag is\n\t\t\tdefined.  It is either relative to the\n\t\t\tcurrent directory or a full path.\n\tcmd\t\tEx command used to locate the tag in\n\t\t\tthe file.\n\tkind\t\tType of the tag.  The value for this\n\t\t\tentry depends on the language specific\n\t\t\tkind values.  Only available when\n\t\t\tusing a tags file generated by\n\t\t\tUniversal/Exuberant ctags or hdrtag.\n\tstatic\t\tA file specific tag.  Refer to\n\t\t\t|static-tag| for more information.\nMore entries may be present, depending on the content of the\ntags file: access, implementation, inherits and signature.\nRefer to the ctags documentation for information about these\nfields.  For C code the fields \"struct\", \"class\" and \"enum\"\nmay appear, they give the name of the entity the tag is\ncontained in.\n\nThe ex-command \"cmd\" can be either an ex search pattern, a\nline number or a line number followed by a byte number.\n\nIf there are no matching tags, then an empty list is returned.\n\nTo get an exact tag match, the anchors '^' and '$' should be\nused in {expr}.  This also make the function work faster.\nRefer to |tag-regexp| for more information about the tag\nsearch regular expression pattern.\n\nRefer to |'tags'| for information about how the tags file is\nlocated by Vim. Refer to |tags-file-format| for the format of\nthe tags file generated by the different ctags tools.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n                  \226\128\162 {filename} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, tan = {binding = "tan", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the tangent of {expr}, measured in radians, as a |Float|\nin the range [-inf, inf].\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo tan(10)\n<\t\t\0090.648361 >vim\n\techo tan(-4.01)\n<\t\t\t-1.181502\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, tanh = {binding = "tanh", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the hyperbolic tangent of {expr} as a |Float| in the\nrange [-1, 1].\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo tanh(0.5)\n<\t\t\0090.462117 >vim\n\techo tanh(-1)\n<\t\t\t-0.761594\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`number`)"}}, tempname = {binding = "tempname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Generates a (non-existent) filename located in the Nvim root\n|tempdir|. Scripts can use the filename as a temporary file.\nExample: >vim\n\tlet tmpfile = tempname()\n\texe \"redir > \" .. tmpfile\n<\n\n                Return: ~\n                  (`string`)"}}, test_garbagecollect_now = {binding = "test_garbagecollect_now", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Like |garbagecollect()|, but executed right away.  This must\nonly be called directly to avoid any structure to exist\ninternally, and |v:testing| must have been set before calling\nany function.   *E1142*\n\n                Return: ~\n                  (`any`)"}}, timer_info = {binding = "timer_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?id"}, ["fnl/docstring"] = "Return a list with information about timers.\nWhen {id} is given only information about this timer is\nreturned.  When timer {id} does not exist an empty list is\nreturned.\nWhen {id} is omitted information about all timers is returned.\n\nFor each timer the information is stored in a |Dictionary| with\nthese items:\n    \"id\"\t    the timer ID\n    \"time\"\t    time the timer was started with\n    \"repeat\"\t    number of times the timer will still fire;\n\t\t    -1 means forever\n    \"callback\"\t    the callback\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, timer_pause = {binding = "timer_pause", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer", "paused"}, ["fnl/docstring"] = "Pause or unpause a timer.  A paused timer does not invoke its\ncallback when its time expires.  Unpausing a timer may cause\nthe callback to be invoked almost immediately if enough time\nhas passed.\n\nPausing a timer is useful to avoid the callback to be called\nfor a short time.\n\nIf {paused} evaluates to a non-zero Number or a non-empty\nString, then the timer is paused, otherwise it is unpaused.\nSee |non-zero-arg|.\n\n                Parameters: ~\n                  \226\128\162 {timer} (`integer`)\n                  \226\128\162 {paused} (`boolean`)\n\n                Return: ~\n                  (`any`)"}}, timer_start = {binding = "timer_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"time", "callback", "?options"}, ["fnl/docstring"] = "Create a timer and return the timer ID.\n\n{time} is the waiting time in milliseconds. This is the\nminimum time before invoking the callback.  When the system is\nbusy or Vim is not waiting for input the time will be longer.\nZero can be used to execute the callback when Vim is back in\nthe main loop.\n\n{callback} is the function to call.  It can be the name of a\nfunction or a |Funcref|.  It is called with one argument, which\nis the timer ID.  The callback is only invoked when Vim is\nwaiting for input.\n\n{options} is a dictionary.  Supported entries:\n   \"repeat\"\tNumber of times to repeat the callback.\n\t\t-1 means forever.  Default is 1.\n\t\tIf the timer causes an error three times in a\n\t\trow the repeat is cancelled.\n\nReturns -1 on error.\n\nExample: >vim\n\tfunc MyHandler(timer)\n\t  echo 'Handler called'\n\tendfunc\n\tlet timer = timer_start(500, 'MyHandler',\n\t\t\\ {'repeat': 3})\n<\t\tThis invokes MyHandler() three times at 500 msec intervals.\n\n                Parameters: ~\n                  \226\128\162 {time} (`number`)\n                  \226\128\162 {callback} (`string|function`)\n                  \226\128\162 {options} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, timer_stop = {binding = "timer_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer"}, ["fnl/docstring"] = "Stop a timer.  The timer callback will no longer be invoked.\n{timer} is an ID returned by timer_start(), thus it must be a\nNumber.  If {timer} does not exist there is no error.\n\n                Parameters: ~\n                  \226\128\162 {timer} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, timer_stopall = {binding = "timer_stopall", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Stop all timers.  The timer callbacks will no longer be\ninvoked.  Useful if some timers is misbehaving.  If there are\nno timers there is no error.\n\n                Return: ~\n                  (`any`)"}}, tolower = {binding = "tolower", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "The result is a copy of the String given, with all uppercase\ncharacters turned into lowercase (just like applying |gu| to\nthe string).  Returns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`string`)"}}, toupper = {binding = "toupper", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "The result is a copy of the String given, with all lowercase\ncharacters turned into uppercase (just like applying |gU| to\nthe string).  Returns an empty string on error.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string`)\n\n                Return: ~\n                  (`string`)"}}, tr = {binding = "tr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"src", "fromstr", "tostr"}, ["fnl/docstring"] = "The result is a copy of the {src} string with all characters\nwhich appear in {fromstr} replaced by the character in that\nposition in the {tostr} string.  Thus the first character in\n{fromstr} is translated into the first character in {tostr}\nand so on.  Exactly like the unix \"tr\" command.\nThis code also deals with multibyte characters properly.\n\nReturns an empty string on error.\n\nExamples: >vim\n\techo tr(\"hello there\", \"ht\", \"HT\")\n<\t\treturns \"Hello THere\" >vim\n\techo tr(\"<blob>\", \"<>\", \"{}\")\n<\t\treturns \"{blob}\"\n\n                Parameters: ~\n                  \226\128\162 {src} (`string`)\n                  \226\128\162 {fromstr} (`string`)\n                  \226\128\162 {tostr} (`string`)\n\n                Return: ~\n                  (`string`)"}}, trim = {binding = "trim", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"text", "?mask", "?dir"}, ["fnl/docstring"] = "Return {text} as a String where any character in {mask} is\nremoved from the beginning and/or end of {text}.\n\nIf {mask} is not given, or is an empty string, {mask} is all\ncharacters up to 0x20, which includes Tab, space, NL and CR,\nplus the non-breaking space character 0xa0.\n\nThe optional {dir} argument specifies where to remove the\ncharacters:\n\0090\tremove from the beginning and end of {text}\n\0091\tremove only at the beginning of {text}\n\0092\tremove only at the end of {text}\nWhen omitted both ends are trimmed.\n\nThis function deals with multibyte characters properly.\nReturns an empty string on error.\n\nExamples: >vim\n\techo trim(\"   some text \")\n<\t\treturns \"some text\" >vim\n\techo trim(\"  \\r\\t\\t\\r RESERVE \\t\\n\\x0B\\xA0\") .. \"_TAIL\"\n<\t\treturns \"RESERVE_TAIL\" >vim\n\techo trim(\"rm<Xrm<>X>rrm\", \"rm<>\")\n<\t\treturns \"Xrm<>X\" (characters in the middle are not removed) >vim\n\techo trim(\"  vim  \", \" \", 2)\n<\t\treturns \"  vim\"\n\n                Parameters: ~\n                  \226\128\162 {text} (`string`)\n                  \226\128\162 {mask} (`string?`)\n                  \226\128\162 {dir} (`0|1|2?`)\n\n                Return: ~\n                  (`string`)"}}, trunc = {binding = "trunc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the largest integral value with magnitude less than or\nequal to {expr} as a |Float| (truncate towards zero).\n{expr} must evaluate to a |Float| or a |Number|.\nReturns 0.0 if {expr} is not a |Float| or a |Number|.\nExamples: >vim\n\techo trunc(1.456)\n<\t\t\0091.0  >vim\n\techo trunc(-5.456)\n<\t\t\t-5.0  >vim\n\techo trunc(4.0)\n<\t\t\0094.0\n\n                Parameters: ~\n                  \226\128\162 {expr} (`number`)\n\n                Return: ~\n                  (`integer`)"}}, type = {binding = "type", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "The result is a Number representing the type of {expr}.\nInstead of using the number directly, it is better to use the\nv:t_ variable that has the value:\n\tNumber:\t    0  |v:t_number|\n\tString:\t    1  |v:t_string|\n\tFuncref:    2  |v:t_func|\n\tList:\t    3  |v:t_list|\n\tDictionary: 4  |v:t_dict|\n\tFloat:\t    5  |v:t_float|\n\tBoolean:    6  |v:t_bool| (|v:false| and |v:true|)\n\tNull:\t    7  (|v:null|)\n\tBlob:\t   10  |v:t_blob|\nFor backward compatibility, this method can be used: >vim\n\tif type(myvar) == type(0) | endif\n\tif type(myvar) == type(\"\") | endif\n\tif type(myvar) == type(function(\"tr\")) | endif\n\tif type(myvar) == type([]) | endif\n\tif type(myvar) == type({}) | endif\n\tif type(myvar) == type(0.0) | endif\n\tif type(myvar) == type(v:true) | endif\n<\t\tIn place of checking for |v:null| type it is better to check\nfor |v:null| directly as it is the only value of this type: >vim\n\tif myvar is v:null | endif\n<\t\tTo check if the v:t_ variables exist use this: >vim\n\tif exists('v:t_number') | endif\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`any`)\n\n                Return: ~\n                  (`integer`)"}}, undofile = {binding = "undofile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Return the name of the undo file that would be used for a file\nwith name {name} when writing.  This uses the 'undodir'\noption, finding directories that exist.  It does not check if\nthe undo file exists.\n{name} is always expanded to the full path, since that is what\nis used internally.\nIf {name} is empty undofile() returns an empty string, since a\nbuffer without a file name will not write an undo file.\nUseful in combination with |:wundo| and |:rundo|.\n\n                Parameters: ~\n                  \226\128\162 {name} (`string`)\n\n                Return: ~\n                  (`string`)"}}, undotree = {binding = "undotree", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?buf"}, ["fnl/docstring"] = "Return the current state of the undo tree for the current\nbuffer, or for a specific buffer if {buf} is given.  The\nresult is a dictionary with the following items:\n  \"seq_last\"\tThe highest undo sequence number used.\n  \"seq_cur\"\tThe sequence number of the current position in\n\t\tthe undo tree.  This differs from \"seq_last\"\n\t\twhen some changes were undone.\n  \"time_cur\"\tTime last used for |:earlier| and related\n\t\tcommands.  Use |strftime()| to convert to\n\t\tsomething readable.\n  \"save_last\"\tNumber of the last file write.  Zero when no\n\t\twrite yet.\n  \"save_cur\"\tNumber of the current position in the undo\n\t\ttree.\n  \"synced\"\tNon-zero when the last undo block was synced.\n\t\tThis happens when waiting from input from the\n\t\tuser.  See |undo-blocks|.\n  \"entries\"\tA list of dictionaries with information about\n\t\tundo blocks.\n\nThe first item in the \"entries\" list is the oldest undo item.\nEach List item is a |Dictionary| with these items:\n  \"seq\"\t\tUndo sequence number.  Same as what appears in\n\t\t|:undolist|.\n  \"time\"\tTimestamp when the change happened.  Use\n\t\t|strftime()| to convert to something readable.\n  \"newhead\"\tOnly appears in the item that is the last one\n\t\tthat was added.  This marks the last change\n\t\tand where further changes will be added.\n  \"curhead\"\tOnly appears in the item that is the last one\n\t\tthat was undone.  This marks the current\n\t\tposition in the undo tree, the block that will\n\t\tbe used by a redo command.  When nothing was\n\t\tundone after the last change this item will\n\t\tnot appear anywhere.\n  \"save\"\tOnly appears on the last block before a file\n\t\twrite.  The number is the write count.  The\n\t\tfirst write has number 1, the last one the\n\t\t\"save_last\" mentioned above.\n  \"alt\"\t\tAlternate entry.  This is again a List of undo\n\t\tblocks.  Each item may again have an \"alt\"\n\t\titem.\n\n                Parameters: ~\n                  \226\128\162 {buf} (`integer|string?`)\n\n                Return: ~\n                  (`vim.fn.undotree.ret`)"}}, uniq = {binding = "uniq", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?func", "?dict"}, ["fnl/docstring"] = "Remove second and succeeding copies of repeated adjacent\n{list} items in-place.  Returns {list}.  If you want a list\nto remain unmodified make a copy first: >vim\n\tlet newlist = uniq(copy(mylist))\n<\t\tThe default compare function uses the string representation of\neach item.  For the use of {func} and {dict} see |sort()|.\n\nReturns zero if {list} is not a |List|.\n\n                Parameters: ~\n                  \226\128\162 {list} (`any`)\n                  \226\128\162 {func} (`any?`)\n                  \226\128\162 {dict} (`any?`)\n\n                Return: ~\n                  (`any[]|0`)"}}, utf16idx = {binding = "utf16idx", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "idx", "?countcc", "?charidx"}, ["fnl/docstring"] = "Same as |charidx()| but returns the UTF-16 code unit index of\nthe byte at {idx} in {string} (after converting it to UTF-16).\n\nWhen {charidx} is present and TRUE, {idx} is used as the\ncharacter index in the String {string} instead of as the byte\nindex.\nAn {idx} in the middle of a UTF-8 sequence is rounded\ndownwards to the beginning of that sequence.\n\nReturns -1 if the arguments are invalid or if there are less\nthan {idx} bytes in {string}. If there are exactly {idx} bytes\nthe length of the string in UTF-16 code units is returned.\n\nSee |byteidx()| and |byteidxcomp()| for getting the byte index\nfrom the UTF-16 index and |charidx()| for getting the\ncharacter index from the UTF-16 index.\nRefer to |string-offset-encoding| for more information.\nExamples: >vim\n\techo utf16idx('a\240\159\152\138\240\159\152\138', 3)\t\" returns 2\n\techo utf16idx('a\240\159\152\138\240\159\152\138', 7)\t\" returns 4\n\techo utf16idx('a\240\159\152\138\240\159\152\138', 1, 0, 1)\t\" returns 2\n\techo utf16idx('a\240\159\152\138\240\159\152\138', 2, 0, 1)\t\" returns 4\n\techo utf16idx('aa\204\168\204\129c', 6)\t\t\" returns 2\n\techo utf16idx('aa\204\168\204\129c', 6, 1)\t\" returns 4\n\techo utf16idx('a\240\159\152\138\240\159\152\138', 9)\t\" returns -1\n<\n\n                Parameters: ~\n                  \226\128\162 {string} (`string`)\n                  \226\128\162 {idx} (`integer`)\n                  \226\128\162 {countcc} (`boolean?`)\n                  \226\128\162 {charidx} (`boolean?`)\n\n                Return: ~\n                  (`integer`)"}}, values = {binding = "values", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Return a |List| with all the values of {dict}.  The |List| is\nin arbitrary order.  Also see |items()| and |keys()|.\nReturns zero if {dict} is not a |Dict|.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`any`)\n\n                Return: ~\n                  (`any`)"}}, virtcol = {binding = "virtcol", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "?list", "?winid"}, ["fnl/docstring"] = "The result is a Number, which is the screen column of the file\nposition given with {expr}.  That is, the total number of\nscreen cells occupied by the part of the line until the end of\nthe character at that position.  When there is a <Tab> at the\nposition, the returned Number will be the column at the end of\nthe <Tab>.  For example, for a <Tab> in column 1, with 'ts'\nset to 8, it returns 8. |conceal| is ignored.\nFor the byte position use |col()|.\n\nFor the use of {expr} see |getpos()| and |col()|.\nWhen {expr} is \"$\", it means the end of the cursor line, so\nthe result is the number of cells in the cursor line plus one.\n\nWhen 'virtualedit' is used {expr} can be [lnum, col, off],\nwhere \"off\" is the offset in screen columns from the start of\nthe character.  E.g., a position within a <Tab> or after the\nlast character.  When \"off\" is omitted zero is used.  When\nVirtual editing is active in the current mode, a position\nbeyond the end of the line can be returned.  Also see\n|'virtualedit'|\n\nIf {list} is present and non-zero then virtcol() returns a\nList with the first and last screen position occupied by the\ncharacter.\n\nWith the optional {winid} argument the values are obtained for\nthat window instead of the current window.\n\nNote that only marks in the current file can be used.\nExamples: >vim\n\t\" With text \"foo^Lbar\" and cursor on the \"^L\":\n\n\techo virtcol(\".\")\t\" returns 5\n\techo virtcol(\".\", 1)\t\" returns [4, 5]\n\techo virtcol(\"$\")\t\" returns 9\n\n\t\" With text \"\t  there\", with 't at 'h':\n\n\techo virtcol(\"'t\")\t\" returns 6\n<\nThe first column is 1.  0 or [0, 0] is returned for an error.\n\nA more advanced example that echoes the maximum length of\nall lines: >vim\n    echo max(map(range(1, line('$')), \"virtcol([v:val, '$'])\"))\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`string|any[]`)\n                  \226\128\162 {list} (`boolean?`)\n                  \226\128\162 {winid} (`integer?`)\n\n                Return: ~\n                  (`any`)"}}, virtcol2col = {binding = "virtcol2col", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"winid", "lnum", "col"}, ["fnl/docstring"] = "The result is a Number, which is the byte index of the\ncharacter in window {winid} at buffer line {lnum} and virtual\ncolumn {col}.\n\nIf buffer line {lnum} is an empty line, 0 is returned.\n\nIf {col} is greater than the last virtual column in line\n{lnum}, then the byte index of the character at the last\nvirtual column is returned.\n\nFor a multi-byte character, the column number of the first\nbyte in the character is returned.\n\nThe {winid} argument can be the window number or the\n|window-ID|. If this is zero, then the current window is used.\n\nReturns -1 if the window {winid} doesn't exist or the buffer\nline {lnum} or virtual column {col} is invalid.\n\nSee also |screenpos()|, |virtcol()| and |col()|.\n\n                Parameters: ~\n                  \226\128\162 {winid} (`integer`)\n                  \226\128\162 {lnum} (`integer`)\n                  \226\128\162 {col} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, visualmode = {binding = "visualmode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?expr"}, ["fnl/docstring"] = "The result is a String, which describes the last Visual mode\nused in the current buffer.  Initially it returns an empty\nstring, but once Visual mode has been used, it returns \"v\",\n\"V\", or \"<CTRL-V>\" (a single CTRL-V character) for\ncharacter-wise, line-wise, or block-wise Visual mode\nrespectively.\nExample: >vim\n\texe \"normal \" .. visualmode()\n<\t\tThis enters the same Visual mode as before.  It is also useful\nin scripts if you wish to act differently depending on the\nVisual mode that was used.\nIf Visual mode is active, use |mode()| to get the Visual mode\n(e.g., in a |:vmap|).\nIf {expr} is supplied and it evaluates to a non-zero Number or\na non-empty String, then the Visual mode will be cleared and\nthe old value is returned.  See |non-zero-arg|.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`boolean?`)\n\n                Return: ~\n                  (`string`)"}}, wait = {binding = "wait", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timeout", "condition", "?interval"}, ["fnl/docstring"] = "Waits until {condition} evaluates to |TRUE|, where {condition}\nis a |Funcref| or |string| containing an expression.\n\n{timeout} is the maximum waiting time in milliseconds, -1\nmeans forever.\n\nCondition is evaluated on user events, internal events, and\nevery {interval} milliseconds (default: 200).\n\nReturns a status integer:\n\0090 if the condition was satisfied before timeout\n\t-1 if the timeout was exceeded\n\t-2 if the function was interrupted (by |CTRL-C|)\n\t-3 if an error occurred\n\n                Parameters: ~\n                  \226\128\162 {timeout} (`integer`)\n                  \226\128\162 {condition} (`any`)\n                  \226\128\162 {interval} (`number?`)\n\n                Return: ~\n                  (`any`)"}}, wildmenumode = {binding = "wildmenumode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns |TRUE| when the wildmenu is active and |FALSE|\notherwise.  See 'wildmenu' and 'wildmode'.\nThis can be used in mappings to handle the 'wildcharm' option\ngracefully. (Makes only sense with |mapmode-c| mappings).\n\nFor example to make <c-j> work like <down> in wildmode, use: >vim\n    cnoremap <expr> <C-j> wildmenumode() ? \"\\<Down>\\<Tab>\" : \"\\<c-j>\"\n<\n(Note: this needs the 'wildcharm' option set appropriately).\n\n                Return: ~\n                  (`any`)"}}, win_execute = {binding = "win_execute", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id", "command", "?silent"}, ["fnl/docstring"] = "Like `execute()` but in the context of window {id}.\nThe window will temporarily be made the current window,\nwithout triggering autocommands or changing directory.  When\nexecuting {command} autocommands will be triggered, this may\nhave unexpected side effects.  Use `:noautocmd` if needed.\nExample: >vim\n\tcall win_execute(winid, 'syntax enable')\n<\t\tDoing the same with `setwinvar()` would not trigger\nautocommands and not actually show syntax highlighting.\n\nWhen window {id} does not exist then no error is given and\nan empty string is returned.\n\n                Parameters: ~\n                  \226\128\162 {id} (`integer`)\n                  \226\128\162 {command} (`string`)\n                  \226\128\162 {silent} (`boolean?`)\n\n                Return: ~\n                  (`any`)"}}, win_findbuf = {binding = "win_findbuf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr"}, ["fnl/docstring"] = "Returns a |List| with |window-ID|s for windows that contain\nbuffer {bufnr}.  When there is none the list is empty.\n\n                Parameters: ~\n                  \226\128\162 {bufnr} (`integer`)\n\n                Return: ~\n                  (`integer[]`)"}}, win_getid = {binding = "win_getid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?win", "?tab"}, ["fnl/docstring"] = "Get the |window-ID| for the specified window.\nWhen {win} is missing use the current window.\nWith {win} this is the window number.  The top window has\nnumber 1.\nWithout {tab} use the current tab, otherwise the tab with\nnumber {tab}.  The first tab has number one.\nReturn zero if the window cannot be found.\n\n                Parameters: ~\n                  \226\128\162 {win} (`integer?`)\n                  \226\128\162 {tab} (`integer?`)\n\n                Return: ~\n                  (`integer`)"}}, win_gettype = {binding = "win_gettype", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?nr"}, ["fnl/docstring"] = "Return the type of the window:\n\t\"autocmd\"\tautocommand window. Temporary window\n\t\t\tused to execute autocommands.\n\t\"command\"\tcommand-line window |cmdwin|\n\t(empty)\t\tnormal window\n\t\"loclist\"\t|location-list-window|\n\t\"popup\"\t\tfloating window |api-floatwin|\n\t\"preview\"\tpreview window |preview-window|\n\t\"quickfix\"\t|quickfix-window|\n\t\"unknown\"\twindow {nr} not found\n\nWhen {nr} is omitted return the type of the current window.\nWhen {nr} is given return the type of this window by number or\n|window-ID|.\n\nAlso see the 'buftype' option.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer?`)\n\n                Return: ~\n                  (`'autocmd'|'command'|''|'loclist'|'popup'|'preview'|'quickfix'|'unknown'`)"}}, win_gotoid = {binding = "win_gotoid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Go to window with ID {expr}.  This may also change the current\ntabpage.\nReturn TRUE if successful, FALSE if the window cannot be found.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`integer`)\n\n                Return: ~\n                  (`0|1`)"}}, win_id2tabwin = {binding = "win_id2tabwin", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return a list with the tab number and window number of window\nwith ID {expr}: [tabnr, winnr].\nReturn [0, 0] if the window cannot be found.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, win_id2win = {binding = "win_id2win", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr"}, ["fnl/docstring"] = "Return the window number of window with ID {expr}.\nReturn 0 if the window cannot be found in the current tabpage.\n\n                Parameters: ~\n                  \226\128\162 {expr} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, win_move_separator = {binding = "win_move_separator", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "offset"}, ["fnl/docstring"] = "Move window {nr}'s vertical separator (i.e., the right border)\nby {offset} columns, as if being dragged by the mouse. {nr}\ncan be a window number or |window-ID|. A positive {offset}\nmoves right and a negative {offset} moves left. Moving a\nwindow's vertical separator will change the width of the\nwindow and the width of other windows adjacent to the vertical\nseparator. The magnitude of movement may be smaller than\nspecified (e.g., as a consequence of maintaining\n'winminwidth'). Returns TRUE if the window can be found and\nFALSE otherwise.\nThis will fail for the rightmost window and a full-width\nwindow, since it has no separator on the right.\nOnly works for the current tab page. *E1308*\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {offset} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, win_move_statusline = {binding = "win_move_statusline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "offset"}, ["fnl/docstring"] = "Move window {nr}'s status line (i.e., the bottom border) by\n{offset} rows, as if being dragged by the mouse. {nr} can be a\nwindow number or |window-ID|. A positive {offset} moves down\nand a negative {offset} moves up. Moving a window's status\nline will change the height of the window and the height of\nother windows adjacent to the status line. The magnitude of\nmovement may be smaller than specified (e.g., as a consequence\nof maintaining 'winminheight'). Returns TRUE if the window can\nbe found and FALSE otherwise.\nOnly works for the current tab page.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {offset} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, win_screenpos = {binding = "win_screenpos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr"}, ["fnl/docstring"] = "Return the screen position of window {nr} as a list with two\nnumbers: [row, col].  The first window always has position\n[1, 1], unless there is a tabline, then it is [2, 1].\n{nr} can be the window number or the |window-ID|.  Use zero\nfor the current window.\nReturns [0, 0] if the window cannot be found.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n\n                Return: ~\n                  (`any`)"}}, win_splitmove = {binding = "win_splitmove", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr", "target", "?options"}, ["fnl/docstring"] = "Temporarily switch to window {target}, then move window {nr}\nto a new split adjacent to {target}.\nUnlike commands such as |:split|, no new windows are created\n(the |window-ID| of window {nr} is unchanged after the move).\n\nBoth {nr} and {target} can be window numbers or |window-ID|s.\nBoth must be in the current tab page.\n\nReturns zero for success, non-zero for failure.\n\n{options} is a |Dictionary| with the following optional entries:\n  \"vertical\"\tWhen TRUE, the split is created vertically,\n\t\tlike with |:vsplit|.\n  \"rightbelow\"\tWhen TRUE, the split is made below or to the\n\t\tright (if vertical).  When FALSE, it is done\n\t\tabove or to the left (if vertical).  When not\n\t\tpresent, the values of 'splitbelow' and\n\t\t'splitright' are used.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n                  \226\128\162 {target} (`integer`)\n                  \226\128\162 {options} (`table?`)\n\n                Return: ~\n                  (`any`)"}}, winbufnr = {binding = "winbufnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr"}, ["fnl/docstring"] = "The result is a Number, which is the number of the buffer\nassociated with window {nr}.  {nr} can be the window number or\nthe |window-ID|.\nWhen {nr} is zero, the number of the buffer in the current\nwindow is returned.\nWhen window {nr} doesn't exist, -1 is returned.\nExample: >vim\n  echo \"The file in the current window is \" .. bufname(winbufnr(0))\n<\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, wincol = {binding = "wincol", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number, which is the virtual column of the\ncursor in the window.  This is counting screen cells from the\nleft side of the window.  The leftmost column is one.\n\n                Return: ~\n                  (`integer`)"}}, windowsversion = {binding = "windowsversion", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a String.  For MS-Windows it indicates the OS\nversion.  E.g, Windows 10 is \"10.0\", Windows 8 is \"6.2\",\nWindows XP is \"5.1\".  For non-MS-Windows systems the result is\nan empty string.\n\n                Return: ~\n                  (`string`)"}}, winheight = {binding = "winheight", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr"}, ["fnl/docstring"] = "Gets the height of |window-ID| {nr} (zero for \"current\nwindow\"), excluding any 'winbar' and 'statusline'. Returns -1\nif window {nr} doesn't exist. An existing window always has\na height of zero or more.\n\nExamples: >vim\n  echo \"Current window has \" .. winheight(0) .. \" lines.\"\n<\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, winlayout = {binding = "winlayout", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?tabnr"}, ["fnl/docstring"] = "The result is a nested List containing the layout of windows\nin a tabpage.\n\nWithout {tabnr} use the current tabpage, otherwise the tabpage\nwith number {tabnr}. If the tabpage {tabnr} is not found,\nreturns an empty list.\n\nFor a leaf window, it returns: >\n\t[\"leaf\", {winid}]\n<\nFor horizontally split windows, which form a column, it\nreturns: >\n\t[\"col\", [{nested list of windows}]]\n<\t\tFor vertically split windows, which form a row, it returns: >\n\t[\"row\", [{nested list of windows}]]\n<\nExample: >vim\n\t\" Only one window in the tab page\n\techo winlayout()\n<\t\t >\n\t['leaf', 1000]\n<\t\t >vim\n\t\" Two horizontally split windows\n\techo winlayout()\n<\t\t >\n\t['col', [['leaf', 1000], ['leaf', 1001]]]\n<\t\t >vim\n\t\" The second tab page, with three horizontally split\n\t\" windows, with two vertically split windows in the\n\t\" middle window\n\techo winlayout(2)\n<\t\t >\n\t['col', [['leaf', 1002], ['row', [['leaf', 1003],\n\t\t\t    ['leaf', 1001]]], ['leaf', 1000]]]\n<\n\n                Parameters: ~\n                  \226\128\162 {tabnr} (`integer?`)\n\n                Return: ~\n                  (`vim.fn.winlayout.ret`)"}}, winline = {binding = "winline", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a Number, which is the screen line of the cursor\nin the window.  This is counting screen lines from the top of\nthe window.  The first line is one.\nIf the cursor was moved the view on the file will be updated\nfirst, this may cause a scroll.\n\n                Return: ~\n                  (`integer`)"}}, winnr = {binding = "winnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?arg"}, ["fnl/docstring"] = "The result is a Number, which is the number of the current\nwindow.  The top window has number 1.\nReturns zero for a popup window.\n\nThe optional argument {arg} supports the following values:\n\t$\tthe number of the last window (the window\n\t\tcount).\n\t#\tthe number of the last accessed window (where\n\t\t|CTRL-W_p| goes to).  If there is no previous\n\t\twindow or it is in another tab page 0 is\n\t\treturned.  May refer to the current window in\n\t\tsome cases (e.g. when evaluating 'statusline'\n\t\texpressions).\n\t{N}j\tthe number of the Nth window below the\n\t\tcurrent window (where |CTRL-W_j| goes to).\n\t{N}k\tthe number of the Nth window above the current\n\t\twindow (where |CTRL-W_k| goes to).\n\t{N}h\tthe number of the Nth window left of the\n\t\tcurrent window (where |CTRL-W_h| goes to).\n\t{N}l\tthe number of the Nth window right of the\n\t\tcurrent window (where |CTRL-W_l| goes to).\nThe number can be used with |CTRL-W_w| and \":wincmd w\"\n|:wincmd|.\nWhen {arg} is invalid an error is given and zero is returned.\nAlso see |tabpagewinnr()| and |win_getid()|.\nExamples: >vim\n\tlet window_count = winnr('$')\n\tlet prev_window = winnr('#')\n\tlet wnum = winnr('3k')\n<\n\n                Parameters: ~\n                  \226\128\162 {arg} (`string|integer?`)\n\n                Return: ~\n                  (`integer`)"}}, winrestcmd = {binding = "winrestcmd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a sequence of |:resize| commands that should restore\nthe current window sizes.  Only works properly when no windows\nare opened or closed and the current window and tab page is\nunchanged.\nExample: >vim\n\tlet cmd = winrestcmd()\n\tcall MessWithWindowSizes()\n\texe cmd\n<\n\n                Return: ~\n                  (`string`)"}}, winrestview = {binding = "winrestview", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dict"}, ["fnl/docstring"] = "Uses the |Dictionary| returned by |winsaveview()| to restore\nthe view of the current window.\nNote: The {dict} does not have to contain all values, that are\nreturned by |winsaveview()|. If values are missing, those\nsettings won't be restored. So you can use: >vim\n    call winrestview({'curswant': 4})\n<\nThis will only set the curswant value (the column the cursor\nwants to move on vertical movements) of the cursor to column 5\n(yes, that is 5), while all other settings will remain the\nsame. This is useful, if you set the cursor position manually.\n\nIf you have changed the values the result is unpredictable.\nIf the window size changed the result won't be the same.\n\n                Parameters: ~\n                  \226\128\162 {dict} (`vim.fn.winrestview.dict`)\n\n                Return: ~\n                  (`any`)"}}, winsaveview = {binding = "winsaveview", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a |Dictionary| that contains information to restore\nthe view of the current window.  Use |winrestview()| to\nrestore the view.\nThis is useful if you have a mapping that jumps around in the\nbuffer and you want to go back to the original view.\nThis does not save fold information.  Use the 'foldenable'\noption to temporarily switch off folding, so that folds are\nnot opened when moving around. This may have side effects.\nThe return value includes:\n\tlnum\t\tcursor line number\n\tcol\t\tcursor column (Note: the first column\n\t\t\tzero, as opposed to what |getcurpos()|\n\t\t\treturns)\n\tcoladd\t\tcursor column offset for 'virtualedit'\n\tcurswant\tcolumn for vertical movement (Note:\n\t\t\tthe first column is zero, as opposed\n\t\t\tto what |getcurpos()| returns).  After\n\t\t\t|$| command it will be a very large\n\t\t\tnumber equal to |v:maxcol|.\n\ttopline\t\tfirst line in the window\n\ttopfill\t\tfiller lines, only in diff mode\n\tleftcol\t\tfirst column displayed; only used when\n\t\t\t'wrap' is off\n\tskipcol\t\tcolumns skipped\nNote that no option values are saved.\n\n                Return: ~\n                  (`vim.fn.winsaveview.ret`)"}}, winwidth = {binding = "winwidth", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"nr"}, ["fnl/docstring"] = "Gets the width of |window-ID| {nr} (zero for \"current\nwindow\"), including columns (|sign-column|, 'statuscolumn',\netc.). Returns -1 if window {nr} doesn't exist. An existing\nwindow always has a width of zero or more.\n\nExample: >vim\n  echo \"Current window has \" .. winwidth(0) .. \" columns.\"\n  if winwidth(0) <= 50\n    50 wincmd |\n  endif\n<\nTo get the buffer \"viewport\", use |getwininfo()|: >vim\n    :echo getwininfo(win_getid())[0].width - getwininfo(win_getid())[0].textoff\n<\nTo get the Nvim screen size, see the 'columns' option.\n\n                Parameters: ~\n                  \226\128\162 {nr} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}, wordcount = {binding = "wordcount", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The result is a dictionary of byte/chars/word statistics for\nthe current buffer.  This is the same info as provided by\n|g_CTRL-G|\nThe return value includes:\n\tbytes\t\tNumber of bytes in the buffer\n\tchars\t\tNumber of chars in the buffer\n\twords\t\tNumber of words in the buffer\n\tcursor_bytes    Number of bytes before cursor position\n\t\t\t(not in Visual mode)\n\tcursor_chars    Number of chars before cursor position\n\t\t\t(not in Visual mode)\n\tcursor_words    Number of words before cursor position\n\t\t\t(not in Visual mode)\n\tvisual_bytes    Number of bytes visually selected\n\t\t\t(only in Visual mode)\n\tvisual_chars    Number of chars visually selected\n\t\t\t(only in Visual mode)\n\tvisual_words    Number of words visually selected\n\t\t\t(only in Visual mode)\n\n                Return: ~\n                  (`any`)"}}, writefile = {binding = "writefile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"object", "fname", "?flags"}, ["fnl/docstring"] = "When {object} is a |List| write it to file {fname}.  Each list\nitem is separated with a NL.  Each list item must be a String\nor Number.\nAll NL characters are replaced with a NUL character.\nInserting CR characters needs to be done before passing {list}\nto writefile().\n\nWhen {object} is a |Blob| write the bytes to file {fname}\nunmodified, also when binary mode is not specified.\n\n{flags} must be a String.  These characters are recognized:\n\n'b'  Binary mode is used: There will not be a NL after the\n     last list item.  An empty item at the end does cause the\n     last line in the file to end in a NL.\n\n'a'  Append mode is used, lines are appended to the file: >vim\n\tcall writefile([\"foo\"], \"event.log\", \"a\")\n\tcall writefile([\"bar\"], \"event.log\", \"a\")\n<\n'D'  Delete the file when the current function ends.  This\n     works like: >vim\n\tdefer delete({fname})\n<\t\t     Fails when not in a function.  Also see |:defer|.\n\n's'  fsync() is called after writing the file.  This flushes\n     the file to disk, if possible.  This takes more time but\n     avoids losing the file if the system crashes.\n\n'S'  fsync() is not called, even when 'fsync' is set.\n\n     When {flags} does not contain \"S\" or \"s\" then fsync() is\n     called if the 'fsync' option is set.\n\nAn existing file is overwritten, if possible.\n\nWhen the write fails -1 is returned, otherwise 0.  There is an\nerror message if the file can't be created or when writing\nfails.\n\nAlso see |readfile()|.\nTo copy a file byte for byte: >vim\n\tlet fl = readfile(\"foo\", \"b\")\n\tcall writefile(fl, \"foocopy\", \"b\")\n<\n\n                Parameters: ~\n                  \226\128\162 {object} (`any`)\n                  \226\128\162 {fname} (`string`)\n                  \226\128\162 {flags} (`string?`)\n\n                Return: ~\n                  (`any`)"}}, xor = {binding = "xor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"expr", "expr1"}, ["fnl/docstring"] = "Bitwise XOR on the two arguments.  The arguments are converted\nto a number.  A List, Dict or Float argument causes an error.\nAlso see `and()` and `or()`.\nExample: >vim\n\tlet bits = xor(bits, 0x80)\n<\n\n                Parameters: ~\n                  \226\128\162 {expr} (`integer`)\n                  \226\128\162 {expr1} (`integer`)\n\n                Return: ~\n                  (`integer`)"}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "Builtin functions"}}, fs = {binding = "fs", fields = {abspath = {binding = "abspath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path"}, ["fnl/docstring"] = "Convert path to an absolute path. A tilde (~) character at the beginning\nof the path is expanded to the user's home directory. Does not check if\nthe path exists, normalize the path, resolve symlinks or hardlinks\n(including `.` and `..`), or expand environment variables. If the path is\nalready absolute, it is returned unchanged. Also converts `\\` path\nseparators to `/`.\n\nParameters: ~\n  \226\128\162 {path}  (`string`) Path\n\nReturn: ~\n    (`string`) Absolute path"}}, basename = {binding = "basename", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?file"}, ["fnl/docstring"] = "Return the basename of the given path\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {file}  (`string?`) Path\n\nReturn: ~\n    (`string?`) Basename of {file}"}}, dir = {binding = "dir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "?opts"}, ["fnl/docstring"] = "Return an iterator over the items located in {path}\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {path}  (`string`) An absolute or relative path to the directory to\n            iterate over. The path is first normalized\n            |vim.fs.normalize()|.\n  \226\128\162 {opts}  (`table?`) Optional keyword arguments:\n            \226\128\162 {depth}? (`integer`, default: `1`) How deep the traverse.\n            \226\128\162 {skip}? (`fun(dir_name: string): boolean`) Predicate to\n              control traversal. Return false to stop searching the\n              current directory. Only useful when depth > 1 Return an\n              iterator over the items located in {path}\n            \226\128\162 {follow}? (`boolean`, default: `false`) Follow symbolic\n              links.\n\nReturn: ~\n    (`Iterator`) over items in {path}. Each iteration yields two values:\n    \"name\" and \"type\". \"name\" is the basename of the item relative to\n    {path}. \"type\" is one of the following: \"file\", \"directory\", \"link\",\n    \"fifo\", \"socket\", \"char\", \"block\", \"unknown\"."}}, dirname = {binding = "dirname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?file"}, ["fnl/docstring"] = "Gets the parent directory of the given path (not expanded/resolved, the\ncaller must do that).\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {file}  (`string?`) Path\n\nReturn: ~\n    (`string?`) Parent directory of {file}"}}, find = {binding = "find", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"names", "?opts"}, ["fnl/docstring"] = "Find files or directories (or other items as specified by `opts.type`) in\nthe given path.\n\nFinds items given in {names} starting from {path}. If {upward} is \"true\"\nthen the search traverses upward through parent directories; otherwise,\nthe search traverses downward. Note that downward searches are recursive\nand may search through many directories! If {stop} is non-nil, then the\nsearch stops when the directory given in {stop} is reached. The search\nterminates when {limit} (default 1) matches are found. You can set {type}\nto \"file\", \"directory\", \"link\", \"socket\", \"char\", \"block\", or \"fifo\" to\nnarrow the search to find only that type.\n\nExamples: >lua\n    -- List all test directories under the runtime directory.\n    local dirs = vim.fs.find(\n      { 'test', 'tst', 'testdir' },\n      { limit = math.huge, type = 'directory', path = './runtime/' }\n    )\n\n    -- Get all \"lib/*.cpp\" and \"lib/*.hpp\" files, using Lua patterns.\n    -- Or use `vim.glob.to_lpeg(\226\128\166):match(\226\128\166)` for glob/wildcard matching.\n    local files = vim.fs.find(function(name, path)\n      return name:match('.*%.[ch]pp$') and path:match('[/\\\\]lib$')\n    end, { limit = math.huge, type = 'file' })\n<\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {names}  (`string|string[]|fun(name: string, path: string): boolean`)\n             Names of the items to find. Must be base names, paths and\n             globs are not supported when {names} is a string or a table.\n             If {names} is a function, it is called for each traversed\n             item with args:\n             \226\128\162 name: base name of the current item\n             \226\128\162 path: full path of the current item\n\n             The function should return `true` if the given item is\n             considered a match.\n  \226\128\162 {opts}   (`table?`) Optional keyword arguments:\n             \226\128\162 {path}? (`string`) Path to begin searching from. If\n               omitted, the |current-directory| is used.\n             \226\128\162 {upward}? (`boolean`, default: `false`) Search upward\n               through parent directories. Otherwise, search through child\n               directories (recursively).\n             \226\128\162 {stop}? (`string`) Stop searching when this directory is\n               reached. The directory itself is not searched.\n             \226\128\162 {type}? (`string`) Find only items of the given type. If\n               omitted, all items that match {names} are included.\n             \226\128\162 {limit}? (`number`, default: `1`) Stop the search after\n               finding this many matches. Use `math.huge` to place no\n               limit on the number of matches.\n             \226\128\162 {follow}? (`boolean`, default: `false`) Follow symbolic\n               links.\n\nReturn: ~\n    (`string[]`) Normalized paths |vim.fs.normalize()| of all matching\n    items"}}, joinpath = {binding = "joinpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"..."}, ["fnl/docstring"] = "Concatenates partial paths (one absolute or relative path followed by zero\nor more relative paths). Slashes are normalized: redundant slashes are\nremoved, and (on Windows) backslashes are replaced with forward-slashes.\n\nExamples:\n\226\128\162 \"foo/\", \"/bar\" => \"foo/bar\"\n\226\128\162 Windows: \"a\\foo\\\", \"\\bar\" => \"a/foo/bar\"\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {...}  (`string`)\n\nReturn: ~\n    (`string`)"}}, normalize = {binding = "normalize", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "?opts"}, ["fnl/docstring"] = "Normalize a path to a standard format. A tilde (~) character at the\nbeginning of the path is expanded to the user's home directory and\nenvironment variables are also expanded. \".\" and \"..\" components are also\nresolved, except when the path is relative and trying to resolve it would\nresult in an absolute path.\n\226\128\162 \".\" as the only part in a relative path:\n  \226\128\162 \".\" => \".\"\n  \226\128\162 \"././\" => \".\"\n\226\128\162 \"..\" when it leads outside the current directory\n  \226\128\162 \"foo/../../bar\" => \"../bar\"\n  \226\128\162 \"../../foo\" => \"../../foo\"\n\226\128\162 \"..\" in the root directory returns the root directory.\n  \226\128\162 \"/../../\" => \"/\"\n\nOn Windows, backslash (\\) characters are converted to forward slashes (/).\n\nExamples: >lua\n    [[C:\\Users\\jdoe]]                         => \"C:/Users/jdoe\"\n    \"~/src/neovim\"                            => \"/home/jdoe/src/neovim\"\n    \"$XDG_CONFIG_HOME/nvim/init.vim\"          => \"/Users/jdoe/.config/nvim/init.vim\"\n    \"~/src/nvim/api/../tui/./tui.c\"           => \"/home/jdoe/src/nvim/tui/tui.c\"\n    \"./foo/bar\"                               => \"foo/bar\"\n    \"foo/../../../bar\"                        => \"../../bar\"\n    \"/home/jdoe/../../../bar\"                 => \"/bar\"\n    \"C:foo/../../baz\"                         => \"C:../baz\"\n    \"C:/foo/../../baz\"                        => \"C:/baz\"\n    [[\\\\?\\UNC\\server\\share\\foo\\..\\..\\..\\bar]] => \"//?/UNC/server/share/bar\"\n<\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {path}  (`string`) Path to normalize\n  \226\128\162 {opts}  (`table?`) A table with the following fields:\n            \226\128\162 {expand_env}? (`boolean`, default: `true`) Expand\n              environment variables.\n            \226\128\162 {win}? (`boolean`, default: `true` in Windows, `false`\n              otherwise) Path is a Windows path.\n\nReturn: ~\n    (`string`) Normalized path"}}, parents = {binding = "parents", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"start"}, ["fnl/docstring"] = "Iterate over all the parents of the given path (not expanded/resolved, the\ncaller must do that).\n\nExample: >lua\n    local root_dir\n    for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do\n      if vim.fn.isdirectory(dir .. '/.git') == 1 then\n        root_dir = dir\n        break\n      end\n    end\n\n    if root_dir then\n      print('Found git repository at', root_dir)\n    end\n<\n\nAttributes: ~\n    Since: 0.8.0\n\nParameters: ~\n  \226\128\162 {start}  (`string`) Initial path.\n\nReturn (multiple): ~\n    (`fun(_, dir: string): string?`) Iterator\n    (`nil`)\n    (`string?`)"}}, relpath = {binding = "relpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"base", "target", "?opts"}, ["fnl/docstring"] = "Gets `target` path relative to `base`, or `nil` if `base` is not an\nancestor.\n\nExample: >lua\n    vim.fs.relpath('/var', '/var/lib') -- 'lib'\n    vim.fs.relpath('/var', '/usr/bin') -- nil\n<\n\nParameters: ~\n  \226\128\162 {base}    (`string`)\n  \226\128\162 {target}  (`string`)\n  \226\128\162 {opts}    (`table?`) Reserved for future use\n\nReturn: ~\n    (`string?`)"}}, rm = {binding = "rm", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "?opts"}, ["fnl/docstring"] = "Remove files or directories\n\nAttributes: ~\n    Since: 0.11.0\n\nParameters: ~\n  \226\128\162 {path}  (`string`) Path to remove\n  \226\128\162 {opts}  (`table?`) A table with the following fields:\n            \226\128\162 {recursive}? (`boolean`) Remove directories and their\n              contents recursively\n            \226\128\162 {force}? (`boolean`) Ignore nonexistent files and arguments"}}, root = {binding = "root", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"source", "marker"}, ["fnl/docstring"] = "Find the first parent directory containing a specific \"marker\", relative\nto a file path or buffer.\n\nIf the buffer is unnamed (has no backing file) or has a non-empty\n'buftype' then the search begins from Nvim's |current-directory|.\n\nExamples: >lua\n    -- Find the root of a Python project, starting from file 'main.py'\n    vim.fs.root(vim.fs.joinpath(vim.env.PWD, 'main.py'), {'pyproject.toml', 'setup.py' })\n\n    -- Find the root of a git repository\n    vim.fs.root(0, '.git')\n\n    -- Find the parent directory containing any file with a .csproj extension\n    vim.fs.root(0, function(name, path)\n      return name:match('%.csproj$') ~= nil\n    end)\n\n    -- Find the first ancestor directory containing EITHER \"stylua.toml\" or \".luarc.json\"; if\n    -- not found, find the first ancestor containing \".git\":\n    vim.fs.root(0, { { 'stylua.toml', '.luarc.json' }, '.git' })\n<\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {source}  (`integer|string`) Buffer number (0 for current buffer) or\n              file path (absolute or relative to the |current-directory|)\n              to begin the search from.\n  \226\128\162 {marker}  (`(string|string[]|fun(name: string, path: string): boolean)[]|string|fun(name: string, path: string): boolean`)\n              Filename, function, or list thereof, that decides how to\n              find the root. To indicate \"equal priority\", specify items\n              in a nested list `{ { 'a.txt', 'b.lua' }, \226\128\166 }`. A function\n              item must return true if `name` and `path` are a match. Each\n              item (which may itself be a nested list) is evaluated\n              in-order against all ancestors, until a match is found.\n\nReturn: ~\n    (`string?`) Directory path containing one of the given markers, or nil\n    if no directory was found."}}}, metadata = {["fls/itemKind"] = "Module"}}, g = {binding = "g", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Global (|g:|) editor variables.\nKey with no value returns `nil`."}}, glob = {binding = "glob", fields = {to_lpeg = {binding = "to_lpeg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern"}, ["fnl/docstring"] = "Parses a raw glob into an |lua-lpeg| pattern.\n\nThis uses glob semantics from LSP 3.17.0:\nhttps://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern\n\nGlob patterns can have the following syntax:\n\226\128\162 `*` to match one or more characters in a path segment\n\226\128\162 `?` to match on one character in a path segment\n\226\128\162 `**` to match any number of path segments, including none\n\226\128\162 `{}` to group conditions (e.g. `*.{ts,js}` matches TypeScript and\n  JavaScript files)\n\226\128\162 `[]` to declare a range of characters to match in a path segment (e.g.,\n  `example.[0-9]` to match on `example.0`, `example.1`, \226\128\166)\n\226\128\162 `[!...]` to negate a range of characters to match in a path segment\n  (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not\n  `example.0`)\n\nParameters: ~\n  \226\128\162 {pattern}  (`string`) The raw glob pattern\n\nReturn: ~\n    (`vim.lpeg.Pattern`) pattern An |lua-lpeg| representation of the\n    pattern"}}}, metadata = {["fls/itemKind"] = "Module"}}, go = {binding = "go", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Get or set global |options|. Like `:setglobal`. Invalid key is an error.\n\nNote: this is different from |vim.o| because this accesses the global\noption value and thus is mostly useful for use with |global-local|\noptions.\n\nExample: >lua\n    vim.go.cmdheight = 4\n    print(vim.go.columns)\n    print(vim.go.bar)     -- error: invalid key\n<"}}, gsplit = {binding = "gsplit", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s", "sep", "?opts"}, ["fnl/docstring"] = "Gets an |iterator| that splits a string at each instance of a separator,\nin \"lazy\" fashion (as opposed to |vim.split()| which is \"eager\").\n\nExample: >lua\n    for s in vim.gsplit(':aa::b:', ':', {plain=true}) do\n      print(s)\n    end\n<\n\nIf you want to also inspect the separator itself (instead of discarding\nit), use |string.gmatch()|. Example: >lua\n    for word, num in ('foo111bar222'):gmatch('([^0-9]*)(%d*)') do\n      print(('word: %s num: %s'):format(word, num))\n    end\n<\n\nParameters: ~\n  \226\128\162 {s}     (`string`) String to split\n  \226\128\162 {sep}   (`string`) Separator or pattern\n  \226\128\162 {opts}  (`table?`) Keyword arguments |kwargs|:\n            \226\128\162 {plain}? (`boolean`) Use `sep` literally (as in\n              string.find).\n            \226\128\162 {trimempty}? (`boolean`) Discard empty segments at start and\n              end of the sequence.\n\nReturn: ~\n    (`fun():string?`) Iterator over the split components\n\nSee also: ~\n  \226\128\162 |string.gmatch()|\n  \226\128\162 |vim.split()|\n  \226\128\162 |lua-pattern|s\n  \226\128\162 https://www.lua.org/pil/20.2.html\n  \226\128\162 http://lua-users.org/wiki/StringLibraryTutorial"}}, health = {binding = "health", fields = {error = {binding = "error", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg", "..."}, ["fnl/docstring"] = "Reports an error.\n\nParameters: ~\n  \226\128\162 {msg}  (`string`)\n  \226\128\162 {...}  (`string|string[]`) Optional advice"}}, info = {binding = "info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg"}, ["fnl/docstring"] = "Reports an informational message.\n\nParameters: ~\n  \226\128\162 {msg}  (`string`)"}}, ok = {binding = "ok", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg"}, ["fnl/docstring"] = "Reports a \"success\" message.\n\nParameters: ~\n  \226\128\162 {msg}  (`string`)"}}, start = {binding = "start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Starts a new report. Most plugins should call this only once, but if you\nwant different sections to appear in your report, call this once per\nsection.\n\nParameters: ~\n  \226\128\162 {name}  (`string`)"}}, warn = {binding = "warn", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg", "..."}, ["fnl/docstring"] = "Reports a warning.\n\nParameters: ~\n  \226\128\162 {msg}  (`string`)\n  \226\128\162 {...}  (`string|string[]`) Optional advice"}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "vim.health is a minimal framework to help users troubleshoot configuration and\nany other environment conditions that a plugin might care about. Nvim ships\nwith healthchecks for configuration, performance, python support, ruby support,\nclipboard support, and more.\n\nTo run all healthchecks, use:>\n:checkhealth\n<\n\nPlugin authors are encouraged to write new healthchecks. health-dev"}}, hl = {binding = "hl", fields = {on_yank = {binding = "on_yank", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Highlight the yanked text during a |TextYankPost| event.\n\nAdd the following to your `init.vim`: >vim\n    autocmd TextYankPost * silent! lua vim.hl.on_yank {higroup='Visual', timeout=300}\n<\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) Optional parameters\n            \226\128\162 higroup highlight group for yanked region (default\n              \"IncSearch\")\n            \226\128\162 timeout time in ms before highlight is cleared (default 150)\n            \226\128\162 on_macro highlight when executing macro (default false)\n            \226\128\162 on_visual highlight when yanking visual selection (default\n              true)\n            \226\128\162 event event structure (default vim.v.event)\n            \226\128\162 priority integer priority (default\n              |vim.hl.priorities|`.user`)"}}, priorities = {binding = "priorities", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Table with default priorities used for highlighting:\n\226\128\162 `syntax`: `50`, used for standard syntax highlighting\n\226\128\162 `treesitter`: `100`, used for treesitter-based highlighting\n\226\128\162 `semantic_tokens`: `125`, used for LSP semantic token highlighting\n\226\128\162 `diagnostics`: `150`, used for code analysis such as diagnostics\n\226\128\162 `user`: `200`, used for user-triggered highlights such as LSP document\n  symbols or `on_yank` autocommands\n\n                                                          "}}, range = {binding = "range", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "ns", "higroup", "start", "finish", "?opts"}, ["fnl/docstring"] = "Apply highlight group to range of text.\n\nParameters: ~\n  \226\128\162 {bufnr}    (`integer`) Buffer number to apply highlighting to\n  \226\128\162 {ns}       (`integer`) Namespace to add highlight to\n  \226\128\162 {higroup}  (`string`) Highlight group to use for highlighting\n  \226\128\162 {start}    (`integer[]|string`) Start of region as a (line, column)\n               tuple or string accepted by |getpos()|\n  \226\128\162 {finish}   (`integer[]|string`) End of region as a (line, column)\n               tuple or string accepted by |getpos()|\n  \226\128\162 {opts}     (`table?`) A table with the following fields:\n               \226\128\162 {regtype}? (`string`, default: `'v'` i.e. charwise) Type\n                 of range. See |getregtype()|\n               \226\128\162 {inclusive}? (`boolean`, default: `false`) Indicates\n                 whether the range is end-inclusive\n               \226\128\162 {priority}? (`integer`, default:\n                 `vim.hl.priorities.user`) Highlight priority\n               \226\128\162 {timeout}? (`integer`, default: -1 no timeout) Time in ms\n                 before highlight is cleared\n\nReturn (multiple): ~\n    (`uv.uv_timer_t?`) range_timer A timer which manages how much time the\n    highlight has left\n    (`fun()?`) range_clear A function which allows clearing the highlight\n    manually. nil is returned if timeout is not specified"}}}, metadata = {["fls/itemKind"] = "Module"}}, iconv = {binding = "iconv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "from", "to"}, ["fnl/docstring"] = "The result is a String, which is the text {str} converted from encoding\n{from} to encoding {to}. When the conversion fails `nil` is returned. When\nsome characters could not be converted they are replaced with \"?\". The\nencoding names are whatever the iconv() library function can accept, see\n\":Man 3 iconv\".\n\nParameters: ~\n  \226\128\162 {str}   (`string`) Text to convert\n  \226\128\162 {from}  (`string`) Encoding of {str}\n  \226\128\162 {to}    (`string`) Target encoding\n\nReturn: ~\n    (`string?`) Converted string if conversion succeeds, `nil` otherwise."}}, in_fast_event = {binding = "in_fast_event", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns true if the code is executing as part of a \"fast\" event handler,\nwhere most of the API is disabled. These are low-level events (e.g.\n|lua-loop-callbacks|) which can be invoked whenever Nvim polls for input.\nWhen this is `false` most API functions are callable (but may be subject\nto other restrictions such as |textlock|)."}}, inspect = {binding = "inspect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"value"}, ["fnl/docstring"] = "Gets a human-readable representation of the given object.\n\nReturn: ~\n    (`string`)\n\nSee also: ~\n  \226\128\162 |vim.print()|\n  \226\128\162 https://github.com/kikito/inspect.lua\n  \226\128\162 https://github.com/mpeterv/vinspect"}}, inspect_pos = {binding = "inspect_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?row", "?col", "?filter"}, ["fnl/docstring"] = "Get all the items at a given buffer position.\n\nCan also be pretty-printed with `:Inspect!`.                   *:Inspect!*\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {bufnr}   (`integer?`) defaults to the current buffer\n  \226\128\162 {row}     (`integer?`) row to inspect, 0-based. Defaults to the row of\n              the current cursor\n  \226\128\162 {col}     (`integer?`) col to inspect, 0-based. Defaults to the col of\n              the current cursor\n  \226\128\162 {filter}  (`table?`) Table with key-value pairs to filter the items\n              \226\128\162 {syntax} (`boolean`, default: `true`) Include syntax based\n                highlight groups.\n              \226\128\162 {treesitter} (`boolean`, default: `true`) Include\n                treesitter based highlight groups.\n              \226\128\162 {extmarks} (`boolean|\"all\"`, default: true) Include\n                extmarks. When `all`, then extmarks without a `hl_group`\n                will also be included.\n              \226\128\162 {semantic_tokens} (`boolean`, default: true) Include\n                semantic token highlights.\n\nReturn: ~\n    (`table`) a table with the following key-value pairs. Items are in\n    \"traversal order\":\n    \226\128\162 treesitter: a list of treesitter captures\n    \226\128\162 syntax: a list of syntax groups\n    \226\128\162 semantic_tokens: a list of semantic tokens\n    \226\128\162 extmarks: a list of extmarks\n    \226\128\162 buffer: the buffer used to get the items\n    \226\128\162 row: the row used to get the items\n    \226\128\162 col: the col used to get the items"}}, is_callable = {binding = "is_callable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"f"}, ["fnl/docstring"] = "Returns true if object `f` can be called as a function.\n\nParameters: ~\n  \226\128\162 {f}  (`any`) Any object\n\nReturn: ~\n    (`boolean`) `true` if `f` is callable, else `false`"}}, isarray = {binding = "isarray", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?t"}, ["fnl/docstring"] = "Tests if `t` is an \"array\": a table indexed only by integers (potentially\nnon-contiguous).\n\nIf the indexes start from 1 and are contiguous then the array is also a\nlist. |vim.islist()|\n\nEmpty table `{}` is an array, unless it was created by |vim.empty_dict()|\nor returned as a dict-like |API| or Vimscript result, for example from\n|rpcrequest()| or |vim.fn|.\n\nParameters: ~\n  \226\128\162 {t}  (`table?`)\n\nReturn: ~\n    (`boolean`) `true` if array-like table, else `false`.\n\nSee also: ~\n  \226\128\162 https://github.com/openresty/luajit2#tableisarray"}}, islist = {binding = "islist", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?t"}, ["fnl/docstring"] = "Tests if `t` is a \"list\": a table indexed only by contiguous integers\nstarting from 1 (what |lua-length| calls a \"regular array\").\n\nEmpty table `{}` is a list, unless it was created by |vim.empty_dict()| or\nreturned as a dict-like |API| or Vimscript result, for example from\n|rpcrequest()| or |vim.fn|.\n\nParameters: ~\n  \226\128\162 {t}  (`table?`)\n\nReturn: ~\n    (`boolean`) `true` if list-like table, else `false`.\n\nSee also: ~\n  \226\128\162 |vim.isarray()|"}}, json = {binding = "json", fields = {decode = {binding = "decode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "?opts"}, ["fnl/docstring"] = "Decodes (or \"unpacks\") the JSON-encoded {str} to a Lua object.\n\226\128\162 Decodes JSON \"null\" as |vim.NIL| (controllable by {opts}, see below).\n\226\128\162 Decodes empty object as |vim.empty_dict()|.\n\226\128\162 Decodes empty array as `{}` (empty Lua table).\n\nExample: >lua\n    vim.print(vim.json.decode('{\"bar\":[],\"foo\":{},\"zub\":null}'))\n    -- { bar = {}, foo = vim.empty_dict(), zub = vim.NIL }\n<\n\nParameters: ~\n  \226\128\162 {str}   (`string`) Stringified JSON data.\n  \226\128\162 {opts}  (`table<string,any>?`) Options table with keys:\n            \226\128\162 luanil: (table) Table with keys:\n              \226\128\162 object: (boolean) When true, converts `null` in JSON\n                objects to Lua `nil` instead of |vim.NIL|.\n              \226\128\162 array: (boolean) When true, converts `null` in JSON arrays\n                to Lua `nil` instead of |vim.NIL|.\n\nReturn: ~\n    (`any`)"}}, encode = {binding = "encode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"obj", "?opts"}, ["fnl/docstring"] = "Encodes (or \"packs\") Lua object {obj} as JSON in a Lua string.\n\nParameters: ~\n  \226\128\162 {obj}   (`any`)\n  \226\128\162 {opts}  (`table<string,any>?`) Options table with keys:\n            \226\128\162 escape_slash: (boolean) (default false) Escape slash\n              characters \"/\" in string values.\n\nReturn: ~\n    (`string`)"}}}, metadata = {["fls/itemKind"] = "Module"}}, keycode = {binding = "keycode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Translates keycodes.\n\nExample: >lua\n    local k = vim.keycode\n    vim.g.mapleader = k'<bs>'\n<\n\nParameters: ~\n  \226\128\162 {str}  (`string`) String to be converted.\n\nReturn: ~\n    (`string`)\n\nSee also: ~\n  \226\128\162 |nvim_replace_termcodes()|"}}, keymap = {binding = "keymap", fields = {del = {binding = "del", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"modes", "lhs", "?opts"}, ["fnl/docstring"] = "Remove an existing mapping. Examples: >lua\n    vim.keymap.del('n', 'lhs')\n\n    vim.keymap.del({'n', 'i', 'v'}, '<leader>w', { buffer = 5 })\n<\n\nParameters: ~\n  \226\128\162 {modes}  (`string|string[]`)\n  \226\128\162 {lhs}    (`string`)\n  \226\128\162 {opts}   (`table?`) A table with the following fields:\n             \226\128\162 {buffer}? (`integer|boolean`) Remove a mapping from the\n               given buffer. When `0` or `true`, use the current buffer.\n\nSee also: ~\n  \226\128\162 |vim.keymap.set()|"}}, set = {binding = "set", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"mode", "lhs", "rhs", "?opts"}, ["fnl/docstring"] = "Defines a |mapping| of |keycodes| to a function or keycodes.\n\nExamples: >lua\n    -- Map \"x\" to a Lua function:\n    vim.keymap.set('n', 'x', function() print(\"real lua function\") end)\n    -- Map \"<leader>x\" to multiple modes for the current buffer:\n    vim.keymap.set({'n', 'v'}, '<leader>x', vim.lsp.buf.references, { buffer = true })\n    -- Map <Tab> to an expression (|:map-<expr>|):\n    vim.keymap.set('i', '<Tab>', function()\n      return vim.fn.pumvisible() == 1 and \"<C-n>\" or \"<Tab>\"\n    end, { expr = true })\n    -- Map \"[%%\" to a <Plug> mapping:\n    vim.keymap.set('n', '[%%', '<Plug>(MatchitNormalMultiBackward)')\n<\n\nParameters: ~\n  \226\128\162 {mode}  (`string|string[]`) Mode \"short-name\" (see\n            |nvim_set_keymap()|), or a list thereof.\n  \226\128\162 {lhs}   (`string`) Left-hand side |{lhs}| of the mapping.\n  \226\128\162 {rhs}   (`string|function`) Right-hand side |{rhs}| of the mapping,\n            can be a Lua function.\n  \226\128\162 {opts}  (`table?`) Table of |:map-arguments|. Same as\n            |nvim_set_keymap()| {opts}, except:\n            \226\128\162 {replace_keycodes} defaults to `true` if \"expr\" is `true`.\n\n            Also accepts:\n            \226\128\162 {buffer}? (`integer|boolean`) Creates buffer-local mapping,\n              `0` or `true` for current buffer.\n            \226\128\162 {remap}? (`boolean`, default: `false`) Make the mapping\n              recursive. Inverse of {noremap}.\n\nSee also: ~\n  \226\128\162 |nvim_set_keymap()|\n  \226\128\162 |maparg()|\n  \226\128\162 |mapcheck()|\n  \226\128\162 |mapset()|"}}}, metadata = {["fls/itemKind"] = "Module"}}, list_contains = {binding = "list_contains", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t", "value"}, ["fnl/docstring"] = "Checks if a list-like table (integer keys without gaps) contains `value`.\n\nParameters: ~\n  \226\128\162 {t}      (`table`) Table to check (must be list-like, not validated)\n  \226\128\162 {value}  (`any`) Value to compare\n\nReturn: ~\n    (`boolean`) `true` if `t` contains `value`\n\nSee also: ~\n  \226\128\162 |vim.tbl_contains()| for checking values in general tables"}}, list_extend = {binding = "list_extend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dst", "src", "?start", "?finish"}, ["fnl/docstring"] = "Extends a list-like table with the values of another list-like table.\n\nNOTE: This mutates dst!\n\nParameters: ~\n  \226\128\162 {dst}     (`table`) List which will be modified and appended to\n  \226\128\162 {src}     (`table`) List from which values will be inserted\n  \226\128\162 {start}   (`integer?`) Start index on src. Defaults to 1\n  \226\128\162 {finish}  (`integer?`) Final index on src. Defaults to `#src`\n\nReturn: ~\n    (`table`) dst\n\nSee also: ~\n  \226\128\162 |vim.tbl_extend()|"}}, list_slice = {binding = "list_slice", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"list", "?start", "?finish"}, ["fnl/docstring"] = "Creates a copy of a table containing only elements from start to end\n(inclusive)\n\nParameters: ~\n  \226\128\162 {list}    (`any[]`) Table\n  \226\128\162 {start}   (`integer?`) Start range of slice\n  \226\128\162 {finish}  (`integer?`) End range of slice\n\nReturn: ~\n    (`any[]`) Copy of table sliced from start to finish (inclusive)"}}, loader = {binding = "loader", fields = {enable = {binding = "enable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?enable"}, ["fnl/docstring"] = "WARNING: This feature is experimental/unstable.\n\nEnables or disables the experimental Lua module loader:\n\nEnable (`enable=true`):\n\226\128\162 overrides |loadfile()|\n\226\128\162 adds the Lua loader using the byte-compilation cache\n\226\128\162 adds the libs loader\n\226\128\162 removes the default Nvim loader\n\nDisable (`enable=false`):\n\226\128\162 removes the loaders\n\226\128\162 adds the default Nvim loader\n\nParameters: ~\n  \226\128\162 {enable}  (`boolean?`) true/nil to enable, false to disable"}}, find = {binding = "find", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"modname", "?opts"}, ["fnl/docstring"] = "WARNING: This feature is experimental/unstable.\n\nFinds Lua modules for the given module name.\n\nParameters: ~\n  \226\128\162 {modname}  (`string`) Module name, or `\"*\"` to find the top-level\n               modules instead\n  \226\128\162 {opts}     (`table?`) Options for finding a module:\n               \226\128\162 {rtp}? (`boolean`, default: `true`) Search for modname in\n                 the runtime path.\n               \226\128\162 {paths}? (`string[]`, default: `{}`) Extra paths to\n                 search for modname\n               \226\128\162 {patterns}? (`string[]`, default:\n                 `{\"/init.lua\", \".lua\"}`) List of patterns to use when\n                 searching for modules. A pattern is a string added to the\n                 basename of the Lua module being searched.\n               \226\128\162 {all}? (`boolean`, default: `false`) Search for all\n                 matches.\n\nReturn: ~\n    (`table[]`) A list of objects with the following fields:\n    \226\128\162 {modpath} (`string`) Path of the module\n    \226\128\162 {modname} (`string`) Name of the module\n    \226\128\162 {stat}? (`uv.fs_stat.result`) The fs_stat of the module path. Won't\n      be returned for `modname=\"*\"`"}}, reset = {binding = "reset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?path"}, ["fnl/docstring"] = "WARNING: This feature is experimental/unstable.\n\nResets the cache for the path, or all the paths if path is nil.\n\nParameters: ~\n  \226\128\162 {path}  (`string?`) path to reset"}}}, metadata = {["fls/itemKind"] = "Module"}}, log = {binding = "log", fields = {levels = {binding = "levels", fields = {DEBUG = {binding = "DEBUG", metadata = {["fls/itemKind"] = "EnumMember"}}, ERROR = {binding = "ERROR", metadata = {["fls/itemKind"] = "EnumMember"}}, INFO = {binding = "INFO", metadata = {["fls/itemKind"] = "EnumMember"}}, OFF = {binding = "OFF", metadata = {["fls/itemKind"] = "EnumMember"}}, TRACE = {binding = "TRACE", metadata = {["fls/itemKind"] = "EnumMember"}}, WARN = {binding = "WARN", metadata = {["fls/itemKind"] = "EnumMember"}}}, metadata = {["fls/itemKind"] = "Module"}}}, metadata = {["fls/itemKind"] = "Module"}}, lpeg = {binding = "lpeg", fields = {B = {binding = "B", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern"}, ["fnl/docstring"] = "Returns a pattern that matches only if the input string at the current\nposition is preceded by `patt`. Pattern `patt` must match only strings\nwith some fixed length, and it cannot contain captures. Like the `and`\npredicate, this pattern never consumes any input, independently of success\nor failure.\n\nParameters: ~\n  \226\128\162 {pattern}  (`vim.lpeg.Pattern|string|integer|boolean|table`)\n\nReturn: ~\n    (`vim.lpeg.Pattern`)"}}, C = {binding = "C", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"patt"}, ["fnl/docstring"] = "Creates a simple capture, which captures the substring of the subject that\nmatches `patt`. The captured value is a string. If `patt` has other\ncaptures, their values are returned after this one.\n\nExample: >lua\n    local function split (s, sep)\n      sep = lpeg.P(sep)\n      local elem = lpeg.C((1 - sep) ^ 0)\n      local p = elem * (sep * elem) ^ 0\n      return lpeg.match(p, s)\n    end\n    local a, b, c = split('a,b,c', ',')\n    assert(a == 'a')\n    assert(b == 'b')\n    assert(c == 'c')\n<\n\nParameters: ~\n  \226\128\162 {patt}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Carg = {binding = "Carg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"n"}, ["fnl/docstring"] = "Creates an argument capture. This pattern matches the empty string and\nproduces the value given as the nth extra argument given in the call to\n`lpeg.match`.\n\nParameters: ~\n  \226\128\162 {n}  (`integer`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cb = {binding = "Cb", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Creates a back capture. This pattern matches the empty string and produces\nthe values produced by the most recent group capture named `name` (where\n`name` can be any Lua value). Most recent means the last complete\noutermost group capture with the given name. A Complete capture means that\nthe entire pattern corresponding to the capture has matched. An Outermost\ncapture means that the capture is not inside another complete capture. In\nthe same way that LPeg does not specify when it evaluates captures, it\ndoes not specify whether it reuses values previously produced by the group\nor re-evaluates them.\n\nParameters: ~\n  \226\128\162 {name}  (`any`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cc = {binding = "Cc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"..."}, ["fnl/docstring"] = "Creates a constant capture. This pattern matches the empty string and\nproduces all given values as its captured values.\n\nParameters: ~\n  \226\128\162 {...}  (`any`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cf = {binding = "Cf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"patt", "func"}, ["fnl/docstring"] = "Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\nCn, this capture will produce the value\n`func(...func(func(C1, C2), C3)...,Cn)`, that is, it will fold (or\naccumulate, or reduce) the captures from `patt` using function `func`.\nThis capture assumes that `patt` should produce at least one capture with\nat least one value (of any type), which becomes the initial value of an\naccumulator. (If you need a specific initial value, you may prefix a\nconstant capture to `patt`.) For each subsequent capture, LPeg calls\n`func` with this accumulator as the first argument and all values produced\nby the capture as extra arguments; the first result from this call becomes\nthe new value for the accumulator. The final value of the accumulator\nbecomes the captured value.\n\nExample: >lua\n    local number = lpeg.R('09') ^ 1 / tonumber\n    local list = number * (',' * number) ^ 0\n    local function add(acc, newvalue) return acc + newvalue end\n    local sum = lpeg.Cf(list, add)\n    assert(sum:match('10,30,43') == 83)\n<\n\nParameters: ~\n  \226\128\162 {patt}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n  \226\128\162 {func}  (`fun(acc, newvalue)`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cg = {binding = "Cg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"patt", "?name"}, ["fnl/docstring"] = "Creates a group capture. It groups all values returned by `patt` into a\nsingle capture. The group may be anonymous (if no name is given) or named\nwith the given name (which can be any non-nil Lua value).\n\nParameters: ~\n  \226\128\162 {patt}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n  \226\128\162 {name}  (`string?`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cmt = {binding = "Cmt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"patt", "fn"}, ["fnl/docstring"] = "Creates a match-time capture. Unlike all other captures, this one is\nevaluated immediately when a match occurs (even if it is part of a larger\npattern that fails later). It forces the immediate evaluation of all its\nnested captures and then calls `function`. The given function gets as\narguments the entire subject, the current position (after the match of\n`patt`), plus any capture values produced by `patt`. The first value\nreturned by `function` defines how the match happens. If the call returns\na number, the match succeeds and the returned number becomes the new\ncurrent position. (Assuming a subject sand current position `i`, the\nreturned number must be in the range `[i, len(s) + 1]`.) If the call\nreturns `true`, the match succeeds without consuming any input (so, to\nreturn true is equivalent to return `i`). If the call returns `false`,\n`nil`, or no value, the match fails. Any extra values returned by the\nfunction become the values produced by the capture.\n\nParameters: ~\n  \226\128\162 {patt}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n  \226\128\162 {fn}    (`fun(s: string, i: integer, ...: any)`) (position:\n            boolean|integer, ...: any)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cp = {binding = "Cp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates a position capture. It matches the empty string and captures the\nposition in the subject where the match occurs. The captured value is a\nnumber.\n\nExample: >lua\n    local I = lpeg.Cp()\n    local function anywhere(p) return lpeg.P({I * p * I + 1 * lpeg.V(1)}) end\n    local match_start, match_end = anywhere('world'):match('hello world!')\n    assert(match_start == 7)\n    assert(match_end == 12)\n<\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Cs = {binding = "Cs", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"patt"}, ["fnl/docstring"] = "Creates a substitution capture. This function creates a substitution\ncapture, which captures the substring of the subject that matches `patt`,\nwith substitutions. For any capture inside `patt` with a value, the\nsubstring that matched the capture is replaced by the capture value (which\nshould be a string). The final captured value is the string resulting from\nall replacements.\n\nExample: >lua\n    local function gsub (s, patt, repl)\n      patt = lpeg.P(patt)\n      patt = lpeg.Cs((patt / repl + 1) ^ 0)\n      return lpeg.match(patt, s)\n    end\n    assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n<\n\nParameters: ~\n  \226\128\162 {patt}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, Ct = {binding = "Ct", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"patt"}, ["fnl/docstring"] = "Creates a table capture. This capture returns a table with all values from\nall anonymous captures made by `patt` inside this table in successive\ninteger keys, starting at 1. Moreover, for each named capture group\ncreated by `patt`, the first value of the group is put into the table with\nthe group name as its key. The captured value is only the table.\n\nParameters: ~\n  \226\128\162 {patt}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n\nReturn: ~\n    (`vim.lpeg.Capture`)"}}, P = {binding = "P", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"value"}, ["fnl/docstring"] = "Converts the given value into a proper pattern. The following rules are\napplied:\n\226\128\162 If the argument is a pattern, it is returned unmodified.\n\226\128\162 If the argument is a string, it is translated to a pattern that matches\n  the string literally.\n\226\128\162 If the argument is a non-negative number `n`, the result is a pattern\n  that matches exactly `n` characters.\n\226\128\162 If the argument is a negative number `-n`, the result is a pattern that\n  succeeds only if the input string has less than `n` characters left:\n  `lpeg.P(-n)` is equivalent to `-lpeg.P(n)` (see the unary minus\n  operation).\n\226\128\162 If the argument is a boolean, the result is a pattern that always\n  succeeds or always fails (according to the boolean value), without\n  consuming any input.\n\226\128\162 If the argument is a table, it is interpreted as a grammar (see\n  Grammars).\n\226\128\162 If the argument is a function, returns a pattern equivalent to a\n  match-time capture over the empty string.\n\nParameters: ~\n  \226\128\162 {value}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n\nReturn: ~\n    (`vim.lpeg.Pattern`)"}}, R = {binding = "R", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"..."}, ["fnl/docstring"] = "Returns a pattern that matches any single character belonging to one of\nthe given ranges. Each `range` is a string `xy` of length 2, representing\nall characters with code between the codes of `x` and `y` (both\ninclusive). As an example, the pattern `lpeg.R('09')` matches any digit,\nand `lpeg.R('az', 'AZ')` matches any ASCII letter.\n\nExample: >lua\n    local pattern = lpeg.R('az') ^ 1 * -1\n    assert(pattern:match('hello') == 6)\n<\n\nParameters: ~\n  \226\128\162 {...}  (`string`)\n\nReturn: ~\n    (`vim.lpeg.Pattern`)"}}, S = {binding = "S", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string"}, ["fnl/docstring"] = "Returns a pattern that matches any single character that appears in the\ngiven string (the `S` stands for Set). As an example, the pattern\n`lpeg.S('+-*/')` matches any arithmetic operator. Note that, if `s` is a\ncharacter (that is, a string of length 1), then `lpeg.P(s)` is equivalent\nto `lpeg.S(s)` which is equivalent to `lpeg.R(s..s)`. Note also that both\n`lpeg.S('')` and `lpeg.R()` are patterns that always fail.\n\nParameters: ~\n  \226\128\162 {string}  (`string`)\n\nReturn: ~\n    (`vim.lpeg.Pattern`)"}}, V = {binding = "V", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v"}, ["fnl/docstring"] = "Creates a non-terminal (a variable) for a grammar. This operation creates\na non-terminal (a variable) for a grammar. The created non-terminal refers\nto the rule indexed by `v` in the enclosing grammar.\n\nExample: >lua\n    local b = lpeg.P({'(' * ((1 - lpeg.S '()') + lpeg.V(1)) ^ 0 * ')'})\n    assert(b:match('((string))') == 11)\n    assert(b:match('(') == nil)\n<\n\nParameters: ~\n  \226\128\162 {v}  (`boolean|string|number|function|table|thread|userdata|lightuserdata`)\n\nReturn: ~\n    (`vim.lpeg.Pattern`)"}}, locale = {binding = "locale", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?tab"}, ["fnl/docstring"] = "Returns a table with patterns for matching some character classes\naccording to the current locale. The table has fields named `alnum`,\n`alpha`, `cntrl`, `digit`, `graph`, `lower`, `print`, `punct`, `space`,\n`upper`, and `xdigit`, each one containing a correspondent pattern. Each\npattern matches any single character that belongs to its class. If called\nwith an argument `table`, then it creates those fields inside the given\ntable and returns that table.\n\nExample: >lua\n    lpeg.locale(lpeg)\n    local space = lpeg.space ^ 0\n    local name = lpeg.C(lpeg.alpha ^ 1) * space\n    local sep = lpeg.S(',;') * space\n    local pair = lpeg.Cg(name * '=' * space * name) * sep ^ -1\n    local list = lpeg.Cf(lpeg.Ct('') * pair ^ 0, rawset)\n    local t = list:match('a=b, c = hi; next = pi')\n    assert(t.a == 'b')\n    assert(t.c == 'hi')\n    assert(t.next == 'pi')\n    local locale = lpeg.locale()\n    assert(type(locale.digit) == 'userdata')\n<\n\nParameters: ~\n  \226\128\162 {tab}  (`table?`)\n\nReturn: ~\n    (`vim.lpeg.Locale`)"}}, match = {binding = "match", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern", "subject", "?init", "..."}, ["fnl/docstring"] = "Matches the given `pattern` against the `subject` string. If the match\nsucceeds, returns the index in the subject of the first character after\nthe match, or the captured values (if the pattern captured any value). An\noptional numeric argument `init` makes the match start at that position in\nthe subject string. As usual in Lua libraries, a negative value counts\nfrom the end. Unlike typical pattern-matching functions, `match` works\nonly in anchored mode; that is, it tries to match the pattern with a\nprefix of the given subject string (at position `init`), not with an\narbitrary substring of the subject. So, if we want to find a pattern\nanywhere in a string, we must either write a loop in Lua or write a\npattern that matches anywhere.\n\nExample: >lua\n    local pattern = lpeg.R('az') ^ 1 * -1\n    assert(pattern:match('hello') == 6)\n    assert(lpeg.match(pattern, 'hello') == 6)\n    assert(pattern:match('1 hello') == nil)\n<\n\nParameters: ~\n  \226\128\162 {pattern}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n  \226\128\162 {subject}  (`string`)\n  \226\128\162 {init}     (`integer?`)\n  \226\128\162 {...}      (`any`)\n\nReturn: ~\n    (`any`) ..."}}, setmaxstack = {binding = "setmaxstack", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"max"}, ["fnl/docstring"] = "Sets a limit for the size of the backtrack stack used by LPeg to track\ncalls and choices. The default limit is `400`. Most well-written patterns\nneed little backtrack levels and therefore you seldom need to change this\nlimit; before changing it you should try to rewrite your pattern to avoid\nthe need for extra space. Nevertheless, a few useful patterns may\noverflow. Also, with recursive grammars, subjects with deep recursion may\nalso need larger limits.\n\nParameters: ~\n  \226\128\162 {max}  (`integer`)"}}, type = {binding = "type", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"value"}, ["fnl/docstring"] = "Returns the string `\"pattern\"` if the given value is a pattern, otherwise\n`nil`.\n\nParameters: ~\n  \226\128\162 {value}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n\nReturn: ~\n    (`\"pattern\"?`)"}}, version = {binding = "version", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a string with the running version of LPeg.\n\nReturn: ~\n    (`string`)"}}}, metadata = {["fls/itemKind"] = "Module"}}, lsp = {binding = "lsp", fields = {buf = {binding = "buf", fields = {add_workspace_folder = {binding = "add_workspace_folder", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?workspace_folder"}, ["fnl/docstring"] = "Add the folder at path to the workspace folders. If {path} is not\nprovided, the user will be prompted for a path using |input()|.\n\nParameters: ~\n  \226\128\162 {workspace_folder}  (`string?`)"}}, clear_references = {binding = "clear_references", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Removes document highlights from current buffer."}}, code_action = {binding = "code_action", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Selects a code action (LSP: \"textDocument/codeAction\" request) available\nat cursor position.\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) A table with the following fields:\n            \226\128\162 {context}? (`lsp.CodeActionContext`) Corresponds to\n              `CodeActionContext` of the LSP specification:\n              \226\128\162 {diagnostics}? (`table`) LSP `Diagnostic[]`. Inferred from\n                the current position if not provided.\n              \226\128\162 {only}? (`table`) List of LSP `CodeActionKind`s used to\n                filter the code actions. Most language servers support\n                values like `refactor` or `quickfix`.\n              \226\128\162 {triggerKind}? (`integer`) The reason why code actions\n                were requested.\n            \226\128\162 {filter}? (`fun(x: lsp.CodeAction|lsp.Command):boolean`)\n              Predicate taking an `CodeAction` and returning a boolean.\n            \226\128\162 {apply}? (`boolean`) When set to `true`, and there is just\n              one remaining action (after filtering), the action is\n              applied without user query.\n            \226\128\162 {range}? (`{start: integer[], end: integer[]}`) Range for\n              which code actions should be requested. If in visual mode\n              this defaults to the active selection. Table must contain\n              `start` and `end` keys with {row,col} tuples using mark-like\n              indexing. See |api-indexing|\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction\n  \226\128\162 vim.lsp.protocol.CodeActionTriggerKind"}}, completion = {binding = "completion", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |vim.lsp.completion.get()| instead."}}, declaration = {binding = "declaration", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Jumps to the declaration of the symbol under the cursor.\n\nNote: ~\n  \226\128\162 Many servers do not implement this method. Generally, see\n    |vim.lsp.buf.definition()| instead.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.lsp.LocationOpts?`) See |vim.lsp.LocationOpts|."}}, definition = {binding = "definition", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Jumps to the definition of the symbol under the cursor.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.lsp.LocationOpts?`) See |vim.lsp.LocationOpts|."}}, document_highlight = {binding = "document_highlight", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Send request to the server to resolve document highlights for the current\ntext document position. This request can be triggered by a key mapping or\nby events such as `CursorHold`, e.g.: >vim\n    autocmd CursorHold  <buffer> lua vim.lsp.buf.document_highlight()\n    autocmd CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()\n    autocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()\n<\n\nNote: Usage of |vim.lsp.buf.document_highlight()| requires the following\nhighlight groups to be defined or you won't be able to see the actual\nhighlights. |hl-LspReferenceText| |hl-LspReferenceRead|\n|hl-LspReferenceWrite|"}}, document_symbol = {binding = "document_symbol", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Lists all symbols in the current buffer in the |location-list|.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.lsp.ListOpts?`) See |vim.lsp.ListOpts|."}}, execute_command = {binding = "execute_command", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |Client:exec_cmd()| instead."}}, format = {binding = "format", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Formats a buffer using the attached (and optionally filtered) language\nserver clients.\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) A table with the following fields:\n            \226\128\162 {formatting_options}? (`table`) Can be used to specify\n              FormattingOptions. Some unspecified options will be\n              automatically derived from the current Nvim options. See\n              https://microsoft.github.io/language-server-protocol/specification/#formattingOptions\n            \226\128\162 {timeout_ms}? (`integer`, default: `1000`) Time in\n              milliseconds to block for formatting requests. No effect if\n              async=true.\n            \226\128\162 {bufnr}? (`integer`, default: current buffer) Restrict\n              formatting to the clients attached to the given buffer.\n            \226\128\162 {filter}? (`fun(client: vim.lsp.Client): boolean?`)\n              Predicate used to filter clients. Receives a client as\n              argument and must return a boolean. Clients matching the\n              predicate are included. Example: >lua\n                -- Never request typescript-language-server for formatting\n                vim.lsp.buf.format {\n                  filter = function(client) return client.name ~= \"ts_ls\" end\n                }\n<\n            \226\128\162 {async}? (`boolean`, default: false) If true the method\n              won't block. Editing the buffer while formatting\n              asynchronous can lead to unexpected changes.\n            \226\128\162 {id}? (`integer`) Restrict formatting to the client with ID\n              (client.id) matching this field.\n            \226\128\162 {name}? (`string`) Restrict formatting to the client with\n              name (client.name) matching this field.\n            \226\128\162 {range}?\n              (`{start:[integer,integer],end:[integer, integer]}|{start:[integer,integer],end:[integer,integer]}[]`,\n              default: current selection in visual mode, `nil` in other\n              modes, formatting the full buffer) Range to format. Table\n              must contain `start` and `end` keys with {row,col} tuples\n              using (1,0) indexing. Can also be a list of tables that\n              contain `start` and `end` keys as described above, in which\n              case `textDocument/rangesFormatting` support is required."}}, hover = {binding = "hover", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?config"}, ["fnl/docstring"] = "Displays hover information about the symbol under the cursor in a floating\nwindow. The window will be dismissed on cursor move. Calling the function\ntwice will jump into the floating window (thus by default, \"KK\" will open\nthe hover window and focus it). In the floating window, all commands and\nmappings are available as usual, except that \"q\" dismisses the window. You\ncan scroll the contents the same as you would any other buffer.\n\nNote: to disable hover highlights, add the following to your config: >lua\n    vim.api.nvim_create_autocmd('ColorScheme', {\n      callback = function()\n        vim.api.nvim_set_hl(0, 'LspReferenceTarget', {})\n      end,\n    })\n<\n\nParameters: ~\n  \226\128\162 {config}  (`vim.lsp.buf.hover.Opts?`) See |vim.lsp.buf.hover.Opts|."}}, implementation = {binding = "implementation", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Lists all the implementations for the symbol under the cursor in the\nquickfix window.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.lsp.LocationOpts?`) See |vim.lsp.LocationOpts|."}}, incoming_calls = {binding = "incoming_calls", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Lists all the call sites of the symbol under the cursor in the |quickfix|\nwindow. If the symbol can resolve to multiple items, the user can pick one\nin the |inputlist()|."}}, list_workspace_folders = {binding = "list_workspace_folders", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "List workspace folders."}}, outgoing_calls = {binding = "outgoing_calls", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Lists all the items that are called by the symbol under the cursor in the\n|quickfix| window. If the symbol can resolve to multiple items, the user\ncan pick one in the |inputlist()|."}}, references = {binding = "references", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?context", "?opts"}, ["fnl/docstring"] = "Lists all the references to the symbol under the cursor in the quickfix\nwindow.\n\nParameters: ~\n  \226\128\162 {context}  (`lsp.ReferenceContext?`) Context for the request\n  \226\128\162 {opts}     (`vim.lsp.ListOpts?`) See |vim.lsp.ListOpts|.\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references\n\n                                   "}}, remove_workspace_folder = {binding = "remove_workspace_folder", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?workspace_folder"}, ["fnl/docstring"] = "Remove the folder at path from the workspace folders. If {path} is not\nprovided, the user will be prompted for a path using |input()|.\n\nParameters: ~\n  \226\128\162 {workspace_folder}  (`string?`)"}}, rename = {binding = "rename", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?new_name", "?opts"}, ["fnl/docstring"] = "Renames all references to the symbol under the cursor.\n\nParameters: ~\n  \226\128\162 {new_name}  (`string?`) If not provided, the user will be prompted for\n                a new name using |vim.ui.input()|.\n  \226\128\162 {opts}      (`table?`) Additional options:\n                \226\128\162 {filter}? (`fun(client: vim.lsp.Client): boolean?`)\n                  Predicate used to filter clients. Receives a client as\n                  argument and must return a boolean. Clients matching the\n                  predicate are included.\n                \226\128\162 {name}? (`string`) Restrict clients used for rename to\n                  ones where client.name matches this field.\n                \226\128\162 {bufnr}? (`integer`) (default: current buffer)"}}, signature_help = {binding = "signature_help", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?config"}, ["fnl/docstring"] = "Displays signature information about the symbol under the cursor in a\nfloating window.\n\nParameters: ~\n  \226\128\162 {config}  (`vim.lsp.buf.signature_help.Opts?`) See\n              |vim.lsp.buf.signature_help.Opts|."}}, type_definition = {binding = "type_definition", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Jumps to the definition of the type of the symbol under the cursor.\n\nParameters: ~\n  \226\128\162 {opts}  (`vim.lsp.LocationOpts?`) See |vim.lsp.LocationOpts|."}}, typehierarchy = {binding = "typehierarchy", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"kind"}, ["fnl/docstring"] = "Lists all the subtypes or supertypes of the symbol under the cursor in the\n|quickfix| window. If the symbol can resolve to multiple items, the user\ncan pick one using |vim.ui.select()|.\n\nParameters: ~\n  \226\128\162 {kind}  (`\"subtypes\"|\"supertypes\"`)"}}, workspace_symbol = {binding = "workspace_symbol", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?query", "?opts"}, ["fnl/docstring"] = "Lists all symbols in the current workspace in the quickfix window.\n\nThe list is filtered against {query}; if the argument is omitted from the\ncall, the user is prompted to enter a string on the command line. An empty\nstring means no filtering is done.\n\nParameters: ~\n  \226\128\162 {query}  (`string?`) optional\n  \226\128\162 {opts}   (`vim.lsp.ListOpts?`) See |vim.lsp.ListOpts|."}}}, metadata = {["fls/itemKind"] = "Module"}}, buf_attach_client = {binding = "buf_attach_client", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "client_id"}, ["fnl/docstring"] = "Implements the `textDocument/did\226\128\166` notifications required to track a\nbuffer for any language server.\n\nWithout calling this, the server won't be notified of changes to a buffer.\n\nParameters: ~\n  \226\128\162 {bufnr}      (`integer`) Buffer handle, or 0 for current\n  \226\128\162 {client_id}  (`integer`) Client id\n\nReturn: ~\n    (`boolean`) success `true` if client was attached successfully;\n    `false` otherwise"}}, buf_detach_client = {binding = "buf_detach_client", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "client_id"}, ["fnl/docstring"] = "Detaches client from the specified buffer. Note: While the server is\nnotified that the text document (buffer) was closed, it is still able to\nsend notifications should it ignore this notification.\n\nParameters: ~\n  \226\128\162 {bufnr}      (`integer`) Buffer handle, or 0 for current\n  \226\128\162 {client_id}  (`integer`) Client id"}}, buf_is_attached = {binding = "buf_is_attached", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "client_id"}, ["fnl/docstring"] = "Checks if a buffer is attached for a particular client.\n\nParameters: ~\n  \226\128\162 {bufnr}      (`integer`) Buffer handle, or 0 for current\n  \226\128\162 {client_id}  (`integer`) the client id"}}, buf_notify = {binding = "buf_notify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "method", "params"}, ["fnl/docstring"] = "Send a notification to a server\n\nParameters: ~\n  \226\128\162 {bufnr}   (`integer?`) The number of the buffer\n  \226\128\162 {method}  (`string`) Name of the request method\n  \226\128\162 {params}  (`any`) Arguments to send to the server\n\nReturn: ~\n    (`boolean`) success true if any client returns true; false otherwise\n\n                                               "}}, buf_request_all = {binding = "buf_request_all", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "method", "?params", "handler"}, ["fnl/docstring"] = "Sends an async request for all active clients attached to the buffer and\nexecutes the `handler` callback with the combined result.\n\nParameters: ~\n  \226\128\162 {bufnr}    (`integer`) Buffer handle, or 0 for current.\n  \226\128\162 {method}   (`string`) LSP method name\n  \226\128\162 {params}   (`table|(fun(client: vim.lsp.Client, bufnr: integer): table?)?`)\n               Parameters to send to the server. Can also be passed as a\n               function that returns the params table for cases where\n               parameters are specific to the client.\n  \226\128\162 {handler}  (`function`) Handler called after all requests are\n               completed. Server results are passed as a\n               `client_id:result` map.\n\nReturn: ~\n    (`function`) cancel Function that cancels all requests.\n\n                                              "}}, buf_request_sync = {binding = "buf_request_sync", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "method", "?params"}, ["fnl/docstring"] = "Sends a request to all server and waits for the response of all of them.\n\nCalls |vim.lsp.buf_request_all()| but blocks Nvim while awaiting the\nresult. Parameters are the same as |vim.lsp.buf_request_all()| but the\nresult is different. Waits a maximum of {timeout_ms}.\n\nParameters: ~\n  \226\128\162 {bufnr}       (`integer`) Buffer handle, or 0 for current.\n  \226\128\162 {method}      (`string`) LSP method name\n  \226\128\162 {params}      (`table?`) Parameters to send to the server\n  \226\128\162 {timeout_ms}  (`integer?`, default: `1000`) Maximum time in\n                  milliseconds to wait for a result.\n\nReturn (multiple): ~\n    (`table<integer, {error: lsp.ResponseError?, result: any}>?`) result\n    Map of client_id:request_result.\n    (`string?`) err On timeout, cancel, or error, `err` is a string\n    describing the failure reason, and `result` is nil."}}, client_is_stopped = {binding = "client_is_stopped", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"client_id"}, ["fnl/docstring"] = "Checks whether a client is stopped.\n\nParameters: ~\n  \226\128\162 {client_id}  (`integer`)\n\nReturn: ~\n    (`boolean`) stopped true if client is stopped, false otherwise.\n\ncommands                                                    *vim.lsp.commands*\nRegistry for client side commands. This is an extension point for plugins\nto handle custom commands which are not part of the core language server\nprotocol specification.\n\nThe registry is a table where the key is a unique command name, and the\nvalue is a function which is called if any LSP action (code action, code\nlenses, ...) triggers the command.\n\nIf an LSP response contains a command for which no matching entry is\navailable in this registry, the command will be executed via the LSP\nserver using `workspace/executeCommand`.\n\nThe first argument to the function will be the `Command`: Command title:\nString command: String arguments?: any[]\n\nThe second argument is the `ctx` of |lsp-handler|"}}, codelens = {binding = "codelens", fields = {clear = {binding = "clear", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?client_id", "?bufnr"}, ["fnl/docstring"] = "Clear the lenses\n\nParameters: ~\n  \226\128\162 {client_id}  (`integer?`) filter by client_id. All clients if nil\n  \226\128\162 {bufnr}      (`integer?`) filter by buffer. All buffers if nil, 0 for\n                 current buffer"}}, display = {binding = "display", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?lenses", "bufnr", "client_id"}, ["fnl/docstring"] = "Display the lenses using virtual text\n\nParameters: ~\n  \226\128\162 {lenses}     (`lsp.CodeLens[]?`) lenses to display\n  \226\128\162 {bufnr}      (`integer`)\n  \226\128\162 {client_id}  (`integer`)"}}, get = {binding = "get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr"}, ["fnl/docstring"] = "Return all lenses for the given buffer\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer`) Buffer number. 0 can be used for the current\n             buffer.\n\nReturn: ~\n    (`lsp.CodeLens[]`)"}}, on_codelens = {binding = "on_codelens", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?err", "result", "ctx"}, ["fnl/docstring"] = "|lsp-handler| for the method `textDocument/codeLens`\n\nParameters: ~\n  \226\128\162 {err}     (`lsp.ResponseError?`)\n  \226\128\162 {result}  (`lsp.CodeLens[]`)\n  \226\128\162 {ctx}     (`lsp.HandlerContext`)"}}, refresh = {binding = "refresh", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts", "?bufnr"}, ["fnl/docstring"] = "Refresh the lenses.\n\nIt is recommended to trigger this using an autocmd or via keymap.\n\nExample: >vim\n    autocmd BufEnter,CursorHold,InsertLeave <buffer> lua vim.lsp.codelens.refresh({ bufnr = 0 })\n<\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) Optional fields\n            \226\128\162 {bufnr} (`integer?`) filter by buffer. All buffers if nil, 0\n              for current buffer"}}, run = {binding = "run", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Run the code lens in the current line"}}, save = {binding = "save", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?lenses", "bufnr", "client_id"}, ["fnl/docstring"] = "Store lenses for a specific buffer and client\n\nParameters: ~\n  \226\128\162 {lenses}     (`lsp.CodeLens[]?`) lenses to store\n  \226\128\162 {bufnr}      (`integer`)\n  \226\128\162 {client_id}  (`integer`)"}}}, metadata = {["fls/itemKind"] = "Module"}}, completion = {binding = "completion", fields = {enable = {binding = "enable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"enable", "client_id", "bufnr", "?opts"}, ["fnl/docstring"] = "Enables or disables completions from the given language client in the\ngiven buffer. Effects of enabling completions are:\n\226\128\162 Calling |vim.lsp.completion.get()| uses the enabled clients to retrieve\n  completion candidates\n\226\128\162 Accepting a completion candidate using `<c-y>` applies side effects like\n  expanding snippets, text edits (e.g. insert import statements) and\n  executing associated commands. This works for completions triggered via\n  autotrigger, omnifunc or completion.get()\n\nExample: |lsp-attach| |lsp-completion|\n\nNote: the behavior of `autotrigger=true` is controlled by the LSP\n`triggerCharacters` field. You can override it on LspAttach, see\n|lsp-autocompletion|.\n\nParameters: ~\n  \226\128\162 {enable}     (`boolean`) True to enable, false to disable\n  \226\128\162 {client_id}  (`integer`) Client ID\n  \226\128\162 {bufnr}      (`integer`) Buffer handle, or 0 for the current buffer\n  \226\128\162 {opts}       (`table?`) A table with the following fields:\n                 \226\128\162 {autotrigger}? (`boolean`) (default: false) When true,\n                   completion triggers automatically based on the server's\n                   `triggerCharacters`.\n                 \226\128\162 {convert}? (`fun(item: lsp.CompletionItem): table`)\n                   Transforms an LSP CompletionItem to |complete-items|."}}, get = {binding = "get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Triggers LSP completion once in the current buffer, if LSP completion is\nenabled (see |lsp-attach| |lsp-completion|).\n\nUsed by the default LSP |omnicompletion| provider |vim.lsp.omnifunc()|,\nthus |i_CTRL-X_CTRL-O| invokes this in LSP-enabled buffers. Use CTRL-Y to\nselect an item from the completion menu. |complete_CTRL-Y|\n\nTo invoke manually with CTRL-space, use this mapping: >lua\n    -- Use CTRL-space to trigger LSP completion.\n    -- Use CTRL-Y to select an item. |complete_CTRL-Y|\n    vim.keymap.set('i', '<c-space>', function()\n      vim.lsp.completion.get()\n    end)\n<\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) A table with the following fields:\n            \226\128\162 {ctx}? (`lsp.CompletionContext`) Completion context.\n              Defaults to a trigger kind of `invoked`."}}}, metadata = {["fls/itemKind"] = "Module"}}, config = {binding = "config", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "cfg"}, ["fnl/docstring"] = "Update the configuration for an LSP client.\n\nUse name '*' to set default configuration for all clients.\n\nCan also be table-assigned to redefine the configuration for a client.\n\nExamples:\n\226\128\162 Add a root marker for all clients: >lua\n    vim.lsp.config('*', {\n      root_markers = { '.git' },\n    })\n<\n\226\128\162 Add additional capabilities to all clients: >lua\n    vim.lsp.config('*', {\n      capabilities = {\n        textDocument = {\n          semanticTokens = {\n            multilineTokenSupport = true,\n          }\n        }\n      }\n    })\n<\n\226\128\162 (Re-)define the configuration for clangd: >lua\n    vim.lsp.config.clangd = {\n      cmd = {\n        'clangd',\n        '--clang-tidy',\n        '--background-index',\n        '--offset-encoding=utf-8',\n      },\n      root_markers = { '.clangd', 'compile_commands.json' },\n      filetypes = { 'c', 'cpp' },\n    }\n<\n\226\128\162 Get configuration for luals: >lua\n    local cfg = vim.lsp.config.luals\n<\n\nParameters: ~\n  \226\128\162 {name}  (`string`)\n  \226\128\162 {cfg}   (`vim.lsp.Config`) See |vim.lsp.Config|."}}, diagnostic = {binding = "diagnostic", fields = {from = {binding = "from", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"diagnostics"}, ["fnl/docstring"] = "Converts the input `vim.Diagnostic`s to LSP diagnostics.\n\nParameters: ~\n  \226\128\162 {diagnostics}  (`vim.Diagnostic[]`)\n\nReturn: ~\n    (`lsp.Diagnostic[]`)\n\n                                      "}}, get_namespace = {binding = "get_namespace", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"client_id", "?is_pull"}, ["fnl/docstring"] = "Get the diagnostic namespace associated with an LSP client\n|vim.diagnostic| for diagnostics\n\nParameters: ~\n  \226\128\162 {client_id}  (`integer`) The id of the LSP client\n  \226\128\162 {is_pull}    (`boolean?`) Whether the namespace is for a pull or push\n                 client. Defaults to push\n\n                                      "}}, on_diagnostic = {binding = "on_diagnostic", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?error", "result", "ctx"}, ["fnl/docstring"] = "|lsp-handler| for the method \"textDocument/diagnostic\"\n\nSee |vim.diagnostic.config()| for configuration options.\n\nParameters: ~\n  \226\128\162 {error}   (`lsp.ResponseError?`)\n  \226\128\162 {result}  (`lsp.DocumentDiagnosticReport`)\n  \226\128\162 {ctx}     (`lsp.HandlerContext`)\n\n                             "}}, on_publish_diagnostics = {binding = "on_publish_diagnostics", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"params", "ctx"}, ["fnl/docstring"] = "|lsp-handler| for the method \"textDocument/publishDiagnostics\"\n\nSee |vim.diagnostic.config()| for configuration options.\n\nParameters: ~\n  \226\128\162 {params}  (`lsp.PublishDiagnosticsParams`)\n  \226\128\162 {ctx}     (`lsp.HandlerContext`)"}}}, metadata = {["fls/itemKind"] = "Module"}}, enable = {binding = "enable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?enable"}, ["fnl/docstring"] = "Auto-starts LSP when a buffer is opened, based on the |lsp-config|\n`filetypes`, `root_markers`, and `root_dir` fields.\n\nExamples: >lua\n    vim.lsp.enable('clangd')\n    vim.lsp.enable({'luals', 'pyright'})\n<\n\nExample: *lsp-restart* Passing `false` stops and detaches the client(s).\nThus you can \"restart\" LSP by disabling and re-enabling a given config: >lua\n    vim.lsp.enable('clangd', false)\n    vim.lsp.enable('clangd', true)\n<\n\nExample: To dynamically decide whether LSP is activated, define a\n|lsp-root_dir()| function which calls `on_dir()` only when you want that\nconfig to activate: >lua\n    vim.lsp.config('lua_ls', {\n      root_dir = function(bufnr, on_dir)\n        if not vim.fn.bufname(bufnr):match('%.txt$') then\n          on_dir(vim.fn.getcwd())\n        end\n      end\n    })\n<\n\nParameters: ~\n  \226\128\162 {name}    (`string|string[]`) Name(s) of client(s) to enable.\n  \226\128\162 {enable}  (`boolean?`) `true|nil` to enable, `false` to disable\n              (actively stops and detaches clients as needed)"}}, foldclose = {binding = "foldclose", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"kind", "?winid"}, ["fnl/docstring"] = "Close all {kind} of folds in the the window with {winid}.\n\nTo automatically fold imports when opening a file, you can use an autocmd: >lua\n    vim.api.nvim_create_autocmd('LspNotify', {\n      callback = function(args)\n        if args.data.method == 'textDocument/didOpen' then\n          vim.lsp.foldclose('imports', vim.fn.bufwinid(args.buf))\n        end\n      end,\n    })\n<\n\nParameters: ~\n  \226\128\162 {kind}   (`lsp.FoldingRangeKind`) Kind to close, one of \"comment\",\n             \"imports\" or \"region\".\n  \226\128\162 {winid}  (`integer?`) Defaults to the current window."}}, foldexpr = {binding = "foldexpr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lnum"}, ["fnl/docstring"] = "Provides an interface between the built-in client and a `foldexpr`\nfunction.\n\nTo use, set 'foldmethod' to \"expr\" and set the value of 'foldexpr': >lua\n    vim.o.foldmethod = 'expr'\n    vim.o.foldexpr = 'v:lua.vim.lsp.foldexpr()'\n<\n\nOr use it only when supported by checking for the\n\"textDocument/foldingRange\" capability in an |LspAttach| autocommand.\nExample: >lua\n    vim.o.foldmethod = 'expr'\n    -- Default to treesitter folding\n    vim.o.foldexpr = 'v:lua.vim.treesitter.foldexpr()'\n    -- Prefer LSP folding if client supports it\n    vim.api.nvim_create_autocmd('LspAttach', {\n      callback = function(args)\n        local client = vim.lsp.get_client_by_id(args.data.client_id)\n        if client:supports_method('textDocument/foldingRange') then\n          local win = vim.api.nvim_get_current_win()\n          vim.wo[win][0].foldexpr = 'v:lua.vim.lsp.foldexpr()'\n        end\n      end,\n    })\n<\n\nParameters: ~\n  \226\128\162 {lnum}  (`integer`) line number"}}, foldtext = {binding = "foldtext", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Provides a `foldtext` function that shows the `collapsedText` retrieved,\ndefaults to the first folded line if `collapsedText` is not provided."}}, formatexpr = {binding = "formatexpr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Provides an interface between the built-in client and a `formatexpr`\nfunction.\n\nCurrently only supports a single client. This can be set via\n`setlocal formatexpr=v:lua.vim.lsp.formatexpr()` or (more typically) in\n`on_attach` via\n`vim.bo[bufnr].formatexpr = 'v:lua.vim.lsp.formatexpr(#{timeout_ms:250})'`.\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) A table with the following fields:\n            \226\128\162 {timeout_ms} (`integer`, default: 500ms) The timeout period\n              for the formatting request..\n\n                                      "}}, get_buffers_by_client_id = {binding = "get_buffers_by_client_id", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"client_id"}, ["fnl/docstring"] = "Returns list of buffers attached to client_id.\n\nParameters: ~\n  \226\128\162 {client_id}  (`integer`) client id\n\nReturn: ~\n    (`integer[]`) buffers list of buffer ids"}}, get_client_by_id = {binding = "get_client_by_id", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"client_id"}, ["fnl/docstring"] = "Gets a client by id, or nil if the id is invalid. The returned client may\nnot yet be fully initialized.\n\nParameters: ~\n  \226\128\162 {client_id}  (`integer`) client id\n\nReturn: ~\n    (`vim.lsp.Client?`) client rpc object"}}, get_clients = {binding = "get_clients", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?filter"}, ["fnl/docstring"] = "Get active clients.\n\nParameters: ~\n  \226\128\162 {filter}  (`table?`) Key-value pairs used to filter the returned\n              clients.\n              \226\128\162 {id}? (`integer`) Only return clients with the given id\n              \226\128\162 {bufnr}? (`integer`) Only return clients attached to this\n                buffer\n              \226\128\162 {name}? (`string`) Only return clients with the given name\n              \226\128\162 {method}? (`string`) Only return clients supporting the\n                given method\n\nReturn: ~\n    (`vim.lsp.Client[]`) List of |vim.lsp.Client| objects"}}, get_log_path = {binding = "get_log_path", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the path of the logfile used by the LSP client.\n\nReturn: ~\n    (`string`) path to log file"}}, inlay_hint = {binding = "inlay_hint", fields = {enable = {binding = "enable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?enable", "?filter", "?bufnr"}, ["fnl/docstring"] = "Enables or disables inlay hints for the {filter}ed scope.\n\nTo \"toggle\", pass the inverse of `is_enabled()`: >lua\n    vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled())\n<\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {enable}  (`boolean?`) true/nil to enable, false to disable\n  \226\128\162 {filter}  (`table?`) Optional filters |kwargs|, or `nil` for all.\n              \226\128\162 {bufnr} (`integer?`) Buffer number, or 0 for current\n                buffer, or nil for all."}}, get = {binding = "get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?filter", "?bufnr", "?range"}, ["fnl/docstring"] = "Get the list of inlay hints, (optionally) restricted by buffer or range.\n\nExample usage: >lua\n    local hint = vim.lsp.inlay_hint.get({ bufnr = 0 })[1] -- 0 for current buffer\n\n    local client = vim.lsp.get_client_by_id(hint.client_id)\n    local resp = client:request_sync('inlayHint/resolve', hint.inlay_hint, 100, 0)\n    local resolved_hint = assert(resp and resp.result, resp.err)\n    vim.lsp.util.apply_text_edits(resolved_hint.textEdits, 0, client.encoding)\n\n    location = resolved_hint.label[1].location\n    client:request('textDocument/hover', {\n      textDocument = { uri = location.uri },\n      position = location.range.start,\n    })\n<\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {filter}  (`table?`) Optional filters |kwargs|:\n              \226\128\162 {bufnr} (`integer?`)\n              \226\128\162 {range} (`lsp.Range?`)\n\nReturn: ~\n    (`table[]`) A list of objects with the following fields:\n    \226\128\162 {bufnr} (`integer`)\n    \226\128\162 {client_id} (`integer`)\n    \226\128\162 {inlay_hint} (`lsp.InlayHint`)"}}, is_enabled = {binding = "is_enabled", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?filter", "?bufnr"}, ["fnl/docstring"] = "Query whether inlay hint is enabled in the {filter}ed scope\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {filter}  (`table?`) Optional filters |kwargs|, or `nil` for all.\n              \226\128\162 {bufnr} (`integer?`) Buffer number, or 0 for current\n                buffer, or nil for all.\n\nReturn: ~\n    (`boolean`)"}}}, metadata = {["fls/itemKind"] = "Module"}}, is_enabled = {binding = "is_enabled", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Checks if the given LSP config is enabled (globally, not per-buffer).\n\nUnlike `vim.lsp.config['\226\128\166']`, this does not have the side-effect of\nresolving the config.\n\nParameters: ~\n  \226\128\162 {name}  (`string`) Config name\n\nReturn: ~\n    (`boolean`)"}}, log = {binding = "log", fields = {get_filename = {binding = "get_filename", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the log filename.\n\nReturn: ~\n    (`string`) log filename"}}, get_level = {binding = "get_level", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the current log level.\n\nReturn: ~\n    (`integer`) current log level"}}, set_format_func = {binding = "set_format_func", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "Sets formatting function used to format logs\n\nParameters: ~\n  \226\128\162 {handle}  (`function`) function to apply to logging arguments, pass\n              vim.inspect for multi-line formatting"}}, set_level = {binding = "set_level", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"level"}, ["fnl/docstring"] = "Sets the current log level.\n\nParameters: ~\n  \226\128\162 {level}  (`string|integer`) One of |vim.log.levels|"}}, should_log = {binding = "should_log", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"level"}, ["fnl/docstring"] = "Checks whether the level is sufficient for logging.\n\nParameters: ~\n  \226\128\162 {level}  (`integer`) log level\n\nReturn: ~\n    (`boolean`) true if would log, false if not"}}}, metadata = {["fls/itemKind"] = "Module"}}, omnifunc = {binding = "omnifunc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"findstart", "base"}, ["fnl/docstring"] = "Implements 'omnifunc' compatible LSP completion.\n\nParameters: ~\n  \226\128\162 {findstart}  (`integer`) 0 or 1, decides behavior\n  \226\128\162 {base}       (`integer`) findstart=0, text to match against\n\nReturn: ~\n    (`integer|table`) Decided by {findstart}:\n    \226\128\162 findstart=0: column where the completion starts, or -2 or -3\n    \226\128\162 findstart=1: list of matches (actually just calls |complete()|)\n\nSee also: ~\n  \226\128\162 |complete-functions|\n  \226\128\162 |complete-items|\n  \226\128\162 |CompleteDone|"}}, protocol = {binding = "protocol", fields = {make_client_capabilities = {binding = "make_client_capabilities", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets a new ClientCapabilities object describing the LSP client\ncapabilities.\n\nReturn: ~\n    (`lsp.ClientCapabilities`)\n\nMethods                                             *vim.lsp.protocol.Methods*\nLSP method names.\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specification/#metaModel\n\n                                 "}}, resolve_capabilities = {binding = "resolve_capabilities", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"server_capabilities"}, ["fnl/docstring"] = "Creates a normalized object describing LSP server capabilities.\n\nParameters: ~\n  \226\128\162 {server_capabilities}  (`table`) Table of capabilities supported by\n                           the server\n\nReturn: ~\n    (`lsp.ServerCapabilities?`) Normalized table of capabilities"}}}, metadata = {["fls/itemKind"] = "Module"}}, rpc = {binding = "rpc", fields = {connect = {binding = "connect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"host_or_path", "?port"}, ["fnl/docstring"] = "Create a LSP RPC client factory that connects to either:\n\226\128\162 a named pipe (windows)\n\226\128\162 a domain socket (unix)\n\226\128\162 a host and port via TCP\n\nReturn a function that can be passed to the `cmd` field for\n|vim.lsp.start()|.\n\nParameters: ~\n  \226\128\162 {host_or_path}  (`string`) host to connect to or path to a pipe/domain\n                    socket\n  \226\128\162 {port}          (`integer?`) TCP port to connect to. If absent the\n                    first argument must be a pipe\n\nReturn: ~\n    (`fun(dispatchers: vim.lsp.rpc.Dispatchers): vim.lsp.rpc.PublicClient`)"}}, format_rpc_error = {binding = "format_rpc_error", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"err"}, ["fnl/docstring"] = "Constructs an error message from an LSP error object.\n\nParameters: ~\n  \226\128\162 {err}  (`table`) The error object\n\nReturn: ~\n    (`string`) error_message The formatted error message"}}, notify = {binding = "notify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"method", "?params"}, ["fnl/docstring"] = "Sends a notification to the LSP server.\n\nParameters: ~\n  \226\128\162 {method}  (`string`) The invoked LSP method\n  \226\128\162 {params}  (`table?`) Parameters for the invoked LSP method\n\nReturn: ~\n    (`boolean`) `true` if notification could be sent, `false` if not\n\n                                                   "}}, request = {binding = "request", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"method", "?params", "callback", "?notify_reply_callback"}, ["fnl/docstring"] = "Sends a request to the LSP server and runs {callback} upon response.\n\nParameters: ~\n  \226\128\162 {method}                 (`string`) The invoked LSP method\n  \226\128\162 {params}                 (`table?`) Parameters for the invoked LSP\n                             method\n  \226\128\162 {callback}               (`fun(err: lsp.ResponseError?, result: any)`)\n                             Callback to invoke\n  \226\128\162 {notify_reply_callback}  (`fun(message_id: integer)?`) Callback to\n                             invoke as soon as a request is no longer\n                             pending\n\nReturn (multiple): ~\n    (`boolean`) success `true` if request could be sent, `false` if not\n    (`integer?`) message_id if request could be sent, `nil` if not\n\n                                        "}}, rpc_response_error = {binding = "rpc_response_error", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"code", "?message", "?data"}, ["fnl/docstring"] = "Creates an RPC response table `error` to be sent to the LSP response.\n\nParameters: ~\n  \226\128\162 {code}     (`integer`) RPC error code defined, see\n               `vim.lsp.protocol.ErrorCodes`\n  \226\128\162 {message}  (`string?`) arbitrary message to send to server\n  \226\128\162 {data}     (`any?`) arbitrary data to send to server\n\nReturn: ~\n    (`lsp.ResponseError`)\n\nSee also: ~\n  \226\128\162 lsp.ErrorCodes See `vim.lsp.protocol.ErrorCodes`"}}, start = {binding = "start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "?dispatchers", "on_error", "?extra_spawn_params"}, ["fnl/docstring"] = "Starts an LSP server process and create an LSP RPC client object to\ninteract with it. Communication with the spawned process happens via\nstdio. For communication via TCP, spawn a process manually and use\n|vim.lsp.rpc.connect()|\n\nParameters: ~\n  \226\128\162 {cmd}                 (`string[]`) Command to start the LSP server.\n  \226\128\162 {dispatchers}         (`table?`) Dispatchers for LSP message types.\n                          \226\128\162 {notification}\n                            (`fun(method: string, params: table)`)\n                          \226\128\162 {server_request}\n                            (`fun(method: string, params: table): any?, lsp.ResponseError?`)\n                          \226\128\162 {on_exit}\n                            (`fun(code: integer, signal: integer)`)\n                          \226\128\162 {on_error} (`fun(code: integer, err: any)`)\n  \226\128\162 {extra_spawn_params}  (`table?`) Additional context for the LSP server\n                          process.\n                          \226\128\162 {cwd}? (`string`) Working directory for the\n                            LSP server process\n                          \226\128\162 {detached}? (`boolean`) Detach the LSP server\n                            process from the current process\n                          \226\128\162 {env}? (`table<string,string>`) Additional\n                            environment variables for LSP server process.\n                            See |vim.system()|\n\nReturn: ~\n    (`vim.lsp.rpc.PublicClient`) See |vim.lsp.rpc.PublicClient|."}}}, metadata = {["fls/itemKind"] = "Module"}}, semantic_tokens = {binding = "semantic_tokens", fields = {force_refresh = {binding = "force_refresh", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr"}, ["fnl/docstring"] = "Force a refresh of all semantic tokens\n\nOnly has an effect if the buffer is currently active for semantic token\nhighlighting (|vim.lsp.semantic_tokens.start()| has been called for it)\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) filter by buffer. All buffers if nil, current\n             buffer if 0\n\n                                    "}}, get_at_pos = {binding = "get_at_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?row", "?col"}, ["fnl/docstring"] = "Return the semantic token(s) at the given position. If called without\narguments, returns the token under the cursor.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer number (0 for current buffer, default)\n  \226\128\162 {row}    (`integer?`) Position row (default cursor position)\n  \226\128\162 {col}    (`integer?`) Position column (default cursor position)\n\nReturn: ~\n    (`table?`) List of tokens at position. Each token has the following\n    fields:\n    \226\128\162 line (integer) line number, 0-based\n    \226\128\162 start_col (integer) start column, 0-based\n    \226\128\162 end_col (integer) end column, 0-based\n    \226\128\162 type (string) token type as string, e.g. \"variable\"\n    \226\128\162 modifiers (table) token modifiers as a set. E.g., { static = true,\n      readonly = true }\n    \226\128\162 client_id (integer)\n\n                               "}}, highlight_token = {binding = "highlight_token", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"token", "bufnr", "client_id", "hl_group", "?opts"}, ["fnl/docstring"] = "Highlight a semantic token.\n\nApply an extmark with a given highlight group for a semantic token. The\nmark will be deleted by the semantic token engine when appropriate; for\nexample, when the LSP sends updated tokens. This function is intended for\nuse inside |LspTokenUpdate| callbacks.\n\nParameters: ~\n  \226\128\162 {token}      (`table`) A semantic token, found as `args.data.token` in\n                 |LspTokenUpdate|\n  \226\128\162 {bufnr}      (`integer`) The buffer to highlight, or `0` for current\n                 buffer\n  \226\128\162 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n  \226\128\162 {hl_group}   (`string`) Highlight group name\n  \226\128\162 {opts}       (`table?`) Optional parameters:\n                 \226\128\162 {priority}? (`integer`, default:\n                   `vim.hl.priorities.semantic_tokens + 3`) Priority for\n                   the applied extmark."}}, start = {binding = "start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "client_id", "?opts"}, ["fnl/docstring"] = "Start the semantic token highlighting engine for the given buffer with the\ngiven client. The client must already be attached to the buffer.\n\nNOTE: This is currently called automatically by\n|vim.lsp.buf_attach_client()|. To opt-out of semantic highlighting with a\nserver that supports it, you can delete the semanticTokensProvider table\nfrom the {server_capabilities} of your client in your |LspAttach| callback\nor your configuration's `on_attach` callback: >lua\n    client.server_capabilities.semanticTokensProvider = nil\n<\n\nParameters: ~\n  \226\128\162 {bufnr}      (`integer`) Buffer number, or `0` for current buffer\n  \226\128\162 {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n  \226\128\162 {opts}       (`table?`) Optional keyword arguments\n                 \226\128\162 debounce (integer, default: 200): Debounce token\n                   requests to the server by the given number in\n                   milliseconds"}}, stop = {binding = "stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "client_id"}, ["fnl/docstring"] = "Stop the semantic token highlighting engine for the given buffer with the\ngiven client.\n\nNOTE: This is automatically called by a |LspDetach| autocmd that is set up\nas part of `start()`, so you should only need this function to manually\ndisengage the semantic token engine without fully detaching the LSP client\nfrom the buffer.\n\nParameters: ~\n  \226\128\162 {bufnr}      (`integer`) Buffer number, or `0` for current buffer\n  \226\128\162 {client_id}  (`integer`) The ID of the |vim.lsp.Client|"}}}, metadata = {["fls/itemKind"] = "Module"}}, set_log_level = {binding = "set_log_level", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"level"}, ["fnl/docstring"] = "Sets the global log level for LSP logging.\n\nLevels by name: \"TRACE\", \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"OFF\"\n\nLevel numbers begin with \"TRACE\" at 0\n\nUse `lsp.log_levels` for reverse lookup.\n\nParameters: ~\n  \226\128\162 {level}  (`integer|string`) the case insensitive level name or number\n\nSee also: ~\n  \226\128\162 |vim.lsp.log_levels|"}}, start = {binding = "start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"config", "?opts"}, ["fnl/docstring"] = "Create a new LSP client and start a language server or reuses an already\nrunning client if one is found matching `name` and `root_dir`. Attaches\nthe current buffer to the client.\n\nExample: >lua\n    vim.lsp.start({\n       name = 'my-server-name',\n       cmd = {'name-of-language-server-executable'},\n       root_dir = vim.fs.root(0, {'pyproject.toml', 'setup.py'}),\n    })\n<\n\nSee |vim.lsp.ClientConfig| for all available options. The most important\nare:\n\226\128\162 `name` arbitrary name for the LSP client. Should be unique per language\n  server.\n\226\128\162 `cmd` command string[] or function.\n\226\128\162 `root_dir` path to the project root. By default this is used to decide\n  if an existing client should be re-used. The example above uses\n  |vim.fs.root()| to detect the root by traversing the file system upwards\n  starting from the current directory until either a `pyproject.toml` or\n  `setup.py` file is found.\n\226\128\162 `workspace_folders` list of `{ uri:string, name: string }` tables\n  specifying the project root folders used by the language server. If\n  `nil` the property is derived from `root_dir` for convenience.\n\nLanguage servers use this information to discover metadata like the\ndependencies of your project and they tend to index the contents within\nthe project folder.\n\nTo ensure a language server is only started for languages it can handle,\nmake sure to call |vim.lsp.start()| within a |FileType| autocmd. Either\nuse |:au|, |nvim_create_autocmd()| or put the call in a\n`ftplugin/<filetype_name>.lua` (See |ftplugin-name|)\n\nParameters: ~\n  \226\128\162 {config}  (`vim.lsp.ClientConfig`) Configuration for the server. See\n              |vim.lsp.ClientConfig|.\n  \226\128\162 {opts}    (`table?`) Optional keyword arguments.\n              \226\128\162 {reuse_client}?\n                (`fun(client: vim.lsp.Client, config: vim.lsp.ClientConfig): boolean`)\n                Predicate used to decide if a client should be re-used.\n                Used on all running clients. The default implementation\n                re-uses a client if it has the same name and if the given\n                workspace folders (or root_dir) are all included in the\n                client's workspace folders.\n              \226\128\162 {bufnr}? (`integer`) Buffer handle to attach to if\n                starting or re-using a client (0 for current).\n              \226\128\162 {attach}? (`boolean`) Whether to attach the client to a\n                buffer (default true). If set to `false`, `reuse_client`\n                and `bufnr` will be ignored.\n              \226\128\162 {silent}? (`boolean`) Suppress error reporting if the LSP\n                server fails to start (default false).\n\nReturn: ~\n    (`integer?`) client_id"}}, status = {binding = "status", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Consumes the latest progress messages from all clients and formats them as\na string. Empty if there are no clients or if no new messages\n\nReturn: ~\n    (`string`)"}}, stop_client = {binding = "stop_client", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"client_id", "?force"}, ["fnl/docstring"] = "Stops a client(s).\n\nYou can also use the `stop()` function on a |vim.lsp.Client| object. To\nstop all clients: >lua\n    vim.lsp.stop_client(vim.lsp.get_clients())\n<\n\nBy default asks the server to shutdown, unless stop was requested already\nfor this client, then force-shutdown is attempted.\n\nParameters: ~\n  \226\128\162 {client_id}  (`integer|integer[]|vim.lsp.Client[]`) id, list of id's,\n                 or list of |vim.lsp.Client| objects\n  \226\128\162 {force}      (`boolean?`) shutdown forcefully"}}, tagfunc = {binding = "tagfunc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pattern", "flags"}, ["fnl/docstring"] = "Provides an interface between the built-in client and 'tagfunc'.\n\nWhen used with normal mode commands (e.g. |CTRL-]|) this will invoke the\n\"textDocument/definition\" LSP method to find the tag under the cursor.\nOtherwise, uses \"workspace/symbol\". If no results are returned from any\nLSP servers, falls back to using built-in tags.\n\nParameters: ~\n  \226\128\162 {pattern}  (`string`) Pattern used to find a workspace symbol\n  \226\128\162 {flags}    (`string`) See |tag-function|\n\nReturn: ~\n    (`table[]`) tags A list of matching tags"}}, util = {binding = "util", fields = {apply_text_document_edit = {binding = "apply_text_document_edit", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"text_document_edit", "?index", "?position_encoding"}, ["fnl/docstring"] = "Applies a `TextDocumentEdit`, which is a list of changes to a single\ndocument.\n\nParameters: ~\n  \226\128\162 {text_document_edit}  (`lsp.TextDocumentEdit`)\n  \226\128\162 {index}               (`integer?`) Optional index of the edit, if from\n                          a list of edits (or nil, if not from a list)\n  \226\128\162 {position_encoding}   (`'utf-8'|'utf-16'|'utf-32'?`)\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentEdit\n\n                                         "}}, apply_text_edits = {binding = "apply_text_edits", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"text_edits", "bufnr", "position_encoding"}, ["fnl/docstring"] = "Applies a list of text edits to a buffer.\n\nParameters: ~\n  \226\128\162 {text_edits}         (`lsp.TextEdit[]`)\n  \226\128\162 {bufnr}              (`integer`) Buffer id\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'`)\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textEdit\n\n                                     "}}, apply_workspace_edit = {binding = "apply_workspace_edit", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"workspace_edit", "position_encoding"}, ["fnl/docstring"] = "Applies a `WorkspaceEdit`.\n\nParameters: ~\n  \226\128\162 {workspace_edit}     (`lsp.WorkspaceEdit`)\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'`) (required)\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_applyEdit"}}, buf_clear_references = {binding = "buf_clear_references", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr"}, ["fnl/docstring"] = "Removes document highlights from a buffer.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer id\n\n                                 "}}, buf_highlight_references = {binding = "buf_highlight_references", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "references", "position_encoding"}, ["fnl/docstring"] = "Shows a list of document highlights for a certain buffer.\n\nParameters: ~\n  \226\128\162 {bufnr}              (`integer`) Buffer id\n  \226\128\162 {references}         (`lsp.DocumentHighlight[]`) objects to highlight\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'`)\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specification/#textDocumentContentChangeEvent\n\n                                         "}}, character_offset = {binding = "character_offset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "row", "col", "?offset_encoding"}, ["fnl/docstring"] = "Returns the UTF-32 and UTF-16 offsets for a position in a certain buffer.\n\nParameters: ~\n  \226\128\162 {buf}              (`integer`) buffer number (0 for current)\n  \226\128\162 {row}              (`integer`) 0-indexed line\n  \226\128\162 {col}              (`integer`) 0-indexed byte offset in line\n  \226\128\162 {offset_encoding}  (`'utf-8'|'utf-16'|'utf-32'?`) defaults to\n                       `offset_encoding` of first client of `buf`\n\nReturn: ~\n    (`integer`) `offset_encoding` index of the character in line {row}\n    column {col} in buffer {buf}\n\n                          "}}, convert_input_to_markdown_lines = {binding = "convert_input_to_markdown_lines", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"input", "?contents"}, ["fnl/docstring"] = "Converts any of `MarkedString` | `MarkedString[]` | `MarkupContent` into a\nlist of lines containing valid markdown. Useful to populate the hover\nwindow for `textDocument/hover`, for parsing the result of\n`textDocument/signatureHelp`, and potentially others.\n\nNote that if the input is of type `MarkupContent` and its kind is\n`plaintext`, then the corresponding value is returned without further\nmodifications.\n\nParameters: ~\n  \226\128\162 {input}     (`lsp.MarkedString|lsp.MarkedString[]|lsp.MarkupContent`)\n  \226\128\162 {contents}  (`string[]?`) List of strings to extend with converted\n                lines. Defaults to {}.\n\nReturn: ~\n    (`string[]`) extended with lines of converted markdown.\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover\n\n                 "}}, convert_signature_help_to_markdown_lines = {binding = "convert_signature_help_to_markdown_lines", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"signature_help", "?ft", "?triggers"}, ["fnl/docstring"] = "Converts `textDocument/signatureHelp` response to markdown lines.\n\nParameters: ~\n  \226\128\162 {signature_help}  (`lsp.SignatureHelp`) Response of\n                      `textDocument/SignatureHelp`\n  \226\128\162 {ft}              (`string?`) filetype that will be use as the `lang`\n                      for the label markdown code block\n  \226\128\162 {triggers}        (`string[]?`) list of trigger characters from the\n                      lsp server. used to better determine parameter\n                      offsets\n\nReturn (multiple): ~\n    (`string[]?`) lines of converted markdown.\n    (`Range4?`) highlight range for the active parameter\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_signatureHelp"}}, get_effective_tabstop = {binding = "get_effective_tabstop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr"}, ["fnl/docstring"] = "Returns indentation size.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer handle, defaults to current\n\nReturn: ~\n    (`integer`) indentation size\n\nSee also: ~\n  \226\128\162 'shiftwidth'\n\n                                       "}}, jump_to_location = {binding = "jump_to_location", metadata = {["fls/itemKind"] = "Function", ["fnl/docstring"] = "DEPRECATED IN 0.11\n\nUse |vim.lsp.util.show_document()| with\n\t\t\t\t\t`{focus=true}` instead."}}, locations_to_items = {binding = "locations_to_items", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"locations", "?position_encoding"}, ["fnl/docstring"] = "Returns the items with the byte position calculated correctly and in\nsorted order, for display in quickfix and location lists.\n\nThe `user_data` field of each resulting item will contain the original\n`Location` or `LocationLink` it was computed from.\n\nThe result can be passed to the {list} argument of |setqflist()| or\n|setloclist()|.\n\nParameters: ~\n  \226\128\162 {locations}          (`lsp.Location[]|lsp.LocationLink[]`)\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'?`) default to first\n                         client of buffer\n\nReturn: ~\n    (`vim.quickfix.entry[]`) See |setqflist()| for the format\n\n                              "}}, make_floating_popup_options = {binding = "make_floating_popup_options", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"width", "height", "?opts"}, ["fnl/docstring"] = "Creates a table with sensible default options for a floating window. The\ntable can be passed to |nvim_open_win()|.\n\nParameters: ~\n  \226\128\162 {width}   (`integer`) window width (in character cells)\n  \226\128\162 {height}  (`integer`) window height (in character cells)\n  \226\128\162 {opts}    (`vim.lsp.util.open_floating_preview.Opts?`) See\n              |vim.lsp.util.open_floating_preview.Opts|.\n\nReturn: ~\n    (`vim.api.keyset.win_config`)\n\n                                   "}}, make_formatting_params = {binding = "make_formatting_params", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?options"}, ["fnl/docstring"] = "Creates a `DocumentFormattingParams` object for the current buffer and\ncursor position.\n\nParameters: ~\n  \226\128\162 {options}  (`lsp.FormattingOptions?`) with valid `FormattingOptions`\n               entries\n\nReturn: ~\n    (`lsp.DocumentFormattingParams`) object\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting\n\n                                  "}}, make_given_range_params = {binding = "make_given_range_params", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?start_pos", "?end_pos", "?bufnr", "position_encoding"}, ["fnl/docstring"] = "Using the given range in the current buffer, creates an object that is\nsimilar to |vim.lsp.util.make_range_params()|.\n\nParameters: ~\n  \226\128\162 {start_pos}          (`[integer,integer]?`) {row,col} mark-indexed\n                         position. Defaults to the start of the last\n                         visual selection.\n  \226\128\162 {end_pos}            (`[integer,integer]?`) {row,col} mark-indexed\n                         position. Defaults to the end of the last visual\n                         selection.\n  \226\128\162 {bufnr}              (`integer?`) buffer handle or 0 for current,\n                         defaults to current\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'`)\n\nReturn: ~\n    (`{ textDocument: { uri: lsp.DocumentUri }, range: lsp.Range }`)\n\n                                     "}}, make_position_params = {binding = "make_position_params", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?window", "position_encoding"}, ["fnl/docstring"] = "Creates a `TextDocumentPositionParams` object for the current buffer and\ncursor position.\n\nParameters: ~\n  \226\128\162 {window}             (`integer?`) |window-ID| or 0 for current,\n                         defaults to current\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'`)\n\nReturn: ~\n    (`lsp.TextDocumentPositionParams`)\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentPositionParams\n\n                                        "}}, make_range_params = {binding = "make_range_params", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?window", "position_encoding"}, ["fnl/docstring"] = "Using the current position in the current buffer, creates an object that\ncan be used as a building block for several LSP requests, such as\n`textDocument/codeAction`, `textDocument/colorPresentation`,\n`textDocument/rangeFormatting`.\n\nParameters: ~\n  \226\128\162 {window}             (`integer?`) |window-ID| or 0 for current,\n                         defaults to current\n  \226\128\162 {position_encoding}  (`\"utf-8\"|\"utf-16\"|\"utf-32\"`)\n\nReturn: ~\n    (`{ textDocument: { uri: lsp.DocumentUri }, range: lsp.Range }`)\n\n                                "}}, make_text_document_params = {binding = "make_text_document_params", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr"}, ["fnl/docstring"] = "Creates a `TextDocumentIdentifier` object for the current buffer.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer handle, defaults to current\n\nReturn: ~\n    (`lsp.TextDocumentIdentifier`)\n\nSee also: ~\n  \226\128\162 https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier\n\n                                    "}}, make_workspace_params = {binding = "make_workspace_params", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"added", "removed"}, ["fnl/docstring"] = "Create the workspace params\n\nParameters: ~\n  \226\128\162 {added}    (`lsp.WorkspaceFolder[]`)\n  \226\128\162 {removed}  (`lsp.WorkspaceFolder[]`)\n\nReturn: ~\n    (`lsp.WorkspaceFoldersChangeEvent`)\n\n                                    "}}, open_floating_preview = {binding = "open_floating_preview", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"contents", "syntax", "?opts"}, ["fnl/docstring"] = "Shows contents in a floating window.\n\nParameters: ~\n  \226\128\162 {contents}  (`table`) of lines to show in window\n  \226\128\162 {syntax}    (`string`) of syntax to set for opened buffer\n  \226\128\162 {opts}      (`vim.lsp.util.open_floating_preview.Opts?`) with optional\n                fields (additional keys are filtered with\n                |vim.lsp.util.make_floating_popup_options()| before they\n                are passed on to |nvim_open_win()|). See\n                |vim.lsp.util.open_floating_preview.Opts|.\n\nReturn (multiple): ~\n    (`integer`) bufnr of newly created float window\n    (`integer`) winid of newly created float window preview window"}}, preview_location = {binding = "preview_location", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"location", "?opts"}, ["fnl/docstring"] = "Previews a location in a floating window\n\nbehavior depends on type of location:\n\226\128\162 for Location, range is shown (e.g., function definition)\n\226\128\162 for LocationLink, targetRange is shown (e.g., body of function\n  definition)\n\nParameters: ~\n  \226\128\162 {location}  (`lsp.Location|lsp.LocationLink`)\n  \226\128\162 {opts}      (`vim.lsp.util.open_floating_preview.Opts?`) See\n                |vim.lsp.util.open_floating_preview.Opts|.\n\nReturn (multiple): ~\n    (`integer?`) buffer id of float window\n    (`integer?`) window id of float window"}}, rename = {binding = "rename", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"old_fname", "new_fname", "?opts"}, ["fnl/docstring"] = "Rename old_fname to new_fname\n\nExisting buffers are renamed as well, while maintaining their bufnr.\n\nIt deletes existing buffers that conflict with the renamed file name only\nwhen\n\226\128\162 `opts` requests overwriting; or\n\226\128\162 the conflicting buffers are not loaded, so that deleting them does not\n  result in data loss.\n\nParameters: ~\n  \226\128\162 {old_fname}  (`string`)\n  \226\128\162 {new_fname}  (`string`)\n  \226\128\162 {opts}       (`table?`) Options:\n                 \226\128\162 {overwrite}? (`boolean`)\n                 \226\128\162 {ignoreIfExists}? (`boolean`)\n\n                                            "}}, show_document = {binding = "show_document", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"location", "?position_encoding", "?opts"}, ["fnl/docstring"] = "Shows document and optionally jumps to the location.\n\nParameters: ~\n  \226\128\162 {location}           (`lsp.Location|lsp.LocationLink`)\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'?`)\n  \226\128\162 {opts}               (`table?`) A table with the following fields:\n                         \226\128\162 {reuse_win}? (`boolean`) Jump to existing\n                           window if buffer is already open.\n                         \226\128\162 {focus}? (`boolean`) Whether to focus/jump to\n                           location if possible. (defaults: true)\n\nReturn: ~\n    (`boolean`) `true` if succeeded\n\n                                         "}}, stylize_markdown = {binding = "stylize_markdown", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "contents", "?opts"}, ["fnl/docstring"] = "Converts markdown into syntax highlighted regions by stripping the code\nblocks and converting them into highlighted code. This will by default\ninsert a blank line separator after those code block regions to improve\nreadability.\n\nThis method configures the given buffer and returns the lines to set.\n\nIf you want to open a popup with fancy markdown, use\n`open_floating_preview` instead\n\nParameters: ~\n  \226\128\162 {bufnr}     (`integer`)\n  \226\128\162 {contents}  (`string[]`) of lines to show in window\n  \226\128\162 {opts}      (`table?`) with optional fields\n                \226\128\162 height of floating window\n                \226\128\162 width of floating window\n                \226\128\162 wrap_at character to wrap at for computing height\n                \226\128\162 max_width maximal width of floating window\n                \226\128\162 max_height maximal height of floating window\n                \226\128\162 separator insert separator after code block\n\nReturn: ~\n    (`table`) stripped content\n\n                                         "}}, symbols_to_items = {binding = "symbols_to_items", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"symbols", "?bufnr", "?position_encoding"}, ["fnl/docstring"] = "Converts symbols to quickfix list items.\n\nParameters: ~\n  \226\128\162 {symbols}            (`lsp.DocumentSymbol[]|lsp.SymbolInformation[]`)\n                         list of symbols\n  \226\128\162 {bufnr}              (`integer?`) buffer handle or 0 for current,\n                         defaults to current\n  \226\128\162 {position_encoding}  (`'utf-8'|'utf-16'|'utf-32'?`) default to first\n                         client of buffer\n\nReturn: ~\n    (`vim.quickfix.entry[]`) See |setqflist()| for the format"}}}, metadata = {["fls/itemKind"] = "Module"}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "LSP client/framework LSP\n\nNvim supports the Language Server Protocol (LSP), which means it acts as a\nclient to LSP servers and includes a Lua framework vim.lsp for building\nenhanced LSP tools."}}, lua_omnifunc = {binding = "lua_omnifunc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"find_start"}, ["fnl/docstring"] = "Omnifunc for completing Lua values from the runtime Lua interpreter,\nsimilar to the builtin completion for the `:lua` command.\n\nActivate using `set omnifunc=v:lua.vim.lua_omnifunc` in a Lua buffer.\n\nParameters: ~\n  \226\128\162 {find_start}  (`1|0`)"}}, mpack = {binding = "mpack", fields = {decode = {binding = "decode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Decodes (or \"unpacks\") the msgpack-encoded {str} to a Lua object.\n\nParameters: ~\n  \226\128\162 {str}  (`string`)\n\nReturn: ~\n    (`any`)"}}, encode = {binding = "encode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"obj"}, ["fnl/docstring"] = "Encodes (or \"packs\") Lua object {obj} as msgpack in a Lua string.\n\nParameters: ~\n  \226\128\162 {obj}  (`any`)\n\nReturn: ~\n    (`string`)"}}}, metadata = {["fls/itemKind"] = "Module"}}, notify = {binding = "notify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg", "?level", "?opts"}, ["fnl/docstring"] = "Displays a notification to the user.\n\nThis function can be overridden by plugins to display notifications using\na custom provider (such as the system notification provider). By default,\nwrites to |:messages|.\n\nParameters: ~\n  \226\128\162 {msg}    (`string`) Content of the notification to show to the user.\n  \226\128\162 {level}  (`integer?`) One of the values from |vim.log.levels|.\n  \226\128\162 {opts}   (`table?`) Optional parameters. Unused by default."}}, notify_once = {binding = "notify_once", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msg", "?level", "?opts"}, ["fnl/docstring"] = "Displays a notification only one time.\n\nLike |vim.notify()|, but subsequent calls with the same message will not\ndisplay a notification.\n\nParameters: ~\n  \226\128\162 {msg}    (`string`) Content of the notification to show to the user.\n  \226\128\162 {level}  (`integer?`) One of the values from |vim.log.levels|.\n  \226\128\162 {opts}   (`table?`) Optional parameters. Unused by default.\n\nReturn: ~\n    (`boolean`) true if message was displayed, else false"}}, o = {binding = "o", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Get or set |options|. Works like `:set`, so buffer/window-scoped options\ntarget the current buffer/window. Invalid key is an error.\n\nExample: >lua\n    vim.o.cmdheight = 4\n    print(vim.o.columns)\n    print(vim.o.foo)     -- error: invalid key\n<"}}, on_key = {binding = "on_key", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?fn", "?ns_id", "?opts"}, ["fnl/docstring"] = "Adds Lua function {fn} with namespace id {ns_id} as a listener to every,\nyes every, input key.\n\nThe Nvim command-line option |-w| is related but does not support\ncallbacks and cannot be toggled dynamically.\n\nNote: ~\n  \226\128\162 {fn} will be removed on error.\n  \226\128\162 {fn} won't be invoked recursively, i.e. if {fn} itself consumes input,\n    it won't be invoked for those keys.\n  \226\128\162 {fn} will not be cleared by |nvim_buf_clear_namespace()|\n\nParameters: ~\n  \226\128\162 {fn}     (`fun(key: string, typed: string): string??`) Function\n             invoked for every input key, after mappings have been applied\n             but before further processing. Arguments {key} and {typed}\n             are raw keycodes, where {key} is the key after mappings are\n             applied, and {typed} is the key(s) before mappings are\n             applied. {typed} may be empty if {key} is produced by\n             non-typed key(s) or by the same typed key(s) that produced a\n             previous {key}. If {fn} returns an empty string, {key} is\n             discarded/ignored. When {fn} is `nil`, the callback\n             associated with namespace {ns_id} is removed.\n  \226\128\162 {ns_id}  (`integer?`) Namespace ID. If nil or 0, generates and returns\n             a new |nvim_create_namespace()| id.\n  \226\128\162 {opts}   (`table?`) Optional parameters\n\nReturn: ~\n    (`integer`) Namespace id associated with {fn}. Or count of all\n    callbacks if on_key() is called without arguments.\n\nSee also: ~\n  \226\128\162 |keytrans()|"}}, opt = {binding = "opt", fields = {acd = {binding = "acd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autochdir' 'acd'\tboolean\t(default off)\n\t\tglobal\nWhen on, Vim will change the current working directory whenever you\nopen a file, switch buffers, delete a buffer or open/close a window.\nIt will change to the directory containing the file which was opened\nor selected.  When a buffer has no name it also has no directory, thus\nthe current directory won't change when navigating to it.\nNote: When this option is on some plugins may not work."}}, ai = {binding = "ai", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoindent' 'ai'\tboolean\t(default on)\n\t\tlocal to buffer\nCopy indent from current line when starting a new line (typing <CR>\nin Insert mode or when using the \"o\" or \"O\" command).  If you do not\ntype anything on the new line except <BS> or CTRL-D and then type\n<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor\nto another line has the same effect, unless the 'I' flag is included\nin 'cpoptions'.\nWhen autoindent is on, formatting (with the \"gq\" command or when you\nreach 'textwidth' in Insert mode) uses the indentation of the first\nline.\nWhen 'smartindent' or 'cindent' is on the indent is changed in\na different way."}}, allowrevins = {binding = "allowrevins", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'allowrevins' 'ari'\tboolean\t(default off)\n\t\tglobal\nAllow CTRL-_ in Insert mode.  This is default off, to avoid that users\nthat accidentally type CTRL-_ instead of SHIFT-_ get into reverse\nInsert mode, and don't know how to get out.  See 'revins'."}}, ambiwidth = {binding = "ambiwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ambiwidth' 'ambw'\tstring\t(default \"single\")\n\t\tglobal\nTells Vim what to do with characters with East Asian Width Class\nAmbiguous (such as Euro, Registered Sign, Copyright Sign, Greek\nletters, Cyrillic letters).\n\nThere are currently two possible values:\n\"single\":\tUse the same width as characters in US-ASCII.  This is\n\t\texpected by most users.\n\"double\":\tUse twice the width of ASCII characters.\n\t\t\t\t\t\t*E834* *E835*\nThe value \"double\" cannot be used if 'listchars' or 'fillchars'\ncontains a character that would be double width.  These errors may\nalso be given when calling setcellwidths().\n\nThe values are overruled for characters specified with\n|setcellwidths()|.\n\nThere are a number of CJK fonts for which the width of glyphs for\nthose characters are solely based on how many octets they take in\nlegacy/traditional CJK encodings.  In those encodings, Euro,\nRegistered sign, Greek/Cyrillic letters are represented by two octets,\ntherefore those fonts have \"wide\" glyphs for them.  This is also\ntrue of some line drawing characters used to make tables in text\nfile.  Therefore, when a CJK font is used for GUI Vim or\nVim is running inside a terminal (emulators) that uses a CJK font\n(or Vim is run inside an xterm invoked with \"-cjkwidth\" option.),\nthis option should be set to \"double\" to match the width perceived\nby Vim with the width of glyphs in the font.  Perhaps it also has\nto be set to \"double\" under CJK MS-Windows when the system locale is\nset to one of CJK locales.  See Unicode Standard Annex #11\n(https://www.unicode.org/reports/tr11)."}}, ambw = {binding = "ambw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ambiwidth' 'ambw'\tstring\t(default \"single\")\n\t\tglobal\nTells Vim what to do with characters with East Asian Width Class\nAmbiguous (such as Euro, Registered Sign, Copyright Sign, Greek\nletters, Cyrillic letters).\n\nThere are currently two possible values:\n\"single\":\tUse the same width as characters in US-ASCII.  This is\n\t\texpected by most users.\n\"double\":\tUse twice the width of ASCII characters.\n\t\t\t\t\t\t*E834* *E835*\nThe value \"double\" cannot be used if 'listchars' or 'fillchars'\ncontains a character that would be double width.  These errors may\nalso be given when calling setcellwidths().\n\nThe values are overruled for characters specified with\n|setcellwidths()|.\n\nThere are a number of CJK fonts for which the width of glyphs for\nthose characters are solely based on how many octets they take in\nlegacy/traditional CJK encodings.  In those encodings, Euro,\nRegistered sign, Greek/Cyrillic letters are represented by two octets,\ntherefore those fonts have \"wide\" glyphs for them.  This is also\ntrue of some line drawing characters used to make tables in text\nfile.  Therefore, when a CJK font is used for GUI Vim or\nVim is running inside a terminal (emulators) that uses a CJK font\n(or Vim is run inside an xterm invoked with \"-cjkwidth\" option.),\nthis option should be set to \"double\" to match the width perceived\nby Vim with the width of glyphs in the font.  Perhaps it also has\nto be set to \"double\" under CJK MS-Windows when the system locale is\nset to one of CJK locales.  See Unicode Standard Annex #11\n(https://www.unicode.org/reports/tr11)."}}, ar = {binding = "ar", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoread' 'ar'\t\tboolean\t(default on)\n\t\tglobal or local to buffer |global-local|\nWhen a file has been detected to have been changed outside of Vim and\nit has not been changed inside of Vim, automatically read it again.\nWhen the file has been deleted this is not done, so you have the text\nfrom before it was deleted.  When it appears again then it is read.\n|timestamp|\nIf this option has a local value, use this command to switch back to\nusing the global value: >vim\n\tset autoread<\n<"}}, arab = {binding = "arab", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabic' 'arab'\t\tboolean\t(default off)\n\t\tlocal to window\nThis option can be set to start editing Arabic text.\nSetting this option will:\n- Set the 'rightleft' option, unless 'termbidi' is set.\n- Set the 'arabicshape' option, unless 'termbidi' is set.\n- Set the 'keymap' option to \"arabic\"; in Insert mode CTRL-^ toggles\n  between typing English and Arabic key mapping.\n- Set the 'delcombine' option\n\nResetting this option will:\n- Reset the 'rightleft' option.\n- Disable the use of 'keymap' (without changing its value).\nNote that 'arabicshape' and 'delcombine' are not reset (it is a global\noption).\nAlso see |arabic.txt|."}}, arabic = {binding = "arabic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabic' 'arab'\t\tboolean\t(default off)\n\t\tlocal to window\nThis option can be set to start editing Arabic text.\nSetting this option will:\n- Set the 'rightleft' option, unless 'termbidi' is set.\n- Set the 'arabicshape' option, unless 'termbidi' is set.\n- Set the 'keymap' option to \"arabic\"; in Insert mode CTRL-^ toggles\n  between typing English and Arabic key mapping.\n- Set the 'delcombine' option\n\nResetting this option will:\n- Reset the 'rightleft' option.\n- Disable the use of 'keymap' (without changing its value).\nNote that 'arabicshape' and 'delcombine' are not reset (it is a global\noption).\nAlso see |arabic.txt|."}}, arabicshape = {binding = "arabicshape", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabicshape' 'arshape'\tboolean\t(default on)\n\t\tglobal\nWhen on and 'termbidi' is off, the required visual character\ncorrections that need to take place for displaying the Arabic language\ntake effect.  Shaping, in essence, gets enabled; the term is a broad\none which encompasses:\n  a) the changing/morphing of characters based on their location\n     within a word (initial, medial, final and stand-alone).\n  b) the enabling of the ability to compose characters\n  c) the enabling of the required combining of some characters\nWhen disabled the display shows each character's true stand-alone\nform.\nArabic is a complex language which requires other settings, for\nfurther details see |arabic.txt|."}}, ari = {binding = "ari", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'allowrevins' 'ari'\tboolean\t(default off)\n\t\tglobal\nAllow CTRL-_ in Insert mode.  This is default off, to avoid that users\nthat accidentally type CTRL-_ instead of SHIFT-_ get into reverse\nInsert mode, and don't know how to get out.  See 'revins'."}}, arshape = {binding = "arshape", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabicshape' 'arshape'\tboolean\t(default on)\n\t\tglobal\nWhen on and 'termbidi' is off, the required visual character\ncorrections that need to take place for displaying the Arabic language\ntake effect.  Shaping, in essence, gets enabled; the term is a broad\none which encompasses:\n  a) the changing/morphing of characters based on their location\n     within a word (initial, medial, final and stand-alone).\n  b) the enabling of the ability to compose characters\n  c) the enabling of the required combining of some characters\nWhen disabled the display shows each character's true stand-alone\nform.\nArabic is a complex language which requires other settings, for\nfurther details see |arabic.txt|."}}, autochdir = {binding = "autochdir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autochdir' 'acd'\tboolean\t(default off)\n\t\tglobal\nWhen on, Vim will change the current working directory whenever you\nopen a file, switch buffers, delete a buffer or open/close a window.\nIt will change to the directory containing the file which was opened\nor selected.  When a buffer has no name it also has no directory, thus\nthe current directory won't change when navigating to it.\nNote: When this option is on some plugins may not work."}}, autoindent = {binding = "autoindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoindent' 'ai'\tboolean\t(default on)\n\t\tlocal to buffer\nCopy indent from current line when starting a new line (typing <CR>\nin Insert mode or when using the \"o\" or \"O\" command).  If you do not\ntype anything on the new line except <BS> or CTRL-D and then type\n<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor\nto another line has the same effect, unless the 'I' flag is included\nin 'cpoptions'.\nWhen autoindent is on, formatting (with the \"gq\" command or when you\nreach 'textwidth' in Insert mode) uses the indentation of the first\nline.\nWhen 'smartindent' or 'cindent' is on the indent is changed in\na different way."}}, autoread = {binding = "autoread", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoread' 'ar'\t\tboolean\t(default on)\n\t\tglobal or local to buffer |global-local|\nWhen a file has been detected to have been changed outside of Vim and\nit has not been changed inside of Vim, automatically read it again.\nWhen the file has been deleted this is not done, so you have the text\nfrom before it was deleted.  When it appears again then it is read.\n|timestamp|\nIf this option has a local value, use this command to switch back to\nusing the global value: >vim\n\tset autoread<\n<"}}, autowrite = {binding = "autowrite", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowrite' 'aw'\tboolean\t(default off)\n\t\tglobal\nWrite the contents of the file, if it has been modified, on each\n`:next`, `:rewind`, `:last`, `:first`, `:previous`, `:stop`,\n`:suspend`, `:tag`, `:!`, `:make`, CTRL-] and CTRL-^ command; and when\na `:buffer`, CTRL-O, CTRL-I, '{A-Z0-9}, or `{A-Z0-9} command takes one\nto another file.\nA buffer is not written if it becomes hidden, e.g. when 'bufhidden' is\nset to \"hide\" and `:next` is used.\nNote that for some commands the 'autowrite' option is not used, see\n'autowriteall' for that.\nSome buffers will not be written, specifically when 'buftype' is\n\"nowrite\", \"nofile\", \"terminal\" or \"prompt\".\nUSE WITH CARE: If you make temporary changes to a buffer that you\ndon't want to be saved this option may cause it to be saved anyway.\nRenaming the buffer with \":file {name}\" may help avoid this."}}, autowriteall = {binding = "autowriteall", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowriteall' 'awa'\tboolean\t(default off)\n\t\tglobal\nLike 'autowrite', but also used for commands \":edit\", \":enew\", \":quit\",\n\":qall\", \":exit\", \":xit\", \":recover\" and closing the Vim window.\nSetting this option also implies that Vim behaves like 'autowrite' has\nbeen set."}}, aw = {binding = "aw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowrite' 'aw'\tboolean\t(default off)\n\t\tglobal\nWrite the contents of the file, if it has been modified, on each\n`:next`, `:rewind`, `:last`, `:first`, `:previous`, `:stop`,\n`:suspend`, `:tag`, `:!`, `:make`, CTRL-] and CTRL-^ command; and when\na `:buffer`, CTRL-O, CTRL-I, '{A-Z0-9}, or `{A-Z0-9} command takes one\nto another file.\nA buffer is not written if it becomes hidden, e.g. when 'bufhidden' is\nset to \"hide\" and `:next` is used.\nNote that for some commands the 'autowrite' option is not used, see\n'autowriteall' for that.\nSome buffers will not be written, specifically when 'buftype' is\n\"nowrite\", \"nofile\", \"terminal\" or \"prompt\".\nUSE WITH CARE: If you make temporary changes to a buffer that you\ndon't want to be saved this option may cause it to be saved anyway.\nRenaming the buffer with \":file {name}\" may help avoid this."}}, awa = {binding = "awa", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowriteall' 'awa'\tboolean\t(default off)\n\t\tglobal\nLike 'autowrite', but also used for commands \":edit\", \":enew\", \":quit\",\n\":qall\", \":exit\", \":xit\", \":recover\" and closing the Vim window.\nSetting this option also implies that Vim behaves like 'autowrite' has\nbeen set."}}, background = {binding = "background", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'background' 'bg'\tstring\t(default \"dark\")\n\t\tglobal\nWhen set to \"dark\" or \"light\", adjusts the default color groups for\nthat background type.  The |TUI| or other UI sets this on startup\n(triggering |OptionSet|) if it can detect the background color.\n\nThis option does NOT change the background color, it tells Nvim what\nthe \"inherited\" (terminal/GUI) background looks like.\nSee |:hi-normal| if you want to set the background color explicitly.\n\t\t\t\t\t*g:colors_name*\nWhen a color scheme is loaded (the \"g:colors_name\" variable is set)\nchanging 'background' will cause the color scheme to be reloaded.  If\nthe color scheme adjusts to the value of 'background' this will work.\nHowever, if the color scheme sets 'background' itself the effect may\nbe undone.  First delete the \"g:colors_name\" variable when needed.\n\nNormally this option would be set in the vimrc file.  Possibly\ndepending on the terminal name.  Example: >vim\n\tif $TERM ==# \"xterm\"\n\t  set background=dark\n\tendif\n<\tWhen this option is changed, the default settings for the highlight groups\nwill change.  To use other settings, place \":highlight\" commands AFTER\nthe setting of the 'background' option."}}, backspace = {binding = "backspace", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backspace' 'bs'\tstring\t(default \"indent,eol,start\")\n\t\tglobal\nInfluences the working of <BS>, <Del>, CTRL-W and CTRL-U in Insert\nmode.  This is a list of items, separated by commas.  Each item allows\na way to backspace over something:\nvalue\teffect\t~\nindent\tallow backspacing over autoindent\neol\tallow backspacing over line breaks (join lines)\nstart\tallow backspacing over the start of insert; CTRL-W and CTRL-U\n\tstop once at the start of insert.\nnostop\tlike start, except CTRL-W and CTRL-U do not stop at the start of\n\tinsert.\n\nWhen the value is empty, Vi compatible backspacing is used, none of\nthe ways mentioned for the items above are possible."}}, backup = {binding = "backup", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backup' 'bk'\t\tboolean\t(default off)\n\t\tglobal\nMake a backup before overwriting a file.  Leave it around after the\nfile has been successfully written.  If you do not want to keep the\nbackup file, but you do want a backup while the file is being\nwritten, reset this option and set the 'writebackup' option (this is\nthe default).  If you do not want a backup file at all reset both\noptions (use this if your file system is almost full).  See the\n|backup-table| for more explanations.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nWhen 'patchmode' is set, the backup may be renamed to become the\noldest version of a file."}}, backupcopy = {binding = "backupcopy", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupcopy' 'bkc'\tstring\t(default \"auto\")\n\t\tglobal or local to buffer |global-local|\nWhen writing a file and a backup is made, this option tells how it's\ndone.  This is a comma-separated list of words.\n\nThe main values are:\n\"yes\"\tmake a copy of the file and overwrite the original one\n\"no\"\trename the file and write a new one\n\"auto\"\tone of the previous, what works best\n\nExtra values that can be combined with the ones above are:\n\"breaksymlink\"\talways break symlinks when writing\n\"breakhardlink\"\talways break hardlinks when writing\n\nMaking a copy and overwriting the original file:\n- Takes extra time to copy the file.\n+ When the file has special attributes, is a (hard/symbolic) link or\n  has a resource fork, all this is preserved.\n- When the file is a link the backup will have the name of the link,\n  not of the real file.\n\nRenaming the file and writing a new one:\n+ It's fast.\n- Sometimes not all attributes of the file can be copied to the new\n  file.\n- When the file is a link the new file will not be a link.\n\nThe \"auto\" value is the middle way: When Vim sees that renaming the\nfile is possible without side effects (the attributes can be passed on\nand the file is not a link) that is used.  When problems are expected,\na copy will be made.\n\nThe \"breaksymlink\" and \"breakhardlink\" values can be used in\ncombination with any of \"yes\", \"no\" and \"auto\".  When included, they\nforce Vim to always break either symbolic or hard links by doing\nexactly what the \"no\" option does, renaming the original file to\nbecome the backup and writing a new file in its place.  This can be\nuseful for example in source trees where all the files are symbolic or\nhard links and any changes should stay in the local source tree, not\nbe propagated back to the original source.\n\t\t\t\t\t\t\t*crontab*\nOne situation where \"no\" and \"auto\" will cause problems: A program\nthat opens a file, invokes Vim to edit that file, and then tests if\nthe open file was changed (through the file descriptor) will check the\nbackup file instead of the newly created file.  \"crontab -e\" is an\nexample, as are several |file-watcher| daemons like inotify.  In that\ncase you probably want to switch this option.\n\nWhen a copy is made, the original file is truncated and then filled\nwith the new text.  This means that protection bits, owner and\nsymbolic links of the original file are unmodified.  The backup file,\nhowever, is a new file, owned by the user who edited the file.  The\ngroup of the backup is set to the group of the original file.  If this\nfails, the protection bits for the group are made the same as for\nothers.\n\nWhen the file is renamed, this is the other way around: The backup has\nthe same attributes of the original file, and the newly written file\nis owned by the current user.  When the file was a (hard/symbolic)\nlink, the new file will not!  That's why the \"auto\" value doesn't\nrename when the file is a link.  The owner and group of the newly\nwritten file will be set to the same ones as the original file, but\nthe system may refuse to do this.  In that case the \"auto\" value will\nagain not rename the file."}}, backupdir = {binding = "backupdir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupdir' 'bdir'\tstring\t(default \".,$XDG_STATE_HOME/nvim/backup//\")\n\t\tglobal\nList of directories for the backup file, separated with commas.\n- The backup file will be created in the first directory in the list\n  where this is possible.  If none of the directories exist Nvim will\n  attempt to create the last directory in the list.\n- Empty means that no backup file will be created ('patchmode' is\n  impossible!).  Writing may fail because of this.\n- A directory \".\" means to put the backup file in the same directory\n  as the edited file.\n- A directory starting with \"./\" (or \".\\\" for MS-Windows) means to put\n  the backup file relative to where the edited file is.  The leading\n  \".\" is replaced with the path name of the edited file.\n  (\".\" inside a directory name has no special meaning).\n- Spaces after the comma are ignored, other spaces are considered part\n  of the directory name.  To have a space at the start of a directory\n  name, precede it with a backslash.\n- To include a comma in a directory name precede it with a backslash.\n- A directory name may end in an '/'.\n- For Unix and Win32, if a directory ends in two path separators \"//\",\n  the swap file name will be built from the complete path to the file\n  with all path separators changed to percent '%' signs. This will\n  ensure file name uniqueness in the backup directory.\n  On Win32, it is also possible to end with \"\\\\\".  However, When a\n  separating comma is following, you must use \"//\", since \"\\\\\" will\n  include the comma in the file name. Therefore it is recommended to\n  use '//', instead of '\\\\'.\n- Environment variables are expanded |:set_env|.\n- Careful with '\\' characters, type one before a space, type two to\n  get one in the option (see |option-backslash|), for example: >vim\n    set bdir=c:\\\\tmp,\\ dir\\\\,with\\\\,commas,\\\\\\ dir\\ with\\ spaces\n<\nSee also 'backup' and 'writebackup' options.\nIf you want to hide your backup files on Unix, consider this value: >vim\n\tset backupdir=./.backup,~/.backup,.,/tmp\n<\tYou must create a \".backup\" directory in each directory and in your\nhome directory for this to work properly.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\ndirectories from the list.  This avoids problems when a future version\nuses another default.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, backupext = {binding = "backupext", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupext' 'bex'\tstring\t(default \"~\")\n\t\tglobal\nString which is appended to a file name to make the name of the\nbackup file.  The default is quite unusual, because this avoids\naccidentally overwriting existing files with a backup file.  You might\nprefer using \".bak\", but make sure that you don't have files with\n\".bak\" that you want to keep.\nOnly normal file name characters can be used; `/\\*?[|<>` are illegal.\n\nIf you like to keep a lot of backups, you could use a BufWritePre\nautocommand to change 'backupext' just before writing the file to\ninclude a timestamp. >vim\n\tau BufWritePre * let &bex = '-' .. strftime(\"%Y%b%d%X\") .. '~'\n<\tUse 'backupdir' to put the backup in a different directory."}}, backupskip = {binding = "backupskip", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupskip' 'bsk'\tstring\t(default \"$TMPDIR/*,$TMP/*,$TEMP/*\"\n                                 Unix: \"/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*\"\n                                 Mac: \"/private/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*\")\n\t\tglobal\nA list of file patterns.  When one of the patterns matches with the\nname of the file which is written, no backup file is created.  Both\nthe specified file name and the full path name of the file are used.\nThe pattern is used like with |:autocmd|, see |autocmd-pattern|.\nWatch out for special characters, see |option-backslash|.\nWhen $TMPDIR, $TMP or $TEMP is not defined, it is not used for the\ndefault value.  \"/tmp/*\" is only used for Unix.\n\nWARNING: Not having a backup file means that when Vim fails to write\nyour buffer correctly and then, for whatever reason, Vim exits, you\nlose both the original file and what you were writing.  Only disable\nbackups if you don't care about losing the file.\n\nNote that environment variables are not expanded.  If you want to use\n$HOME you must expand it explicitly, e.g.: >vim\n\tlet &backupskip = escape(expand('$HOME'), '\\') .. '/tmp/*'\n\n<\tNote that the default also makes sure that \"crontab -e\" works (when a\nbackup would be made by renaming the original file crontab won't see\nthe newly created file).  Also see 'backupcopy' and |crontab|."}}, bdir = {binding = "bdir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupdir' 'bdir'\tstring\t(default \".,$XDG_STATE_HOME/nvim/backup//\")\n\t\tglobal\nList of directories for the backup file, separated with commas.\n- The backup file will be created in the first directory in the list\n  where this is possible.  If none of the directories exist Nvim will\n  attempt to create the last directory in the list.\n- Empty means that no backup file will be created ('patchmode' is\n  impossible!).  Writing may fail because of this.\n- A directory \".\" means to put the backup file in the same directory\n  as the edited file.\n- A directory starting with \"./\" (or \".\\\" for MS-Windows) means to put\n  the backup file relative to where the edited file is.  The leading\n  \".\" is replaced with the path name of the edited file.\n  (\".\" inside a directory name has no special meaning).\n- Spaces after the comma are ignored, other spaces are considered part\n  of the directory name.  To have a space at the start of a directory\n  name, precede it with a backslash.\n- To include a comma in a directory name precede it with a backslash.\n- A directory name may end in an '/'.\n- For Unix and Win32, if a directory ends in two path separators \"//\",\n  the swap file name will be built from the complete path to the file\n  with all path separators changed to percent '%' signs. This will\n  ensure file name uniqueness in the backup directory.\n  On Win32, it is also possible to end with \"\\\\\".  However, When a\n  separating comma is following, you must use \"//\", since \"\\\\\" will\n  include the comma in the file name. Therefore it is recommended to\n  use '//', instead of '\\\\'.\n- Environment variables are expanded |:set_env|.\n- Careful with '\\' characters, type one before a space, type two to\n  get one in the option (see |option-backslash|), for example: >vim\n    set bdir=c:\\\\tmp,\\ dir\\\\,with\\\\,commas,\\\\\\ dir\\ with\\ spaces\n<\nSee also 'backup' and 'writebackup' options.\nIf you want to hide your backup files on Unix, consider this value: >vim\n\tset backupdir=./.backup,~/.backup,.,/tmp\n<\tYou must create a \".backup\" directory in each directory and in your\nhome directory for this to work properly.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\ndirectories from the list.  This avoids problems when a future version\nuses another default.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, belloff = {binding = "belloff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'belloff' 'bo'\t\tstring\t(default \"all\")\n\t\tglobal\nSpecifies for which events the bell will not be rung. It is a comma-\nseparated list of items. For each item that is present, the bell\nwill be silenced. This is most useful to specify specific events in\ninsert mode to be silenced.\nYou can also make it flash by using 'visualbell'.\n\nitem\t    meaning when present\t~\nall\t    All events.\nbackspace   When hitting <BS> or <Del> and deleting results in an\n\t    error.\ncursor\t    Fail to move around using the cursor keys or\n\t    <PageUp>/<PageDown> in |Insert-mode|.\ncomplete    Error occurred when using |i_CTRL-X_CTRL-K| or\n\t    |i_CTRL-X_CTRL-T|.\ncopy\t    Cannot copy char from insert mode using |i_CTRL-Y| or\n\t    |i_CTRL-E|.\nctrlg\t    Unknown Char after <C-G> in Insert mode.\nerror\t    Other Error occurred (e.g. try to join last line)\n\t    (mostly used in |Normal-mode| or |Cmdline-mode|).\nesc\t    hitting <Esc> in |Normal-mode|.\nhangul\t    Ignored.\nlang\t    Calling the beep module for Lua/Mzscheme/TCL.\nmess\t    No output available for |g<|.\nshowmatch   Error occurred for 'showmatch' function.\noperator    Empty region error |cpo-E|.\nregister    Unknown register after <C-R> in |Insert-mode|.\nshell\t    Bell from shell output |:!|.\nspell\t    Error happened on spell suggest.\nterm\t    Bell from |:terminal| output.\nwildmode    More matches in |cmdline-completion| available\n\t    (depends on the 'wildmode' setting).\n\nThis is most useful to fine tune when in Insert mode the bell should\nbe rung. For Normal mode and Ex commands, the bell is often rung to\nindicate that an error occurred. It can be silenced by adding the\n\"error\" keyword."}}, bex = {binding = "bex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupext' 'bex'\tstring\t(default \"~\")\n\t\tglobal\nString which is appended to a file name to make the name of the\nbackup file.  The default is quite unusual, because this avoids\naccidentally overwriting existing files with a backup file.  You might\nprefer using \".bak\", but make sure that you don't have files with\n\".bak\" that you want to keep.\nOnly normal file name characters can be used; `/\\*?[|<>` are illegal.\n\nIf you like to keep a lot of backups, you could use a BufWritePre\nautocommand to change 'backupext' just before writing the file to\ninclude a timestamp. >vim\n\tau BufWritePre * let &bex = '-' .. strftime(\"%Y%b%d%X\") .. '~'\n<\tUse 'backupdir' to put the backup in a different directory."}}, bg = {binding = "bg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'background' 'bg'\tstring\t(default \"dark\")\n\t\tglobal\nWhen set to \"dark\" or \"light\", adjusts the default color groups for\nthat background type.  The |TUI| or other UI sets this on startup\n(triggering |OptionSet|) if it can detect the background color.\n\nThis option does NOT change the background color, it tells Nvim what\nthe \"inherited\" (terminal/GUI) background looks like.\nSee |:hi-normal| if you want to set the background color explicitly.\n\t\t\t\t\t*g:colors_name*\nWhen a color scheme is loaded (the \"g:colors_name\" variable is set)\nchanging 'background' will cause the color scheme to be reloaded.  If\nthe color scheme adjusts to the value of 'background' this will work.\nHowever, if the color scheme sets 'background' itself the effect may\nbe undone.  First delete the \"g:colors_name\" variable when needed.\n\nNormally this option would be set in the vimrc file.  Possibly\ndepending on the terminal name.  Example: >vim\n\tif $TERM ==# \"xterm\"\n\t  set background=dark\n\tendif\n<\tWhen this option is changed, the default settings for the highlight groups\nwill change.  To use other settings, place \":highlight\" commands AFTER\nthe setting of the 'background' option."}}, bh = {binding = "bh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'bufhidden' 'bh'\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nThis option specifies what happens when a buffer is no longer\ndisplayed in a window:\n  <empty>\tfollow the global 'hidden' option\n  hide\t\thide the buffer (don't unload it), even if 'hidden' is\n\t\tnot set\n  unload\tunload the buffer, even if 'hidden' is set; the\n\t\t|:hide| command will also unload the buffer\n  delete\tdelete the buffer from the buffer list, even if\n\t\t'hidden' is set; the |:hide| command will also delete\n\t\tthe buffer, making it behave like |:bdelete|\n  wipe\t\twipe the buffer from the buffer list, even if\n\t\t'hidden' is set; the |:hide| command will also wipe\n\t\tout the buffer, making it behave like |:bwipeout|\n\nCAREFUL: when \"unload\", \"delete\" or \"wipe\" is used changes in a buffer\nare lost without a warning.  Also, these values may break autocommands\nthat switch between buffers temporarily.\nThis option is used together with 'buftype' and 'swapfile' to specify\nspecial kinds of buffers.   See |special-buffers|."}}, bin = {binding = "bin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'binary' 'bin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nThis option should be set before editing a binary file.  You can also\nuse the |-b| Vim argument.  When this option is switched on a few\noptions will be changed (also when it already was on):\n\t'textwidth'  will be set to 0\n\t'wrapmargin' will be set to 0\n\t'modeline'   will be off\n\t'expandtab'  will be off\nAlso, 'fileformat' and 'fileformats' options will not be used, the\nfile is read and written like 'fileformat' was \"unix\" (a single <NL>\nseparates lines).\nThe 'fileencoding' and 'fileencodings' options will not be used, the\nfile is read without conversion.\nNOTE: When you start editing a(nother) file while the 'bin' option is\non, settings from autocommands may change the settings again (e.g.,\n'textwidth'), causing trouble when editing.  You might want to set\n'bin' again when the file has been loaded.\nThe previous values of these options are remembered and restored when\n'bin' is switched from on to off.  Each buffer has its own set of\nsaved option values.\nTo edit a file with 'binary' set you can use the |++bin| argument.\nThis avoids you have to do \":set bin\", which would have effect for all\nfiles you edit.\nWhen writing a file the <EOL> for the last line is only written if\nthere was one in the original file (normally Vim appends an <EOL> to\nthe last line if there is none; this would make the file longer).  See\nthe 'endofline' option."}}, binary = {binding = "binary", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'binary' 'bin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nThis option should be set before editing a binary file.  You can also\nuse the |-b| Vim argument.  When this option is switched on a few\noptions will be changed (also when it already was on):\n\t'textwidth'  will be set to 0\n\t'wrapmargin' will be set to 0\n\t'modeline'   will be off\n\t'expandtab'  will be off\nAlso, 'fileformat' and 'fileformats' options will not be used, the\nfile is read and written like 'fileformat' was \"unix\" (a single <NL>\nseparates lines).\nThe 'fileencoding' and 'fileencodings' options will not be used, the\nfile is read without conversion.\nNOTE: When you start editing a(nother) file while the 'bin' option is\non, settings from autocommands may change the settings again (e.g.,\n'textwidth'), causing trouble when editing.  You might want to set\n'bin' again when the file has been loaded.\nThe previous values of these options are remembered and restored when\n'bin' is switched from on to off.  Each buffer has its own set of\nsaved option values.\nTo edit a file with 'binary' set you can use the |++bin| argument.\nThis avoids you have to do \":set bin\", which would have effect for all\nfiles you edit.\nWhen writing a file the <EOL> for the last line is only written if\nthere was one in the original file (normally Vim appends an <EOL> to\nthe last line if there is none; this would make the file longer).  See\nthe 'endofline' option."}}, bk = {binding = "bk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backup' 'bk'\t\tboolean\t(default off)\n\t\tglobal\nMake a backup before overwriting a file.  Leave it around after the\nfile has been successfully written.  If you do not want to keep the\nbackup file, but you do want a backup while the file is being\nwritten, reset this option and set the 'writebackup' option (this is\nthe default).  If you do not want a backup file at all reset both\noptions (use this if your file system is almost full).  See the\n|backup-table| for more explanations.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nWhen 'patchmode' is set, the backup may be renamed to become the\noldest version of a file."}}, bkc = {binding = "bkc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupcopy' 'bkc'\tstring\t(default \"auto\")\n\t\tglobal or local to buffer |global-local|\nWhen writing a file and a backup is made, this option tells how it's\ndone.  This is a comma-separated list of words.\n\nThe main values are:\n\"yes\"\tmake a copy of the file and overwrite the original one\n\"no\"\trename the file and write a new one\n\"auto\"\tone of the previous, what works best\n\nExtra values that can be combined with the ones above are:\n\"breaksymlink\"\talways break symlinks when writing\n\"breakhardlink\"\talways break hardlinks when writing\n\nMaking a copy and overwriting the original file:\n- Takes extra time to copy the file.\n+ When the file has special attributes, is a (hard/symbolic) link or\n  has a resource fork, all this is preserved.\n- When the file is a link the backup will have the name of the link,\n  not of the real file.\n\nRenaming the file and writing a new one:\n+ It's fast.\n- Sometimes not all attributes of the file can be copied to the new\n  file.\n- When the file is a link the new file will not be a link.\n\nThe \"auto\" value is the middle way: When Vim sees that renaming the\nfile is possible without side effects (the attributes can be passed on\nand the file is not a link) that is used.  When problems are expected,\na copy will be made.\n\nThe \"breaksymlink\" and \"breakhardlink\" values can be used in\ncombination with any of \"yes\", \"no\" and \"auto\".  When included, they\nforce Vim to always break either symbolic or hard links by doing\nexactly what the \"no\" option does, renaming the original file to\nbecome the backup and writing a new file in its place.  This can be\nuseful for example in source trees where all the files are symbolic or\nhard links and any changes should stay in the local source tree, not\nbe propagated back to the original source.\n\t\t\t\t\t\t\t*crontab*\nOne situation where \"no\" and \"auto\" will cause problems: A program\nthat opens a file, invokes Vim to edit that file, and then tests if\nthe open file was changed (through the file descriptor) will check the\nbackup file instead of the newly created file.  \"crontab -e\" is an\nexample, as are several |file-watcher| daemons like inotify.  In that\ncase you probably want to switch this option.\n\nWhen a copy is made, the original file is truncated and then filled\nwith the new text.  This means that protection bits, owner and\nsymbolic links of the original file are unmodified.  The backup file,\nhowever, is a new file, owned by the user who edited the file.  The\ngroup of the backup is set to the group of the original file.  If this\nfails, the protection bits for the group are made the same as for\nothers.\n\nWhen the file is renamed, this is the other way around: The backup has\nthe same attributes of the original file, and the newly written file\nis owned by the current user.  When the file was a (hard/symbolic)\nlink, the new file will not!  That's why the \"auto\" value doesn't\nrename when the file is a link.  The owner and group of the newly\nwritten file will be set to the same ones as the original file, but\nthe system may refuse to do this.  In that case the \"auto\" value will\nagain not rename the file."}}, bl = {binding = "bl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'buflisted' 'bl'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen this option is set, the buffer shows up in the buffer list.  If\nit is reset it is not used for \":bnext\", \"ls\", the Buffers menu, etc.\nThis option is reset by Vim for buffers that are only used to remember\na file name or marks.  Vim sets it when starting to edit a buffer.\nBut not when moving to a buffer with \":buffer\"."}}, bo = {binding = "bo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'belloff' 'bo'\t\tstring\t(default \"all\")\n\t\tglobal\nSpecifies for which events the bell will not be rung. It is a comma-\nseparated list of items. For each item that is present, the bell\nwill be silenced. This is most useful to specify specific events in\ninsert mode to be silenced.\nYou can also make it flash by using 'visualbell'.\n\nitem\t    meaning when present\t~\nall\t    All events.\nbackspace   When hitting <BS> or <Del> and deleting results in an\n\t    error.\ncursor\t    Fail to move around using the cursor keys or\n\t    <PageUp>/<PageDown> in |Insert-mode|.\ncomplete    Error occurred when using |i_CTRL-X_CTRL-K| or\n\t    |i_CTRL-X_CTRL-T|.\ncopy\t    Cannot copy char from insert mode using |i_CTRL-Y| or\n\t    |i_CTRL-E|.\nctrlg\t    Unknown Char after <C-G> in Insert mode.\nerror\t    Other Error occurred (e.g. try to join last line)\n\t    (mostly used in |Normal-mode| or |Cmdline-mode|).\nesc\t    hitting <Esc> in |Normal-mode|.\nhangul\t    Ignored.\nlang\t    Calling the beep module for Lua/Mzscheme/TCL.\nmess\t    No output available for |g<|.\nshowmatch   Error occurred for 'showmatch' function.\noperator    Empty region error |cpo-E|.\nregister    Unknown register after <C-R> in |Insert-mode|.\nshell\t    Bell from shell output |:!|.\nspell\t    Error happened on spell suggest.\nterm\t    Bell from |:terminal| output.\nwildmode    More matches in |cmdline-completion| available\n\t    (depends on the 'wildmode' setting).\n\nThis is most useful to fine tune when in Insert mode the bell should\nbe rung. For Normal mode and Ex commands, the bell is often rung to\nindicate that an error occurred. It can be silenced by adding the\n\"error\" keyword."}}, bomb = {binding = "bomb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'bomb'\t\t\tboolean\t(default off)\n\t\tlocal to buffer\nWhen writing a file and the following conditions are met, a BOM (Byte\nOrder Mark) is prepended to the file:\n- this option is on\n- the 'binary' option is off\n- 'fileencoding' is \"utf-8\", \"ucs-2\", \"ucs-4\" or one of the little/big\n  endian variants.\nSome applications use the BOM to recognize the encoding of the file.\nOften used for UCS-2 files on MS-Windows.  For other applications it\ncauses trouble, for example: \"cat file1 file2\" makes the BOM of file2\nappear halfway through the resulting file.  Gcc doesn't accept a BOM.\nWhen Vim reads a file and 'fileencodings' starts with \"ucs-bom\", a\ncheck for the presence of the BOM is done and 'bomb' set accordingly.\nUnless 'binary' is set, it is removed from the first line, so that you\ndon't see it when editing.  When you don't change the options, the BOM\nwill be restored when writing the file."}}, breakat = {binding = "breakat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakat' 'brk'\t\tstring\t(default \" ^I!@*-+;:,./?\")\n\t\tglobal\nThis option lets you choose which characters might cause a line\nbreak if 'linebreak' is on.  Only works for ASCII characters."}}, breakindent = {binding = "breakindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakindent' 'bri'\tboolean\t(default off)\n\t\tlocal to window\nEvery wrapped line will continue visually indented (same amount of\nspace as the beginning of that line), thus preserving horizontal blocks\nof text."}}, breakindentopt = {binding = "breakindentopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakindentopt' 'briopt'\tstring\t(default \"\")\n\t\tlocal to window\nSettings for 'breakindent'. It can consist of the following optional\nitems and must be separated by a comma:\n\tmin:{n}\t    Minimum text width that will be kept after\n\t\t    applying 'breakindent', even if the resulting\n\t\t    text should normally be narrower. This prevents\n\t\t    text indented almost to the right window border\n\t\t    occupying lots of vertical space when broken.\n\t\t    (default: 20)\n\tshift:{n}   After applying 'breakindent', the wrapped line's\n\t\t    beginning will be shifted by the given number of\n\t\t    characters.  It permits dynamic French paragraph\n\t\t    indentation (negative) or emphasizing the line\n\t\t    continuation (positive).\n\t\t    (default: 0)\n\tsbr\t    Display the 'showbreak' value before applying the\n\t\t    additional indent.\n\t\t    (default: off)\n\tlist:{n}    Adds an additional indent for lines that match a\n\t\t    numbered or bulleted list (using the\n\t\t    'formatlistpat' setting).\n\t\t    (default: 0)\n\tlist:-1\t    Uses the width of a match with 'formatlistpat' for\n\t\t    indentation.\n\tcolumn:{n}  Indent at column {n}. Will overrule the other\n\t\t    sub-options. Note: an additional indent may be\n\t\t    added for the 'showbreak' setting.\n\t\t    (default: off)"}}, bri = {binding = "bri", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakindent' 'bri'\tboolean\t(default off)\n\t\tlocal to window\nEvery wrapped line will continue visually indented (same amount of\nspace as the beginning of that line), thus preserving horizontal blocks\nof text."}}, briopt = {binding = "briopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakindentopt' 'briopt'\tstring\t(default \"\")\n\t\tlocal to window\nSettings for 'breakindent'. It can consist of the following optional\nitems and must be separated by a comma:\n\tmin:{n}\t    Minimum text width that will be kept after\n\t\t    applying 'breakindent', even if the resulting\n\t\t    text should normally be narrower. This prevents\n\t\t    text indented almost to the right window border\n\t\t    occupying lots of vertical space when broken.\n\t\t    (default: 20)\n\tshift:{n}   After applying 'breakindent', the wrapped line's\n\t\t    beginning will be shifted by the given number of\n\t\t    characters.  It permits dynamic French paragraph\n\t\t    indentation (negative) or emphasizing the line\n\t\t    continuation (positive).\n\t\t    (default: 0)\n\tsbr\t    Display the 'showbreak' value before applying the\n\t\t    additional indent.\n\t\t    (default: off)\n\tlist:{n}    Adds an additional indent for lines that match a\n\t\t    numbered or bulleted list (using the\n\t\t    'formatlistpat' setting).\n\t\t    (default: 0)\n\tlist:-1\t    Uses the width of a match with 'formatlistpat' for\n\t\t    indentation.\n\tcolumn:{n}  Indent at column {n}. Will overrule the other\n\t\t    sub-options. Note: an additional indent may be\n\t\t    added for the 'showbreak' setting.\n\t\t    (default: off)"}}, brk = {binding = "brk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakat' 'brk'\t\tstring\t(default \" ^I!@*-+;:,./?\")\n\t\tglobal\nThis option lets you choose which characters might cause a line\nbreak if 'linebreak' is on.  Only works for ASCII characters."}}, bs = {binding = "bs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backspace' 'bs'\tstring\t(default \"indent,eol,start\")\n\t\tglobal\nInfluences the working of <BS>, <Del>, CTRL-W and CTRL-U in Insert\nmode.  This is a list of items, separated by commas.  Each item allows\na way to backspace over something:\nvalue\teffect\t~\nindent\tallow backspacing over autoindent\neol\tallow backspacing over line breaks (join lines)\nstart\tallow backspacing over the start of insert; CTRL-W and CTRL-U\n\tstop once at the start of insert.\nnostop\tlike start, except CTRL-W and CTRL-U do not stop at the start of\n\tinsert.\n\nWhen the value is empty, Vi compatible backspacing is used, none of\nthe ways mentioned for the items above are possible."}}, bsk = {binding = "bsk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backupskip' 'bsk'\tstring\t(default \"$TMPDIR/*,$TMP/*,$TEMP/*\"\n                                 Unix: \"/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*\"\n                                 Mac: \"/private/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*\")\n\t\tglobal\nA list of file patterns.  When one of the patterns matches with the\nname of the file which is written, no backup file is created.  Both\nthe specified file name and the full path name of the file are used.\nThe pattern is used like with |:autocmd|, see |autocmd-pattern|.\nWatch out for special characters, see |option-backslash|.\nWhen $TMPDIR, $TMP or $TEMP is not defined, it is not used for the\ndefault value.  \"/tmp/*\" is only used for Unix.\n\nWARNING: Not having a backup file means that when Vim fails to write\nyour buffer correctly and then, for whatever reason, Vim exits, you\nlose both the original file and what you were writing.  Only disable\nbackups if you don't care about losing the file.\n\nNote that environment variables are not expanded.  If you want to use\n$HOME you must expand it explicitly, e.g.: >vim\n\tlet &backupskip = escape(expand('$HOME'), '\\') .. '/tmp/*'\n\n<\tNote that the default also makes sure that \"crontab -e\" works (when a\nbackup would be made by renaming the original file crontab won't see\nthe newly created file).  Also see 'backupcopy' and |crontab|."}}, bt = {binding = "bt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'buftype' 'bt'\t\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nThe value of this option specifies the type of a buffer:\n  <empty>\tnormal buffer\n  acwrite\tbuffer will always be written with |BufWriteCmd|s\n  help\t\thelp buffer (do not set this manually)\n  nofile\tbuffer is not related to a file, will not be written\n  nowrite\tbuffer will not be written\n  quickfix\tlist of errors |:cwindow| or locations |:lwindow|\n  terminal\t|terminal-emulator| buffer\n  prompt\tbuffer where only the last line can be edited, meant\n\t\tto be used by a plugin, see |prompt-buffer|\n\nThis option is used together with 'bufhidden' and 'swapfile' to\nspecify special kinds of buffers.   See |special-buffers|.\nAlso see |win_gettype()|, which returns the type of the window.\n\nBe careful with changing this option, it can have many side effects!\nOne such effect is that Vim will not check the timestamp of the file,\nif the file is changed by another program this will not be noticed.\n\nA \"quickfix\" buffer is only used for the error list and the location\nlist.  This value is set by the |:cwindow| and |:lwindow| commands and\nyou are not supposed to change it.\n\n\"nofile\" and \"nowrite\" buffers are similar:\nboth:\t\tThe buffer is not to be written to disk, \":w\" doesn't\n\t\twork (\":w filename\" does work though).\nboth:\t\tThe buffer is never considered to be |'modified'|.\n\t\tThere is no warning when the changes will be lost, for\n\t\texample when you quit Vim.\nboth:\t\tA swap file is only created when using too much memory\n\t\t(when 'swapfile' has been reset there is never a swap\n\t\tfile).\nnofile only:\tThe buffer name is fixed, it is not handled like a\n\t\tfile name.  It is not modified in response to a |:cd|\n\t\tcommand.\nboth:\t\tWhen using \":e bufname\" and already editing \"bufname\"\n\t\tthe buffer is made empty and autocommands are\n\t\ttriggered as usual for |:edit|.\n\t\t\t\t\t\t*E676*\n\"acwrite\" implies that the buffer name is not related to a file, like\n\"nofile\", but it will be written.  Thus, in contrast to \"nofile\" and\n\"nowrite\", \":w\" does work and a modified buffer can't be abandoned\nwithout saving.  For writing there must be matching |BufWriteCmd|,\n|FileWriteCmd| or |FileAppendCmd| autocommands."}}, bufhidden = {binding = "bufhidden", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'bufhidden' 'bh'\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nThis option specifies what happens when a buffer is no longer\ndisplayed in a window:\n  <empty>\tfollow the global 'hidden' option\n  hide\t\thide the buffer (don't unload it), even if 'hidden' is\n\t\tnot set\n  unload\tunload the buffer, even if 'hidden' is set; the\n\t\t|:hide| command will also unload the buffer\n  delete\tdelete the buffer from the buffer list, even if\n\t\t'hidden' is set; the |:hide| command will also delete\n\t\tthe buffer, making it behave like |:bdelete|\n  wipe\t\twipe the buffer from the buffer list, even if\n\t\t'hidden' is set; the |:hide| command will also wipe\n\t\tout the buffer, making it behave like |:bwipeout|\n\nCAREFUL: when \"unload\", \"delete\" or \"wipe\" is used changes in a buffer\nare lost without a warning.  Also, these values may break autocommands\nthat switch between buffers temporarily.\nThis option is used together with 'buftype' and 'swapfile' to specify\nspecial kinds of buffers.   See |special-buffers|."}}, buflisted = {binding = "buflisted", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'buflisted' 'bl'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen this option is set, the buffer shows up in the buffer list.  If\nit is reset it is not used for \":bnext\", \"ls\", the Buffers menu, etc.\nThis option is reset by Vim for buffers that are only used to remember\na file name or marks.  Vim sets it when starting to edit a buffer.\nBut not when moving to a buffer with \":buffer\"."}}, buftype = {binding = "buftype", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'buftype' 'bt'\t\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nThe value of this option specifies the type of a buffer:\n  <empty>\tnormal buffer\n  acwrite\tbuffer will always be written with |BufWriteCmd|s\n  help\t\thelp buffer (do not set this manually)\n  nofile\tbuffer is not related to a file, will not be written\n  nowrite\tbuffer will not be written\n  quickfix\tlist of errors |:cwindow| or locations |:lwindow|\n  terminal\t|terminal-emulator| buffer\n  prompt\tbuffer where only the last line can be edited, meant\n\t\tto be used by a plugin, see |prompt-buffer|\n\nThis option is used together with 'bufhidden' and 'swapfile' to\nspecify special kinds of buffers.   See |special-buffers|.\nAlso see |win_gettype()|, which returns the type of the window.\n\nBe careful with changing this option, it can have many side effects!\nOne such effect is that Vim will not check the timestamp of the file,\nif the file is changed by another program this will not be noticed.\n\nA \"quickfix\" buffer is only used for the error list and the location\nlist.  This value is set by the |:cwindow| and |:lwindow| commands and\nyou are not supposed to change it.\n\n\"nofile\" and \"nowrite\" buffers are similar:\nboth:\t\tThe buffer is not to be written to disk, \":w\" doesn't\n\t\twork (\":w filename\" does work though).\nboth:\t\tThe buffer is never considered to be |'modified'|.\n\t\tThere is no warning when the changes will be lost, for\n\t\texample when you quit Vim.\nboth:\t\tA swap file is only created when using too much memory\n\t\t(when 'swapfile' has been reset there is never a swap\n\t\tfile).\nnofile only:\tThe buffer name is fixed, it is not handled like a\n\t\tfile name.  It is not modified in response to a |:cd|\n\t\tcommand.\nboth:\t\tWhen using \":e bufname\" and already editing \"bufname\"\n\t\tthe buffer is made empty and autocommands are\n\t\ttriggered as usual for |:edit|.\n\t\t\t\t\t\t*E676*\n\"acwrite\" implies that the buffer name is not related to a file, like\n\"nofile\", but it will be written.  Thus, in contrast to \"nofile\" and\n\"nowrite\", \":w\" does work and a modified buffer can't be abandoned\nwithout saving.  For writing there must be matching |BufWriteCmd|,\n|FileWriteCmd| or |FileAppendCmd| autocommands."}}, casemap = {binding = "casemap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'casemap' 'cmp'\t\tstring\t(default \"internal,keepascii\")\n\t\tglobal\nSpecifies details about changing the case of letters.  It may contain\nthese words, separated by a comma:\ninternal\tUse internal case mapping functions, the current\n\t\tlocale does not change the case mapping. When\n\t\t\"internal\" is omitted, the towupper() and towlower()\n\t\tsystem library functions are used when available.\nkeepascii\tFor the ASCII characters (0x00 to 0x7f) use the US\n\t\tcase mapping, the current locale is not effective.\n\t\tThis probably only matters for Turkish."}}, cb = {binding = "cb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'clipboard' 'cb'\tstring\t(default \"\")\n\t\tglobal\nThis option is a list of comma-separated names.\nThese names are recognized:\n\n\t\t\t\t\t*clipboard-unnamed*\nunnamed\t\tWhen included, Vim will use the clipboard register \"*\"\n\t\tfor all yank, delete, change and put operations which\n\t\twould normally go to the unnamed register.  When a\n\t\tregister is explicitly specified, it will always be\n\t\tused regardless of whether \"unnamed\" is in 'clipboard'\n\t\tor not.  The clipboard register can always be\n\t\texplicitly accessed using the \"* notation.  Also see\n\t\t|clipboard|.\n\n\t\t\t\t\t*clipboard-unnamedplus*\nunnamedplus\tA variant of the \"unnamed\" flag which uses the\n\t\tclipboard register \"+\" (|quoteplus|) instead of\n\t\tregister \"*\" for all yank, delete, change and put\n\t\toperations which would normally go to the unnamed\n\t\tregister.  When \"unnamed\" is also included to the\n\t\toption, yank and delete operations (but not put)\n\t\twill additionally copy the text into register\n\t\t\"*\". See |clipboard|."}}, cc = {binding = "cc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'colorcolumn' 'cc'\tstring\t(default \"\")\n\t\tlocal to window\n'colorcolumn' is a comma-separated list of screen columns that are\nhighlighted with ColorColumn |hl-ColorColumn|.  Useful to align\ntext.  Will make screen redrawing slower.\nThe screen column can be an absolute number, or a number preceded with\n'+' or '-', which is added to or subtracted from 'textwidth'. >vim\n\n\tset cc=+1\t  \" highlight column after 'textwidth'\n\tset cc=+1,+2,+3  \" highlight three columns after 'textwidth'\n\thi ColorColumn ctermbg=lightgrey guibg=lightgrey\n<\nWhen 'textwidth' is zero then the items with '-' and '+' are not used.\nA maximum of 256 columns are highlighted."}}, ccv = {binding = "ccv", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'charconvert' 'ccv'\tstring\t(default \"\")\n\t\tglobal\nAn expression that is used for character encoding conversion.  It is\nevaluated when a file that is to be read or has been written has a\ndifferent encoding from what is desired.\n'charconvert' is not used when the internal iconv() function is\nsupported and is able to do the conversion.  Using iconv() is\npreferred, because it is much faster.\n'charconvert' is not used when reading stdin |--|, because there is no\nfile to convert from.  You will have to save the text in a file first.\nThe expression must return zero, false or an empty string for success,\nnon-zero or true for failure.\nSee |encoding-names| for possible encoding names.\nAdditionally, names given in 'fileencodings' and 'fileencoding' are\nused.\nConversion between \"latin1\", \"unicode\", \"ucs-2\", \"ucs-4\" and \"utf-8\"\nis done internally by Vim, 'charconvert' is not used for this.\nAlso used for Unicode conversion.\nExample: >vim\n\tset charconvert=CharConvert()\n\tfun CharConvert()\n\t  system(\"recode \"\n\t\t\\ .. v:charconvert_from .. \"..\" .. v:charconvert_to\n\t\t\\ .. \" <\" .. v:fname_in .. \" >\" .. v:fname_out)\n\t  return v:shell_error\n\tendfun\n<\tThe related Vim variables are:\n\tv:charconvert_from\tname of the current encoding\n\tv:charconvert_to\tname of the desired encoding\n\tv:fname_in\t\tname of the input file\n\tv:fname_out\t\tname of the output file\nNote that v:fname_in and v:fname_out will never be the same.\n\nThe advantage of using a function call without arguments is that it is\nfaster, see |expr-option-function|.\n\nIf the 'charconvert' expression starts with s: or |<SID>|, then it is\nreplaced with the script ID (|local-function|). Example: >vim\n\tset charconvert=s:MyConvert()\n\tset charconvert=<SID>SomeConvert()\n<\tOtherwise the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, cd = {binding = "cd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cdpath' 'cd'\t\tstring\t(default equivalent to $CDPATH or \",,\")\n\t\tglobal\nThis is a list of directories which will be searched when using the\n|:cd|, |:tcd| and |:lcd| commands, provided that the directory being\nsearched for has a relative path, not an absolute part starting with\n\"/\", \"./\" or \"../\", the 'cdpath' option is not used then.\nThe 'cdpath' option's value has the same form and semantics as\n|'path'|.  Also see |file-searching|.\nThe default value is taken from $CDPATH, with a \",\" prepended to look\nin the current directory first.\nIf the default value taken from $CDPATH is not what you want, include\na modified version of the following command in your vimrc file to\noverride it: >vim\n  let &cdpath = ',' .. substitute(substitute($CDPATH, '[, ]', '\\\\\\0', 'g'), ':', ',', 'g')\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n(parts of 'cdpath' can be passed to the shell to expand file names)."}}, cdh = {binding = "cdh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cdhome' 'cdh'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, |:cd|, |:tcd| and |:lcd| without an argument changes the\ncurrent working directory to the |$HOME| directory like in Unix.\nWhen off, those commands just print the current directory name.\nOn Unix this option has no effect.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, cdhome = {binding = "cdhome", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cdhome' 'cdh'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, |:cd|, |:tcd| and |:lcd| without an argument changes the\ncurrent working directory to the |$HOME| directory like in Unix.\nWhen off, those commands just print the current directory name.\nOn Unix this option has no effect.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, cdpath = {binding = "cdpath", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cdpath' 'cd'\t\tstring\t(default equivalent to $CDPATH or \",,\")\n\t\tglobal\nThis is a list of directories which will be searched when using the\n|:cd|, |:tcd| and |:lcd| commands, provided that the directory being\nsearched for has a relative path, not an absolute part starting with\n\"/\", \"./\" or \"../\", the 'cdpath' option is not used then.\nThe 'cdpath' option's value has the same form and semantics as\n|'path'|.  Also see |file-searching|.\nThe default value is taken from $CDPATH, with a \",\" prepended to look\nin the current directory first.\nIf the default value taken from $CDPATH is not what you want, include\na modified version of the following command in your vimrc file to\noverride it: >vim\n  let &cdpath = ',' .. substitute(substitute($CDPATH, '[, ]', '\\\\\\0', 'g'), ':', ',', 'g')\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n(parts of 'cdpath' can be passed to the shell to expand file names)."}}, cedit = {binding = "cedit", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cedit'\t\t\tstring\t(default CTRL-F)\n\t\tglobal\nThe key used in Command-line Mode to open the command-line window.\nOnly non-printable keys are allowed.\nThe key can be specified as a single character, but it is difficult to\ntype.  The preferred way is to use |key-notation| (e.g. <Up>, <C-F>) or\na letter preceded with a caret (e.g. `^F` is CTRL-F).  Examples: >vim\n\tset cedit=^Y\n\tset cedit=<Esc>\n<\t|Nvi| also has this option, but it only uses the first character.\nSee |cmdwin|."}}, cf = {binding = "cf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'confirm' 'cf'\t\tboolean\t(default off)\n\t\tglobal\nWhen 'confirm' is on, certain operations that would normally\nfail because of unsaved changes to a buffer, e.g. \":q\" and \":e\",\ninstead raise a dialog asking if you wish to save the current\nfile(s).  You can still use a ! to unconditionally |abandon| a buffer.\nIf 'confirm' is off you can still activate confirmation for one\ncommand only (this is most useful in mappings) with the |:confirm|\ncommand.\nAlso see the |confirm()| function and the 'v' flag in 'guioptions'."}}, cfu = {binding = "cfu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completefunc' 'cfu'\tstring\t(default \"\")\n\t\tlocal to buffer\nThis option specifies a function to be used for Insert mode completion\nwith CTRL-X CTRL-U. |i_CTRL-X_CTRL-U|\nSee |complete-functions| for an explanation of how the function is\ninvoked and what it should return.  The value can be the name of a\nfunction, a |lambda| or a |Funcref|. See |option-value-function| for\nmore information.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ch = {binding = "ch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cmdheight' 'ch'\tnumber\t(default 1)\n\t\tglobal or local to tab page\nNumber of screen lines to use for the command-line.  Helps avoiding\n|hit-enter| prompts.\nThe value of this option is stored with the tab page, so that each tab\npage can have a different value.\n\nWhen 'cmdheight' is zero, there is no command-line unless it is being\nused.  The command-line will cover the last line of the screen when\nshown.\n\nWARNING: `cmdheight=0` is EXPERIMENTAL. Expect some unwanted behaviour.\nSome 'shortmess' flags and similar mechanism might fail to take effect,\ncausing unwanted hit-enter prompts.  Some informative messages, both\nfrom Nvim itself and plugins, will not be displayed."}}, channel = {binding = "channel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'channel'\t\tnumber\t(default 0)\n\t\tlocal to buffer\n|channel| connected to the buffer, or 0 if no channel is connected.\nIn a |:terminal| buffer this is the terminal channel.\nRead-only."}}, charconvert = {binding = "charconvert", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'charconvert' 'ccv'\tstring\t(default \"\")\n\t\tglobal\nAn expression that is used for character encoding conversion.  It is\nevaluated when a file that is to be read or has been written has a\ndifferent encoding from what is desired.\n'charconvert' is not used when the internal iconv() function is\nsupported and is able to do the conversion.  Using iconv() is\npreferred, because it is much faster.\n'charconvert' is not used when reading stdin |--|, because there is no\nfile to convert from.  You will have to save the text in a file first.\nThe expression must return zero, false or an empty string for success,\nnon-zero or true for failure.\nSee |encoding-names| for possible encoding names.\nAdditionally, names given in 'fileencodings' and 'fileencoding' are\nused.\nConversion between \"latin1\", \"unicode\", \"ucs-2\", \"ucs-4\" and \"utf-8\"\nis done internally by Vim, 'charconvert' is not used for this.\nAlso used for Unicode conversion.\nExample: >vim\n\tset charconvert=CharConvert()\n\tfun CharConvert()\n\t  system(\"recode \"\n\t\t\\ .. v:charconvert_from .. \"..\" .. v:charconvert_to\n\t\t\\ .. \" <\" .. v:fname_in .. \" >\" .. v:fname_out)\n\t  return v:shell_error\n\tendfun\n<\tThe related Vim variables are:\n\tv:charconvert_from\tname of the current encoding\n\tv:charconvert_to\tname of the desired encoding\n\tv:fname_in\t\tname of the input file\n\tv:fname_out\t\tname of the output file\nNote that v:fname_in and v:fname_out will never be the same.\n\nThe advantage of using a function call without arguments is that it is\nfaster, see |expr-option-function|.\n\nIf the 'charconvert' expression starts with s: or |<SID>|, then it is\nreplaced with the script ID (|local-function|). Example: >vim\n\tset charconvert=s:MyConvert()\n\tset charconvert=<SID>SomeConvert()\n<\tOtherwise the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ci = {binding = "ci", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'copyindent' 'ci'\tboolean\t(default off)\n\t\tlocal to buffer\nCopy the structure of the existing lines indent when autoindenting a\nnew line.  Normally the new indent is reconstructed by a series of\ntabs followed by spaces as required (unless |'expandtab'| is enabled,\nin which case only spaces are used).  Enabling this option makes the\nnew line copy whatever characters were used for indenting on the\nexisting line.  'expandtab' has no effect on these characters, a Tab\nremains a Tab.  If the new indent is greater than on the existing\nline, the remaining space is filled in the normal manner.\nSee 'preserveindent'."}}, cia = {binding = "cia", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completeitemalign' 'cia'\tstring\t(default \"abbr,kind,menu\")\n\t\tglobal\nA comma-separated list of strings that controls the alignment and\ndisplay order of items in the popup menu during Insert mode\ncompletion.  The supported values are \"abbr\", \"kind\", and \"menu\".\nThese values allow customizing how |complete-items| are shown in the\npopup menu.  Note: must always contain those three values in any\norder."}}, cin = {binding = "cin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cindent' 'cin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nEnables automatic C program indenting.  See 'cinkeys' to set the keys\nthat trigger reindenting in insert mode and 'cinoptions' to set your\npreferred indent style.\nIf 'indentexpr' is not empty, it overrules 'cindent'.\nIf 'lisp' is not on and both 'indentexpr' and 'equalprg' are empty,\nthe \"=\" operator indents using this algorithm rather than calling an\nexternal program.\nSee |C-indenting|.\nWhen you don't like the way 'cindent' works, try the 'smartindent'\noption or 'indentexpr'."}}, cindent = {binding = "cindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cindent' 'cin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nEnables automatic C program indenting.  See 'cinkeys' to set the keys\nthat trigger reindenting in insert mode and 'cinoptions' to set your\npreferred indent style.\nIf 'indentexpr' is not empty, it overrules 'cindent'.\nIf 'lisp' is not on and both 'indentexpr' and 'equalprg' are empty,\nthe \"=\" operator indents using this algorithm rather than calling an\nexternal program.\nSee |C-indenting|.\nWhen you don't like the way 'cindent' works, try the 'smartindent'\noption or 'indentexpr'."}}, cink = {binding = "cink", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinkeys' 'cink'\tstring\t(default \"0{,0},0),0],:,0#,!^F,o,O,e\")\n\t\tlocal to buffer\nA list of keys that, when typed in Insert mode, cause reindenting of\nthe current line.  Only used if 'cindent' is on and 'indentexpr' is\nempty.\nFor the format of this option see |cinkeys-format|.\nSee |C-indenting|."}}, cinkeys = {binding = "cinkeys", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinkeys' 'cink'\tstring\t(default \"0{,0},0),0],:,0#,!^F,o,O,e\")\n\t\tlocal to buffer\nA list of keys that, when typed in Insert mode, cause reindenting of\nthe current line.  Only used if 'cindent' is on and 'indentexpr' is\nempty.\nFor the format of this option see |cinkeys-format|.\nSee |C-indenting|."}}, cino = {binding = "cino", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinoptions' 'cino'\tstring\t(default \"\")\n\t\tlocal to buffer\nThe 'cinoptions' affect the way 'cindent' reindents lines in a C\nprogram.  See |cinoptions-values| for the values of this option, and\n|C-indenting| for info on C indenting in general."}}, cinoptions = {binding = "cinoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinoptions' 'cino'\tstring\t(default \"\")\n\t\tlocal to buffer\nThe 'cinoptions' affect the way 'cindent' reindents lines in a C\nprogram.  See |cinoptions-values| for the values of this option, and\n|C-indenting| for info on C indenting in general."}}, cinscopedecls = {binding = "cinscopedecls", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinscopedecls' 'cinsd'\tstring\t(default \"public,protected,private\")\n\t\tlocal to buffer\nKeywords that are interpreted as a C++ scope declaration by |cino-g|.\nUseful e.g. for working with the Qt framework that defines additional\nscope declarations \"signals\", \"public slots\" and \"private slots\": >vim\n\tset cinscopedecls+=signals,public\\ slots,private\\ slots\n<"}}, cinsd = {binding = "cinsd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinscopedecls' 'cinsd'\tstring\t(default \"public,protected,private\")\n\t\tlocal to buffer\nKeywords that are interpreted as a C++ scope declaration by |cino-g|.\nUseful e.g. for working with the Qt framework that defines additional\nscope declarations \"signals\", \"public slots\" and \"private slots\": >vim\n\tset cinscopedecls+=signals,public\\ slots,private\\ slots\n<"}}, cinw = {binding = "cinw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinwords' 'cinw'\tstring\t(default \"if,else,while,do,for,switch\")\n\t\tlocal to buffer\nThese keywords start an extra indent in the next line when\n'smartindent' or 'cindent' is set.  For 'cindent' this is only done at\nan appropriate place (inside {}).\nNote that 'ignorecase' isn't used for 'cinwords'.  If case doesn't\nmatter, include the keyword both the uppercase and lowercase:\n\"if,If,IF\"."}}, cinwords = {binding = "cinwords", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cinwords' 'cinw'\tstring\t(default \"if,else,while,do,for,switch\")\n\t\tlocal to buffer\nThese keywords start an extra indent in the next line when\n'smartindent' or 'cindent' is set.  For 'cindent' this is only done at\nan appropriate place (inside {}).\nNote that 'ignorecase' isn't used for 'cinwords'.  If case doesn't\nmatter, include the keyword both the uppercase and lowercase:\n\"if,If,IF\"."}}, clipboard = {binding = "clipboard", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'clipboard' 'cb'\tstring\t(default \"\")\n\t\tglobal\nThis option is a list of comma-separated names.\nThese names are recognized:\n\n\t\t\t\t\t*clipboard-unnamed*\nunnamed\t\tWhen included, Vim will use the clipboard register \"*\"\n\t\tfor all yank, delete, change and put operations which\n\t\twould normally go to the unnamed register.  When a\n\t\tregister is explicitly specified, it will always be\n\t\tused regardless of whether \"unnamed\" is in 'clipboard'\n\t\tor not.  The clipboard register can always be\n\t\texplicitly accessed using the \"* notation.  Also see\n\t\t|clipboard|.\n\n\t\t\t\t\t*clipboard-unnamedplus*\nunnamedplus\tA variant of the \"unnamed\" flag which uses the\n\t\tclipboard register \"+\" (|quoteplus|) instead of\n\t\tregister \"*\" for all yank, delete, change and put\n\t\toperations which would normally go to the unnamed\n\t\tregister.  When \"unnamed\" is also included to the\n\t\toption, yank and delete operations (but not put)\n\t\twill additionally copy the text into register\n\t\t\"*\". See |clipboard|."}}, cmdheight = {binding = "cmdheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cmdheight' 'ch'\tnumber\t(default 1)\n\t\tglobal or local to tab page\nNumber of screen lines to use for the command-line.  Helps avoiding\n|hit-enter| prompts.\nThe value of this option is stored with the tab page, so that each tab\npage can have a different value.\n\nWhen 'cmdheight' is zero, there is no command-line unless it is being\nused.  The command-line will cover the last line of the screen when\nshown.\n\nWARNING: `cmdheight=0` is EXPERIMENTAL. Expect some unwanted behaviour.\nSome 'shortmess' flags and similar mechanism might fail to take effect,\ncausing unwanted hit-enter prompts.  Some informative messages, both\nfrom Nvim itself and plugins, will not be displayed."}}, cmdwinheight = {binding = "cmdwinheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cmdwinheight' 'cwh'\tnumber\t(default 7)\n\t\tglobal\nNumber of screen lines to use for the command-line window. |cmdwin|"}}, cmp = {binding = "cmp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'casemap' 'cmp'\t\tstring\t(default \"internal,keepascii\")\n\t\tglobal\nSpecifies details about changing the case of letters.  It may contain\nthese words, separated by a comma:\ninternal\tUse internal case mapping functions, the current\n\t\tlocale does not change the case mapping. When\n\t\t\"internal\" is omitted, the towupper() and towlower()\n\t\tsystem library functions are used when available.\nkeepascii\tFor the ASCII characters (0x00 to 0x7f) use the US\n\t\tcase mapping, the current locale is not effective.\n\t\tThis probably only matters for Turkish."}}, cms = {binding = "cms", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'commentstring' 'cms'\tstring\t(default \"\")\n\t\tlocal to buffer\nA template for a comment.  The \"%s\" in the value is replaced with the\ncomment text, and should be padded with a space when possible.\nUsed for |commenting| and to add markers for folding, see |fold-marker|."}}, co = {binding = "co", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'columns' 'co'\t\tnumber\t(default 80 or terminal width)\n\t\tglobal\nNumber of columns of the screen.  Normally this is set by the terminal\ninitialization and does not have to be set by hand.\nWhen Vim is running in the GUI or in a resizable window, setting this\noption will cause the window size to be changed.  When you only want\nto use the size for the GUI, put the command in your |ginit.vim| file.\nWhen you set this option and Vim is unable to change the physical\nnumber of columns of the display, the display may be messed up.  For\nthe GUI it is always possible and Vim limits the number of columns to\nwhat fits on the screen.  You can use this command to get the widest\nwindow possible: >vim\n\tset columns=9999\n<\tMinimum value is 12, maximum value is 10000."}}, cocu = {binding = "cocu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'concealcursor' 'cocu'\tstring\t(default \"\")\n\t\tlocal to window\nSets the modes in which text in the cursor line can also be concealed.\nWhen the current mode is listed then concealing happens just like in\nother lines.\n  n\t\tNormal mode\n  v\t\tVisual mode\n  i\t\tInsert mode\n  c\t\tCommand line editing, for 'incsearch'\n\n'v' applies to all lines in the Visual area, not only the cursor.\nA useful value is \"nc\".  This is used in help files.  So long as you\nare moving around text is concealed, but when starting to insert text\nor selecting a Visual area the concealed text is displayed, so that\nyou can see what you are doing.\nKeep in mind that the cursor position is not always where it's\ndisplayed.  E.g., when moving vertically it may change column."}}, cole = {binding = "cole", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'conceallevel' 'cole'\tnumber\t(default 0)\n\t\tlocal to window\nDetermine how text with the \"conceal\" syntax attribute |:syn-conceal|\nis shown:\n\nValue\t\tEffect ~\n0\t\tText is shown normally\n1\t\tEach block of concealed text is replaced with one\n\t\tcharacter.  If the syntax item does not have a custom\n\t\treplacement character defined (see |:syn-cchar|) the\n\t\tcharacter defined in 'listchars' is used.\n\t\tIt is highlighted with the \"Conceal\" highlight group.\n2\t\tConcealed text is completely hidden unless it has a\n\t\tcustom replacement character defined (see\n\t\t|:syn-cchar|).\n3\t\tConcealed text is completely hidden.\n\nNote: in the cursor line concealed text is not hidden, so that you can\nedit and copy the text.  This can be changed with the 'concealcursor'\noption."}}, colorcolumn = {binding = "colorcolumn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'colorcolumn' 'cc'\tstring\t(default \"\")\n\t\tlocal to window\n'colorcolumn' is a comma-separated list of screen columns that are\nhighlighted with ColorColumn |hl-ColorColumn|.  Useful to align\ntext.  Will make screen redrawing slower.\nThe screen column can be an absolute number, or a number preceded with\n'+' or '-', which is added to or subtracted from 'textwidth'. >vim\n\n\tset cc=+1\t  \" highlight column after 'textwidth'\n\tset cc=+1,+2,+3  \" highlight three columns after 'textwidth'\n\thi ColorColumn ctermbg=lightgrey guibg=lightgrey\n<\nWhen 'textwidth' is zero then the items with '-' and '+' are not used.\nA maximum of 256 columns are highlighted."}}, columns = {binding = "columns", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'columns' 'co'\t\tnumber\t(default 80 or terminal width)\n\t\tglobal\nNumber of columns of the screen.  Normally this is set by the terminal\ninitialization and does not have to be set by hand.\nWhen Vim is running in the GUI or in a resizable window, setting this\noption will cause the window size to be changed.  When you only want\nto use the size for the GUI, put the command in your |ginit.vim| file.\nWhen you set this option and Vim is unable to change the physical\nnumber of columns of the display, the display may be messed up.  For\nthe GUI it is always possible and Vim limits the number of columns to\nwhat fits on the screen.  You can use this command to get the widest\nwindow possible: >vim\n\tset columns=9999\n<\tMinimum value is 12, maximum value is 10000."}}, com = {binding = "com", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'comments' 'com'\tstring\t(default \"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-,fb:\226\128\162\")\n\t\tlocal to buffer\nA comma-separated list of strings that can start a comment line.  See\n|format-comments|.  See |option-backslash| about using backslashes to\ninsert a space."}}, comments = {binding = "comments", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'comments' 'com'\tstring\t(default \"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-,fb:\226\128\162\")\n\t\tlocal to buffer\nA comma-separated list of strings that can start a comment line.  See\n|format-comments|.  See |option-backslash| about using backslashes to\ninsert a space."}}, commentstring = {binding = "commentstring", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'commentstring' 'cms'\tstring\t(default \"\")\n\t\tlocal to buffer\nA template for a comment.  The \"%s\" in the value is replaced with the\ncomment text, and should be padded with a space when possible.\nUsed for |commenting| and to add markers for folding, see |fold-marker|."}}, complete = {binding = "complete", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'complete' 'cpt'\tstring\t(default \".,w,b,u,t\")\n\t\tlocal to buffer\nThis option specifies how keyword completion |ins-completion| works\nwhen CTRL-P or CTRL-N are used.  It is also used for whole-line\ncompletion |i_CTRL-X_CTRL-L|.  It indicates the type of completion\nand the places to scan.  It is a comma-separated list of flags:\n.\tscan the current buffer ('wrapscan' is ignored)\nw\tscan buffers from other windows\nb\tscan other loaded buffers that are in the buffer list\nu\tscan the unloaded buffers that are in the buffer list\nU\tscan the buffers that are not in the buffer list\nk\tscan the files given with the 'dictionary' option\nkspell  use the currently active spell checking |spell|\nk{dict}\tscan the file {dict}.  Several \"k\" flags can be given,\n\tpatterns are valid too.  For example: >vim\n\t\tset cpt=k/usr/dict/*,k~/spanish\n<\ts\tscan the files given with the 'thesaurus' option\ns{tsr}\tscan the file {tsr}.  Several \"s\" flags can be given, patterns\n\tare valid too.\ni\tscan current and included files\nd\tscan current and included files for defined name or macro\n\t|i_CTRL-X_CTRL-D|\n]\ttag completion\nt\tsame as \"]\"\nf\tscan the buffer names (as opposed to buffer contents)\n\nUnloaded buffers are not loaded, thus their autocmds |:autocmd| are\nnot executed, this may lead to unexpected completions from some files\n(gzipped files for example).  Unloaded buffers are not scanned for\nwhole-line completion.\n\nAs you can see, CTRL-N and CTRL-P can be used to do any 'iskeyword'-\nbased expansion (e.g., dictionary |i_CTRL-X_CTRL-K|, included patterns\n|i_CTRL-X_CTRL-I|, tags |i_CTRL-X_CTRL-]| and normal expansions)."}}, completefunc = {binding = "completefunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completefunc' 'cfu'\tstring\t(default \"\")\n\t\tlocal to buffer\nThis option specifies a function to be used for Insert mode completion\nwith CTRL-X CTRL-U. |i_CTRL-X_CTRL-U|\nSee |complete-functions| for an explanation of how the function is\ninvoked and what it should return.  The value can be the name of a\nfunction, a |lambda| or a |Funcref|. See |option-value-function| for\nmore information.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, completeitemalign = {binding = "completeitemalign", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completeitemalign' 'cia'\tstring\t(default \"abbr,kind,menu\")\n\t\tglobal\nA comma-separated list of strings that controls the alignment and\ndisplay order of items in the popup menu during Insert mode\ncompletion.  The supported values are \"abbr\", \"kind\", and \"menu\".\nThese values allow customizing how |complete-items| are shown in the\npopup menu.  Note: must always contain those three values in any\norder."}}, completeopt = {binding = "completeopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completeopt' 'cot'\tstring\t(default \"menu,popup\")\n\t\tglobal or local to buffer |global-local|\nA comma-separated list of options for Insert mode completion\n|ins-completion|.  The supported values are:\n\n   fuzzy    Enable |fuzzy-matching| for completion candidates. This\n\t    allows for more flexible and intuitive matching, where\n\t    characters can be skipped and matches can be found even\n\t    if the exact sequence is not typed.  Only makes a\n\t    difference how completion candidates are reduced from the\n\t    list of alternatives, but not how the candidates are\n\t    collected (using different completion types).\n\n   longest  Only insert the longest common text of the matches.  If\n\t    the menu is displayed you can use CTRL-L to add more\n\t    characters.  Whether case is ignored depends on the kind\n\t    of completion.  For buffer text the 'ignorecase' option is\n\t    used.\n\n   menu\t    Use a popup menu to show the possible completions.  The\n\t    menu is only shown when there is more than one match and\n\t    sufficient colors are available.  |ins-completion-menu|\n\n   menuone  Use the popup menu also when there is only one match.\n\t    Useful when there is additional information about the\n\t    match, e.g., what file it comes from.\n\n   noinsert Do not insert any text for a match until the user selects\n\t    a match from the menu.  Only works in combination with\n\t    \"menu\" or \"menuone\". No effect if \"longest\" is present.\n\n   noselect Same as \"noinsert\", except that no menu item is\n\t    pre-selected.  If both \"noinsert\" and \"noselect\" are\n\t    present, \"noselect\" has precedence.\n\n   nosort   Disable sorting of completion candidates based on fuzzy\n\t    scores when \"fuzzy\" is enabled.  Candidates will appear\n\t    in their original order.\n\n   popup    Show extra information about the currently selected\n\t    completion in a popup window.  Only works in combination\n\t    with \"menu\" or \"menuone\".  Overrides \"preview\".\n\n   preinsert\n\t    Preinsert the portion of the first candidate word that is\n\t    not part of the current completion leader and using the\n\t    |hl-ComplMatchIns| highlight group.  In order for it to\n\t    work, \"fuzzy\" must not be set and \"menuone\" must be set.\n\n   preview  Show extra information about the currently selected\n\t    completion in the preview window.  Only works in\n\t    combination with \"menu\" or \"menuone\"."}}, completeslash = {binding = "completeslash", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completeslash' 'csl'\tstring\t(default \"\")\n\t\tlocal to buffer\n\t\tonly modifiable in MS-Windows\nWhen this option is set it overrules 'shellslash' for completion:\n- When this option is set to \"slash\", a forward slash is used for path\n  completion in insert mode. This is useful when editing HTML tag, or\n  Makefile with 'noshellslash' on MS-Windows.\n- When this option is set to \"backslash\", backslash is used. This is\n  useful when editing a batch file with 'shellslash' set on MS-Windows.\n- When this option is empty, same character is used as for\n  'shellslash'.\nFor Insert mode completion the buffer-local value is used.  For\ncommand line completion the global value is used."}}, concealcursor = {binding = "concealcursor", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'concealcursor' 'cocu'\tstring\t(default \"\")\n\t\tlocal to window\nSets the modes in which text in the cursor line can also be concealed.\nWhen the current mode is listed then concealing happens just like in\nother lines.\n  n\t\tNormal mode\n  v\t\tVisual mode\n  i\t\tInsert mode\n  c\t\tCommand line editing, for 'incsearch'\n\n'v' applies to all lines in the Visual area, not only the cursor.\nA useful value is \"nc\".  This is used in help files.  So long as you\nare moving around text is concealed, but when starting to insert text\nor selecting a Visual area the concealed text is displayed, so that\nyou can see what you are doing.\nKeep in mind that the cursor position is not always where it's\ndisplayed.  E.g., when moving vertically it may change column."}}, conceallevel = {binding = "conceallevel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'conceallevel' 'cole'\tnumber\t(default 0)\n\t\tlocal to window\nDetermine how text with the \"conceal\" syntax attribute |:syn-conceal|\nis shown:\n\nValue\t\tEffect ~\n0\t\tText is shown normally\n1\t\tEach block of concealed text is replaced with one\n\t\tcharacter.  If the syntax item does not have a custom\n\t\treplacement character defined (see |:syn-cchar|) the\n\t\tcharacter defined in 'listchars' is used.\n\t\tIt is highlighted with the \"Conceal\" highlight group.\n2\t\tConcealed text is completely hidden unless it has a\n\t\tcustom replacement character defined (see\n\t\t|:syn-cchar|).\n3\t\tConcealed text is completely hidden.\n\nNote: in the cursor line concealed text is not hidden, so that you can\nedit and copy the text.  This can be changed with the 'concealcursor'\noption."}}, confirm = {binding = "confirm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'confirm' 'cf'\t\tboolean\t(default off)\n\t\tglobal\nWhen 'confirm' is on, certain operations that would normally\nfail because of unsaved changes to a buffer, e.g. \":q\" and \":e\",\ninstead raise a dialog asking if you wish to save the current\nfile(s).  You can still use a ! to unconditionally |abandon| a buffer.\nIf 'confirm' is off you can still activate confirmation for one\ncommand only (this is most useful in mappings) with the |:confirm|\ncommand.\nAlso see the |confirm()| function and the 'v' flag in 'guioptions'."}}, copyindent = {binding = "copyindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'copyindent' 'ci'\tboolean\t(default off)\n\t\tlocal to buffer\nCopy the structure of the existing lines indent when autoindenting a\nnew line.  Normally the new indent is reconstructed by a series of\ntabs followed by spaces as required (unless |'expandtab'| is enabled,\nin which case only spaces are used).  Enabling this option makes the\nnew line copy whatever characters were used for indenting on the\nexisting line.  'expandtab' has no effect on these characters, a Tab\nremains a Tab.  If the new indent is greater than on the existing\nline, the remaining space is filled in the normal manner.\nSee 'preserveindent'."}}, cot = {binding = "cot", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completeopt' 'cot'\tstring\t(default \"menu,popup\")\n\t\tglobal or local to buffer |global-local|\nA comma-separated list of options for Insert mode completion\n|ins-completion|.  The supported values are:\n\n   fuzzy    Enable |fuzzy-matching| for completion candidates. This\n\t    allows for more flexible and intuitive matching, where\n\t    characters can be skipped and matches can be found even\n\t    if the exact sequence is not typed.  Only makes a\n\t    difference how completion candidates are reduced from the\n\t    list of alternatives, but not how the candidates are\n\t    collected (using different completion types).\n\n   longest  Only insert the longest common text of the matches.  If\n\t    the menu is displayed you can use CTRL-L to add more\n\t    characters.  Whether case is ignored depends on the kind\n\t    of completion.  For buffer text the 'ignorecase' option is\n\t    used.\n\n   menu\t    Use a popup menu to show the possible completions.  The\n\t    menu is only shown when there is more than one match and\n\t    sufficient colors are available.  |ins-completion-menu|\n\n   menuone  Use the popup menu also when there is only one match.\n\t    Useful when there is additional information about the\n\t    match, e.g., what file it comes from.\n\n   noinsert Do not insert any text for a match until the user selects\n\t    a match from the menu.  Only works in combination with\n\t    \"menu\" or \"menuone\". No effect if \"longest\" is present.\n\n   noselect Same as \"noinsert\", except that no menu item is\n\t    pre-selected.  If both \"noinsert\" and \"noselect\" are\n\t    present, \"noselect\" has precedence.\n\n   nosort   Disable sorting of completion candidates based on fuzzy\n\t    scores when \"fuzzy\" is enabled.  Candidates will appear\n\t    in their original order.\n\n   popup    Show extra information about the currently selected\n\t    completion in a popup window.  Only works in combination\n\t    with \"menu\" or \"menuone\".  Overrides \"preview\".\n\n   preinsert\n\t    Preinsert the portion of the first candidate word that is\n\t    not part of the current completion leader and using the\n\t    |hl-ComplMatchIns| highlight group.  In order for it to\n\t    work, \"fuzzy\" must not be set and \"menuone\" must be set.\n\n   preview  Show extra information about the currently selected\n\t    completion in the preview window.  Only works in\n\t    combination with \"menu\" or \"menuone\"."}}, cpo = {binding = "cpo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cpoptions' 'cpo'\tstring\t(default \"aABceFs_\")\n\t\tglobal\nA sequence of single character flags.  When a character is present\nthis indicates Vi-compatible behavior.  This is used for things where\nnot being Vi-compatible is mostly or sometimes preferred.\n'cpoptions' stands for \"compatible-options\".\nCommas can be added for readability.\nTo avoid problems with flags that are added in the future, use the\n\"+=\" and \"-=\" feature of \":set\" |add-option-flags|.\n\n    contains\tbehavior\t~\n\t\t\t\t\t\t\t*cpo-a*\n\ta\tWhen included, a \":read\" command with a file name\n\t\targument will set the alternate file name for the\n\t\tcurrent window.\n\t\t\t\t\t\t\t*cpo-A*\n\tA\tWhen included, a \":write\" command with a file name\n\t\targument will set the alternate file name for the\n\t\tcurrent window.\n\t\t\t\t\t\t\t*cpo-b*\n\tb\t\"\\|\" in a \":map\" command is recognized as the end of\n\t\tthe map command.  The '\\' is included in the mapping,\n\t\tthe text after the '|' is interpreted as the next\n\t\tcommand.  Use a CTRL-V instead of a backslash to\n\t\tinclude the '|' in the mapping.  Applies to all\n\t\tmapping, abbreviation, menu and autocmd commands.\n\t\tSee also |map_bar|.\n\t\t\t\t\t\t\t*cpo-B*\n\tB\tA backslash has no special meaning in mappings,\n\t\tabbreviations, user commands and the \"to\" part of the\n\t\tmenu commands.  Remove this flag to be able to use a\n\t\tbackslash like a CTRL-V.  For example, the command\n\t\t\":map X \\<Esc>\" results in X being mapped to:\n\t\t\t'B' included:\t\"\\^[\"\t (^[ is a real <Esc>)\n\t\t\t'B' excluded:\t\"<Esc>\"  (5 characters)\n\t\t\t\t\t\t\t*cpo-c*\n\tc\tSearching continues at the end of any match at the\n\t\tcursor position, but not further than the start of the\n\t\tnext line.  When not present searching continues\n\t\tone character from the cursor position.  With 'c'\n\t\t\"abababababab\" only gets three matches when repeating\n\t\t\"/abab\", without 'c' there are five matches.\n\t\t\t\t\t\t\t*cpo-C*\n\tC\tDo not concatenate sourced lines that start with a\n\t\tbackslash.  See |line-continuation|.\n\t\t\t\t\t\t\t*cpo-d*\n\td\tUsing \"./\" in the 'tags' option doesn't mean to use\n\t\tthe tags file relative to the current file, but the\n\t\ttags file in the current directory.\n\t\t\t\t\t\t\t*cpo-D*\n\tD\tCan't use CTRL-K to enter a digraph after Normal mode\n\t\tcommands with a character argument, like |r|, |f| and\n\t\t|t|.\n\t\t\t\t\t\t\t*cpo-e*\n\te\tWhen executing a register with \":@r\", always add a\n\t\t<CR> to the last line, also when the register is not\n\t\tlinewise.  If this flag is not present, the register\n\t\tis not linewise and the last line does not end in a\n\t\t<CR>, then the last line is put on the command-line\n\t\tand can be edited before hitting <CR>.\n\t\t\t\t\t\t\t*cpo-E*\n\tE\tIt is an error when using \"y\", \"d\", \"c\", \"g~\", \"gu\" or\n\t\t\"gU\" on an Empty region.  The operators only work when\n\t\tat least one character is to be operated on.  Example:\n\t\tThis makes \"y0\" fail in the first column.\n\t\t\t\t\t\t\t*cpo-f*\n\tf\tWhen included, a \":read\" command with a file name\n\t\targument will set the file name for the current buffer,\n\t\tif the current buffer doesn't have a file name yet.\n\t\t\t\t\t\t\t*cpo-F*\n\tF\tWhen included, a \":write\" command with a file name\n\t\targument will set the file name for the current\n\t\tbuffer, if the current buffer doesn't have a file name\n\t\tyet.  Also see |cpo-P|.\n\t\t\t\t\t\t\t*cpo-i*\n\ti\tWhen included, interrupting the reading of a file will\n\t\tleave it modified.\n\t\t\t\t\t\t\t*cpo-I*\n\tI\tWhen moving the cursor up or down just after inserting\n\t\tindent for 'autoindent', do not delete the indent.\n\t\t\t\t\t\t\t*cpo-J*\n\tJ\tA |sentence| has to be followed by two spaces after\n\t\tthe '.', '!' or '?'.  A <Tab> is not recognized as\n\t\twhite space.\n\t\t\t\t\t\t\t*cpo-K*\n\tK\tDon't wait for a key code to complete when it is\n\t\thalfway through a mapping.  This breaks mapping\n\t\t<F1><F1> when only part of the second <F1> has been\n\t\tread.  It enables cancelling the mapping by typing\n\t\t<F1><Esc>.\n\t\t\t\t\t\t\t*cpo-l*\n\tl\tBackslash in a [] range in a search pattern is taken\n\t\tliterally, only \"\\]\", \"\\^\", \"\\-\" and \"\\\\\" are special.\n\t\tSee |/[]|\n\t\t   'l' included: \"/[ \\t]\"  finds <Space>, '\\' and 't'\n\t\t   'l' excluded: \"/[ \\t]\"  finds <Space> and <Tab>\n\t\t\t\t\t\t\t*cpo-L*\n\tL\tWhen the 'list' option is set, 'wrapmargin',\n\t\t'textwidth', 'softtabstop' and Virtual Replace mode\n\t\t(see |gR|) count a <Tab> as two characters, instead of\n\t\tthe normal behavior of a <Tab>.\n\t\t\t\t\t\t\t*cpo-m*\n\tm\tWhen included, a showmatch will always wait half a\n\t\tsecond.  When not included, a showmatch will wait half\n\t\ta second or until a character is typed.  |'showmatch'|\n\t\t\t\t\t\t\t*cpo-M*\n\tM\tWhen excluded, \"%\" matching will take backslashes into\n\t\taccount.  Thus in \"( \\( )\" and \"\\( ( \\)\" the outer\n\t\tparenthesis match.  When included \"%\" ignores\n\t\tbackslashes, which is Vi compatible.\n\t\t\t\t\t\t\t*cpo-n*\n\tn\tWhen included, the column used for 'number' and\n\t\t'relativenumber' will also be used for text of wrapped\n\t\tlines.\n\t\t\t\t\t\t\t*cpo-o*\n\to\tLine offset to search command is not remembered for\n\t\tnext search.\n\t\t\t\t\t\t\t*cpo-O*\n\tO\tDon't complain if a file is being overwritten, even\n\t\twhen it didn't exist when editing it.  This is a\n\t\tprotection against a file unexpectedly created by\n\t\tsomeone else.  Vi didn't complain about this.\n\t\t\t\t\t\t\t*cpo-P*\n\tP\tWhen included, a \":write\" command that appends to a\n\t\tfile will set the file name for the current buffer, if\n\t\tthe current buffer doesn't have a file name yet and\n\t\tthe 'F' flag is also included |cpo-F|.\n\t\t\t\t\t\t\t*cpo-q*\n\tq\tWhen joining multiple lines leave the cursor at the\n\t\tposition where it would be when joining two lines.\n\t\t\t\t\t\t\t*cpo-r*\n\tr\tRedo (\".\" command) uses \"/\" to repeat a search\n\t\tcommand, instead of the actually used search string.\n\t\t\t\t\t\t\t*cpo-R*\n\tR\tRemove marks from filtered lines.  Without this flag\n\t\tmarks are kept like |:keepmarks| was used.\n\t\t\t\t\t\t\t*cpo-s*\n\ts\tSet buffer options when entering the buffer for the\n\t\tfirst time.  This is like it is in Vim version 3.0.\n\t\tAnd it is the default.  If not present the options are\n\t\tset when the buffer is created.\n\t\t\t\t\t\t\t*cpo-S*\n\tS\tSet buffer options always when entering a buffer\n\t\t(except 'readonly', 'fileformat', 'filetype' and\n\t\t'syntax').  This is the (most) Vi compatible setting.\n\t\tThe options are set to the values in the current\n\t\tbuffer.  When you change an option and go to another\n\t\tbuffer, the value is copied.  Effectively makes the\n\t\tbuffer options global to all buffers.\n\n\t\t's'    'S'     copy buffer options\n\t\tno     no      when buffer created\n\t\tyes    no      when buffer first entered (default)\n\t\t X     yes     each time when buffer entered (vi comp.)\n\t\t\t\t\t\t\t*cpo-t*\n\tt\tSearch pattern for the tag command is remembered for\n\t\t\"n\" command.  Otherwise Vim only puts the pattern in\n\t\tthe history for search pattern, but doesn't change the\n\t\tlast used search pattern.\n\t\t\t\t\t\t\t*cpo-u*\n\tu\tUndo is Vi compatible.  See |undo-two-ways|.\n\t\t\t\t\t\t\t*cpo-v*\n\tv\tBackspaced characters remain visible on the screen in\n\t\tInsert mode.  Without this flag the characters are\n\t\terased from the screen right away.  With this flag the\n\t\tscreen newly typed text overwrites backspaced\n\t\tcharacters.\n\t\t\t\t\t\t\t*cpo-W*\n\tW\tDon't overwrite a readonly file.  When omitted, \":w!\"\n\t\toverwrites a readonly file, if possible.\n\t\t\t\t\t\t\t*cpo-x*\n\tx\t<Esc> on the command-line executes the command-line.\n\t\tThe default in Vim is to abandon the command-line,\n\t\tbecause <Esc> normally aborts a command.  |c_<Esc>|\n\t\t\t\t\t\t\t*cpo-X*\n\tX\tWhen using a count with \"R\" the replaced text is\n\t\tdeleted only once.  Also when repeating \"R\" with \".\"\n\t\tand a count.\n\t\t\t\t\t\t\t*cpo-y*\n\ty\tA yank command can be redone with \".\".  Think twice if\n\t\tyou really want to use this, it may break some\n\t\tplugins, since most people expect \".\" to only repeat a\n\t\tchange.\n\t\t\t\t\t\t\t*cpo-Z*\n\tZ\tWhen using \"w!\" while the 'readonly' option is set,\n\t\tdon't reset 'readonly'.\n\t\t\t\t\t\t\t*cpo-!*\n\t!\tWhen redoing a filter command, use the last used\n\t\texternal command, whatever it was.  Otherwise the last\n\t\tused -filter- command is used.\n\t\t\t\t\t\t\t*cpo-$*\n\t$\tWhen making a change to one line, don't redisplay the\n\t\tline, but put a '$' at the end of the changed text.\n\t\tThe changed text will be overwritten when you type the\n\t\tnew text.  The line is redisplayed if you type any\n\t\tcommand that moves the cursor from the insertion\n\t\tpoint.\n\t\t\t\t\t\t\t*cpo-%*\n\t%\tVi-compatible matching is done for the \"%\" command.\n\t\tDoes not recognize \"#if\", \"#endif\", etc.\n\t\tDoes not recognize \"/*\" and \"*/\".\n\t\tParens inside single and double quotes are also\n\t\tcounted, causing a string that contains a paren to\n\t\tdisturb the matching.  For example, in a line like\n\t\t\"if (strcmp(\"foo(\", s))\" the first paren does not\n\t\tmatch the last one.  When this flag is not included,\n\t\tparens inside single and double quotes are treated\n\t\tspecially.  When matching a paren outside of quotes,\n\t\teverything inside quotes is ignored.  When matching a\n\t\tparen inside quotes, it will find the matching one (if\n\t\tthere is one).  This works very well for C programs.\n\t\tThis flag is also used for other features, such as\n\t\tC-indenting.\n\t\t\t\t\t\t\t*cpo-+*\n\t+\tWhen included, a \":write file\" command will reset the\n\t\t'modified' flag of the buffer, even though the buffer\n\t\titself may still be different from its file.\n\t\t\t\t\t\t\t*cpo->*\n\t>\tWhen appending to a register, put a line break before\n\t\tthe appended text.\n\t\t\t\t\t\t\t*cpo-;*\n\t;\tWhen using |,| or |;| to repeat the last |t| search\n\t\tand the cursor is right in front of the searched\n\t\tcharacter, the cursor won't move. When not included,\n\t\tthe cursor would skip over it and jump to the\n\t\tfollowing occurrence.\n\t\t\t\t\t\t\t*cpo-_*\n\t_\tWhen using |cw| on a word, do not include the\n\t\twhitespace following the word in the motion."}}, cpoptions = {binding = "cpoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cpoptions' 'cpo'\tstring\t(default \"aABceFs_\")\n\t\tglobal\nA sequence of single character flags.  When a character is present\nthis indicates Vi-compatible behavior.  This is used for things where\nnot being Vi-compatible is mostly or sometimes preferred.\n'cpoptions' stands for \"compatible-options\".\nCommas can be added for readability.\nTo avoid problems with flags that are added in the future, use the\n\"+=\" and \"-=\" feature of \":set\" |add-option-flags|.\n\n    contains\tbehavior\t~\n\t\t\t\t\t\t\t*cpo-a*\n\ta\tWhen included, a \":read\" command with a file name\n\t\targument will set the alternate file name for the\n\t\tcurrent window.\n\t\t\t\t\t\t\t*cpo-A*\n\tA\tWhen included, a \":write\" command with a file name\n\t\targument will set the alternate file name for the\n\t\tcurrent window.\n\t\t\t\t\t\t\t*cpo-b*\n\tb\t\"\\|\" in a \":map\" command is recognized as the end of\n\t\tthe map command.  The '\\' is included in the mapping,\n\t\tthe text after the '|' is interpreted as the next\n\t\tcommand.  Use a CTRL-V instead of a backslash to\n\t\tinclude the '|' in the mapping.  Applies to all\n\t\tmapping, abbreviation, menu and autocmd commands.\n\t\tSee also |map_bar|.\n\t\t\t\t\t\t\t*cpo-B*\n\tB\tA backslash has no special meaning in mappings,\n\t\tabbreviations, user commands and the \"to\" part of the\n\t\tmenu commands.  Remove this flag to be able to use a\n\t\tbackslash like a CTRL-V.  For example, the command\n\t\t\":map X \\<Esc>\" results in X being mapped to:\n\t\t\t'B' included:\t\"\\^[\"\t (^[ is a real <Esc>)\n\t\t\t'B' excluded:\t\"<Esc>\"  (5 characters)\n\t\t\t\t\t\t\t*cpo-c*\n\tc\tSearching continues at the end of any match at the\n\t\tcursor position, but not further than the start of the\n\t\tnext line.  When not present searching continues\n\t\tone character from the cursor position.  With 'c'\n\t\t\"abababababab\" only gets three matches when repeating\n\t\t\"/abab\", without 'c' there are five matches.\n\t\t\t\t\t\t\t*cpo-C*\n\tC\tDo not concatenate sourced lines that start with a\n\t\tbackslash.  See |line-continuation|.\n\t\t\t\t\t\t\t*cpo-d*\n\td\tUsing \"./\" in the 'tags' option doesn't mean to use\n\t\tthe tags file relative to the current file, but the\n\t\ttags file in the current directory.\n\t\t\t\t\t\t\t*cpo-D*\n\tD\tCan't use CTRL-K to enter a digraph after Normal mode\n\t\tcommands with a character argument, like |r|, |f| and\n\t\t|t|.\n\t\t\t\t\t\t\t*cpo-e*\n\te\tWhen executing a register with \":@r\", always add a\n\t\t<CR> to the last line, also when the register is not\n\t\tlinewise.  If this flag is not present, the register\n\t\tis not linewise and the last line does not end in a\n\t\t<CR>, then the last line is put on the command-line\n\t\tand can be edited before hitting <CR>.\n\t\t\t\t\t\t\t*cpo-E*\n\tE\tIt is an error when using \"y\", \"d\", \"c\", \"g~\", \"gu\" or\n\t\t\"gU\" on an Empty region.  The operators only work when\n\t\tat least one character is to be operated on.  Example:\n\t\tThis makes \"y0\" fail in the first column.\n\t\t\t\t\t\t\t*cpo-f*\n\tf\tWhen included, a \":read\" command with a file name\n\t\targument will set the file name for the current buffer,\n\t\tif the current buffer doesn't have a file name yet.\n\t\t\t\t\t\t\t*cpo-F*\n\tF\tWhen included, a \":write\" command with a file name\n\t\targument will set the file name for the current\n\t\tbuffer, if the current buffer doesn't have a file name\n\t\tyet.  Also see |cpo-P|.\n\t\t\t\t\t\t\t*cpo-i*\n\ti\tWhen included, interrupting the reading of a file will\n\t\tleave it modified.\n\t\t\t\t\t\t\t*cpo-I*\n\tI\tWhen moving the cursor up or down just after inserting\n\t\tindent for 'autoindent', do not delete the indent.\n\t\t\t\t\t\t\t*cpo-J*\n\tJ\tA |sentence| has to be followed by two spaces after\n\t\tthe '.', '!' or '?'.  A <Tab> is not recognized as\n\t\twhite space.\n\t\t\t\t\t\t\t*cpo-K*\n\tK\tDon't wait for a key code to complete when it is\n\t\thalfway through a mapping.  This breaks mapping\n\t\t<F1><F1> when only part of the second <F1> has been\n\t\tread.  It enables cancelling the mapping by typing\n\t\t<F1><Esc>.\n\t\t\t\t\t\t\t*cpo-l*\n\tl\tBackslash in a [] range in a search pattern is taken\n\t\tliterally, only \"\\]\", \"\\^\", \"\\-\" and \"\\\\\" are special.\n\t\tSee |/[]|\n\t\t   'l' included: \"/[ \\t]\"  finds <Space>, '\\' and 't'\n\t\t   'l' excluded: \"/[ \\t]\"  finds <Space> and <Tab>\n\t\t\t\t\t\t\t*cpo-L*\n\tL\tWhen the 'list' option is set, 'wrapmargin',\n\t\t'textwidth', 'softtabstop' and Virtual Replace mode\n\t\t(see |gR|) count a <Tab> as two characters, instead of\n\t\tthe normal behavior of a <Tab>.\n\t\t\t\t\t\t\t*cpo-m*\n\tm\tWhen included, a showmatch will always wait half a\n\t\tsecond.  When not included, a showmatch will wait half\n\t\ta second or until a character is typed.  |'showmatch'|\n\t\t\t\t\t\t\t*cpo-M*\n\tM\tWhen excluded, \"%\" matching will take backslashes into\n\t\taccount.  Thus in \"( \\( )\" and \"\\( ( \\)\" the outer\n\t\tparenthesis match.  When included \"%\" ignores\n\t\tbackslashes, which is Vi compatible.\n\t\t\t\t\t\t\t*cpo-n*\n\tn\tWhen included, the column used for 'number' and\n\t\t'relativenumber' will also be used for text of wrapped\n\t\tlines.\n\t\t\t\t\t\t\t*cpo-o*\n\to\tLine offset to search command is not remembered for\n\t\tnext search.\n\t\t\t\t\t\t\t*cpo-O*\n\tO\tDon't complain if a file is being overwritten, even\n\t\twhen it didn't exist when editing it.  This is a\n\t\tprotection against a file unexpectedly created by\n\t\tsomeone else.  Vi didn't complain about this.\n\t\t\t\t\t\t\t*cpo-P*\n\tP\tWhen included, a \":write\" command that appends to a\n\t\tfile will set the file name for the current buffer, if\n\t\tthe current buffer doesn't have a file name yet and\n\t\tthe 'F' flag is also included |cpo-F|.\n\t\t\t\t\t\t\t*cpo-q*\n\tq\tWhen joining multiple lines leave the cursor at the\n\t\tposition where it would be when joining two lines.\n\t\t\t\t\t\t\t*cpo-r*\n\tr\tRedo (\".\" command) uses \"/\" to repeat a search\n\t\tcommand, instead of the actually used search string.\n\t\t\t\t\t\t\t*cpo-R*\n\tR\tRemove marks from filtered lines.  Without this flag\n\t\tmarks are kept like |:keepmarks| was used.\n\t\t\t\t\t\t\t*cpo-s*\n\ts\tSet buffer options when entering the buffer for the\n\t\tfirst time.  This is like it is in Vim version 3.0.\n\t\tAnd it is the default.  If not present the options are\n\t\tset when the buffer is created.\n\t\t\t\t\t\t\t*cpo-S*\n\tS\tSet buffer options always when entering a buffer\n\t\t(except 'readonly', 'fileformat', 'filetype' and\n\t\t'syntax').  This is the (most) Vi compatible setting.\n\t\tThe options are set to the values in the current\n\t\tbuffer.  When you change an option and go to another\n\t\tbuffer, the value is copied.  Effectively makes the\n\t\tbuffer options global to all buffers.\n\n\t\t's'    'S'     copy buffer options\n\t\tno     no      when buffer created\n\t\tyes    no      when buffer first entered (default)\n\t\t X     yes     each time when buffer entered (vi comp.)\n\t\t\t\t\t\t\t*cpo-t*\n\tt\tSearch pattern for the tag command is remembered for\n\t\t\"n\" command.  Otherwise Vim only puts the pattern in\n\t\tthe history for search pattern, but doesn't change the\n\t\tlast used search pattern.\n\t\t\t\t\t\t\t*cpo-u*\n\tu\tUndo is Vi compatible.  See |undo-two-ways|.\n\t\t\t\t\t\t\t*cpo-v*\n\tv\tBackspaced characters remain visible on the screen in\n\t\tInsert mode.  Without this flag the characters are\n\t\terased from the screen right away.  With this flag the\n\t\tscreen newly typed text overwrites backspaced\n\t\tcharacters.\n\t\t\t\t\t\t\t*cpo-W*\n\tW\tDon't overwrite a readonly file.  When omitted, \":w!\"\n\t\toverwrites a readonly file, if possible.\n\t\t\t\t\t\t\t*cpo-x*\n\tx\t<Esc> on the command-line executes the command-line.\n\t\tThe default in Vim is to abandon the command-line,\n\t\tbecause <Esc> normally aborts a command.  |c_<Esc>|\n\t\t\t\t\t\t\t*cpo-X*\n\tX\tWhen using a count with \"R\" the replaced text is\n\t\tdeleted only once.  Also when repeating \"R\" with \".\"\n\t\tand a count.\n\t\t\t\t\t\t\t*cpo-y*\n\ty\tA yank command can be redone with \".\".  Think twice if\n\t\tyou really want to use this, it may break some\n\t\tplugins, since most people expect \".\" to only repeat a\n\t\tchange.\n\t\t\t\t\t\t\t*cpo-Z*\n\tZ\tWhen using \"w!\" while the 'readonly' option is set,\n\t\tdon't reset 'readonly'.\n\t\t\t\t\t\t\t*cpo-!*\n\t!\tWhen redoing a filter command, use the last used\n\t\texternal command, whatever it was.  Otherwise the last\n\t\tused -filter- command is used.\n\t\t\t\t\t\t\t*cpo-$*\n\t$\tWhen making a change to one line, don't redisplay the\n\t\tline, but put a '$' at the end of the changed text.\n\t\tThe changed text will be overwritten when you type the\n\t\tnew text.  The line is redisplayed if you type any\n\t\tcommand that moves the cursor from the insertion\n\t\tpoint.\n\t\t\t\t\t\t\t*cpo-%*\n\t%\tVi-compatible matching is done for the \"%\" command.\n\t\tDoes not recognize \"#if\", \"#endif\", etc.\n\t\tDoes not recognize \"/*\" and \"*/\".\n\t\tParens inside single and double quotes are also\n\t\tcounted, causing a string that contains a paren to\n\t\tdisturb the matching.  For example, in a line like\n\t\t\"if (strcmp(\"foo(\", s))\" the first paren does not\n\t\tmatch the last one.  When this flag is not included,\n\t\tparens inside single and double quotes are treated\n\t\tspecially.  When matching a paren outside of quotes,\n\t\teverything inside quotes is ignored.  When matching a\n\t\tparen inside quotes, it will find the matching one (if\n\t\tthere is one).  This works very well for C programs.\n\t\tThis flag is also used for other features, such as\n\t\tC-indenting.\n\t\t\t\t\t\t\t*cpo-+*\n\t+\tWhen included, a \":write file\" command will reset the\n\t\t'modified' flag of the buffer, even though the buffer\n\t\titself may still be different from its file.\n\t\t\t\t\t\t\t*cpo->*\n\t>\tWhen appending to a register, put a line break before\n\t\tthe appended text.\n\t\t\t\t\t\t\t*cpo-;*\n\t;\tWhen using |,| or |;| to repeat the last |t| search\n\t\tand the cursor is right in front of the searched\n\t\tcharacter, the cursor won't move. When not included,\n\t\tthe cursor would skip over it and jump to the\n\t\tfollowing occurrence.\n\t\t\t\t\t\t\t*cpo-_*\n\t_\tWhen using |cw| on a word, do not include the\n\t\twhitespace following the word in the motion."}}, cpt = {binding = "cpt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'complete' 'cpt'\tstring\t(default \".,w,b,u,t\")\n\t\tlocal to buffer\nThis option specifies how keyword completion |ins-completion| works\nwhen CTRL-P or CTRL-N are used.  It is also used for whole-line\ncompletion |i_CTRL-X_CTRL-L|.  It indicates the type of completion\nand the places to scan.  It is a comma-separated list of flags:\n.\tscan the current buffer ('wrapscan' is ignored)\nw\tscan buffers from other windows\nb\tscan other loaded buffers that are in the buffer list\nu\tscan the unloaded buffers that are in the buffer list\nU\tscan the buffers that are not in the buffer list\nk\tscan the files given with the 'dictionary' option\nkspell  use the currently active spell checking |spell|\nk{dict}\tscan the file {dict}.  Several \"k\" flags can be given,\n\tpatterns are valid too.  For example: >vim\n\t\tset cpt=k/usr/dict/*,k~/spanish\n<\ts\tscan the files given with the 'thesaurus' option\ns{tsr}\tscan the file {tsr}.  Several \"s\" flags can be given, patterns\n\tare valid too.\ni\tscan current and included files\nd\tscan current and included files for defined name or macro\n\t|i_CTRL-X_CTRL-D|\n]\ttag completion\nt\tsame as \"]\"\nf\tscan the buffer names (as opposed to buffer contents)\n\nUnloaded buffers are not loaded, thus their autocmds |:autocmd| are\nnot executed, this may lead to unexpected completions from some files\n(gzipped files for example).  Unloaded buffers are not scanned for\nwhole-line completion.\n\nAs you can see, CTRL-N and CTRL-P can be used to do any 'iskeyword'-\nbased expansion (e.g., dictionary |i_CTRL-X_CTRL-K|, included patterns\n|i_CTRL-X_CTRL-I|, tags |i_CTRL-X_CTRL-]| and normal expansions)."}}, crb = {binding = "crb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorbind' 'crb'\tboolean\t(default off)\n\t\tlocal to window\nWhen this option is set, as the cursor in the current\nwindow moves other cursorbound windows (windows that also have\nthis option set) move their cursors to the corresponding line and\ncolumn.  This option is useful for viewing the\ndifferences between two versions of a file (see 'diff'); in diff mode,\ninserted and deleted lines (though not characters within a line) are\ntaken into account."}}, csl = {binding = "csl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'completeslash' 'csl'\tstring\t(default \"\")\n\t\tlocal to buffer\n\t\tonly modifiable in MS-Windows\nWhen this option is set it overrules 'shellslash' for completion:\n- When this option is set to \"slash\", a forward slash is used for path\n  completion in insert mode. This is useful when editing HTML tag, or\n  Makefile with 'noshellslash' on MS-Windows.\n- When this option is set to \"backslash\", backslash is used. This is\n  useful when editing a batch file with 'shellslash' set on MS-Windows.\n- When this option is empty, same character is used as for\n  'shellslash'.\nFor Insert mode completion the buffer-local value is used.  For\ncommand line completion the global value is used."}}, cuc = {binding = "cuc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorcolumn' 'cuc'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the screen column of the cursor with CursorColumn\n|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing\nslower.\nIf you only want the highlighting in the current window you can use\nthese autocommands: >vim\n\tau WinLeave * set nocursorline nocursorcolumn\n\tau WinEnter * set cursorline cursorcolumn\n<"}}, cul = {binding = "cul", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorline' 'cul'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the text line of the cursor with CursorLine |hl-CursorLine|.\nUseful to easily spot the cursor.  Will make screen redrawing slower.\nWhen Visual mode is active the highlighting isn't used to make it\neasier to see the selected text."}}, culopt = {binding = "culopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorlineopt' 'culopt'\tstring\t(default \"both\")\n\t\tlocal to window\nComma-separated list of settings for how 'cursorline' is displayed.\nValid values:\n\"line\"\t\tHighlight the text line of the cursor with\n\t\tCursorLine |hl-CursorLine|.\n\"screenline\"\tHighlight only the screen line of the cursor with\n\t\tCursorLine |hl-CursorLine|.\n\"number\"\tHighlight the line number of the cursor with\n\t\tCursorLineNr |hl-CursorLineNr|.\n\nSpecial value:\n\"both\"\t\tAlias for the values \"line,number\".\n\n\"line\" and \"screenline\" cannot be used together."}}, cursorbind = {binding = "cursorbind", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorbind' 'crb'\tboolean\t(default off)\n\t\tlocal to window\nWhen this option is set, as the cursor in the current\nwindow moves other cursorbound windows (windows that also have\nthis option set) move their cursors to the corresponding line and\ncolumn.  This option is useful for viewing the\ndifferences between two versions of a file (see 'diff'); in diff mode,\ninserted and deleted lines (though not characters within a line) are\ntaken into account."}}, cursorcolumn = {binding = "cursorcolumn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorcolumn' 'cuc'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the screen column of the cursor with CursorColumn\n|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing\nslower.\nIf you only want the highlighting in the current window you can use\nthese autocommands: >vim\n\tau WinLeave * set nocursorline nocursorcolumn\n\tau WinEnter * set cursorline cursorcolumn\n<"}}, cursorline = {binding = "cursorline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorline' 'cul'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the text line of the cursor with CursorLine |hl-CursorLine|.\nUseful to easily spot the cursor.  Will make screen redrawing slower.\nWhen Visual mode is active the highlighting isn't used to make it\neasier to see the selected text."}}, cursorlineopt = {binding = "cursorlineopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorlineopt' 'culopt'\tstring\t(default \"both\")\n\t\tlocal to window\nComma-separated list of settings for how 'cursorline' is displayed.\nValid values:\n\"line\"\t\tHighlight the text line of the cursor with\n\t\tCursorLine |hl-CursorLine|.\n\"screenline\"\tHighlight only the screen line of the cursor with\n\t\tCursorLine |hl-CursorLine|.\n\"number\"\tHighlight the line number of the cursor with\n\t\tCursorLineNr |hl-CursorLineNr|.\n\nSpecial value:\n\"both\"\t\tAlias for the values \"line,number\".\n\n\"line\" and \"screenline\" cannot be used together."}}, cwh = {binding = "cwh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cmdwinheight' 'cwh'\tnumber\t(default 7)\n\t\tglobal\nNumber of screen lines to use for the command-line window. |cmdwin|"}}, debug = {binding = "debug", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'debug'\t\t\tstring\t(default \"\")\n\t\tglobal\nThese values can be used:\nmsg\tError messages that would otherwise be omitted will be given\n\tanyway.\nthrow\tError messages that would otherwise be omitted will be given\n\tanyway and also throw an exception and set |v:errmsg|.\nbeep\tA message will be given when otherwise only a beep would be\n\tproduced.\nThe values can be combined, separated by a comma.\n\"msg\" and \"throw\" are useful for debugging 'foldexpr', 'formatexpr' or\n'indentexpr'."}}, deco = {binding = "deco", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'delcombine' 'deco'\tboolean\t(default off)\n\t\tglobal\nIf editing Unicode and this option is set, backspace and Normal mode\n\"x\" delete each combining character on its own.  When it is off (the\ndefault) the character along with its combining characters are\ndeleted.\nNote: When 'delcombine' is set \"xx\" may work differently from \"2x\"!\n\nThis is useful for Arabic, Hebrew and many other languages where one\nmay have combining characters overtop of base characters, and want\nto remove only the combining ones."}}, def = {binding = "def", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'define' 'def'\t\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nPattern to be used to find a macro definition.  It is a search\npattern, just like for the \"/\" command.  This option is used for the\ncommands like \"[i\" and \"[d\" |include-search|.  The 'isident' option is\nused to recognize the defined name after the match: >\n\t{match with 'define'}{non-ID chars}{defined name}{non-ID char}\n<\tSee |option-backslash| about inserting backslashes to include a space\nor backslash.\nFor C++ this value would be useful, to include const type declarations: >\n\t^\\(#\\s*define\\|[a-z]*\\s*const\\s*[a-z]*\\)\n<\tYou can also use \"\\ze\" just before the name and continue the pattern\nto check what is following.  E.g. for Javascript, if a function is\ndefined with `func_name = function(args)`: >\n\t^\\s*\\ze\\i\\+\\s*=\\s*function(\n<\tIf the function is defined with `func_name : function() {...`: >\n        ^\\s*\\ze\\i\\+\\s*[:]\\s*(*function\\s*(\n<\tWhen using the \":set\" command, you need to double the backslashes!\nTo avoid that use `:let` with a single quote string: >vim\n\tlet &l:define = '^\\s*\\ze\\k\\+\\s*=\\s*function('\n<"}}, define = {binding = "define", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'define' 'def'\t\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nPattern to be used to find a macro definition.  It is a search\npattern, just like for the \"/\" command.  This option is used for the\ncommands like \"[i\" and \"[d\" |include-search|.  The 'isident' option is\nused to recognize the defined name after the match: >\n\t{match with 'define'}{non-ID chars}{defined name}{non-ID char}\n<\tSee |option-backslash| about inserting backslashes to include a space\nor backslash.\nFor C++ this value would be useful, to include const type declarations: >\n\t^\\(#\\s*define\\|[a-z]*\\s*const\\s*[a-z]*\\)\n<\tYou can also use \"\\ze\" just before the name and continue the pattern\nto check what is following.  E.g. for Javascript, if a function is\ndefined with `func_name = function(args)`: >\n\t^\\s*\\ze\\i\\+\\s*=\\s*function(\n<\tIf the function is defined with `func_name : function() {...`: >\n        ^\\s*\\ze\\i\\+\\s*[:]\\s*(*function\\s*(\n<\tWhen using the \":set\" command, you need to double the backslashes!\nTo avoid that use `:let` with a single quote string: >vim\n\tlet &l:define = '^\\s*\\ze\\k\\+\\s*=\\s*function('\n<"}}, delcombine = {binding = "delcombine", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'delcombine' 'deco'\tboolean\t(default off)\n\t\tglobal\nIf editing Unicode and this option is set, backspace and Normal mode\n\"x\" delete each combining character on its own.  When it is off (the\ndefault) the character along with its combining characters are\ndeleted.\nNote: When 'delcombine' is set \"xx\" may work differently from \"2x\"!\n\nThis is useful for Arabic, Hebrew and many other languages where one\nmay have combining characters overtop of base characters, and want\nto remove only the combining ones."}}, dex = {binding = "dex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'diffexpr' 'dex'\tstring\t(default \"\")\n\t\tglobal\nExpression which is evaluated to obtain a diff file (either ed-style\nor unified-style) from two versions of a file.  See |diff-diffexpr|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, dg = {binding = "dg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'digraph' 'dg'\t\tboolean\t(default off)\n\t\tglobal\nEnable the entering of digraphs in Insert mode with {char1} <BS>\n{char2}.  See |digraphs|."}}, dict = {binding = "dict", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'dictionary' 'dict'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nList of file names, separated by commas, that are used to lookup words\nfor keyword completion commands |i_CTRL-X_CTRL-K|.  Each file should\ncontain a list of words.  This can be one word per line, or several\nwords per line, separated by non-keyword characters (white space is\npreferred).  Maximum line length is 510 bytes.\n\nWhen this option is empty or an entry \"spell\" is present, and spell\nchecking is enabled, words in the word lists for the currently active\n'spelllang' are used. See |spell|.\n\nTo include a comma in a file name precede it with a backslash.  Spaces\nafter a comma are ignored, otherwise spaces are included in the file\nname.  See |option-backslash| about using backslashes.\nThis has nothing to do with the |Dictionary| variable type.\nWhere to find a list of words?\n- BSD/macOS include the \"/usr/share/dict/words\" file.\n- Try \"apt install spell\" to get the \"/usr/share/dict/words\" file on\n  apt-managed systems (Debian/Ubuntu).\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\ndirectories from the list.  This avoids problems when a future version\nuses another default.\nBackticks cannot be used in this option for security reasons."}}, dictionary = {binding = "dictionary", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'dictionary' 'dict'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nList of file names, separated by commas, that are used to lookup words\nfor keyword completion commands |i_CTRL-X_CTRL-K|.  Each file should\ncontain a list of words.  This can be one word per line, or several\nwords per line, separated by non-keyword characters (white space is\npreferred).  Maximum line length is 510 bytes.\n\nWhen this option is empty or an entry \"spell\" is present, and spell\nchecking is enabled, words in the word lists for the currently active\n'spelllang' are used. See |spell|.\n\nTo include a comma in a file name precede it with a backslash.  Spaces\nafter a comma are ignored, otherwise spaces are included in the file\nname.  See |option-backslash| about using backslashes.\nThis has nothing to do with the |Dictionary| variable type.\nWhere to find a list of words?\n- BSD/macOS include the \"/usr/share/dict/words\" file.\n- Try \"apt install spell\" to get the \"/usr/share/dict/words\" file on\n  apt-managed systems (Debian/Ubuntu).\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\ndirectories from the list.  This avoids problems when a future version\nuses another default.\nBackticks cannot be used in this option for security reasons."}}, diff = {binding = "diff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'diff'\t\t\tboolean\t(default off)\n\t\tlocal to window\nJoin the current window in the group of windows that shows differences\nbetween files.  See |diff-mode|."}}, diffexpr = {binding = "diffexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'diffexpr' 'dex'\tstring\t(default \"\")\n\t\tglobal\nExpression which is evaluated to obtain a diff file (either ed-style\nor unified-style) from two versions of a file.  See |diff-diffexpr|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, diffopt = {binding = "diffopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'diffopt' 'dip'\t\tstring\t(default \"internal,filler,closeoff,linematch:40\")\n\t\tglobal\nOption settings for diff mode.  It can consist of the following items.\nAll are optional.  Items must be separated by a comma.\n\n\talgorithm:{text} Use the specified diff algorithm with the\n\t\t\tinternal diff engine. Currently supported\n\t\t\talgorithms are:\n\t\t\tmyers      the default algorithm\n\t\t\tminimal    spend extra time to generate the\n\t\t\t\t   smallest possible diff\n\t\t\tpatience   patience diff algorithm\n\t\t\thistogram  histogram diff algorithm\n\n\tcloseoff\tWhen a window is closed where 'diff' is set\n\t\t\tand there is only one window remaining in the\n\t\t\tsame tab page with 'diff' set, execute\n\t\t\t`:diffoff` in that window.  This undoes a\n\t\t\t`:diffsplit` command.\n\n\tcontext:{n}\tUse a context of {n} lines between a change\n\t\t\tand a fold that contains unchanged lines.\n\t\t\tWhen omitted a context of six lines is used.\n\t\t\tWhen using zero the context is actually one,\n\t\t\tsince folds require a line in between, also\n\t\t\tfor a deleted line. Set it to a very large\n\t\t\tvalue (999999) to disable folding completely.\n\t\t\tSee |fold-diff|.\n\n\tfiller\t\tShow filler lines, to keep the text\n\t\t\tsynchronized with a window that has inserted\n\t\t\tlines at the same position.  Mostly useful\n\t\t\twhen windows are side-by-side and 'scrollbind'\n\t\t\tis set.\n\n\tfoldcolumn:{n}\tSet the 'foldcolumn' option to {n} when\n\t\t\tstarting diff mode.  Without this 2 is used.\n\n\tfollowwrap\tFollow the 'wrap' option and leave as it is.\n\n\thorizontal\tStart diff mode with horizontal splits (unless\n\t\t\texplicitly specified otherwise).\n\n\thiddenoff\tDo not use diff mode for a buffer when it\n\t\t\tbecomes hidden.\n\n\tiblank\t\tIgnore changes where lines are all blank.  Adds\n\t\t\tthe \"-B\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.\n\t\t\tNOTE: the diff windows will get out of sync,\n\t\t\tbecause no differences between blank lines are\n\t\t\ttaken into account.\n\n\ticase\t\tIgnore changes in case of text.  \"a\" and \"A\"\n\t\t\tare considered the same.  Adds the \"-i\" flag\n\t\t\tto the \"diff\" command if 'diffexpr' is empty.\n\n\tindent-heuristic\n\t\t\tUse the indent heuristic for the internal\n\t\t\tdiff library.\n\n\tinternal\tUse the internal diff library.  This is\n\t\t\tignored when 'diffexpr' is set.  *E960*\n\t\t\tWhen running out of memory when writing a\n\t\t\tbuffer this item will be ignored for diffs\n\t\t\tinvolving that buffer.  Set the 'verbose'\n\t\t\toption to see when this happens.\n\n\tiwhite\t\tIgnore changes in amount of white space.  Adds\n\t\t\tthe \"-b\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.  It should ignore adding trailing\n\t\t\twhite space, but not leading white space.\n\n\tiwhiteall\tIgnore all white space changes.  Adds\n\t\t\tthe \"-w\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.\n\n\tiwhiteeol\tIgnore white space changes at end of line.\n\t\t\tAdds the \"-Z\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.\n\n\tlinematch:{n}   Align and mark changes between the most\n\t\t\tsimilar lines between the buffers. When the\n\t\t\ttotal number of lines in the diff hunk exceeds\n\t\t\t{n}, the lines will not be aligned because for\n\t\t\tvery large diff hunks there will be a\n\t\t\tnoticeable lag. A reasonable setting is\n\t\t\t\"linematch:60\", as this will enable alignment\n\t\t\tfor a 2 buffer diff hunk of 30 lines each,\n\t\t\tor a 3 buffer diff hunk of 20 lines each.\n\n\tvertical\tStart diff mode with vertical splits (unless\n\t\t\texplicitly specified otherwise).\n\nExamples: >vim\n\tset diffopt=internal,filler,context:4\n\tset diffopt=\n\tset diffopt=internal,filler,foldcolumn:3\n\tset diffopt-=internal  \" do NOT use the internal diff parser\n<"}}, digraph = {binding = "digraph", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'digraph' 'dg'\t\tboolean\t(default off)\n\t\tglobal\nEnable the entering of digraphs in Insert mode with {char1} <BS>\n{char2}.  See |digraphs|."}}, dip = {binding = "dip", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'diffopt' 'dip'\t\tstring\t(default \"internal,filler,closeoff,linematch:40\")\n\t\tglobal\nOption settings for diff mode.  It can consist of the following items.\nAll are optional.  Items must be separated by a comma.\n\n\talgorithm:{text} Use the specified diff algorithm with the\n\t\t\tinternal diff engine. Currently supported\n\t\t\talgorithms are:\n\t\t\tmyers      the default algorithm\n\t\t\tminimal    spend extra time to generate the\n\t\t\t\t   smallest possible diff\n\t\t\tpatience   patience diff algorithm\n\t\t\thistogram  histogram diff algorithm\n\n\tcloseoff\tWhen a window is closed where 'diff' is set\n\t\t\tand there is only one window remaining in the\n\t\t\tsame tab page with 'diff' set, execute\n\t\t\t`:diffoff` in that window.  This undoes a\n\t\t\t`:diffsplit` command.\n\n\tcontext:{n}\tUse a context of {n} lines between a change\n\t\t\tand a fold that contains unchanged lines.\n\t\t\tWhen omitted a context of six lines is used.\n\t\t\tWhen using zero the context is actually one,\n\t\t\tsince folds require a line in between, also\n\t\t\tfor a deleted line. Set it to a very large\n\t\t\tvalue (999999) to disable folding completely.\n\t\t\tSee |fold-diff|.\n\n\tfiller\t\tShow filler lines, to keep the text\n\t\t\tsynchronized with a window that has inserted\n\t\t\tlines at the same position.  Mostly useful\n\t\t\twhen windows are side-by-side and 'scrollbind'\n\t\t\tis set.\n\n\tfoldcolumn:{n}\tSet the 'foldcolumn' option to {n} when\n\t\t\tstarting diff mode.  Without this 2 is used.\n\n\tfollowwrap\tFollow the 'wrap' option and leave as it is.\n\n\thorizontal\tStart diff mode with horizontal splits (unless\n\t\t\texplicitly specified otherwise).\n\n\thiddenoff\tDo not use diff mode for a buffer when it\n\t\t\tbecomes hidden.\n\n\tiblank\t\tIgnore changes where lines are all blank.  Adds\n\t\t\tthe \"-B\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.\n\t\t\tNOTE: the diff windows will get out of sync,\n\t\t\tbecause no differences between blank lines are\n\t\t\ttaken into account.\n\n\ticase\t\tIgnore changes in case of text.  \"a\" and \"A\"\n\t\t\tare considered the same.  Adds the \"-i\" flag\n\t\t\tto the \"diff\" command if 'diffexpr' is empty.\n\n\tindent-heuristic\n\t\t\tUse the indent heuristic for the internal\n\t\t\tdiff library.\n\n\tinternal\tUse the internal diff library.  This is\n\t\t\tignored when 'diffexpr' is set.  *E960*\n\t\t\tWhen running out of memory when writing a\n\t\t\tbuffer this item will be ignored for diffs\n\t\t\tinvolving that buffer.  Set the 'verbose'\n\t\t\toption to see when this happens.\n\n\tiwhite\t\tIgnore changes in amount of white space.  Adds\n\t\t\tthe \"-b\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.  It should ignore adding trailing\n\t\t\twhite space, but not leading white space.\n\n\tiwhiteall\tIgnore all white space changes.  Adds\n\t\t\tthe \"-w\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.\n\n\tiwhiteeol\tIgnore white space changes at end of line.\n\t\t\tAdds the \"-Z\" flag to the \"diff\" command if\n\t\t\t'diffexpr' is empty.  Check the documentation\n\t\t\tof the \"diff\" command for what this does\n\t\t\texactly.\n\n\tlinematch:{n}   Align and mark changes between the most\n\t\t\tsimilar lines between the buffers. When the\n\t\t\ttotal number of lines in the diff hunk exceeds\n\t\t\t{n}, the lines will not be aligned because for\n\t\t\tvery large diff hunks there will be a\n\t\t\tnoticeable lag. A reasonable setting is\n\t\t\t\"linematch:60\", as this will enable alignment\n\t\t\tfor a 2 buffer diff hunk of 30 lines each,\n\t\t\tor a 3 buffer diff hunk of 20 lines each.\n\n\tvertical\tStart diff mode with vertical splits (unless\n\t\t\texplicitly specified otherwise).\n\nExamples: >vim\n\tset diffopt=internal,filler,context:4\n\tset diffopt=\n\tset diffopt=internal,filler,foldcolumn:3\n\tset diffopt-=internal  \" do NOT use the internal diff parser\n<"}}, dir = {binding = "dir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'directory' 'dir'\tstring\t(default \"$XDG_STATE_HOME/nvim/swap//\")\n\t\tglobal\nList of directory names for the swap file, separated with commas.\n\nPossible items:\n- The swap file will be created in the first directory where this is\n  possible.  If it is not possible in any directory, but last\n  directory listed in the option does not exist, it is created.\n- Empty means that no swap file will be used (recovery is\n  impossible!) and no |E303| error will be given.\n- A directory \".\" means to put the swap file in the same directory as\n  the edited file.  On Unix, a dot is prepended to the file name, so\n  it doesn't show in a directory listing.  On MS-Windows the \"hidden\"\n  attribute is set and a dot prepended if possible.\n- A directory starting with \"./\" (or \".\\\" for MS-Windows) means to put\n  the swap file relative to where the edited file is.  The leading \".\"\n  is replaced with the path name of the edited file.\n- For Unix and Win32, if a directory ends in two path separators \"//\",\n  the swap file name will be built from the complete path to the file\n  with all path separators replaced by percent '%' signs (including\n  the colon following the drive letter on Win32). This will ensure\n  file name uniqueness in the preserve directory.\n  On Win32, it is also possible to end with \"\\\\\".  However, When a\n  separating comma is following, you must use \"//\", since \"\\\\\" will\n  include the comma in the file name. Therefore it is recommended to\n  use '//', instead of '\\\\'.\n- Spaces after the comma are ignored, other spaces are considered part\n  of the directory name.  To have a space at the start of a directory\n  name, precede it with a backslash.\n- To include a comma in a directory name precede it with a backslash.\n- A directory name may end in an ':' or '/'.\n- Environment variables are expanded |:set_env|.\n- Careful with '\\' characters, type one before a space, type two to\n  get one in the option (see |option-backslash|), for example: >vim\n    set dir=c:\\\\tmp,\\ dir\\\\,with\\\\,commas,\\\\\\ dir\\ with\\ spaces\n<\nEditing the same file twice will result in a warning.  Using \"/tmp\" on\nis discouraged: if the system crashes you lose the swap file. And\nothers on the computer may be able to see the files.\nUse |:set+=| and |:set-=| when adding or removing directories from the\nlist, this avoids problems if the Nvim default is changed.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, directory = {binding = "directory", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'directory' 'dir'\tstring\t(default \"$XDG_STATE_HOME/nvim/swap//\")\n\t\tglobal\nList of directory names for the swap file, separated with commas.\n\nPossible items:\n- The swap file will be created in the first directory where this is\n  possible.  If it is not possible in any directory, but last\n  directory listed in the option does not exist, it is created.\n- Empty means that no swap file will be used (recovery is\n  impossible!) and no |E303| error will be given.\n- A directory \".\" means to put the swap file in the same directory as\n  the edited file.  On Unix, a dot is prepended to the file name, so\n  it doesn't show in a directory listing.  On MS-Windows the \"hidden\"\n  attribute is set and a dot prepended if possible.\n- A directory starting with \"./\" (or \".\\\" for MS-Windows) means to put\n  the swap file relative to where the edited file is.  The leading \".\"\n  is replaced with the path name of the edited file.\n- For Unix and Win32, if a directory ends in two path separators \"//\",\n  the swap file name will be built from the complete path to the file\n  with all path separators replaced by percent '%' signs (including\n  the colon following the drive letter on Win32). This will ensure\n  file name uniqueness in the preserve directory.\n  On Win32, it is also possible to end with \"\\\\\".  However, When a\n  separating comma is following, you must use \"//\", since \"\\\\\" will\n  include the comma in the file name. Therefore it is recommended to\n  use '//', instead of '\\\\'.\n- Spaces after the comma are ignored, other spaces are considered part\n  of the directory name.  To have a space at the start of a directory\n  name, precede it with a backslash.\n- To include a comma in a directory name precede it with a backslash.\n- A directory name may end in an ':' or '/'.\n- Environment variables are expanded |:set_env|.\n- Careful with '\\' characters, type one before a space, type two to\n  get one in the option (see |option-backslash|), for example: >vim\n    set dir=c:\\\\tmp,\\ dir\\\\,with\\\\,commas,\\\\\\ dir\\ with\\ spaces\n<\nEditing the same file twice will result in a warning.  Using \"/tmp\" on\nis discouraged: if the system crashes you lose the swap file. And\nothers on the computer may be able to see the files.\nUse |:set+=| and |:set-=| when adding or removing directories from the\nlist, this avoids problems if the Nvim default is changed.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, display = {binding = "display", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'display' 'dy'\t\tstring\t(default \"lastline\")\n\t\tglobal\nChange the way text is displayed.  This is a comma-separated list of\nflags:\nlastline\tWhen included, as much as possible of the last line\n\t\tin a window will be displayed.  \"@@@\" is put in the\n\t\tlast columns of the last screen line to indicate the\n\t\trest of the line is not displayed.\ntruncate\tLike \"lastline\", but \"@@@\" is displayed in the first\n\t\tcolumn of the last screen line.  Overrules \"lastline\".\nuhex\t\tShow unprintable characters hexadecimal as <xx>\n\t\tinstead of using ^C and ~C.\nmsgsep\t\tObsolete flag. Allowed but takes no effect. |msgsep|\n\nWhen neither \"lastline\" nor \"truncate\" is included, a last line that\ndoesn't fit is replaced with \"@\" lines.\n\nThe \"@\" character can be changed by setting the \"lastline\" item in\n'fillchars'.  The character is highlighted with |hl-NonText|."}}, dy = {binding = "dy", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'display' 'dy'\t\tstring\t(default \"lastline\")\n\t\tglobal\nChange the way text is displayed.  This is a comma-separated list of\nflags:\nlastline\tWhen included, as much as possible of the last line\n\t\tin a window will be displayed.  \"@@@\" is put in the\n\t\tlast columns of the last screen line to indicate the\n\t\trest of the line is not displayed.\ntruncate\tLike \"lastline\", but \"@@@\" is displayed in the first\n\t\tcolumn of the last screen line.  Overrules \"lastline\".\nuhex\t\tShow unprintable characters hexadecimal as <xx>\n\t\tinstead of using ^C and ~C.\nmsgsep\t\tObsolete flag. Allowed but takes no effect. |msgsep|\n\nWhen neither \"lastline\" nor \"truncate\" is included, a last line that\ndoesn't fit is replaced with \"@\" lines.\n\nThe \"@\" character can be changed by setting the \"lastline\" item in\n'fillchars'.  The character is highlighted with |hl-NonText|."}}, ea = {binding = "ea", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'equalalways' 'ea'\tboolean\t(default on)\n\t\tglobal\nWhen on, all the windows are automatically made the same size after\nsplitting or closing a window.  This also happens the moment the\noption is switched on.  When off, splitting a window will reduce the\nsize of the current window and leave the other windows the same.  When\nclosing a window the extra lines are given to the window next to it\n(depending on 'splitbelow' and 'splitright').\nWhen mixing vertically and horizontally split windows, a minimal size\nis computed and some windows may be larger if there is room.  The\n'eadirection' option tells in which direction the size is affected.\nChanging the height and width of a window can be avoided by setting\n'winfixheight' and 'winfixwidth', respectively.\nIf a window size is specified when creating a new window sizes are\ncurrently not equalized (it's complicated, but may be implemented in\nthe future)."}}, ead = {binding = "ead", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'eadirection' 'ead'\tstring\t(default \"both\")\n\t\tglobal\nTells when the 'equalalways' option applies:\n\tver\tvertically, width of windows is not affected\n\thor\thorizontally, height of windows is not affected\n\tboth\twidth and height of windows is affected"}}, eadirection = {binding = "eadirection", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'eadirection' 'ead'\tstring\t(default \"both\")\n\t\tglobal\nTells when the 'equalalways' option applies:\n\tver\tvertically, width of windows is not affected\n\thor\thorizontally, height of windows is not affected\n\tboth\twidth and height of windows is affected"}}, eb = {binding = "eb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorbells' 'eb'\tboolean\t(default off)\n\t\tglobal\nRing the bell (beep or screen flash) for error messages.  This only\nmakes a difference for error messages, the bell will be used always\nfor a lot of errors without a message (e.g., hitting <Esc> in Normal\nmode).  See 'visualbell' to make the bell behave like a screen flash\nor do nothing. See 'belloff' to finetune when to ring the bell."}}, ef = {binding = "ef", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorfile' 'ef'\tstring\t(default \"errors.err\")\n\t\tglobal\nName of the errorfile for the QuickFix mode (see |:cf|).\nWhen the \"-q\" command-line argument is used, 'errorfile' is set to the\nfollowing argument.  See |-q|.\nNOT used for the \":make\" command.  See 'makeef' for that.\nEnvironment variables are expanded |:set_env|.\nSee |option-backslash| about including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, efm = {binding = "efm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorformat' 'efm'\tstring\t(default is very long)\n\t\tglobal or local to buffer |global-local|\nScanf-like description of the format for the lines in the error file\n(see |errorformat|)."}}, ei = {binding = "ei", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'eventignore' 'ei'\tstring\t(default \"\")\n\t\tglobal\nA list of autocommand event names, which are to be ignored.\nWhen set to \"all\" or when \"all\" is one of the items, all autocommand\nevents are ignored, autocommands will not be executed.\nOtherwise this is a comma-separated list of event names.  Example: >vim\n    set ei=WinEnter,WinLeave\n<"}}, eiw = {binding = "eiw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'eventignorewin' 'eiw'\tstring\t(default \"\")\n\t\tlocal to window\nSimilar to 'eventignore' but applies to a particular window and its\nbuffers, for which window and buffer related autocommands can be\nignored indefinitely without affecting the global 'eventignore'."}}, emo = {binding = "emo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'emoji' 'emo'\t\tboolean\t(default on)\n\t\tglobal\nWhen on all Unicode emoji characters are considered to be full width.\nThis excludes \"text emoji\" characters, which are normally displayed as\nsingle width. However, such \"text emoji\" are treated as full-width\nemoji if they are followed by the U+FE0F variant selector.\n\nUnfortunately there is no good specification for this and it has been\ndetermined on trial-and-error basis.  Use the |setcellwidths()|\nfunction to change the behavior."}}, emoji = {binding = "emoji", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'emoji' 'emo'\t\tboolean\t(default on)\n\t\tglobal\nWhen on all Unicode emoji characters are considered to be full width.\nThis excludes \"text emoji\" characters, which are normally displayed as\nsingle width. However, such \"text emoji\" are treated as full-width\nemoji if they are followed by the U+FE0F variant selector.\n\nUnfortunately there is no good specification for this and it has been\ndetermined on trial-and-error basis.  Use the |setcellwidths()|\nfunction to change the behavior."}}, enc = {binding = "enc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'encoding' 'enc'\tstring\t(default \"utf-8\")\n\t\tglobal\nString-encoding used internally and for |RPC| communication.\nAlways UTF-8.\n\nSee 'fileencoding' to control file-content encoding."}}, encoding = {binding = "encoding", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'encoding' 'enc'\tstring\t(default \"utf-8\")\n\t\tglobal\nString-encoding used internally and for |RPC| communication.\nAlways UTF-8.\n\nSee 'fileencoding' to control file-content encoding."}}, endoffile = {binding = "endoffile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endoffile' 'eof'\tboolean\t(default off)\n\t\tlocal to buffer\nIndicates that a CTRL-Z character was found at the end of the file\nwhen reading it.  Normally only happens when 'fileformat' is \"dos\".\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no CTRL-Z will be written at the\nend of the file.\nSee |eol-and-eof| for example settings."}}, endofline = {binding = "endofline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endofline' 'eol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no <EOL> will be written for the\nlast line in the file.  This option is automatically set or reset when\nstarting to edit a new file, depending on whether file has an <EOL>\nfor the last line in the file.  Normally you don't have to set or\nreset this option.\nWhen 'binary' is off and 'fixeol' is on the value is not used when\nwriting the file.  When 'binary' is on or 'fixeol' is off it is used\nto remember the presence of a <EOL> for the last line in the file, so\nthat when you write the file the situation from the original file can\nbe kept.  But you can change it if you want to.\nSee |eol-and-eof| for example settings."}}, eof = {binding = "eof", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endoffile' 'eof'\tboolean\t(default off)\n\t\tlocal to buffer\nIndicates that a CTRL-Z character was found at the end of the file\nwhen reading it.  Normally only happens when 'fileformat' is \"dos\".\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no CTRL-Z will be written at the\nend of the file.\nSee |eol-and-eof| for example settings."}}, eol = {binding = "eol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endofline' 'eol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no <EOL> will be written for the\nlast line in the file.  This option is automatically set or reset when\nstarting to edit a new file, depending on whether file has an <EOL>\nfor the last line in the file.  Normally you don't have to set or\nreset this option.\nWhen 'binary' is off and 'fixeol' is on the value is not used when\nwriting the file.  When 'binary' is on or 'fixeol' is off it is used\nto remember the presence of a <EOL> for the last line in the file, so\nthat when you write the file the situation from the original file can\nbe kept.  But you can change it if you want to.\nSee |eol-and-eof| for example settings."}}, ep = {binding = "ep", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'equalprg' 'ep'\t\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nExternal program to use for \"=\" command.  When this option is empty\nthe internal formatting functions are used; either 'lisp', 'cindent'\nor 'indentexpr'.\nEnvironment variables are expanded |:set_env|.  See |option-backslash|\nabout including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, equalalways = {binding = "equalalways", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'equalalways' 'ea'\tboolean\t(default on)\n\t\tglobal\nWhen on, all the windows are automatically made the same size after\nsplitting or closing a window.  This also happens the moment the\noption is switched on.  When off, splitting a window will reduce the\nsize of the current window and leave the other windows the same.  When\nclosing a window the extra lines are given to the window next to it\n(depending on 'splitbelow' and 'splitright').\nWhen mixing vertically and horizontally split windows, a minimal size\nis computed and some windows may be larger if there is room.  The\n'eadirection' option tells in which direction the size is affected.\nChanging the height and width of a window can be avoided by setting\n'winfixheight' and 'winfixwidth', respectively.\nIf a window size is specified when creating a new window sizes are\ncurrently not equalized (it's complicated, but may be implemented in\nthe future)."}}, equalprg = {binding = "equalprg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'equalprg' 'ep'\t\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nExternal program to use for \"=\" command.  When this option is empty\nthe internal formatting functions are used; either 'lisp', 'cindent'\nor 'indentexpr'.\nEnvironment variables are expanded |:set_env|.  See |option-backslash|\nabout including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, errorbells = {binding = "errorbells", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorbells' 'eb'\tboolean\t(default off)\n\t\tglobal\nRing the bell (beep or screen flash) for error messages.  This only\nmakes a difference for error messages, the bell will be used always\nfor a lot of errors without a message (e.g., hitting <Esc> in Normal\nmode).  See 'visualbell' to make the bell behave like a screen flash\nor do nothing. See 'belloff' to finetune when to ring the bell."}}, errorfile = {binding = "errorfile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorfile' 'ef'\tstring\t(default \"errors.err\")\n\t\tglobal\nName of the errorfile for the QuickFix mode (see |:cf|).\nWhen the \"-q\" command-line argument is used, 'errorfile' is set to the\nfollowing argument.  See |-q|.\nNOT used for the \":make\" command.  See 'makeef' for that.\nEnvironment variables are expanded |:set_env|.\nSee |option-backslash| about including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, errorformat = {binding = "errorformat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorformat' 'efm'\tstring\t(default is very long)\n\t\tglobal or local to buffer |global-local|\nScanf-like description of the format for the lines in the error file\n(see |errorformat|)."}}, et = {binding = "et", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'expandtab' 'et'\tboolean\t(default off)\n\t\tlocal to buffer\nIn Insert mode: Use the appropriate number of spaces to insert a\n<Tab>.  Spaces are used in indents with the '>' and '<' commands and\nwhen 'autoindent' is on.  To insert a real tab when 'expandtab' is\non, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|."}}, eventignore = {binding = "eventignore", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'eventignore' 'ei'\tstring\t(default \"\")\n\t\tglobal\nA list of autocommand event names, which are to be ignored.\nWhen set to \"all\" or when \"all\" is one of the items, all autocommand\nevents are ignored, autocommands will not be executed.\nOtherwise this is a comma-separated list of event names.  Example: >vim\n    set ei=WinEnter,WinLeave\n<"}}, eventignorewin = {binding = "eventignorewin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'eventignorewin' 'eiw'\tstring\t(default \"\")\n\t\tlocal to window\nSimilar to 'eventignore' but applies to a particular window and its\nbuffers, for which window and buffer related autocommands can be\nignored indefinitely without affecting the global 'eventignore'."}}, ex = {binding = "ex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'exrc' 'ex'\t\tboolean\t(default off)\n\t\tglobal\nEnables project-local configuration. Nvim will execute any .nvim.lua,\n.nvimrc, or .exrc file found in the |current-directory|, if the file is\nin the |trust| list. Use |:trust| to manage trusted files. See also\n|vim.secure.read()|.\n\nTo get its own location, Lua exrc files can use |debug.getinfo()|.\n\nCompare 'exrc' to |editorconfig|:\n- 'exrc' can execute any code; editorconfig only specifies settings.\n- 'exrc' is Nvim-specific; editorconfig works in other editors.\n\nTo achieve project-local LSP configuration:\n1. Enable 'exrc'.\n2. Place LSP configs at \".nvim/lsp/*.lua\" in your project root.\n3. Create \".nvim.lua\" in your project root directory with this line: >lua\n     vim.cmd[[set runtimepath+=.nvim]]\n<\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, expandtab = {binding = "expandtab", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'expandtab' 'et'\tboolean\t(default off)\n\t\tlocal to buffer\nIn Insert mode: Use the appropriate number of spaces to insert a\n<Tab>.  Spaces are used in indents with the '>' and '<' commands and\nwhen 'autoindent' is on.  To insert a real tab when 'expandtab' is\non, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|."}}, exrc = {binding = "exrc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'exrc' 'ex'\t\tboolean\t(default off)\n\t\tglobal\nEnables project-local configuration. Nvim will execute any .nvim.lua,\n.nvimrc, or .exrc file found in the |current-directory|, if the file is\nin the |trust| list. Use |:trust| to manage trusted files. See also\n|vim.secure.read()|.\n\nTo get its own location, Lua exrc files can use |debug.getinfo()|.\n\nCompare 'exrc' to |editorconfig|:\n- 'exrc' can execute any code; editorconfig only specifies settings.\n- 'exrc' is Nvim-specific; editorconfig works in other editors.\n\nTo achieve project-local LSP configuration:\n1. Enable 'exrc'.\n2. Place LSP configs at \".nvim/lsp/*.lua\" in your project root.\n3. Create \".nvim.lua\" in your project root directory with this line: >lua\n     vim.cmd[[set runtimepath+=.nvim]]\n<\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, fcl = {binding = "fcl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldclose' 'fcl'\tstring\t(default \"\")\n\t\tglobal\nWhen set to \"all\", a fold is closed when the cursor isn't in it and\nits level is higher than 'foldlevel'.  Useful if you want folds to\nautomatically close when moving out of them."}}, fcs = {binding = "fcs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fillchars' 'fcs'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nCharacters to fill the statuslines, vertical separators and special\nlines in the window.\nIt is a comma-separated list of items.  Each item has a name, a colon\nand the value of that item: |E1511|\n\n  item\t\tdefault\t\tUsed for ~\n  stl\t\t' '\t\tstatusline of the current window\n  stlnc\t\t' '\t\tstatusline of the non-current windows\n  wbr\t\t' '\t\twindow bar\n  horiz\t\t'\226\148\128' or '-'\thorizontal separators |:split|\n  horizup\t'\226\148\180' or '-'\tupwards facing horizontal separator\n  horizdown\t'\226\148\172' or '-'\tdownwards facing horizontal separator\n  vert\t\t'\226\148\130' or '|'\tvertical separators |:vsplit|\n  vertleft\t'\226\148\164' or '|'\tleft facing vertical separator\n  vertright\t'\226\148\156' or '|'\tright facing vertical separator\n  verthoriz\t'\226\148\188' or '+'\toverlapping vertical and horizontal\n\t\t\t\tseparator\n  fold\t\t'\194\183' or '-'\tfilling 'foldtext'\n  foldopen\t'-'\t\tmark the beginning of a fold\n  foldclose\t'+'\t\tshow a closed fold\n  foldsep\t'\226\148\130' or '|'      open fold middle marker\n  diff\t\t'-'\t\tdeleted lines of the 'diff' option\n  msgsep\t' '\t\tmessage separator 'display'\n  eob\t\t'~'\t\tempty lines at the end of a buffer\n  lastline\t'@'\t\t'display' contains lastline/truncate\n\nAny one that is omitted will fall back to the default.\n\nNote that \"horiz\", \"horizup\", \"horizdown\", \"vertleft\", \"vertright\" and\n\"verthoriz\" are only used when 'laststatus' is 3, since only vertical\nwindow separators are used otherwise.\n\nIf 'ambiwidth' is \"double\" then \"horiz\", \"horizup\", \"horizdown\",\n\"vert\", \"vertleft\", \"vertright\", \"verthoriz\", \"foldsep\" and \"fold\"\ndefault to single-byte alternatives.\n\nExample: >vim\n    set fillchars=stl:\\ ,stlnc:\\ ,vert:\226\148\130,fold:\194\183,diff:-\n<\nFor the \"stl\", \"stlnc\", \"foldopen\", \"foldclose\" and \"foldsep\" items\nsingle-byte and multibyte characters are supported.  But double-width\ncharacters are not supported. |E1512|\n\nThe highlighting used for these items:\n  item\t\thighlight group ~\n  stl\t\tStatusLine\t\t|hl-StatusLine|\n  stlnc\t\tStatusLineNC\t\t|hl-StatusLineNC|\n  wbr\t\tWinBar\t\t\t|hl-WinBar| or |hl-WinBarNC|\n  horiz\t\tWinSeparator\t\t|hl-WinSeparator|\n  horizup\tWinSeparator\t\t|hl-WinSeparator|\n  horizdown\tWinSeparator\t\t|hl-WinSeparator|\n  vert\t\tWinSeparator\t\t|hl-WinSeparator|\n  vertleft\tWinSeparator\t\t|hl-WinSeparator|\n  vertright\tWinSeparator\t\t|hl-WinSeparator|\n  verthoriz\tWinSeparator\t\t|hl-WinSeparator|\n  fold\t\tFolded\t\t\t|hl-Folded|\n  diff\t\tDiffDelete\t\t|hl-DiffDelete|\n  eob\t\tEndOfBuffer\t\t|hl-EndOfBuffer|\n  lastline\tNonText\t\t\t|hl-NonText|"}}, fdc = {binding = "fdc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldcolumn' 'fdc'\tstring\t(default \"0\")\n\t\tlocal to window\nWhen and how to draw the foldcolumn. Valid values are:\n    \"auto\":       resize to the minimum amount of folds to display.\n    \"auto:[1-9]\": resize to accommodate multiple folds up to the\n\t\t  selected level\n    \"0\":          to disable foldcolumn\n    \"[1-9]\":      to display a fixed number of columns\nSee |folding|."}}, fde = {binding = "fde", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldexpr' 'fde'\tstring\t(default \"0\")\n\t\tlocal to window\nThe expression used for when 'foldmethod' is \"expr\".  It is evaluated\nfor each line to obtain its fold level.  The context is set to the\nscript where 'foldexpr' was set, script-local items can be accessed.\nSee |fold-expr| for the usage.\n\nThe expression will be evaluated in the |sandbox| if set from a\nmodeline, see |sandbox-option|.\nThis option can't be set from a |modeline| when the 'diff' option is\non or the 'modelineexpr' option is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'foldexpr' |textlock|."}}, fdi = {binding = "fdi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldignore' 'fdi'\tstring\t(default \"#\")\n\t\tlocal to window\nUsed only when 'foldmethod' is \"indent\".  Lines starting with\ncharacters in 'foldignore' will get their fold level from surrounding\nlines.  White space is skipped before checking for this character.\nThe default \"#\" works well for C programs.  See |fold-indent|."}}, fdl = {binding = "fdl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldlevel' 'fdl'\tnumber\t(default 0)\n\t\tlocal to window\nSets the fold level: Folds with a higher level will be closed.\nSetting this option to zero will close all folds.  Higher numbers will\nclose fewer folds.\nThis option is set by commands like |zm|, |zM| and |zR|.\nSee |fold-foldlevel|."}}, fdls = {binding = "fdls", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldlevelstart' 'fdls'\tnumber\t(default -1)\n\t\tglobal\nSets 'foldlevel' when starting to edit another buffer in a window.\nUseful to always start editing with all folds closed (value zero),\nsome folds closed (one) or no folds closed (99).\nThis is done before reading any modeline, thus a setting in a modeline\noverrules this option.  Starting to edit a file for |diff-mode| also\nignores this option and closes all folds.\nIt is also done before BufReadPre autocommands, to allow an autocmd to\noverrule the 'foldlevel' value for specific files.\nWhen the value is negative, it is not used."}}, fdm = {binding = "fdm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldmethod' 'fdm'\tstring\t(default \"manual\")\n\t\tlocal to window\nThe kind of folding used for the current window.  Possible values:\n|fold-manual|\tmanual\t    Folds are created manually.\n|fold-indent|\tindent\t    Lines with equal indent form a fold.\n|fold-expr|\texpr\t    'foldexpr' gives the fold level of a line.\n|fold-marker|\tmarker\t    Markers are used to specify folds.\n|fold-syntax|\tsyntax\t    Syntax highlighting items specify folds.\n|fold-diff|\tdiff\t    Fold text that is not changed."}}, fdn = {binding = "fdn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldnestmax' 'fdn'\tnumber\t(default 20)\n\t\tlocal to window\nSets the maximum nesting of folds for the \"indent\" and \"syntax\"\nmethods.  This avoids that too many folds will be created.  Using more\nthan 20 doesn't work, because the internal limit is 20."}}, fdo = {binding = "fdo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldopen' 'fdo'\tstring\t(default \"block,hor,mark,percent,quickfix,search,tag,undo\")\n\t\tglobal\nSpecifies for which type of commands folds will be opened, if the\ncommand moves the cursor into a closed fold.  It is a comma-separated\nlist of items.\nNOTE: When the command is part of a mapping this option is not used.\nAdd the |zv| command to the mapping to get the same effect.\n(rationale: the mapping may want to control opening folds itself)\n\n\titem\t\tcommands ~\n\tall\t\tany\n\tblock\t\t(, {, [[, [{, etc.\n\thor\t\thorizontal movements: \"l\", \"w\", \"fx\", etc.\n\tinsert\t\tany command in Insert mode\n\tjump\t\tfar jumps: \"G\", \"gg\", etc.\n\tmark\t\tjumping to a mark: \"'m\", CTRL-O, etc.\n\tpercent\t\t\"%\"\n\tquickfix\t\":cn\", \":crew\", \":make\", etc.\n\tsearch\t\tsearch for a pattern: \"/\", \"n\", \"*\", \"gd\", etc.\n\t\t\t(not for a search pattern in a \":\" command)\n\t\t\tAlso for |[s| and |]s|.\n\ttag\t\tjumping to a tag: \":ta\", CTRL-T, etc.\n\tundo\t\tundo or redo: \"u\" and CTRL-R\nWhen a movement command is used for an operator (e.g., \"dl\" or \"y%\")\nthis option is not used.  This means the operator will include the\nwhole closed fold.\nNote that vertical movements are not here, because it would make it\nvery difficult to move onto a closed fold.\nIn insert mode the folds containing the cursor will always be open\nwhen text is inserted.\nTo close folds you can re-apply 'foldlevel' with the |zx| command or\nset the 'foldclose' option to \"all\"."}}, fdt = {binding = "fdt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldtext' 'fdt'\tstring\t(default \"foldtext()\")\n\t\tlocal to window\nAn expression which is used to specify the text displayed for a closed\nfold.  The context is set to the script where 'foldexpr' was set,\nscript-local items can be accessed.  See |fold-foldtext| for the\nusage.\n\nThe expression will be evaluated in the |sandbox| if set from a\nmodeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'foldtext' |textlock|.\n\nWhen set to an empty string, foldtext is disabled, and the line\nis displayed normally with highlighting and no line wrapping."}}, fen = {binding = "fen", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldenable' 'fen'\tboolean\t(default on)\n\t\tlocal to window\nWhen off, all folds are open.  This option can be used to quickly\nswitch between showing all text unfolded and viewing the text with\nfolds (including manually opened or closed folds).  It can be toggled\nwith the |zi| command.  The 'foldcolumn' will remain blank when\n'foldenable' is off.\nThis option is set by commands that create a new fold or close a fold.\nSee |folding|."}}, fenc = {binding = "fenc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileencoding' 'fenc'\tstring\t(default \"\")\n\t\tlocal to buffer\nFile-content encoding for the current buffer. Conversion is done with\niconv() or as specified with 'charconvert'.\n\nWhen 'fileencoding' is not UTF-8, conversion will be done when\nwriting the file.  For reading see below.\nWhen 'fileencoding' is empty, the file will be saved with UTF-8\nencoding (no conversion when reading or writing a file).\n\nWARNING: Conversion to a non-Unicode encoding can cause loss of\ninformation!\n\nSee |encoding-names| for the possible values.  Additionally, values may be\nspecified that can be handled by the converter, see\n|mbyte-conversion|.\n\nWhen reading a file 'fileencoding' will be set from 'fileencodings'.\nTo read a file in a certain encoding it won't work by setting\n'fileencoding', use the |++enc| argument.  One exception: when\n'fileencodings' is empty the value of 'fileencoding' is used.\nFor a new file the global value of 'fileencoding' is used.\n\nPrepending \"8bit-\" and \"2byte-\" has no meaning here, they are ignored.\nWhen the option is set, the value is converted to lowercase.  Thus\nyou can set it with uppercase values too.  '_' characters are\nreplaced with '-'.  If a name is recognized from the list at\n|encoding-names|, it is replaced by the standard name.  For example\n\"ISO8859-2\" becomes \"iso-8859-2\".\n\nWhen this option is set, after starting to edit a file, the 'modified'\noption is set, because the file would be different when written.\n\nKeep in mind that changing 'fenc' from a modeline happens\nAFTER the text has been read, thus it applies to when the file will be\nwritten.  If you do set 'fenc' in a modeline, you might want to set\n'nomodified' to avoid not being able to \":q\".\n\nThis option cannot be changed when 'modifiable' is off."}}, fencs = {binding = "fencs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileencodings' 'fencs'\tstring\t(default \"ucs-bom,utf-8,default,latin1\")\n\t\tglobal\nThis is a list of character encodings considered when starting to edit\nan existing file.  When a file is read, Vim tries to use the first\nmentioned character encoding.  If an error is detected, the next one\nin the list is tried.  When an encoding is found that works,\n'fileencoding' is set to it.  If all fail, 'fileencoding' is set to\nan empty string, which means that UTF-8 is used.\n\tWARNING: Conversion can cause loss of information! You can use\n\tthe |++bad| argument to specify what is done with characters\n\tthat can't be converted.\nFor an empty file or a file with only ASCII characters most encodings\nwill work and the first entry of 'fileencodings' will be used (except\n\"ucs-bom\", which requires the BOM to be present).  If you prefer\nanother encoding use an BufReadPost autocommand event to test if your\npreferred encoding is to be used.  Example: >vim\n\tau BufReadPost * if search('\\S', 'w') == 0 |\n\t\t\\ set fenc=iso-2022-jp | endif\n<\tThis sets 'fileencoding' to \"iso-2022-jp\" if the file does not contain\nnon-blank characters.\nWhen the |++enc| argument is used then the value of 'fileencodings' is\nnot used.\nNote that 'fileencodings' is not used for a new file, the global value\nof 'fileencoding' is used instead.  You can set it with: >vim\n\tsetglobal fenc=iso-8859-2\n<\tThis means that a non-existing file may get a different encoding than\nan empty file.\nThe special value \"ucs-bom\" can be used to check for a Unicode BOM\n(Byte Order Mark) at the start of the file.  It must not be preceded\nby \"utf-8\" or another Unicode encoding for this to work properly.\nAn entry for an 8-bit encoding (e.g., \"latin1\") should be the last,\nbecause Vim cannot detect an error, thus the encoding is always\naccepted.\nThe special value \"default\" can be used for the encoding from the\nenvironment.  It is useful when your environment uses a non-latin1\nencoding, such as Russian.\nWhen a file contains an illegal UTF-8 byte sequence it won't be\nrecognized as \"utf-8\".  You can use the |8g8| command to find the\nillegal byte sequence.\nWRONG VALUES:\t\t\tWHAT'S WRONG:\n\tlatin1,utf-8\t\t\"latin1\" will always be used\n\tutf-8,ucs-bom,latin1\tBOM won't be recognized in an utf-8\n\t\t\t\tfile\n\tcp1250,latin1\t\t\"cp1250\" will always be used\nIf 'fileencodings' is empty, 'fileencoding' is not modified.\nSee 'fileencoding' for the possible values.\nSetting this option does not have an effect until the next time a file\nis read."}}, fex = {binding = "fex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatexpr' 'fex'\tstring\t(default \"\")\n\t\tlocal to buffer\nExpression which is evaluated to format a range of lines for the |gq|\noperator or automatic formatting (see 'formatoptions').  When this\noption is empty 'formatprg' is used.\n\nThe |v:lnum|  variable holds the first line to be formatted.\nThe |v:count| variable holds the number of lines to be formatted.\nThe |v:char|  variable holds the character that is going to be\n\t      inserted if the expression is being evaluated due to\n\t      automatic formatting.  This can be empty.  Don't insert\n\t      it yet!\n\nExample: >vim\n\tset formatexpr=mylang#Format()\n<\tThis will invoke the mylang#Format() function in the\nautoload/mylang.vim file in 'runtimepath'. |autoload|\n\nThe advantage of using a function call without arguments is that it is\nfaster, see |expr-option-function|.\n\nThe expression is also evaluated when 'textwidth' is set and adding\ntext beyond that limit.  This happens under the same conditions as\nwhen internal formatting is used.  Make sure the cursor is kept in the\nsame spot relative to the text then!  The |mode()| function will\nreturn \"i\" or \"R\" in this situation.\n\nWhen the expression evaluates to non-zero Vim will fall back to using\nthe internal format mechanism.\n\nIf the expression starts with s: or |<SID>|, then it is replaced with\nthe script ID (|local-function|). Example: >vim\n\tset formatexpr=s:MyFormatExpr()\n\tset formatexpr=<SID>SomeFormatExpr()\n<\tOtherwise, the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nThe expression will be evaluated in the |sandbox| when set from a\nmodeline, see |sandbox-option|.  That stops the option from working,\nsince changing the buffer text is not allowed.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\nNOTE: This option is set to \"\" when 'compatible' is set."}}, ff = {binding = "ff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileformat' 'ff'\tstring\t(default Windows: \"dos\", Unix: \"unix\")\n\t\tlocal to buffer\nThis gives the <EOL> of the current buffer, which is used for\nreading/writing the buffer from/to a file:\n    dos\t    <CR><NL>\n    unix    <NL>\n    mac\t    <CR>\nWhen \"dos\" is used, CTRL-Z at the end of a file is ignored.\nSee |file-formats| and |file-read|.\nFor the character encoding of the file see 'fileencoding'.\nWhen 'binary' is set, the value of 'fileformat' is ignored, file I/O\nworks like it was set to \"unix\".\nThis option is set automatically when starting to edit a file and\n'fileformats' is not empty and 'binary' is off.\nWhen this option is set, after starting to edit a file, the 'modified'\noption is set, because the file would be different when written.\nThis option cannot be changed when 'modifiable' is off."}}, ffs = {binding = "ffs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileformats' 'ffs'\tstring\t(default Windows: \"dos,unix\", Unix: \"unix,dos\")\n\t\tglobal\nThis gives the end-of-line (<EOL>) formats that will be tried when\nstarting to edit a new buffer and when reading a file into an existing\nbuffer:\n- When empty, the format defined with 'fileformat' will be used\n  always.  It is not set automatically.\n- When set to one name, that format will be used whenever a new buffer\n  is opened.  'fileformat' is set accordingly for that buffer.  The\n  'fileformats' name will be used when a file is read into an existing\n  buffer, no matter what 'fileformat' for that buffer is set to.\n- When more than one name is present, separated by commas, automatic\n  <EOL> detection will be done when reading a file.  When starting to\n  edit a file, a check is done for the <EOL>:\n  1. If all lines end in <CR><NL>, and 'fileformats' includes \"dos\",\n     'fileformat' is set to \"dos\".\n  2. If a <NL> is found and 'fileformats' includes \"unix\", 'fileformat'\n     is set to \"unix\".  Note that when a <NL> is found without a\n     preceding <CR>, \"unix\" is preferred over \"dos\".\n  3. If 'fileformat' has not yet been set, and if a <CR> is found, and\n     if 'fileformats' includes \"mac\", 'fileformat' is set to \"mac\".\n     This means that \"mac\" is only chosen when:\n      \"unix\" is not present or no <NL> is found in the file, and\n      \"dos\" is not present or no <CR><NL> is found in the file.\n     Except: if \"unix\" was chosen, but there is a <CR> before\n     the first <NL>, and there appear to be more <CR>s than <NL>s in\n     the first few lines, \"mac\" is used.\n  4. If 'fileformat' is still not set, the first name from\n     'fileformats' is used.\n  When reading a file into an existing buffer, the same is done, but\n  this happens like 'fileformat' has been set appropriately for that\n  file only, the option is not changed.\nWhen 'binary' is set, the value of 'fileformats' is not used.\n\nWhen Vim starts up with an empty buffer the first item is used.  You\ncan overrule this by setting 'fileformat' in your .vimrc.\n\nFor systems with a Dos-like <EOL> (<CR><NL>), when reading files that\nare \":source\"ed and for vimrc files, automatic <EOL> detection may be\ndone:\n- When 'fileformats' is empty, there is no automatic detection.  Dos\n  format will be used.\n- When 'fileformats' is set to one or more names, automatic detection\n  is done.  This is based on the first <NL> in the file: If there is a\n  <CR> in front of it, Dos format is used, otherwise Unix format is\n  used.\nAlso see |file-formats|."}}, ffu = {binding = "ffu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'findfunc' 'ffu'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nFunction that is called to obtain the filename(s) for the |:find|\ncommand.  When this option is empty, the internal |file-searching|\nmechanism is used.\n\nThe value can be the name of a function, a |lambda| or a |Funcref|.\nSee |option-value-function| for more information.\n\nThe function is called with two arguments.  The first argument is a\n|String| and is the |:find| command argument.  The second argument is\na |Boolean| and is set to |v:true| when the function is called to get\na List of command-line completion matches for the |:find| command.\nThe function should return a List of strings.\n\nThe function is called only once per |:find| command invocation.\nThe function can process all the directories specified in 'path'.\n\nIf a match is found, the function should return a |List| containing\none or more file names.  If a match is not found, the function\nshould return an empty List.\n\nIf any errors are encountered during the function invocation, an\nempty List is used as the return value.\n\nIt is not allowed to change text or jump to another window while\nexecuting the 'findfunc' |textlock|.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n\nExamples:\n>vim\n    \" Use glob()\n    func FindFuncGlob(cmdarg, cmdcomplete)\n\tlet pat = a:cmdcomplete ? $'{a:cmdarg}*' : a:cmdarg\n\treturn glob(pat, v:false, v:true)\n    endfunc\n    set findfunc=FindFuncGlob\n\n    \" Use the 'git ls-files' output\n    func FindGitFiles(cmdarg, cmdcomplete)\n\tlet fnames = systemlist('git ls-files')\n\treturn fnames->filter('v:val =~? a:cmdarg')\n    endfunc\n    set findfunc=FindGitFiles\n<"}}, fic = {binding = "fic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileignorecase' 'fic'\tboolean\t(default on for systems where case in file\n                                 names is normally ignored)\n\t\tglobal\nWhen set case is ignored when using file names and directories.\nSee 'wildignorecase' for only ignoring case when doing completion."}}, fileencoding = {binding = "fileencoding", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileencoding' 'fenc'\tstring\t(default \"\")\n\t\tlocal to buffer\nFile-content encoding for the current buffer. Conversion is done with\niconv() or as specified with 'charconvert'.\n\nWhen 'fileencoding' is not UTF-8, conversion will be done when\nwriting the file.  For reading see below.\nWhen 'fileencoding' is empty, the file will be saved with UTF-8\nencoding (no conversion when reading or writing a file).\n\nWARNING: Conversion to a non-Unicode encoding can cause loss of\ninformation!\n\nSee |encoding-names| for the possible values.  Additionally, values may be\nspecified that can be handled by the converter, see\n|mbyte-conversion|.\n\nWhen reading a file 'fileencoding' will be set from 'fileencodings'.\nTo read a file in a certain encoding it won't work by setting\n'fileencoding', use the |++enc| argument.  One exception: when\n'fileencodings' is empty the value of 'fileencoding' is used.\nFor a new file the global value of 'fileencoding' is used.\n\nPrepending \"8bit-\" and \"2byte-\" has no meaning here, they are ignored.\nWhen the option is set, the value is converted to lowercase.  Thus\nyou can set it with uppercase values too.  '_' characters are\nreplaced with '-'.  If a name is recognized from the list at\n|encoding-names|, it is replaced by the standard name.  For example\n\"ISO8859-2\" becomes \"iso-8859-2\".\n\nWhen this option is set, after starting to edit a file, the 'modified'\noption is set, because the file would be different when written.\n\nKeep in mind that changing 'fenc' from a modeline happens\nAFTER the text has been read, thus it applies to when the file will be\nwritten.  If you do set 'fenc' in a modeline, you might want to set\n'nomodified' to avoid not being able to \":q\".\n\nThis option cannot be changed when 'modifiable' is off."}}, fileencodings = {binding = "fileencodings", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileencodings' 'fencs'\tstring\t(default \"ucs-bom,utf-8,default,latin1\")\n\t\tglobal\nThis is a list of character encodings considered when starting to edit\nan existing file.  When a file is read, Vim tries to use the first\nmentioned character encoding.  If an error is detected, the next one\nin the list is tried.  When an encoding is found that works,\n'fileencoding' is set to it.  If all fail, 'fileencoding' is set to\nan empty string, which means that UTF-8 is used.\n\tWARNING: Conversion can cause loss of information! You can use\n\tthe |++bad| argument to specify what is done with characters\n\tthat can't be converted.\nFor an empty file or a file with only ASCII characters most encodings\nwill work and the first entry of 'fileencodings' will be used (except\n\"ucs-bom\", which requires the BOM to be present).  If you prefer\nanother encoding use an BufReadPost autocommand event to test if your\npreferred encoding is to be used.  Example: >vim\n\tau BufReadPost * if search('\\S', 'w') == 0 |\n\t\t\\ set fenc=iso-2022-jp | endif\n<\tThis sets 'fileencoding' to \"iso-2022-jp\" if the file does not contain\nnon-blank characters.\nWhen the |++enc| argument is used then the value of 'fileencodings' is\nnot used.\nNote that 'fileencodings' is not used for a new file, the global value\nof 'fileencoding' is used instead.  You can set it with: >vim\n\tsetglobal fenc=iso-8859-2\n<\tThis means that a non-existing file may get a different encoding than\nan empty file.\nThe special value \"ucs-bom\" can be used to check for a Unicode BOM\n(Byte Order Mark) at the start of the file.  It must not be preceded\nby \"utf-8\" or another Unicode encoding for this to work properly.\nAn entry for an 8-bit encoding (e.g., \"latin1\") should be the last,\nbecause Vim cannot detect an error, thus the encoding is always\naccepted.\nThe special value \"default\" can be used for the encoding from the\nenvironment.  It is useful when your environment uses a non-latin1\nencoding, such as Russian.\nWhen a file contains an illegal UTF-8 byte sequence it won't be\nrecognized as \"utf-8\".  You can use the |8g8| command to find the\nillegal byte sequence.\nWRONG VALUES:\t\t\tWHAT'S WRONG:\n\tlatin1,utf-8\t\t\"latin1\" will always be used\n\tutf-8,ucs-bom,latin1\tBOM won't be recognized in an utf-8\n\t\t\t\tfile\n\tcp1250,latin1\t\t\"cp1250\" will always be used\nIf 'fileencodings' is empty, 'fileencoding' is not modified.\nSee 'fileencoding' for the possible values.\nSetting this option does not have an effect until the next time a file\nis read."}}, fileformat = {binding = "fileformat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileformat' 'ff'\tstring\t(default Windows: \"dos\", Unix: \"unix\")\n\t\tlocal to buffer\nThis gives the <EOL> of the current buffer, which is used for\nreading/writing the buffer from/to a file:\n    dos\t    <CR><NL>\n    unix    <NL>\n    mac\t    <CR>\nWhen \"dos\" is used, CTRL-Z at the end of a file is ignored.\nSee |file-formats| and |file-read|.\nFor the character encoding of the file see 'fileencoding'.\nWhen 'binary' is set, the value of 'fileformat' is ignored, file I/O\nworks like it was set to \"unix\".\nThis option is set automatically when starting to edit a file and\n'fileformats' is not empty and 'binary' is off.\nWhen this option is set, after starting to edit a file, the 'modified'\noption is set, because the file would be different when written.\nThis option cannot be changed when 'modifiable' is off."}}, fileformats = {binding = "fileformats", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileformats' 'ffs'\tstring\t(default Windows: \"dos,unix\", Unix: \"unix,dos\")\n\t\tglobal\nThis gives the end-of-line (<EOL>) formats that will be tried when\nstarting to edit a new buffer and when reading a file into an existing\nbuffer:\n- When empty, the format defined with 'fileformat' will be used\n  always.  It is not set automatically.\n- When set to one name, that format will be used whenever a new buffer\n  is opened.  'fileformat' is set accordingly for that buffer.  The\n  'fileformats' name will be used when a file is read into an existing\n  buffer, no matter what 'fileformat' for that buffer is set to.\n- When more than one name is present, separated by commas, automatic\n  <EOL> detection will be done when reading a file.  When starting to\n  edit a file, a check is done for the <EOL>:\n  1. If all lines end in <CR><NL>, and 'fileformats' includes \"dos\",\n     'fileformat' is set to \"dos\".\n  2. If a <NL> is found and 'fileformats' includes \"unix\", 'fileformat'\n     is set to \"unix\".  Note that when a <NL> is found without a\n     preceding <CR>, \"unix\" is preferred over \"dos\".\n  3. If 'fileformat' has not yet been set, and if a <CR> is found, and\n     if 'fileformats' includes \"mac\", 'fileformat' is set to \"mac\".\n     This means that \"mac\" is only chosen when:\n      \"unix\" is not present or no <NL> is found in the file, and\n      \"dos\" is not present or no <CR><NL> is found in the file.\n     Except: if \"unix\" was chosen, but there is a <CR> before\n     the first <NL>, and there appear to be more <CR>s than <NL>s in\n     the first few lines, \"mac\" is used.\n  4. If 'fileformat' is still not set, the first name from\n     'fileformats' is used.\n  When reading a file into an existing buffer, the same is done, but\n  this happens like 'fileformat' has been set appropriately for that\n  file only, the option is not changed.\nWhen 'binary' is set, the value of 'fileformats' is not used.\n\nWhen Vim starts up with an empty buffer the first item is used.  You\ncan overrule this by setting 'fileformat' in your .vimrc.\n\nFor systems with a Dos-like <EOL> (<CR><NL>), when reading files that\nare \":source\"ed and for vimrc files, automatic <EOL> detection may be\ndone:\n- When 'fileformats' is empty, there is no automatic detection.  Dos\n  format will be used.\n- When 'fileformats' is set to one or more names, automatic detection\n  is done.  This is based on the first <NL> in the file: If there is a\n  <CR> in front of it, Dos format is used, otherwise Unix format is\n  used.\nAlso see |file-formats|."}}, fileignorecase = {binding = "fileignorecase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileignorecase' 'fic'\tboolean\t(default on for systems where case in file\n                                 names is normally ignored)\n\t\tglobal\nWhen set case is ignored when using file names and directories.\nSee 'wildignorecase' for only ignoring case when doing completion."}}, filetype = {binding = "filetype", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'filetype' 'ft'\t\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nWhen this option is set, the FileType autocommand event is triggered.\nAll autocommands that match with the value of this option will be\nexecuted.  Thus the value of 'filetype' is used in place of the file\nname.\nOtherwise this option does not always reflect the current file type.\nThis option is normally set when the file type is detected.  To enable\nthis use the \":filetype on\" command. |:filetype|\nSetting this option to a different value is most useful in a modeline,\nfor a file for which the file type is not automatically recognized.\nExample, for in an IDL file: >c\n\t/* vim: set filetype=idl : */\n<\t|FileType| |filetypes|\nWhen a dot appears in the value then this separates two filetype\nnames, it should therefore not be used for a filetype.  Example: >c\n\t/* vim: set filetype=c.doxygen : */\n<\tThis will use the \"c\" filetype first, then the \"doxygen\" filetype.\nThis works both for filetype plugins and for syntax files.  More than\none dot may appear.\nThis option is not copied to another buffer, independent of the 's' or\n'S' flag in 'cpoptions'.\nOnly alphanumeric characters, '-' and '_' can be used."}}, fillchars = {binding = "fillchars", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fillchars' 'fcs'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nCharacters to fill the statuslines, vertical separators and special\nlines in the window.\nIt is a comma-separated list of items.  Each item has a name, a colon\nand the value of that item: |E1511|\n\n  item\t\tdefault\t\tUsed for ~\n  stl\t\t' '\t\tstatusline of the current window\n  stlnc\t\t' '\t\tstatusline of the non-current windows\n  wbr\t\t' '\t\twindow bar\n  horiz\t\t'\226\148\128' or '-'\thorizontal separators |:split|\n  horizup\t'\226\148\180' or '-'\tupwards facing horizontal separator\n  horizdown\t'\226\148\172' or '-'\tdownwards facing horizontal separator\n  vert\t\t'\226\148\130' or '|'\tvertical separators |:vsplit|\n  vertleft\t'\226\148\164' or '|'\tleft facing vertical separator\n  vertright\t'\226\148\156' or '|'\tright facing vertical separator\n  verthoriz\t'\226\148\188' or '+'\toverlapping vertical and horizontal\n\t\t\t\tseparator\n  fold\t\t'\194\183' or '-'\tfilling 'foldtext'\n  foldopen\t'-'\t\tmark the beginning of a fold\n  foldclose\t'+'\t\tshow a closed fold\n  foldsep\t'\226\148\130' or '|'      open fold middle marker\n  diff\t\t'-'\t\tdeleted lines of the 'diff' option\n  msgsep\t' '\t\tmessage separator 'display'\n  eob\t\t'~'\t\tempty lines at the end of a buffer\n  lastline\t'@'\t\t'display' contains lastline/truncate\n\nAny one that is omitted will fall back to the default.\n\nNote that \"horiz\", \"horizup\", \"horizdown\", \"vertleft\", \"vertright\" and\n\"verthoriz\" are only used when 'laststatus' is 3, since only vertical\nwindow separators are used otherwise.\n\nIf 'ambiwidth' is \"double\" then \"horiz\", \"horizup\", \"horizdown\",\n\"vert\", \"vertleft\", \"vertright\", \"verthoriz\", \"foldsep\" and \"fold\"\ndefault to single-byte alternatives.\n\nExample: >vim\n    set fillchars=stl:\\ ,stlnc:\\ ,vert:\226\148\130,fold:\194\183,diff:-\n<\nFor the \"stl\", \"stlnc\", \"foldopen\", \"foldclose\" and \"foldsep\" items\nsingle-byte and multibyte characters are supported.  But double-width\ncharacters are not supported. |E1512|\n\nThe highlighting used for these items:\n  item\t\thighlight group ~\n  stl\t\tStatusLine\t\t|hl-StatusLine|\n  stlnc\t\tStatusLineNC\t\t|hl-StatusLineNC|\n  wbr\t\tWinBar\t\t\t|hl-WinBar| or |hl-WinBarNC|\n  horiz\t\tWinSeparator\t\t|hl-WinSeparator|\n  horizup\tWinSeparator\t\t|hl-WinSeparator|\n  horizdown\tWinSeparator\t\t|hl-WinSeparator|\n  vert\t\tWinSeparator\t\t|hl-WinSeparator|\n  vertleft\tWinSeparator\t\t|hl-WinSeparator|\n  vertright\tWinSeparator\t\t|hl-WinSeparator|\n  verthoriz\tWinSeparator\t\t|hl-WinSeparator|\n  fold\t\tFolded\t\t\t|hl-Folded|\n  diff\t\tDiffDelete\t\t|hl-DiffDelete|\n  eob\t\tEndOfBuffer\t\t|hl-EndOfBuffer|\n  lastline\tNonText\t\t\t|hl-NonText|"}}, findfunc = {binding = "findfunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'findfunc' 'ffu'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nFunction that is called to obtain the filename(s) for the |:find|\ncommand.  When this option is empty, the internal |file-searching|\nmechanism is used.\n\nThe value can be the name of a function, a |lambda| or a |Funcref|.\nSee |option-value-function| for more information.\n\nThe function is called with two arguments.  The first argument is a\n|String| and is the |:find| command argument.  The second argument is\na |Boolean| and is set to |v:true| when the function is called to get\na List of command-line completion matches for the |:find| command.\nThe function should return a List of strings.\n\nThe function is called only once per |:find| command invocation.\nThe function can process all the directories specified in 'path'.\n\nIf a match is found, the function should return a |List| containing\none or more file names.  If a match is not found, the function\nshould return an empty List.\n\nIf any errors are encountered during the function invocation, an\nempty List is used as the return value.\n\nIt is not allowed to change text or jump to another window while\nexecuting the 'findfunc' |textlock|.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n\nExamples:\n>vim\n    \" Use glob()\n    func FindFuncGlob(cmdarg, cmdcomplete)\n\tlet pat = a:cmdcomplete ? $'{a:cmdarg}*' : a:cmdarg\n\treturn glob(pat, v:false, v:true)\n    endfunc\n    set findfunc=FindFuncGlob\n\n    \" Use the 'git ls-files' output\n    func FindGitFiles(cmdarg, cmdcomplete)\n\tlet fnames = systemlist('git ls-files')\n\treturn fnames->filter('v:val =~? a:cmdarg')\n    endfunc\n    set findfunc=FindGitFiles\n<"}}, fixendofline = {binding = "fixendofline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fixendofline' 'fixeol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is on, <EOL> at the end of file\nwill be restored if missing.  Turn this option off if you want to\npreserve the situation from the original file.\nWhen the 'binary' option is set the value of this option doesn't\nmatter.\nSee the 'endofline' option.\nSee |eol-and-eof| for example settings."}}, fixeol = {binding = "fixeol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fixendofline' 'fixeol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is on, <EOL> at the end of file\nwill be restored if missing.  Turn this option off if you want to\npreserve the situation from the original file.\nWhen the 'binary' option is set the value of this option doesn't\nmatter.\nSee the 'endofline' option.\nSee |eol-and-eof| for example settings."}}, flp = {binding = "flp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatlistpat' 'flp'\tstring\t(default \"^\\s*\\d\\+[\\]:.)}\\t ]\\s*\")\n\t\tlocal to buffer\nA pattern that is used to recognize a list header.  This is used for\nthe \"n\" flag in 'formatoptions'.\nThe pattern must match exactly the text that will be the indent for\nthe line below it.  You can use |/\\ze| to mark the end of the match\nwhile still checking more characters.  There must be a character\nfollowing the pattern, when it matches the whole line it is handled\nlike there is no match.\nThe default recognizes a number, followed by an optional punctuation\ncharacter and white space."}}, fml = {binding = "fml", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldminlines' 'fml'\tnumber\t(default 1)\n\t\tlocal to window\nSets the number of screen lines above which a fold can be displayed\nclosed.  Also for manually closed folds.  With the default value of\none a fold can only be closed if it takes up two or more screen lines.\nSet to zero to be able to close folds of just one screen line.\nNote that this only has an effect on what is displayed.  After using\n\"zc\" to close a fold, which is displayed open because it's smaller\nthan 'foldminlines', a following \"zc\" may close a containing fold."}}, fmr = {binding = "fmr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldmarker' 'fmr'\tstring\t(default \"{{{,}}}\")\n\t\tlocal to window\nThe start and end marker used when 'foldmethod' is \"marker\".  There\nmust be one comma, which separates the start and end marker.  The\nmarker is a literal string (a regular expression would be too slow).\nSee |fold-marker|."}}, fo = {binding = "fo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatoptions' 'fo'\tstring\t(default \"tcqj\")\n\t\tlocal to buffer\nThis is a sequence of letters which describes how automatic\nformatting is to be done.\nSee |fo-table| for possible values and |gq| for how to format text.\nCommas can be inserted for readability.\nTo avoid problems with flags that are added in the future, use the\n\"+=\" and \"-=\" feature of \":set\" |add-option-flags|."}}, foldclose = {binding = "foldclose", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldclose' 'fcl'\tstring\t(default \"\")\n\t\tglobal\nWhen set to \"all\", a fold is closed when the cursor isn't in it and\nits level is higher than 'foldlevel'.  Useful if you want folds to\nautomatically close when moving out of them."}}, foldcolumn = {binding = "foldcolumn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldcolumn' 'fdc'\tstring\t(default \"0\")\n\t\tlocal to window\nWhen and how to draw the foldcolumn. Valid values are:\n    \"auto\":       resize to the minimum amount of folds to display.\n    \"auto:[1-9]\": resize to accommodate multiple folds up to the\n\t\t  selected level\n    \"0\":          to disable foldcolumn\n    \"[1-9]\":      to display a fixed number of columns\nSee |folding|."}}, foldenable = {binding = "foldenable", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldenable' 'fen'\tboolean\t(default on)\n\t\tlocal to window\nWhen off, all folds are open.  This option can be used to quickly\nswitch between showing all text unfolded and viewing the text with\nfolds (including manually opened or closed folds).  It can be toggled\nwith the |zi| command.  The 'foldcolumn' will remain blank when\n'foldenable' is off.\nThis option is set by commands that create a new fold or close a fold.\nSee |folding|."}}, foldexpr = {binding = "foldexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldexpr' 'fde'\tstring\t(default \"0\")\n\t\tlocal to window\nThe expression used for when 'foldmethod' is \"expr\".  It is evaluated\nfor each line to obtain its fold level.  The context is set to the\nscript where 'foldexpr' was set, script-local items can be accessed.\nSee |fold-expr| for the usage.\n\nThe expression will be evaluated in the |sandbox| if set from a\nmodeline, see |sandbox-option|.\nThis option can't be set from a |modeline| when the 'diff' option is\non or the 'modelineexpr' option is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'foldexpr' |textlock|."}}, foldignore = {binding = "foldignore", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldignore' 'fdi'\tstring\t(default \"#\")\n\t\tlocal to window\nUsed only when 'foldmethod' is \"indent\".  Lines starting with\ncharacters in 'foldignore' will get their fold level from surrounding\nlines.  White space is skipped before checking for this character.\nThe default \"#\" works well for C programs.  See |fold-indent|."}}, foldlevel = {binding = "foldlevel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldlevel' 'fdl'\tnumber\t(default 0)\n\t\tlocal to window\nSets the fold level: Folds with a higher level will be closed.\nSetting this option to zero will close all folds.  Higher numbers will\nclose fewer folds.\nThis option is set by commands like |zm|, |zM| and |zR|.\nSee |fold-foldlevel|."}}, foldlevelstart = {binding = "foldlevelstart", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldlevelstart' 'fdls'\tnumber\t(default -1)\n\t\tglobal\nSets 'foldlevel' when starting to edit another buffer in a window.\nUseful to always start editing with all folds closed (value zero),\nsome folds closed (one) or no folds closed (99).\nThis is done before reading any modeline, thus a setting in a modeline\noverrules this option.  Starting to edit a file for |diff-mode| also\nignores this option and closes all folds.\nIt is also done before BufReadPre autocommands, to allow an autocmd to\noverrule the 'foldlevel' value for specific files.\nWhen the value is negative, it is not used."}}, foldmarker = {binding = "foldmarker", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldmarker' 'fmr'\tstring\t(default \"{{{,}}}\")\n\t\tlocal to window\nThe start and end marker used when 'foldmethod' is \"marker\".  There\nmust be one comma, which separates the start and end marker.  The\nmarker is a literal string (a regular expression would be too slow).\nSee |fold-marker|."}}, foldmethod = {binding = "foldmethod", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldmethod' 'fdm'\tstring\t(default \"manual\")\n\t\tlocal to window\nThe kind of folding used for the current window.  Possible values:\n|fold-manual|\tmanual\t    Folds are created manually.\n|fold-indent|\tindent\t    Lines with equal indent form a fold.\n|fold-expr|\texpr\t    'foldexpr' gives the fold level of a line.\n|fold-marker|\tmarker\t    Markers are used to specify folds.\n|fold-syntax|\tsyntax\t    Syntax highlighting items specify folds.\n|fold-diff|\tdiff\t    Fold text that is not changed."}}, foldminlines = {binding = "foldminlines", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldminlines' 'fml'\tnumber\t(default 1)\n\t\tlocal to window\nSets the number of screen lines above which a fold can be displayed\nclosed.  Also for manually closed folds.  With the default value of\none a fold can only be closed if it takes up two or more screen lines.\nSet to zero to be able to close folds of just one screen line.\nNote that this only has an effect on what is displayed.  After using\n\"zc\" to close a fold, which is displayed open because it's smaller\nthan 'foldminlines', a following \"zc\" may close a containing fold."}}, foldnestmax = {binding = "foldnestmax", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldnestmax' 'fdn'\tnumber\t(default 20)\n\t\tlocal to window\nSets the maximum nesting of folds for the \"indent\" and \"syntax\"\nmethods.  This avoids that too many folds will be created.  Using more\nthan 20 doesn't work, because the internal limit is 20."}}, foldopen = {binding = "foldopen", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldopen' 'fdo'\tstring\t(default \"block,hor,mark,percent,quickfix,search,tag,undo\")\n\t\tglobal\nSpecifies for which type of commands folds will be opened, if the\ncommand moves the cursor into a closed fold.  It is a comma-separated\nlist of items.\nNOTE: When the command is part of a mapping this option is not used.\nAdd the |zv| command to the mapping to get the same effect.\n(rationale: the mapping may want to control opening folds itself)\n\n\titem\t\tcommands ~\n\tall\t\tany\n\tblock\t\t(, {, [[, [{, etc.\n\thor\t\thorizontal movements: \"l\", \"w\", \"fx\", etc.\n\tinsert\t\tany command in Insert mode\n\tjump\t\tfar jumps: \"G\", \"gg\", etc.\n\tmark\t\tjumping to a mark: \"'m\", CTRL-O, etc.\n\tpercent\t\t\"%\"\n\tquickfix\t\":cn\", \":crew\", \":make\", etc.\n\tsearch\t\tsearch for a pattern: \"/\", \"n\", \"*\", \"gd\", etc.\n\t\t\t(not for a search pattern in a \":\" command)\n\t\t\tAlso for |[s| and |]s|.\n\ttag\t\tjumping to a tag: \":ta\", CTRL-T, etc.\n\tundo\t\tundo or redo: \"u\" and CTRL-R\nWhen a movement command is used for an operator (e.g., \"dl\" or \"y%\")\nthis option is not used.  This means the operator will include the\nwhole closed fold.\nNote that vertical movements are not here, because it would make it\nvery difficult to move onto a closed fold.\nIn insert mode the folds containing the cursor will always be open\nwhen text is inserted.\nTo close folds you can re-apply 'foldlevel' with the |zx| command or\nset the 'foldclose' option to \"all\"."}}, foldtext = {binding = "foldtext", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldtext' 'fdt'\tstring\t(default \"foldtext()\")\n\t\tlocal to window\nAn expression which is used to specify the text displayed for a closed\nfold.  The context is set to the script where 'foldexpr' was set,\nscript-local items can be accessed.  See |fold-foldtext| for the\nusage.\n\nThe expression will be evaluated in the |sandbox| if set from a\nmodeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'foldtext' |textlock|.\n\nWhen set to an empty string, foldtext is disabled, and the line\nis displayed normally with highlighting and no line wrapping."}}, formatexpr = {binding = "formatexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatexpr' 'fex'\tstring\t(default \"\")\n\t\tlocal to buffer\nExpression which is evaluated to format a range of lines for the |gq|\noperator or automatic formatting (see 'formatoptions').  When this\noption is empty 'formatprg' is used.\n\nThe |v:lnum|  variable holds the first line to be formatted.\nThe |v:count| variable holds the number of lines to be formatted.\nThe |v:char|  variable holds the character that is going to be\n\t      inserted if the expression is being evaluated due to\n\t      automatic formatting.  This can be empty.  Don't insert\n\t      it yet!\n\nExample: >vim\n\tset formatexpr=mylang#Format()\n<\tThis will invoke the mylang#Format() function in the\nautoload/mylang.vim file in 'runtimepath'. |autoload|\n\nThe advantage of using a function call without arguments is that it is\nfaster, see |expr-option-function|.\n\nThe expression is also evaluated when 'textwidth' is set and adding\ntext beyond that limit.  This happens under the same conditions as\nwhen internal formatting is used.  Make sure the cursor is kept in the\nsame spot relative to the text then!  The |mode()| function will\nreturn \"i\" or \"R\" in this situation.\n\nWhen the expression evaluates to non-zero Vim will fall back to using\nthe internal format mechanism.\n\nIf the expression starts with s: or |<SID>|, then it is replaced with\nthe script ID (|local-function|). Example: >vim\n\tset formatexpr=s:MyFormatExpr()\n\tset formatexpr=<SID>SomeFormatExpr()\n<\tOtherwise, the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nThe expression will be evaluated in the |sandbox| when set from a\nmodeline, see |sandbox-option|.  That stops the option from working,\nsince changing the buffer text is not allowed.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\nNOTE: This option is set to \"\" when 'compatible' is set."}}, formatlistpat = {binding = "formatlistpat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatlistpat' 'flp'\tstring\t(default \"^\\s*\\d\\+[\\]:.)}\\t ]\\s*\")\n\t\tlocal to buffer\nA pattern that is used to recognize a list header.  This is used for\nthe \"n\" flag in 'formatoptions'.\nThe pattern must match exactly the text that will be the indent for\nthe line below it.  You can use |/\\ze| to mark the end of the match\nwhile still checking more characters.  There must be a character\nfollowing the pattern, when it matches the whole line it is handled\nlike there is no match.\nThe default recognizes a number, followed by an optional punctuation\ncharacter and white space."}}, formatoptions = {binding = "formatoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatoptions' 'fo'\tstring\t(default \"tcqj\")\n\t\tlocal to buffer\nThis is a sequence of letters which describes how automatic\nformatting is to be done.\nSee |fo-table| for possible values and |gq| for how to format text.\nCommas can be inserted for readability.\nTo avoid problems with flags that are added in the future, use the\n\"+=\" and \"-=\" feature of \":set\" |add-option-flags|."}}, formatprg = {binding = "formatprg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatprg' 'fp'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nThe name of an external program that will be used to format the lines\nselected with the |gq| operator.  The program must take the input on\nstdin and produce the output on stdout.  The Unix program \"fmt\" is\nsuch a program.\nIf the 'formatexpr' option is not empty it will be used instead.\nOtherwise, if 'formatprg' option is an empty string, the internal\nformat function will be used |C-indenting|.\nEnvironment variables are expanded |:set_env|.  See |option-backslash|\nabout including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, fp = {binding = "fp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'formatprg' 'fp'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nThe name of an external program that will be used to format the lines\nselected with the |gq| operator.  The program must take the input on\nstdin and produce the output on stdout.  The Unix program \"fmt\" is\nsuch a program.\nIf the 'formatexpr' option is not empty it will be used instead.\nOtherwise, if 'formatprg' option is an empty string, the internal\nformat function will be used |C-indenting|.\nEnvironment variables are expanded |:set_env|.  See |option-backslash|\nabout including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, fs = {binding = "fs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fsync' 'fs'\t\tboolean\t(default on)\n\t\tglobal\nWhen on, the OS function fsync() will be called after saving a file\n(|:write|, |writefile()|, \226\128\166), |swap-file|, |undo-persistence| and |shada-file|.\nThis flushes the file to disk, ensuring that it is safely written.\nSlow on some systems: writing buffers, quitting Nvim, and other\noperations may sometimes take a few seconds.\n\nFiles are ALWAYS flushed ('fsync' is ignored) when:\n- |CursorHold| event is triggered\n- |:preserve| is called\n- system signals low battery life\n- Nvim exits abnormally\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, fsync = {binding = "fsync", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fsync' 'fs'\t\tboolean\t(default on)\n\t\tglobal\nWhen on, the OS function fsync() will be called after saving a file\n(|:write|, |writefile()|, \226\128\166), |swap-file|, |undo-persistence| and |shada-file|.\nThis flushes the file to disk, ensuring that it is safely written.\nSlow on some systems: writing buffers, quitting Nvim, and other\noperations may sometimes take a few seconds.\n\nFiles are ALWAYS flushed ('fsync' is ignored) when:\n- |CursorHold| event is triggered\n- |:preserve| is called\n- system signals low battery life\n- Nvim exits abnormally\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ft = {binding = "ft", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'filetype' 'ft'\t\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nWhen this option is set, the FileType autocommand event is triggered.\nAll autocommands that match with the value of this option will be\nexecuted.  Thus the value of 'filetype' is used in place of the file\nname.\nOtherwise this option does not always reflect the current file type.\nThis option is normally set when the file type is detected.  To enable\nthis use the \":filetype on\" command. |:filetype|\nSetting this option to a different value is most useful in a modeline,\nfor a file for which the file type is not automatically recognized.\nExample, for in an IDL file: >c\n\t/* vim: set filetype=idl : */\n<\t|FileType| |filetypes|\nWhen a dot appears in the value then this separates two filetype\nnames, it should therefore not be used for a filetype.  Example: >c\n\t/* vim: set filetype=c.doxygen : */\n<\tThis will use the \"c\" filetype first, then the \"doxygen\" filetype.\nThis works both for filetype plugins and for syntax files.  More than\none dot may appear.\nThis option is not copied to another buffer, independent of the 's' or\n'S' flag in 'cpoptions'.\nOnly alphanumeric characters, '-' and '_' can be used."}}, gcr = {binding = "gcr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'guicursor' 'gcr'\tstring\t(default \"n-v-c-sm:block,i-ci-ve:ver25,r-cr-o:hor20,t:block-blinkon500-blinkoff500-TermCursor\")\n\t\tglobal\nConfigures the cursor style for each mode. Works in the GUI and many\nterminals.  See |tui-cursor-shape|.\n\nTo disable cursor-styling, reset the option: >vim\n\tset guicursor=\n\n<\tTo enable mode shapes, \"Cursor\" highlight, and blinking: >vim\n\tset guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50\n\t  \\,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor\n\t  \\,sm:block-blinkwait175-blinkoff150-blinkon175\n\n<\tThe option is a comma-separated list of parts.  Each part consists of a\nmode-list and an argument-list:\n\tmode-list:argument-list,mode-list:argument-list,..\nThe mode-list is a dash separated list of these modes:\n\tn\tNormal mode\n\tv\tVisual mode\n\tve\tVisual mode with 'selection' \"exclusive\" (same as 'v',\n\t\tif not specified)\n\to\tOperator-pending mode\n\ti\tInsert mode\n\tr\tReplace mode\n\tc\tCommand-line Normal (append) mode\n\tci\tCommand-line Insert mode\n\tcr\tCommand-line Replace mode\n\tsm\tshowmatch in Insert mode\n\tt\tTerminal mode\n\ta\tall modes\nThe argument-list is a dash separated list of these arguments:\n\thor{N}\thorizontal bar, {N} percent of the character height\n\tver{N}\tvertical bar, {N} percent of the character width\n\tblock\tblock cursor, fills the whole character\n\t\t- Only one of the above three should be present.\n\t\t- Default is \"block\" for each mode.\n\tblinkwait{N}\t\t\t\t*cursor-blinking*\n\tblinkon{N}\n\tblinkoff{N}\n\t\tblink times for cursor: blinkwait is the delay before\n\t\tthe cursor starts blinking, blinkon is the time that\n\t\tthe cursor is shown and blinkoff is the time that the\n\t\tcursor is not shown.  Times are in msec.  When one of\n\t\tthe numbers is zero, there is no blinking. E.g.: >vim\n\t\t\tset guicursor=n:blinkon0\n<\n\t\tDefault is \"blinkon0\" for each mode.\n\t{group-name}\n\t\tHighlight group that decides the color and font of the\n\t\tcursor.\n\t\tIn the |TUI|:\n\t\t- |inverse|/reverse and no group-name are interpreted\n\t\t  as \"host-terminal default cursor colors\" which\n\t\t  typically means \"inverted bg and fg colors\".\n\t\t- |ctermfg| and |guifg| are ignored.\n\t{group-name}/{group-name}\n\t\tTwo highlight group names, the first is used when\n\t\tno language mappings are used, the other when they\n\t\tare. |language-mapping|\n\nExamples of parts:\n   n-c-v:block-nCursor\tIn Normal, Command-line and Visual mode, use a\n\t\t\tblock cursor with colors from the \"nCursor\"\n\t\t\thighlight group\n   n-v-c-sm:block,i-ci-ve:ver25-Cursor,r-cr-o:hor20\n\t\t\tIn Normal et al. modes, use a block cursor\n\t\t\twith the default colors defined by the host\n\t\t\tterminal.  In Insert-like modes, use\n\t\t\ta vertical bar cursor with colors from\n\t\t\t\"Cursor\" highlight group.  In Replace-like\n\t\t\tmodes, use an underline cursor with\n\t\t\tdefault colors.\n   i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150\n\t\t\tIn Insert and Command-line Insert mode, use a\n\t\t\00930% vertical bar cursor with colors from the\n\t\t\t\"iCursor\" highlight group.  Blink a bit\n\t\t\tfaster.\n\nThe 'a' mode is different.  It will set the given argument-list for\nall modes.  It does not reset anything to defaults.  This can be used\nto do a common setting for all modes.  For example, to switch off\nblinking: \"a:blinkon0\"\n\nExamples of cursor highlighting: >vim\n    highlight Cursor gui=reverse guifg=NONE guibg=NONE\n    highlight Cursor gui=NONE guifg=bg guibg=fg\n<"}}, gd = {binding = "gd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'gdefault' 'gd'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, the \":substitute\" flag 'g' is default on.  This means that\nall matches in a line are substituted instead of one.  When a 'g' flag\nis given to a \":substitute\" command, this will toggle the substitution\nof all or one match.  See |complex-change|.\n\n\tcommand\t\t'gdefault' on\t'gdefault' off\t~\n\t:s///\t\t  subst. all\t  subst. one\n\t:s///g\t\t  subst. one\t  subst. all\n\t:s///gg\t\t  subst. all\t  subst. one\n\nNOTE: Setting this option may break plugins that rely on the default\nbehavior of the 'g' flag. This will also make the 'g' flag have the\nopposite effect of that documented in |:s_g|."}}, gdefault = {binding = "gdefault", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'gdefault' 'gd'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, the \":substitute\" flag 'g' is default on.  This means that\nall matches in a line are substituted instead of one.  When a 'g' flag\nis given to a \":substitute\" command, this will toggle the substitution\nof all or one match.  See |complex-change|.\n\n\tcommand\t\t'gdefault' on\t'gdefault' off\t~\n\t:s///\t\t  subst. all\t  subst. one\n\t:s///g\t\t  subst. one\t  subst. all\n\t:s///gg\t\t  subst. all\t  subst. one\n\nNOTE: Setting this option may break plugins that rely on the default\nbehavior of the 'g' flag. This will also make the 'g' flag have the\nopposite effect of that documented in |:s_g|."}}, gfm = {binding = "gfm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'grepformat' 'gfm'\tstring\t(default \"%f:%l:%m,%f:%l%m,%f  %l%m\")\n\t\tglobal\nFormat to recognize for the \":grep\" command output.\nThis is a scanf-like string that uses the same format as the\n'errorformat' option: see |errorformat|.\n\nIf ripgrep ('grepprg') is available, this option defaults to `%f:%l:%c:%m`."}}, gfn = {binding = "gfn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'guifont' 'gfn'\t\tstring\t(default \"\")\n\t\tglobal\nThis is a list of fonts which will be used for the GUI version of Vim.\nIn its simplest form the value is just one font name.  When\nthe font cannot be found you will get an error message.  To try other\nfont names a list can be specified, font names separated with commas.\nThe first valid font is used.\n\nSpaces after a comma are ignored.  To include a comma in a font name\nprecede it with a backslash.  Setting an option requires an extra\nbackslash before a space and a backslash.  See also\n|option-backslash|.  For example: >vim\n    set guifont=Screen15,\\ 7x13,font\\\\,with\\\\,commas\n<\twill make Vim try to use the font \"Screen15\" first, and if it fails it\nwill try to use \"7x13\" and then \"font,with,commas\" instead.\n\nIf none of the fonts can be loaded, Vim will keep the current setting.\nIf an empty font list is given, Vim will try using other resource\nsettings (for X, it will use the Vim.font resource), and finally it\nwill try some builtin default which should always be there (\"7x13\" in\nthe case of X).  The font names given should be \"normal\" fonts.  Vim\nwill try to find the related bold and italic fonts.\n\nFor Win32 and Mac OS: >vim\n    set guifont=*\n<\twill bring up a font requester, where you can pick the font you want.\n\nThe font name depends on the GUI used.\n\nFor Mac OSX you can use something like this: >vim\n    set guifont=Monaco:h10\n<\t\t\t\t\t\t\t\t*E236*\nNote that the fonts must be mono-spaced (all characters have the same\nwidth).\n\nTo preview a font on X11, you might be able to use the \"xfontsel\"\nprogram.  The \"xlsfonts\" program gives a list of all available fonts.\n\nFor the Win32 GUI\t\t\t\t\t*E244* *E245*\n- takes these options in the font name:\n\thXX - height is XX (points, can be floating-point)\n\twXX - width is XX (points, can be floating-point)\n\tb   - bold\n\ti   - italic\n\tu   - underline\n\ts   - strikeout\n\tcXX - character set XX.  Valid charsets are: ANSI, ARABIC,\n\t      BALTIC, CHINESEBIG5, DEFAULT, EASTEUROPE, GB2312, GREEK,\n\t      HANGEUL, HEBREW, JOHAB, MAC, OEM, RUSSIAN, SHIFTJIS,\n\t      SYMBOL, THAI, TURKISH, VIETNAMESE ANSI and BALTIC.\n\t      Normally you would use \"cDEFAULT\".\n\n  Use a ':' to separate the options.\n- A '_' can be used in the place of a space, so you don't need to use\n  backslashes to escape the spaces.\n- Examples: >vim\n    set guifont=courier_new:h12:w5:b:cRUSSIAN\n    set guifont=Andale_Mono:h7.5:w4.5\n<"}}, gfw = {binding = "gfw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'guifontwide' 'gfw'\tstring\t(default \"\")\n\t\tglobal\nComma-separated list of fonts to be used for double-width characters.\nThe first font that can be loaded is used.\nNote: The size of these fonts must be exactly twice as wide as the one\nspecified with 'guifont' and the same height.\n\nWhen 'guifont' has a valid font and 'guifontwide' is empty Vim will\nattempt to set 'guifontwide' to a matching double-width font."}}, gp = {binding = "gp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'grepprg' 'gp'\t\tstring\t(default see below)\n\t\tglobal or local to buffer |global-local|\nProgram to use for the |:grep| command.  This option may contain '%'\nand '#' characters, which are expanded like when used in a command-\nline.  The placeholder \"$*\" is allowed to specify where the arguments\nwill be included.  Environment variables are expanded |:set_env|.  See\n|option-backslash| about including spaces and backslashes.\nSpecial value: When 'grepprg' is set to \"internal\" the |:grep| command\nworks like |:vimgrep|, |:lgrep| like |:lvimgrep|, |:grepadd| like\n|:vimgrepadd| and |:lgrepadd| like |:lvimgrepadd|.\nSee also the section |:make_makeprg|, since most of the comments there\napply equally to 'grepprg'.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\nThis option defaults to:\n- `rg --vimgrep -uu ` if ripgrep is available (|:checkhealth|),\n- `grep -HIn $* /dev/null` on Unix,\n- `findstr /n $* nul` on Windows.\nRipgrep can perform additional filtering such as using .gitignore rules\nand skipping hidden files. This is disabled by default (see the -u option)\nto more closely match the behaviour of standard grep.\nYou can make ripgrep match Vim's case handling using the\n-i/--ignore-case and -S/--smart-case options.\nAn |OptionSet| autocmd can be used to set it up to match automatically."}}, grepformat = {binding = "grepformat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'grepformat' 'gfm'\tstring\t(default \"%f:%l:%m,%f:%l%m,%f  %l%m\")\n\t\tglobal\nFormat to recognize for the \":grep\" command output.\nThis is a scanf-like string that uses the same format as the\n'errorformat' option: see |errorformat|.\n\nIf ripgrep ('grepprg') is available, this option defaults to `%f:%l:%c:%m`."}}, grepprg = {binding = "grepprg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'grepprg' 'gp'\t\tstring\t(default see below)\n\t\tglobal or local to buffer |global-local|\nProgram to use for the |:grep| command.  This option may contain '%'\nand '#' characters, which are expanded like when used in a command-\nline.  The placeholder \"$*\" is allowed to specify where the arguments\nwill be included.  Environment variables are expanded |:set_env|.  See\n|option-backslash| about including spaces and backslashes.\nSpecial value: When 'grepprg' is set to \"internal\" the |:grep| command\nworks like |:vimgrep|, |:lgrep| like |:lvimgrep|, |:grepadd| like\n|:vimgrepadd| and |:lgrepadd| like |:lvimgrepadd|.\nSee also the section |:make_makeprg|, since most of the comments there\napply equally to 'grepprg'.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\nThis option defaults to:\n- `rg --vimgrep -uu ` if ripgrep is available (|:checkhealth|),\n- `grep -HIn $* /dev/null` on Unix,\n- `findstr /n $* nul` on Windows.\nRipgrep can perform additional filtering such as using .gitignore rules\nand skipping hidden files. This is disabled by default (see the -u option)\nto more closely match the behaviour of standard grep.\nYou can make ripgrep match Vim's case handling using the\n-i/--ignore-case and -S/--smart-case options.\nAn |OptionSet| autocmd can be used to set it up to match automatically."}}, guicursor = {binding = "guicursor", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'guicursor' 'gcr'\tstring\t(default \"n-v-c-sm:block,i-ci-ve:ver25,r-cr-o:hor20,t:block-blinkon500-blinkoff500-TermCursor\")\n\t\tglobal\nConfigures the cursor style for each mode. Works in the GUI and many\nterminals.  See |tui-cursor-shape|.\n\nTo disable cursor-styling, reset the option: >vim\n\tset guicursor=\n\n<\tTo enable mode shapes, \"Cursor\" highlight, and blinking: >vim\n\tset guicursor=n-v-c:block,i-ci-ve:ver25,r-cr:hor20,o:hor50\n\t  \\,a:blinkwait700-blinkoff400-blinkon250-Cursor/lCursor\n\t  \\,sm:block-blinkwait175-blinkoff150-blinkon175\n\n<\tThe option is a comma-separated list of parts.  Each part consists of a\nmode-list and an argument-list:\n\tmode-list:argument-list,mode-list:argument-list,..\nThe mode-list is a dash separated list of these modes:\n\tn\tNormal mode\n\tv\tVisual mode\n\tve\tVisual mode with 'selection' \"exclusive\" (same as 'v',\n\t\tif not specified)\n\to\tOperator-pending mode\n\ti\tInsert mode\n\tr\tReplace mode\n\tc\tCommand-line Normal (append) mode\n\tci\tCommand-line Insert mode\n\tcr\tCommand-line Replace mode\n\tsm\tshowmatch in Insert mode\n\tt\tTerminal mode\n\ta\tall modes\nThe argument-list is a dash separated list of these arguments:\n\thor{N}\thorizontal bar, {N} percent of the character height\n\tver{N}\tvertical bar, {N} percent of the character width\n\tblock\tblock cursor, fills the whole character\n\t\t- Only one of the above three should be present.\n\t\t- Default is \"block\" for each mode.\n\tblinkwait{N}\t\t\t\t*cursor-blinking*\n\tblinkon{N}\n\tblinkoff{N}\n\t\tblink times for cursor: blinkwait is the delay before\n\t\tthe cursor starts blinking, blinkon is the time that\n\t\tthe cursor is shown and blinkoff is the time that the\n\t\tcursor is not shown.  Times are in msec.  When one of\n\t\tthe numbers is zero, there is no blinking. E.g.: >vim\n\t\t\tset guicursor=n:blinkon0\n<\n\t\tDefault is \"blinkon0\" for each mode.\n\t{group-name}\n\t\tHighlight group that decides the color and font of the\n\t\tcursor.\n\t\tIn the |TUI|:\n\t\t- |inverse|/reverse and no group-name are interpreted\n\t\t  as \"host-terminal default cursor colors\" which\n\t\t  typically means \"inverted bg and fg colors\".\n\t\t- |ctermfg| and |guifg| are ignored.\n\t{group-name}/{group-name}\n\t\tTwo highlight group names, the first is used when\n\t\tno language mappings are used, the other when they\n\t\tare. |language-mapping|\n\nExamples of parts:\n   n-c-v:block-nCursor\tIn Normal, Command-line and Visual mode, use a\n\t\t\tblock cursor with colors from the \"nCursor\"\n\t\t\thighlight group\n   n-v-c-sm:block,i-ci-ve:ver25-Cursor,r-cr-o:hor20\n\t\t\tIn Normal et al. modes, use a block cursor\n\t\t\twith the default colors defined by the host\n\t\t\tterminal.  In Insert-like modes, use\n\t\t\ta vertical bar cursor with colors from\n\t\t\t\"Cursor\" highlight group.  In Replace-like\n\t\t\tmodes, use an underline cursor with\n\t\t\tdefault colors.\n   i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150\n\t\t\tIn Insert and Command-line Insert mode, use a\n\t\t\00930% vertical bar cursor with colors from the\n\t\t\t\"iCursor\" highlight group.  Blink a bit\n\t\t\tfaster.\n\nThe 'a' mode is different.  It will set the given argument-list for\nall modes.  It does not reset anything to defaults.  This can be used\nto do a common setting for all modes.  For example, to switch off\nblinking: \"a:blinkon0\"\n\nExamples of cursor highlighting: >vim\n    highlight Cursor gui=reverse guifg=NONE guibg=NONE\n    highlight Cursor gui=NONE guifg=bg guibg=fg\n<"}}, guifont = {binding = "guifont", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'guifont' 'gfn'\t\tstring\t(default \"\")\n\t\tglobal\nThis is a list of fonts which will be used for the GUI version of Vim.\nIn its simplest form the value is just one font name.  When\nthe font cannot be found you will get an error message.  To try other\nfont names a list can be specified, font names separated with commas.\nThe first valid font is used.\n\nSpaces after a comma are ignored.  To include a comma in a font name\nprecede it with a backslash.  Setting an option requires an extra\nbackslash before a space and a backslash.  See also\n|option-backslash|.  For example: >vim\n    set guifont=Screen15,\\ 7x13,font\\\\,with\\\\,commas\n<\twill make Vim try to use the font \"Screen15\" first, and if it fails it\nwill try to use \"7x13\" and then \"font,with,commas\" instead.\n\nIf none of the fonts can be loaded, Vim will keep the current setting.\nIf an empty font list is given, Vim will try using other resource\nsettings (for X, it will use the Vim.font resource), and finally it\nwill try some builtin default which should always be there (\"7x13\" in\nthe case of X).  The font names given should be \"normal\" fonts.  Vim\nwill try to find the related bold and italic fonts.\n\nFor Win32 and Mac OS: >vim\n    set guifont=*\n<\twill bring up a font requester, where you can pick the font you want.\n\nThe font name depends on the GUI used.\n\nFor Mac OSX you can use something like this: >vim\n    set guifont=Monaco:h10\n<\t\t\t\t\t\t\t\t*E236*\nNote that the fonts must be mono-spaced (all characters have the same\nwidth).\n\nTo preview a font on X11, you might be able to use the \"xfontsel\"\nprogram.  The \"xlsfonts\" program gives a list of all available fonts.\n\nFor the Win32 GUI\t\t\t\t\t*E244* *E245*\n- takes these options in the font name:\n\thXX - height is XX (points, can be floating-point)\n\twXX - width is XX (points, can be floating-point)\n\tb   - bold\n\ti   - italic\n\tu   - underline\n\ts   - strikeout\n\tcXX - character set XX.  Valid charsets are: ANSI, ARABIC,\n\t      BALTIC, CHINESEBIG5, DEFAULT, EASTEUROPE, GB2312, GREEK,\n\t      HANGEUL, HEBREW, JOHAB, MAC, OEM, RUSSIAN, SHIFTJIS,\n\t      SYMBOL, THAI, TURKISH, VIETNAMESE ANSI and BALTIC.\n\t      Normally you would use \"cDEFAULT\".\n\n  Use a ':' to separate the options.\n- A '_' can be used in the place of a space, so you don't need to use\n  backslashes to escape the spaces.\n- Examples: >vim\n    set guifont=courier_new:h12:w5:b:cRUSSIAN\n    set guifont=Andale_Mono:h7.5:w4.5\n<"}}, guifontwide = {binding = "guifontwide", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'guifontwide' 'gfw'\tstring\t(default \"\")\n\t\tglobal\nComma-separated list of fonts to be used for double-width characters.\nThe first font that can be loaded is used.\nNote: The size of these fonts must be exactly twice as wide as the one\nspecified with 'guifont' and the same height.\n\nWhen 'guifont' has a valid font and 'guifontwide' is empty Vim will\nattempt to set 'guifontwide' to a matching double-width font."}}, helpfile = {binding = "helpfile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'helpfile' 'hf'\t\tstring\t(default (MS-Windows) \"$VIMRUNTIME\\doc\\help.txt\"\n                                         (others) \"$VIMRUNTIME/doc/help.txt\")\n\t\tglobal\nName of the main help file.  All distributed help files should be\nplaced together in one directory.  Additionally, all \"doc\" directories\nin 'runtimepath' will be used.\nEnvironment variables are expanded |:set_env|.  For example:\n\"$VIMRUNTIME/doc/help.txt\".  If $VIMRUNTIME is not set, $VIM is also\ntried.  Also see |$VIMRUNTIME| and |option-backslash| about including\nspaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, helpheight = {binding = "helpheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'helpheight' 'hh'\tnumber\t(default 20)\n\t\tglobal\nMinimal initial height of the help window when it is opened with the\n\":help\" command.  The initial height of the help window is half of the\ncurrent window, or (when the 'ea' option is on) the same as other\nwindows.  When the height is less than 'helpheight', the height is\nset to 'helpheight'.  Set to zero to disable."}}, helplang = {binding = "helplang", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'helplang' 'hlg'\tstring\t(default messages language or empty)\n\t\tglobal\nComma-separated list of languages.  Vim will use the first language\nfor which the desired help can be found.  The English help will always\nbe used as a last resort.  You can add \"en\" to prefer English over\nanother language, but that will only find tags that exist in that\nlanguage and not in the English help.\nExample: >vim\n\tset helplang=de,it\n<\tThis will first search German, then Italian and finally English help\nfiles.\nWhen using |CTRL-]| and \":help!\" in a non-English help file Vim will\ntry to find the tag in the current language before using this option.\nSee |help-translated|."}}, hf = {binding = "hf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'helpfile' 'hf'\t\tstring\t(default (MS-Windows) \"$VIMRUNTIME\\doc\\help.txt\"\n                                         (others) \"$VIMRUNTIME/doc/help.txt\")\n\t\tglobal\nName of the main help file.  All distributed help files should be\nplaced together in one directory.  Additionally, all \"doc\" directories\nin 'runtimepath' will be used.\nEnvironment variables are expanded |:set_env|.  For example:\n\"$VIMRUNTIME/doc/help.txt\".  If $VIMRUNTIME is not set, $VIM is also\ntried.  Also see |$VIMRUNTIME| and |option-backslash| about including\nspaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, hh = {binding = "hh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'helpheight' 'hh'\tnumber\t(default 20)\n\t\tglobal\nMinimal initial height of the help window when it is opened with the\n\":help\" command.  The initial height of the help window is half of the\ncurrent window, or (when the 'ea' option is on) the same as other\nwindows.  When the height is less than 'helpheight', the height is\nset to 'helpheight'.  Set to zero to disable."}}, hi = {binding = "hi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'history' 'hi'\t\tnumber\t(default 10000)\n\t\tglobal\nA history of \":\" commands, and a history of previous search patterns\nis remembered.  This option decides how many entries may be stored in\neach of these histories (see |cmdline-editing| and 'messagesopt' for\nthe number of messages to remember).\nThe maximum value is 10000."}}, hid = {binding = "hid", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hidden' 'hid'\t\tboolean\t(default on)\n\t\tglobal\nWhen off a buffer is unloaded (including loss of undo information)\nwhen it is |abandon|ed.  When on a buffer becomes hidden when it is\n|abandon|ed.  A buffer displayed in another window does not become\nhidden, of course.\n\nCommands that move through the buffer list sometimes hide a buffer\nalthough the 'hidden' option is off when these three are true:\n- the buffer is modified\n- 'autowrite' is off or writing is not possible\n- the '!' flag was used\nAlso see |windows|.\n\nTo hide a specific buffer use the 'bufhidden' option.\n'hidden' is set for one command with \":hide {command}\" |:hide|."}}, hidden = {binding = "hidden", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hidden' 'hid'\t\tboolean\t(default on)\n\t\tglobal\nWhen off a buffer is unloaded (including loss of undo information)\nwhen it is |abandon|ed.  When on a buffer becomes hidden when it is\n|abandon|ed.  A buffer displayed in another window does not become\nhidden, of course.\n\nCommands that move through the buffer list sometimes hide a buffer\nalthough the 'hidden' option is off when these three are true:\n- the buffer is modified\n- 'autowrite' is off or writing is not possible\n- the '!' flag was used\nAlso see |windows|.\n\nTo hide a specific buffer use the 'bufhidden' option.\n'hidden' is set for one command with \":hide {command}\" |:hide|."}}, history = {binding = "history", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'history' 'hi'\t\tnumber\t(default 10000)\n\t\tglobal\nA history of \":\" commands, and a history of previous search patterns\nis remembered.  This option decides how many entries may be stored in\neach of these histories (see |cmdline-editing| and 'messagesopt' for\nthe number of messages to remember).\nThe maximum value is 10000."}}, hlg = {binding = "hlg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'helplang' 'hlg'\tstring\t(default messages language or empty)\n\t\tglobal\nComma-separated list of languages.  Vim will use the first language\nfor which the desired help can be found.  The English help will always\nbe used as a last resort.  You can add \"en\" to prefer English over\nanother language, but that will only find tags that exist in that\nlanguage and not in the English help.\nExample: >vim\n\tset helplang=de,it\n<\tThis will first search German, then Italian and finally English help\nfiles.\nWhen using |CTRL-]| and \":help!\" in a non-English help file Vim will\ntry to find the tag in the current language before using this option.\nSee |help-translated|."}}, hls = {binding = "hls", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hlsearch' 'hls'\tboolean\t(default on)\n\t\tglobal\nWhen there is a previous search pattern, highlight all its matches.\nThe |hl-Search| highlight group determines the highlighting for all\nmatches not under the cursor while the |hl-CurSearch| highlight group\n(if defined) determines the highlighting for the match under the\ncursor. If |hl-CurSearch| is not defined, then |hl-Search| is used for\nboth. Note that only the matching text is highlighted, any offsets\nare not applied.\nSee also: 'incsearch' and |:match|.\nWhen you get bored looking at the highlighted matches, you can turn it\noff with |:nohlsearch|.  This does not change the option value, as\nsoon as you use a search command, the highlighting comes back.\n'redrawtime' specifies the maximum time spent on finding matches.\nWhen the search pattern can match an end-of-line, Vim will try to\nhighlight all of the matched text.  However, this depends on where the\nsearch starts.  This will be the first line in the window or the first\nline below a closed fold.  A match in a previous line which is not\ndrawn may not continue in a newly drawn line.\nYou can specify whether the highlight status is restored on startup\nwith the 'h' flag in 'shada' |shada-h|."}}, hlsearch = {binding = "hlsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hlsearch' 'hls'\tboolean\t(default on)\n\t\tglobal\nWhen there is a previous search pattern, highlight all its matches.\nThe |hl-Search| highlight group determines the highlighting for all\nmatches not under the cursor while the |hl-CurSearch| highlight group\n(if defined) determines the highlighting for the match under the\ncursor. If |hl-CurSearch| is not defined, then |hl-Search| is used for\nboth. Note that only the matching text is highlighted, any offsets\nare not applied.\nSee also: 'incsearch' and |:match|.\nWhen you get bored looking at the highlighted matches, you can turn it\noff with |:nohlsearch|.  This does not change the option value, as\nsoon as you use a search command, the highlighting comes back.\n'redrawtime' specifies the maximum time spent on finding matches.\nWhen the search pattern can match an end-of-line, Vim will try to\nhighlight all of the matched text.  However, this depends on where the\nsearch starts.  This will be the first line in the window or the first\nline below a closed fold.  A match in a previous line which is not\ndrawn may not continue in a newly drawn line.\nYou can specify whether the highlight status is restored on startup\nwith the 'h' flag in 'shada' |shada-h|."}}, ic = {binding = "ic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ignorecase' 'ic'\tboolean\t(default off)\n\t\tglobal\nIgnore case in search patterns, |cmdline-completion|, when\nsearching in the tags file, and |expr-==|.\nAlso see 'smartcase' and 'tagcase'.\nCan be overruled by using \"\\c\" or \"\\C\" in the pattern, see\n|/ignorecase|."}}, icm = {binding = "icm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'inccommand' 'icm'\tstring\t(default \"nosplit\")\n\t\tglobal\nWhen nonempty, shows the effects of |:substitute|, |:smagic|,\n|:snomagic| and user commands with the |:command-preview| flag as you\ntype.\n\nPossible values:\n\tnosplit\tShows the effects of a command incrementally in the\n\t\tbuffer.\n\tsplit\tLike \"nosplit\", but also shows partial off-screen\n\t\tresults in a preview window.\n\nIf the preview for built-in commands is too slow (exceeds\n'redrawtime') then 'inccommand' is automatically disabled until\n|Command-line-mode| is done."}}, icon = {binding = "icon", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'icon'\t\t\tboolean\t(default off, on when title can be restored)\n\t\tglobal\nWhen on, the icon text of the window will be set to the value of\n'iconstring' (if it is not empty), or to the name of the file\ncurrently being edited.  Only the last part of the name is used.\nOverridden by the 'iconstring' option.\nOnly works if the terminal supports setting window icons."}}, iconstring = {binding = "iconstring", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'iconstring'\t\tstring\t(default \"\")\n\t\tglobal\nWhen this option is not empty, it will be used for the icon text of\nthe window.  This happens only when the 'icon' option is on.\nOnly works if the terminal supports setting window icon text\nWhen this option contains printf-style '%' items, they will be\nexpanded according to the rules used for 'statusline'.  See\n'titlestring' for example settings.\nThis option cannot be set in a modeline when 'modelineexpr' is off."}}, ignorecase = {binding = "ignorecase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ignorecase' 'ic'\tboolean\t(default off)\n\t\tglobal\nIgnore case in search patterns, |cmdline-completion|, when\nsearching in the tags file, and |expr-==|.\nAlso see 'smartcase' and 'tagcase'.\nCan be overruled by using \"\\c\" or \"\\C\" in the pattern, see\n|/ignorecase|."}}, imi = {binding = "imi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'iminsert' 'imi'\tnumber\t(default 0)\n\t\tlocal to buffer\nSpecifies whether :lmap or an Input Method (IM) is to be used in\nInsert mode.  Valid values:\n\0090\t:lmap is off and IM is off\n\0091\t:lmap is ON and IM is off\n\0092\t:lmap is off and IM is ON\nTo always reset the option to zero when leaving Insert mode with <Esc>\nthis can be used: >vim\n\tinoremap <ESC> <ESC>:set iminsert=0<CR>\n<\tThis makes :lmap and IM turn off automatically when leaving Insert\nmode.\nNote that this option changes when using CTRL-^ in Insert mode\n|i_CTRL-^|.\nThe value is set to 1 when setting 'keymap' to a valid keymap name.\nIt is also used for the argument of commands like \"r\" and \"f\"."}}, iminsert = {binding = "iminsert", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'iminsert' 'imi'\tnumber\t(default 0)\n\t\tlocal to buffer\nSpecifies whether :lmap or an Input Method (IM) is to be used in\nInsert mode.  Valid values:\n\0090\t:lmap is off and IM is off\n\0091\t:lmap is ON and IM is off\n\0092\t:lmap is off and IM is ON\nTo always reset the option to zero when leaving Insert mode with <Esc>\nthis can be used: >vim\n\tinoremap <ESC> <ESC>:set iminsert=0<CR>\n<\tThis makes :lmap and IM turn off automatically when leaving Insert\nmode.\nNote that this option changes when using CTRL-^ in Insert mode\n|i_CTRL-^|.\nThe value is set to 1 when setting 'keymap' to a valid keymap name.\nIt is also used for the argument of commands like \"r\" and \"f\"."}}, ims = {binding = "ims", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'imsearch' 'ims'\tnumber\t(default -1)\n\t\tlocal to buffer\nSpecifies whether :lmap or an Input Method (IM) is to be used when\nentering a search pattern.  Valid values:\n\t-1\tthe value of 'iminsert' is used, makes it look like\n\t\t'iminsert' is also used when typing a search pattern\n\0090\t:lmap is off and IM is off\n\0091\t:lmap is ON and IM is off\n\0092\t:lmap is off and IM is ON\nNote that this option changes when using CTRL-^ in Command-line mode\n|c_CTRL-^|.\nThe value is set to 1 when it is not -1 and setting the 'keymap'\noption to a valid keymap name."}}, imsearch = {binding = "imsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'imsearch' 'ims'\tnumber\t(default -1)\n\t\tlocal to buffer\nSpecifies whether :lmap or an Input Method (IM) is to be used when\nentering a search pattern.  Valid values:\n\t-1\tthe value of 'iminsert' is used, makes it look like\n\t\t'iminsert' is also used when typing a search pattern\n\0090\t:lmap is off and IM is off\n\0091\t:lmap is ON and IM is off\n\0092\t:lmap is off and IM is ON\nNote that this option changes when using CTRL-^ in Command-line mode\n|c_CTRL-^|.\nThe value is set to 1 when it is not -1 and setting the 'keymap'\noption to a valid keymap name."}}, inc = {binding = "inc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'include' 'inc'\t\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nPattern to be used to find an include command.  It is a search\npattern, just like for the \"/\" command (See |pattern|).  This option\nis used for the commands \"[i\", \"]I\", \"[d\", etc.\nNormally the 'isfname' option is used to recognize the file name that\ncomes after the matched pattern.  But if \"\\zs\" appears in the pattern\nthen the text matched from \"\\zs\" to the end, or until \"\\ze\" if it\nappears, is used as the file name.  Use this to include characters\nthat are not in 'isfname', such as a space.  You can then use\n'includeexpr' to process the matched text.\nSee |option-backslash| about including spaces and backslashes."}}, inccommand = {binding = "inccommand", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'inccommand' 'icm'\tstring\t(default \"nosplit\")\n\t\tglobal\nWhen nonempty, shows the effects of |:substitute|, |:smagic|,\n|:snomagic| and user commands with the |:command-preview| flag as you\ntype.\n\nPossible values:\n\tnosplit\tShows the effects of a command incrementally in the\n\t\tbuffer.\n\tsplit\tLike \"nosplit\", but also shows partial off-screen\n\t\tresults in a preview window.\n\nIf the preview for built-in commands is too slow (exceeds\n'redrawtime') then 'inccommand' is automatically disabled until\n|Command-line-mode| is done."}}, include = {binding = "include", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'include' 'inc'\t\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nPattern to be used to find an include command.  It is a search\npattern, just like for the \"/\" command (See |pattern|).  This option\nis used for the commands \"[i\", \"]I\", \"[d\", etc.\nNormally the 'isfname' option is used to recognize the file name that\ncomes after the matched pattern.  But if \"\\zs\" appears in the pattern\nthen the text matched from \"\\zs\" to the end, or until \"\\ze\" if it\nappears, is used as the file name.  Use this to include characters\nthat are not in 'isfname', such as a space.  You can then use\n'includeexpr' to process the matched text.\nSee |option-backslash| about including spaces and backslashes."}}, includeexpr = {binding = "includeexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'includeexpr' 'inex'\tstring\t(default \"\")\n\t\tlocal to buffer\nExpression to be used to transform the string found with the 'include'\noption to a file name.  Mostly useful to change \".\" to \"/\" for Java: >vim\n\tsetlocal includeexpr=substitute(v:fname,'\\\\.','/','g')\n<\tThe \"v:fname\" variable will be set to the file name that was detected.\nNote the double backslash: the `:set` command first halves them, then\none remains in the value, where \"\\.\" matches a dot literally.  For\nsimple character replacements `tr()` avoids the need for escaping: >vim\n\tsetlocal includeexpr=tr(v:fname,'.','/')\n<\nAlso used for the |gf| command if an unmodified file name can't be\nfound.  Allows doing \"gf\" on the name after an 'include' statement.\nAlso used for |<cfile>|.\n\nIf the expression starts with s: or |<SID>|, then it is replaced with\nthe script ID (|local-function|). Example: >vim\n\tsetlocal includeexpr=s:MyIncludeExpr()\n\tsetlocal includeexpr=<SID>SomeIncludeExpr()\n<\tOtherwise, the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nIt is more efficient if the value is just a function call without\narguments, see |expr-option-function|.\n\nThe expression will be evaluated in the |sandbox| when set from a\nmodeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'includeexpr' |textlock|."}}, incsearch = {binding = "incsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'incsearch' 'is'\tboolean\t(default on)\n\t\tglobal\nWhile typing a search command, show where the pattern, as it was typed\nso far, matches.  The matched string is highlighted.  If the pattern\nis invalid or not found, nothing is shown.  The screen will be updated\noften, this is only useful on fast terminals.\nNote that the match will be shown, but the cursor will return to its\noriginal position when no match is found and when pressing <Esc>.  You\nstill need to finish the search command with <Enter> to move the\ncursor to the match.\nYou can use the CTRL-G and CTRL-T keys to move to the next and\nprevious match. |c_CTRL-G| |c_CTRL-T|\nVim only searches for about half a second.  With a complicated\npattern and/or a lot of text the match may not be found.  This is to\navoid that Vim hangs while you are typing the pattern.\nThe |hl-IncSearch| highlight group determines the highlighting.\nWhen 'hlsearch' is on, all matched strings are highlighted too while\ntyping a search command. See also: 'hlsearch'.\nIf you don't want to turn 'hlsearch' on, but want to highlight all\nmatches while searching, you can turn on and off 'hlsearch' with\nautocmd.  Example: >vim\n\taugroup vimrc-incsearch-highlight\n\t  autocmd!\n\t  autocmd CmdlineEnter [\\/\\?] :set hlsearch\n\t  autocmd CmdlineLeave [\\/\\?] :set nohlsearch\n\taugroup END\n<\nCTRL-L can be used to add one character from after the current match\nto the command line.  If 'ignorecase' and 'smartcase' are set and the\ncommand line has no uppercase characters, the added character is\nconverted to lowercase.\nCTRL-R CTRL-W can be used to add the word at the end of the current\nmatch, excluding the characters that were already typed."}}, inde = {binding = "inde", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'indentexpr' 'inde'\tstring\t(default \"\")\n\t\tlocal to buffer\nExpression which is evaluated to obtain the proper indent for a line.\nIt is used when a new line is created, for the |=| operator and\nin Insert mode as specified with the 'indentkeys' option.\nWhen this option is not empty, it overrules the 'cindent' and\n'smartindent' indenting.  When 'lisp' is set, this option is\nonly used when 'lispoptions' contains \"expr:1\".\nThe expression is evaluated with |v:lnum| set to the line number for\nwhich the indent is to be computed.  The cursor is also in this line\nwhen the expression is evaluated (but it may be moved around).\n\nIf the expression starts with s: or |<SID>|, then it is replaced with\nthe script ID (|local-function|). Example: >vim\n\tset indentexpr=s:MyIndentExpr()\n\tset indentexpr=<SID>SomeIndentExpr()\n<\tOtherwise, the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nThe advantage of using a function call without arguments is that it is\nfaster, see |expr-option-function|.\n\nThe expression must return the number of spaces worth of indent.  It\ncan return \"-1\" to keep the current indent (this means 'autoindent' is\nused for the indent).\nFunctions useful for computing the indent are |indent()|, |cindent()|\nand |lispindent()|.\nThe evaluation of the expression must not have side effects!  It must\nnot change the text, jump to another window, etc.  Afterwards the\ncursor position is always restored, thus the cursor may be moved.\nNormally this option would be set to call a function: >vim\n\tset indentexpr=GetMyIndent()\n<\tError messages will be suppressed, unless the 'debug' option contains\n\"msg\".\nSee |indent-expression|.\n\nThe expression will be evaluated in the |sandbox| when set from a\nmodeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'indentexpr' |textlock|."}}, indentexpr = {binding = "indentexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'indentexpr' 'inde'\tstring\t(default \"\")\n\t\tlocal to buffer\nExpression which is evaluated to obtain the proper indent for a line.\nIt is used when a new line is created, for the |=| operator and\nin Insert mode as specified with the 'indentkeys' option.\nWhen this option is not empty, it overrules the 'cindent' and\n'smartindent' indenting.  When 'lisp' is set, this option is\nonly used when 'lispoptions' contains \"expr:1\".\nThe expression is evaluated with |v:lnum| set to the line number for\nwhich the indent is to be computed.  The cursor is also in this line\nwhen the expression is evaluated (but it may be moved around).\n\nIf the expression starts with s: or |<SID>|, then it is replaced with\nthe script ID (|local-function|). Example: >vim\n\tset indentexpr=s:MyIndentExpr()\n\tset indentexpr=<SID>SomeIndentExpr()\n<\tOtherwise, the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nThe advantage of using a function call without arguments is that it is\nfaster, see |expr-option-function|.\n\nThe expression must return the number of spaces worth of indent.  It\ncan return \"-1\" to keep the current indent (this means 'autoindent' is\nused for the indent).\nFunctions useful for computing the indent are |indent()|, |cindent()|\nand |lispindent()|.\nThe evaluation of the expression must not have side effects!  It must\nnot change the text, jump to another window, etc.  Afterwards the\ncursor position is always restored, thus the cursor may be moved.\nNormally this option would be set to call a function: >vim\n\tset indentexpr=GetMyIndent()\n<\tError messages will be suppressed, unless the 'debug' option contains\n\"msg\".\nSee |indent-expression|.\n\nThe expression will be evaluated in the |sandbox| when set from a\nmodeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'indentexpr' |textlock|."}}, indentkeys = {binding = "indentkeys", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'indentkeys' 'indk'\tstring\t(default \"0{,0},0),0],:,0#,!^F,o,O,e\")\n\t\tlocal to buffer\nA list of keys that, when typed in Insert mode, cause reindenting of\nthe current line.  Only happens if 'indentexpr' isn't empty.\nThe format is identical to 'cinkeys', see |indentkeys-format|.\nSee |C-indenting| and |indent-expression|."}}, indk = {binding = "indk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'indentkeys' 'indk'\tstring\t(default \"0{,0},0),0],:,0#,!^F,o,O,e\")\n\t\tlocal to buffer\nA list of keys that, when typed in Insert mode, cause reindenting of\nthe current line.  Only happens if 'indentexpr' isn't empty.\nThe format is identical to 'cinkeys', see |indentkeys-format|.\nSee |C-indenting| and |indent-expression|."}}, inex = {binding = "inex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'includeexpr' 'inex'\tstring\t(default \"\")\n\t\tlocal to buffer\nExpression to be used to transform the string found with the 'include'\noption to a file name.  Mostly useful to change \".\" to \"/\" for Java: >vim\n\tsetlocal includeexpr=substitute(v:fname,'\\\\.','/','g')\n<\tThe \"v:fname\" variable will be set to the file name that was detected.\nNote the double backslash: the `:set` command first halves them, then\none remains in the value, where \"\\.\" matches a dot literally.  For\nsimple character replacements `tr()` avoids the need for escaping: >vim\n\tsetlocal includeexpr=tr(v:fname,'.','/')\n<\nAlso used for the |gf| command if an unmodified file name can't be\nfound.  Allows doing \"gf\" on the name after an 'include' statement.\nAlso used for |<cfile>|.\n\nIf the expression starts with s: or |<SID>|, then it is replaced with\nthe script ID (|local-function|). Example: >vim\n\tsetlocal includeexpr=s:MyIncludeExpr()\n\tsetlocal includeexpr=<SID>SomeIncludeExpr()\n<\tOtherwise, the expression is evaluated in the context of the script\nwhere the option was set, thus script-local items are available.\n\nIt is more efficient if the value is just a function call without\narguments, see |expr-option-function|.\n\nThe expression will be evaluated in the |sandbox| when set from a\nmodeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'includeexpr' |textlock|."}}, inf = {binding = "inf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'infercase' 'inf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen doing keyword completion in insert mode |ins-completion|, and\n'ignorecase' is also on, the case of the match is adjusted depending\non the typed text.  If the typed text contains a lowercase letter\nwhere the match has an upper case letter, the completed part is made\nlowercase.  If the typed text has no lowercase letters and the match\nhas a lowercase letter where the typed text has an uppercase letter,\nand there is a letter before it, the completed part is made uppercase.\nWith 'noinfercase' the match is used as-is."}}, infercase = {binding = "infercase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'infercase' 'inf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen doing keyword completion in insert mode |ins-completion|, and\n'ignorecase' is also on, the case of the match is adjusted depending\non the typed text.  If the typed text contains a lowercase letter\nwhere the match has an upper case letter, the completed part is made\nlowercase.  If the typed text has no lowercase letters and the match\nhas a lowercase letter where the typed text has an uppercase letter,\nand there is a letter before it, the completed part is made uppercase.\nWith 'noinfercase' the match is used as-is."}}, is = {binding = "is", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'incsearch' 'is'\tboolean\t(default on)\n\t\tglobal\nWhile typing a search command, show where the pattern, as it was typed\nso far, matches.  The matched string is highlighted.  If the pattern\nis invalid or not found, nothing is shown.  The screen will be updated\noften, this is only useful on fast terminals.\nNote that the match will be shown, but the cursor will return to its\noriginal position when no match is found and when pressing <Esc>.  You\nstill need to finish the search command with <Enter> to move the\ncursor to the match.\nYou can use the CTRL-G and CTRL-T keys to move to the next and\nprevious match. |c_CTRL-G| |c_CTRL-T|\nVim only searches for about half a second.  With a complicated\npattern and/or a lot of text the match may not be found.  This is to\navoid that Vim hangs while you are typing the pattern.\nThe |hl-IncSearch| highlight group determines the highlighting.\nWhen 'hlsearch' is on, all matched strings are highlighted too while\ntyping a search command. See also: 'hlsearch'.\nIf you don't want to turn 'hlsearch' on, but want to highlight all\nmatches while searching, you can turn on and off 'hlsearch' with\nautocmd.  Example: >vim\n\taugroup vimrc-incsearch-highlight\n\t  autocmd!\n\t  autocmd CmdlineEnter [\\/\\?] :set hlsearch\n\t  autocmd CmdlineLeave [\\/\\?] :set nohlsearch\n\taugroup END\n<\nCTRL-L can be used to add one character from after the current match\nto the command line.  If 'ignorecase' and 'smartcase' are set and the\ncommand line has no uppercase characters, the added character is\nconverted to lowercase.\nCTRL-R CTRL-W can be used to add the word at the end of the current\nmatch, excluding the characters that were already typed."}}, isf = {binding = "isf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'isfname' 'isf'\t\tstring\t(default for Windows:\n                             \"@,48-57,/,\\,.,-,_,+,,,#,$,%,{,},[,],@-@,!,~,=\"\n                            otherwise: \"@,48-57,/,.,-,_,+,,,#,$,%,~,=\")\n\t\tglobal\nThe characters specified by this option are included in file names and\npath names.  Filenames are used for commands like \"gf\", \"[i\" and in\nthe tags file.  It is also used for \"\\f\" in a |pattern|.\nMulti-byte characters 256 and above are always included, only the\ncharacters up to 255 are specified with this option.\nFor UTF-8 the characters 0xa0 to 0xff are included as well.\nThink twice before adding white space to this option.  Although a\nspace may appear inside a file name, the effect will be that Vim\ndoesn't know where a file name starts or ends when doing completion.\nIt most likely works better without a space in 'isfname'.\n\nNote that on systems using a backslash as path separator, Vim tries to\ndo its best to make it work as you would expect.  That is a bit\ntricky, since Vi originally used the backslash to escape special\ncharacters.  Vim will not remove a backslash in front of a normal file\nname character on these systems, but it will on Unix and alikes.  The\n'&' and '^' are not included by default, because these are special for\ncmd.exe.\n\nThe format of this option is a list of parts, separated with commas.\nEach part can be a single character number or a range.  A range is two\ncharacter numbers with '-' in between.  A character number can be a\ndecimal number between 0 and 255 or the ASCII character itself (does\nnot work for digits).  Example:\n\t\"_,-,128-140,#-43\"\t(include '_' and '-' and the range\n\t\t\t\009128 to 140 and '#' to 43)\nIf a part starts with '^', the following character number or range\nwill be excluded from the option.  The option is interpreted from left\nto right.  Put the excluded character after the range where it is\nincluded.  To include '^' itself use it as the last character of the\noption or the end of a range.  Example:\n\t\"^a-z,#,^\"\t(exclude 'a' to 'z', include '#' and '^')\nIf the character is '@', all characters where isalpha() returns TRUE\nare included.  Normally these are the characters a to z and A to Z,\nplus accented characters.  To include '@' itself use \"@-@\".  Examples:\n\t\"@,^a-z\"\tAll alphabetic characters, excluding lower\n\t\t\tcase ASCII letters.\n\t\"a-z,A-Z,@-@\"\tAll letters plus the '@' character.\nA comma can be included by using it where a character number is\nexpected.  Example:\n\t\"48-57,,,_\"\tDigits, comma and underscore.\nA comma can be excluded by prepending a '^'.  Example:\n\t\" -~,^,,9\"\tAll characters from space to '~', excluding\n\t\t\tcomma, plus <Tab>.\nSee |option-backslash| about including spaces and backslashes."}}, isfname = {binding = "isfname", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'isfname' 'isf'\t\tstring\t(default for Windows:\n                             \"@,48-57,/,\\,.,-,_,+,,,#,$,%,{,},[,],@-@,!,~,=\"\n                            otherwise: \"@,48-57,/,.,-,_,+,,,#,$,%,~,=\")\n\t\tglobal\nThe characters specified by this option are included in file names and\npath names.  Filenames are used for commands like \"gf\", \"[i\" and in\nthe tags file.  It is also used for \"\\f\" in a |pattern|.\nMulti-byte characters 256 and above are always included, only the\ncharacters up to 255 are specified with this option.\nFor UTF-8 the characters 0xa0 to 0xff are included as well.\nThink twice before adding white space to this option.  Although a\nspace may appear inside a file name, the effect will be that Vim\ndoesn't know where a file name starts or ends when doing completion.\nIt most likely works better without a space in 'isfname'.\n\nNote that on systems using a backslash as path separator, Vim tries to\ndo its best to make it work as you would expect.  That is a bit\ntricky, since Vi originally used the backslash to escape special\ncharacters.  Vim will not remove a backslash in front of a normal file\nname character on these systems, but it will on Unix and alikes.  The\n'&' and '^' are not included by default, because these are special for\ncmd.exe.\n\nThe format of this option is a list of parts, separated with commas.\nEach part can be a single character number or a range.  A range is two\ncharacter numbers with '-' in between.  A character number can be a\ndecimal number between 0 and 255 or the ASCII character itself (does\nnot work for digits).  Example:\n\t\"_,-,128-140,#-43\"\t(include '_' and '-' and the range\n\t\t\t\009128 to 140 and '#' to 43)\nIf a part starts with '^', the following character number or range\nwill be excluded from the option.  The option is interpreted from left\nto right.  Put the excluded character after the range where it is\nincluded.  To include '^' itself use it as the last character of the\noption or the end of a range.  Example:\n\t\"^a-z,#,^\"\t(exclude 'a' to 'z', include '#' and '^')\nIf the character is '@', all characters where isalpha() returns TRUE\nare included.  Normally these are the characters a to z and A to Z,\nplus accented characters.  To include '@' itself use \"@-@\".  Examples:\n\t\"@,^a-z\"\tAll alphabetic characters, excluding lower\n\t\t\tcase ASCII letters.\n\t\"a-z,A-Z,@-@\"\tAll letters plus the '@' character.\nA comma can be included by using it where a character number is\nexpected.  Example:\n\t\"48-57,,,_\"\tDigits, comma and underscore.\nA comma can be excluded by prepending a '^'.  Example:\n\t\" -~,^,,9\"\tAll characters from space to '~', excluding\n\t\t\tcomma, plus <Tab>.\nSee |option-backslash| about including spaces and backslashes."}}, isi = {binding = "isi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'isident' 'isi'\t\tstring\t(default for Windows:\n                                           \"@,48-57,_,128-167,224-235\"\n                                otherwise: \"@,48-57,_,192-255\")\n\t\tglobal\nThe characters given by this option are included in identifiers.\nIdentifiers are used in recognizing environment variables and after a\nmatch of the 'define' option.  It is also used for \"\\i\" in a\n|pattern|.  See 'isfname' for a description of the format of this\noption.  For '@' only characters up to 255 are used.\nCareful: If you change this option, it might break expanding\nenvironment variables.  E.g., when '/' is included and Vim tries to\nexpand \"$HOME/.local/state/nvim/shada/main.shada\".  Maybe you should\nchange 'iskeyword' instead."}}, isident = {binding = "isident", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'isident' 'isi'\t\tstring\t(default for Windows:\n                                           \"@,48-57,_,128-167,224-235\"\n                                otherwise: \"@,48-57,_,192-255\")\n\t\tglobal\nThe characters given by this option are included in identifiers.\nIdentifiers are used in recognizing environment variables and after a\nmatch of the 'define' option.  It is also used for \"\\i\" in a\n|pattern|.  See 'isfname' for a description of the format of this\noption.  For '@' only characters up to 255 are used.\nCareful: If you change this option, it might break expanding\nenvironment variables.  E.g., when '/' is included and Vim tries to\nexpand \"$HOME/.local/state/nvim/shada/main.shada\".  Maybe you should\nchange 'iskeyword' instead."}}, isk = {binding = "isk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'iskeyword' 'isk'\tstring\t(default \"@,48-57,_,192-255\")\n\t\tlocal to buffer\nKeywords are used in searching and recognizing with many commands:\n\"w\", \"*\", \"[i\", etc.  It is also used for \"\\k\" in a |pattern|.  See\n'isfname' for a description of the format of this option.  For '@'\ncharacters above 255 check the \"word\" character class (any character\nthat is not white space or punctuation).\nFor C programs you could use \"a-z,A-Z,48-57,_,.,-,>\".\nFor a help file it is set to all non-blank printable characters except\n\"*\", '\"' and '|' (so that CTRL-] on a command finds the help for that\ncommand).\nWhen the 'lisp' option is on the '-' character is always included.\nThis option also influences syntax highlighting, unless the syntax\nuses |:syn-iskeyword|."}}, iskeyword = {binding = "iskeyword", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'iskeyword' 'isk'\tstring\t(default \"@,48-57,_,192-255\")\n\t\tlocal to buffer\nKeywords are used in searching and recognizing with many commands:\n\"w\", \"*\", \"[i\", etc.  It is also used for \"\\k\" in a |pattern|.  See\n'isfname' for a description of the format of this option.  For '@'\ncharacters above 255 check the \"word\" character class (any character\nthat is not white space or punctuation).\nFor C programs you could use \"a-z,A-Z,48-57,_,.,-,>\".\nFor a help file it is set to all non-blank printable characters except\n\"*\", '\"' and '|' (so that CTRL-] on a command finds the help for that\ncommand).\nWhen the 'lisp' option is on the '-' character is always included.\nThis option also influences syntax highlighting, unless the syntax\nuses |:syn-iskeyword|."}}, isp = {binding = "isp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'isprint' 'isp'\t\tstring\t(default \"@,161-255\")\n\t\tglobal\nThe characters given by this option are displayed directly on the\nscreen.  It is also used for \"\\p\" in a |pattern|.  The characters from\nspace (ASCII 32) to '~' (ASCII 126) are always displayed directly,\neven when they are not included in 'isprint' or excluded.  See\n'isfname' for a description of the format of this option.\n\nNon-printable characters are displayed with two characters:\n\t  0 -  31\t\"^@\" - \"^_\"\n\t 32 - 126\talways single characters\n\t   127\t\t\"^?\"\n\009128 - 159\t\"~@\" - \"~_\"\n\009160 - 254\t\"| \" - \"|~\"\n\t   255\t\t\"~?\"\nIllegal bytes from 128 to 255 (invalid UTF-8) are\ndisplayed as <xx>, with the hexadecimal value of the byte.\nWhen 'display' contains \"uhex\" all unprintable characters are\ndisplayed as <xx>.\nThe SpecialKey highlighting will be used for unprintable characters.\n|hl-SpecialKey|\n\nMulti-byte characters 256 and above are always included, only the\ncharacters up to 255 are specified with this option.  When a character\nis printable but it is not available in the current font, a\nreplacement character will be shown.\nUnprintable and zero-width Unicode characters are displayed as <xxxx>.\nThere is no option to specify these characters."}}, isprint = {binding = "isprint", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'isprint' 'isp'\t\tstring\t(default \"@,161-255\")\n\t\tglobal\nThe characters given by this option are displayed directly on the\nscreen.  It is also used for \"\\p\" in a |pattern|.  The characters from\nspace (ASCII 32) to '~' (ASCII 126) are always displayed directly,\neven when they are not included in 'isprint' or excluded.  See\n'isfname' for a description of the format of this option.\n\nNon-printable characters are displayed with two characters:\n\t  0 -  31\t\"^@\" - \"^_\"\n\t 32 - 126\talways single characters\n\t   127\t\t\"^?\"\n\009128 - 159\t\"~@\" - \"~_\"\n\009160 - 254\t\"| \" - \"|~\"\n\t   255\t\t\"~?\"\nIllegal bytes from 128 to 255 (invalid UTF-8) are\ndisplayed as <xx>, with the hexadecimal value of the byte.\nWhen 'display' contains \"uhex\" all unprintable characters are\ndisplayed as <xx>.\nThe SpecialKey highlighting will be used for unprintable characters.\n|hl-SpecialKey|\n\nMulti-byte characters 256 and above are always included, only the\ncharacters up to 255 are specified with this option.  When a character\nis printable but it is not available in the current font, a\nreplacement character will be shown.\nUnprintable and zero-width Unicode characters are displayed as <xxxx>.\nThere is no option to specify these characters."}}, joinspaces = {binding = "joinspaces", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'joinspaces' 'js'\tboolean\t(default off)\n\t\tglobal\nInsert two spaces after a '.', '?' and '!' with a join command.\nOtherwise only one space is inserted."}}, jop = {binding = "jop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'jumpoptions' 'jop'\tstring\t(default \"clean\")\n\t\tglobal\nList of words that change the behavior of the |jumplist|.\n  stack         Make the jumplist behave like the tagstack.\n\t\tRelative location of entries in the jumplist is\n\t\tpreserved at the cost of discarding subsequent entries\n\t\twhen navigating backwards in the jumplist and then\n\t\tjumping to a location.  |jumplist-stack|\n\n  view          When moving through the jumplist, |changelist|,\n\t\t|alternate-file| or using |mark-motions| try to\n\t\trestore the |mark-view| in which the action occurred.\n\n  clean         Remove unloaded buffers from the jumplist.\n\t\tEXPERIMENTAL: this flag may change in the future."}}, js = {binding = "js", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'joinspaces' 'js'\tboolean\t(default off)\n\t\tglobal\nInsert two spaces after a '.', '?' and '!' with a join command.\nOtherwise only one space is inserted."}}, jumpoptions = {binding = "jumpoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'jumpoptions' 'jop'\tstring\t(default \"clean\")\n\t\tglobal\nList of words that change the behavior of the |jumplist|.\n  stack         Make the jumplist behave like the tagstack.\n\t\tRelative location of entries in the jumplist is\n\t\tpreserved at the cost of discarding subsequent entries\n\t\twhen navigating backwards in the jumplist and then\n\t\tjumping to a location.  |jumplist-stack|\n\n  view          When moving through the jumplist, |changelist|,\n\t\t|alternate-file| or using |mark-motions| try to\n\t\trestore the |mark-view| in which the action occurred.\n\n  clean         Remove unloaded buffers from the jumplist.\n\t\tEXPERIMENTAL: this flag may change in the future."}}, keymap = {binding = "keymap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'keymap' 'kmp'\t\tstring\t(default \"\")\n\t\tlocal to buffer\nName of a keyboard mapping.  See |mbyte-keymap|.\nSetting this option to a valid keymap name has the side effect of\nsetting 'iminsert' to one, so that the keymap becomes effective.\n'imsearch' is also set to one, unless it was -1\nOnly alphanumeric characters, '.', '-' and '_' can be used."}}, keymodel = {binding = "keymodel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'keymodel' 'km'\t\tstring\t(default \"\")\n\t\tglobal\nList of comma-separated words, which enable special things that keys\ncan do.  These values can be used:\n   startsel\tUsing a shifted special key starts selection (either\n\t\tSelect mode or Visual mode, depending on \"key\" being\n\t\tpresent in 'selectmode').\n   stopsel\tUsing a not-shifted special key stops selection.\nSpecial keys in this context are the cursor keys, <End>, <Home>,\n<PageUp> and <PageDown>."}}, keywordprg = {binding = "keywordprg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'keywordprg' 'kp'\tstring\t(default \":Man\", Windows: \":help\")\n\t\tglobal or local to buffer |global-local|\nProgram to use for the |K| command.  Environment variables are\nexpanded |:set_env|.  \":help\" may be used to access the Vim internal\nhelp.  (Note that previously setting the global option to the empty\nvalue did this, which is now deprecated.)\nWhen the first character is \":\", the command is invoked as a Vim\nEx command prefixed with [count].\nWhen \"man\" or \"man -s\" is used, Vim will automatically translate\na [count] for the \"K\" command to a section number.\nSee |option-backslash| about including spaces and backslashes.\nExample: >vim\n\tset keywordprg=man\\ -s\n\tset keywordprg=:Man\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, km = {binding = "km", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'keymodel' 'km'\t\tstring\t(default \"\")\n\t\tglobal\nList of comma-separated words, which enable special things that keys\ncan do.  These values can be used:\n   startsel\tUsing a shifted special key starts selection (either\n\t\tSelect mode or Visual mode, depending on \"key\" being\n\t\tpresent in 'selectmode').\n   stopsel\tUsing a not-shifted special key stops selection.\nSpecial keys in this context are the cursor keys, <End>, <Home>,\n<PageUp> and <PageDown>."}}, kmp = {binding = "kmp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'keymap' 'kmp'\t\tstring\t(default \"\")\n\t\tlocal to buffer\nName of a keyboard mapping.  See |mbyte-keymap|.\nSetting this option to a valid keymap name has the side effect of\nsetting 'iminsert' to one, so that the keymap becomes effective.\n'imsearch' is also set to one, unless it was -1\nOnly alphanumeric characters, '.', '-' and '_' can be used."}}, kp = {binding = "kp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'keywordprg' 'kp'\tstring\t(default \":Man\", Windows: \":help\")\n\t\tglobal or local to buffer |global-local|\nProgram to use for the |K| command.  Environment variables are\nexpanded |:set_env|.  \":help\" may be used to access the Vim internal\nhelp.  (Note that previously setting the global option to the empty\nvalue did this, which is now deprecated.)\nWhen the first character is \":\", the command is invoked as a Vim\nEx command prefixed with [count].\nWhen \"man\" or \"man -s\" is used, Vim will automatically translate\na [count] for the \"K\" command to a section number.\nSee |option-backslash| about including spaces and backslashes.\nExample: >vim\n\tset keywordprg=man\\ -s\n\tset keywordprg=:Man\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, langmap = {binding = "langmap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langmap' 'lmap'\tstring\t(default \"\")\n\t\tglobal\nThis option allows switching your keyboard into a special language\nmode.  When you are typing text in Insert mode the characters are\ninserted directly.  When in Normal mode the 'langmap' option takes\ncare of translating these special characters to the original meaning\nof the key.  This means you don't have to change the keyboard mode to\nbe able to execute Normal mode commands.\nThis is the opposite of the 'keymap' option, where characters are\nmapped in Insert mode.\nAlso consider setting 'langremap' to off, to prevent 'langmap' from\napplying to characters resulting from a mapping.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n\nExample (for Greek, in UTF-8):\t\t\t\t*greek*  >vim\n    set langmap=\206\145A,\206\146B,\206\168C,\206\148D,\206\149E,\206\166F,\206\147G,\206\151H,\206\153I,\206\158J,\206\154K,\206\155L,\206\156M,\206\157N,\206\159O,\206\160P,QQ,\206\161R,\206\163S,\206\164T,\206\152U,\206\169V,WW,\206\167X,\206\165Y,\206\150Z,\206\177a,\206\178b,\207\136c,\206\180d,\206\181e,\207\134f,\206\179g,\206\183h,\206\185i,\206\190j,\206\186k,\206\187l,\206\188m,\206\189n,\206\191o,\207\128p,qq,\207\129r,\207\131s,\207\132t,\206\184u,\207\137v,\207\130w,\207\135x,\207\133y,\206\182z\n<\tExample (exchanges meaning of z and y for commands): >vim\n    set langmap=zy,yz,ZY,YZ\n<\nThe 'langmap' option is a list of parts, separated with commas.  Each\npart can be in one of two forms:\n1.  A list of pairs.  Each pair is a \"from\" character immediately\n    followed by the \"to\" character.  Examples: \"aA\", \"aAbBcC\".\n2.  A list of \"from\" characters, a semicolon and a list of \"to\"\n    characters.  Example: \"abc;ABC\"\nExample: \"aA,fgh;FGH,cCdDeE\"\nSpecial characters need to be preceded with a backslash.  These are\n\";\", ',', '\"', '|' and backslash itself.\n\nThis will allow you to activate vim actions without having to switch\nback and forth between the languages.  Your language characters will\nbe understood as normal vim English characters (according to the\nlangmap mappings) in the following cases:\n o Normal/Visual mode (commands, buffer/register names, user mappings)\n o Insert/Replace Mode: Register names after CTRL-R\n o Insert/Replace Mode: Mappings\nCharacters entered in Command-line mode will NOT be affected by\nthis option.   Note that this option can be changed at any time\nallowing to switch between mappings for different languages/encodings.\nUse a mapping to avoid having to type it each time!"}}, langmenu = {binding = "langmenu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langmenu' 'lm'\t\tstring\t(default \"\")\n\t\tglobal\nLanguage to use for menu translation.  Tells which file is loaded\nfrom the \"lang\" directory in 'runtimepath': >vim\n\t\"lang/menu_\" .. &langmenu .. \".vim\"\n<\t(without the spaces).  For example, to always use the Dutch menus, no\nmatter what $LANG is set to: >vim\n\tset langmenu=nl_NL.ISO_8859-1\n<\tWhen 'langmenu' is empty, |v:lang| is used.\nOnly normal file name characters can be used, `/\\*?[|<>` are illegal.\nIf your $LANG is set to a non-English language but you do want to use\nthe English menus: >vim\n\tset langmenu=none\n<\tThis option must be set before loading menus, switching on filetype\ndetection or syntax highlighting.  Once the menus are defined setting\nthis option has no effect.  But you could do this: >vim\n\tsource $VIMRUNTIME/delmenu.vim\n\tset langmenu=de_DE.ISO_8859-1\n\tsource $VIMRUNTIME/menu.vim\n<\tWarning: This deletes all menus that you defined yourself!"}}, langremap = {binding = "langremap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langremap' 'lrm'\tboolean\t(default off)\n\t\tglobal\nWhen off, setting 'langmap' does not apply to characters resulting from\na mapping.  If setting 'langmap' disables some of your mappings, make\nsure this option is off."}}, laststatus = {binding = "laststatus", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'laststatus' 'ls'\tnumber\t(default 2)\n\t\tglobal\nThe value of this option influences when the last window will have a\nstatus line:\n\0090: never\n\0091: only if there are at least two windows\n\0092: always\n\0093: always and ONLY the last window\nThe screen looks nicer with a status line if you have several\nwindows, but it takes another screen line. |status-line|"}}, lazyredraw = {binding = "lazyredraw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lazyredraw' 'lz'\tboolean\t(default off)\n\t\tglobal\nWhen this option is set, the screen will not be redrawn while\nexecuting macros, registers and other commands that have not been\ntyped.  Also, updating the window title is postponed.  To force an\nupdate use |:redraw|.\nThis may occasionally cause display errors.  It is only meant to be set\ntemporarily when performing an operation where redrawing may cause\nflickering or cause a slowdown."}}, lbr = {binding = "lbr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'linebreak' 'lbr'\tboolean\t(default off)\n\t\tlocal to window\nIf on, Vim will wrap long lines at a character in 'breakat' rather\nthan at the last character that fits on the screen.  Unlike\n'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,\nit only affects the way the file is displayed, not its contents.\nIf 'breakindent' is set, line is visually indented. Then, the value\nof 'showbreak' is used to put in front of wrapped lines. This option\nis not used when the 'wrap' option is off.\nNote that <Tab> characters after an <EOL> are mostly not displayed\nwith the right amount of white space."}}, lcs = {binding = "lcs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'listchars' 'lcs'\tstring\t(default \"tab:> ,trail:-,nbsp:+\")\n\t\tglobal or local to window |global-local|\nStrings to use in 'list' mode and for the |:list| command.  It is a\ncomma-separated list of string settings. *E1511*\n\n\t\t\t\t\t\t*lcs-eol*\n  eol:c\t\tCharacter to show at the end of each line.  When\n\t\tomitted, there is no extra character at the end of the\n\t\tline.\n\t\t\t\t\t\t*lcs-tab*\n  tab:xy[z]\tTwo or three characters to be used to show a tab.\n\t\tThe third character is optional.\n\n  tab:xy\tThe 'x' is always used, then 'y' as many times as will\n\t\tfit.  Thus \"tab:>-\" displays: >\n\t\t\t>\n\t\t\t>-\n\t\t\t>--\n\t\t\tetc.\n<\n  tab:xyz\tThe 'z' is always used, then 'x' is prepended, and\n\t\tthen 'y' is used as many times as will fit.  Thus\n\t\t\"tab:<->\" displays: >\n\t\t\t>\n\t\t\t<>\n\t\t\t<->\n\t\t\t<-->\n\t\t\tetc.\n<\n\t\tWhen \"tab:\" is omitted, a tab is shown as ^I.\n\t\t\t\t\t\t*lcs-space*\n  space:c\tCharacter to show for a space.  When omitted, spaces\n\t\tare left blank.\n\t\t\t\t\t\t*lcs-multispace*\n  multispace:c...\n\t\tOne or more characters to use cyclically to show for\n\t\tmultiple consecutive spaces.  Overrides the \"space\"\n\t\tsetting, except for single spaces.  When omitted, the\n\t\t\"space\" setting is used.  For example,\n\t\t`:set listchars=multispace:---+` shows ten consecutive\n\t\tspaces as: >\n\t\t\t---+---+--\n<\n\t\t\t\t\t\t*lcs-lead*\n  lead:c\tCharacter to show for leading spaces.  When omitted,\n\t\tleading spaces are blank.  Overrides the \"space\" and\n\t\t\"multispace\" settings for leading spaces.  You can\n\t\tcombine it with \"tab:\", for example: >vim\n\t\t\tset listchars+=tab:>-,lead:.\n<\n\t\t\t\t\t\t*lcs-leadmultispace*\n  leadmultispace:c...\n\t\tLike the |lcs-multispace| value, but for leading\n\t\tspaces only.  Also overrides |lcs-lead| for leading\n\t\tmultiple spaces.\n\t\t`:set listchars=leadmultispace:---+` shows ten\n\t\tconsecutive leading spaces as: >\n\t\t\t---+---+--XXX\n<\n\t\tWhere \"XXX\" denotes the first non-blank characters in\n\t\tthe line.\n\t\t\t\t\t\t*lcs-trail*\n  trail:c\tCharacter to show for trailing spaces.  When omitted,\n\t\ttrailing spaces are blank.  Overrides the \"space\" and\n\t\t\"multispace\" settings for trailing spaces.\n\t\t\t\t\t\t*lcs-extends*\n  extends:c\tCharacter to show in the last column, when 'wrap' is\n\t\toff and the line continues beyond the right of the\n\t\tscreen.\n\t\t\t\t\t\t*lcs-precedes*\n  precedes:c\tCharacter to show in the first visible column of the\n\t\tphysical line, when there is text preceding the\n\t\tcharacter visible in the first column.\n\t\t\t\t\t\t*lcs-conceal*\n  conceal:c\tCharacter to show in place of concealed text, when\n\t\t'conceallevel' is set to 1.  A space when omitted.\n\t\t\t\t\t\t*lcs-nbsp*\n  nbsp:c\tCharacter to show for a non-breakable space character\n\t\t(0xA0 (160 decimal) and U+202F).  Left blank when\n\t\tomitted.\n\nThe characters ':' and ',' should not be used.  UTF-8 characters can\nbe used.  All characters must be single width. *E1512*\n\nEach character can be specified as hex: >vim\n\tset listchars=eol:\\\\x24\n\tset listchars=eol:\\\\u21b5\n\tset listchars=eol:\\\\U000021b5\n<\tNote that a double backslash is used.  The number of hex characters\nmust be exactly 2 for \\\\x, 4 for \\\\u and 8 for \\\\U.\n\nExamples: >vim\n    set lcs=tab:>-,trail:-\n    set lcs=tab:>-,eol:<,nbsp:%\n    set lcs=extends:>,precedes:<\n<\t|hl-NonText| highlighting will be used for \"eol\", \"extends\" and\n\"precedes\". |hl-Whitespace| for \"nbsp\", \"space\", \"tab\", \"multispace\",\n\"lead\" and \"trail\"."}}, linebreak = {binding = "linebreak", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'linebreak' 'lbr'\tboolean\t(default off)\n\t\tlocal to window\nIf on, Vim will wrap long lines at a character in 'breakat' rather\nthan at the last character that fits on the screen.  Unlike\n'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,\nit only affects the way the file is displayed, not its contents.\nIf 'breakindent' is set, line is visually indented. Then, the value\nof 'showbreak' is used to put in front of wrapped lines. This option\nis not used when the 'wrap' option is off.\nNote that <Tab> characters after an <EOL> are mostly not displayed\nwith the right amount of white space."}}, lines = {binding = "lines", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lines'\t\t\tnumber\t(default 24 or terminal height)\n\t\tglobal\nNumber of lines of the Vim window.\nNormally you don't need to set this.  It is done automatically by the\nterminal initialization code.\nWhen Vim is running in the GUI or in a resizable window, setting this\noption will cause the window size to be changed.  When you only want\nto use the size for the GUI, put the command in your |gvimrc| file.\nVim limits the number of lines to what fits on the screen.  You can\nuse this command to get the tallest window possible: >vim\n\tset lines=999\n<\tMinimum value is 2, maximum value is 1000."}}, linespace = {binding = "linespace", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'linespace' 'lsp'\tnumber\t(default 0)\n\t\tglobal\n\t\tonly in the GUI\nNumber of pixel lines inserted between characters.  Useful if the font\nuses the full character cell height, making lines touch each other.\nWhen non-zero there is room for underlining.\nWith some fonts there can be too much room between lines (to have\nspace for ascents and descents).  Then it makes sense to set\n'linespace' to a negative value.  This may cause display problems\nthough!"}}, lisp = {binding = "lisp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lisp'\t\t\tboolean\t(default off)\n\t\tlocal to buffer\nLisp mode: When <Enter> is typed in insert mode set the indent for\nthe next line to Lisp standards (well, sort of).  Also happens with\n\"cc\" or \"S\".  'autoindent' must also be on for this to work.  The 'p'\nflag in 'cpoptions' changes the method of indenting: Vi compatible or\nbetter.  Also see 'lispwords'.\nThe '-' character is included in keyword characters.  Redefines the\n\"=\" operator to use this same indentation algorithm rather than\ncalling an external program if 'equalprg' is empty."}}, lispoptions = {binding = "lispoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lispoptions' 'lop'\tstring\t(default \"\")\n\t\tlocal to buffer\nComma-separated list of items that influence the Lisp indenting when\nenabled with the |'lisp'| option.  Currently only one item is\nsupported:\n\texpr:1\tuse 'indentexpr' for Lisp indenting when it is set\n\texpr:0\tdo not use 'indentexpr' for Lisp indenting (default)\nNote that when using 'indentexpr' the `=` operator indents all the\nlines, otherwise the first line is not indented (Vi-compatible)."}}, lispwords = {binding = "lispwords", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lispwords' 'lw'\tstring\t(default is very long)\n\t\tglobal or local to buffer |global-local|\nComma-separated list of words that influence the Lisp indenting when\nenabled with the |'lisp'| option."}}, list = {binding = "list", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'list'\t\t\tboolean\t(default off)\n\t\tlocal to window\nList mode: By default, show tabs as \">\", trailing spaces as \"-\", and\nnon-breakable space characters as \"+\". Useful to see the difference\nbetween tabs and spaces and for trailing blanks. Further changed by\nthe 'listchars' option.\n\nWhen 'listchars' does not contain \"tab\" field, tabs are shown as \"^I\"\nor \"<09>\", like how unprintable characters are displayed.\n\nThe cursor is displayed at the start of the space a Tab character\noccupies, not at the end as usual in Normal mode.  To get this cursor\nposition while displaying Tabs with spaces, use: >vim\n\tset list lcs=tab:\\ \\\n<\nNote that list mode will also affect formatting (set with 'textwidth'\nor 'wrapmargin') when 'cpoptions' includes 'L'.  See 'listchars' for\nchanging the way tabs are displayed."}}, listchars = {binding = "listchars", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'listchars' 'lcs'\tstring\t(default \"tab:> ,trail:-,nbsp:+\")\n\t\tglobal or local to window |global-local|\nStrings to use in 'list' mode and for the |:list| command.  It is a\ncomma-separated list of string settings. *E1511*\n\n\t\t\t\t\t\t*lcs-eol*\n  eol:c\t\tCharacter to show at the end of each line.  When\n\t\tomitted, there is no extra character at the end of the\n\t\tline.\n\t\t\t\t\t\t*lcs-tab*\n  tab:xy[z]\tTwo or three characters to be used to show a tab.\n\t\tThe third character is optional.\n\n  tab:xy\tThe 'x' is always used, then 'y' as many times as will\n\t\tfit.  Thus \"tab:>-\" displays: >\n\t\t\t>\n\t\t\t>-\n\t\t\t>--\n\t\t\tetc.\n<\n  tab:xyz\tThe 'z' is always used, then 'x' is prepended, and\n\t\tthen 'y' is used as many times as will fit.  Thus\n\t\t\"tab:<->\" displays: >\n\t\t\t>\n\t\t\t<>\n\t\t\t<->\n\t\t\t<-->\n\t\t\tetc.\n<\n\t\tWhen \"tab:\" is omitted, a tab is shown as ^I.\n\t\t\t\t\t\t*lcs-space*\n  space:c\tCharacter to show for a space.  When omitted, spaces\n\t\tare left blank.\n\t\t\t\t\t\t*lcs-multispace*\n  multispace:c...\n\t\tOne or more characters to use cyclically to show for\n\t\tmultiple consecutive spaces.  Overrides the \"space\"\n\t\tsetting, except for single spaces.  When omitted, the\n\t\t\"space\" setting is used.  For example,\n\t\t`:set listchars=multispace:---+` shows ten consecutive\n\t\tspaces as: >\n\t\t\t---+---+--\n<\n\t\t\t\t\t\t*lcs-lead*\n  lead:c\tCharacter to show for leading spaces.  When omitted,\n\t\tleading spaces are blank.  Overrides the \"space\" and\n\t\t\"multispace\" settings for leading spaces.  You can\n\t\tcombine it with \"tab:\", for example: >vim\n\t\t\tset listchars+=tab:>-,lead:.\n<\n\t\t\t\t\t\t*lcs-leadmultispace*\n  leadmultispace:c...\n\t\tLike the |lcs-multispace| value, but for leading\n\t\tspaces only.  Also overrides |lcs-lead| for leading\n\t\tmultiple spaces.\n\t\t`:set listchars=leadmultispace:---+` shows ten\n\t\tconsecutive leading spaces as: >\n\t\t\t---+---+--XXX\n<\n\t\tWhere \"XXX\" denotes the first non-blank characters in\n\t\tthe line.\n\t\t\t\t\t\t*lcs-trail*\n  trail:c\tCharacter to show for trailing spaces.  When omitted,\n\t\ttrailing spaces are blank.  Overrides the \"space\" and\n\t\t\"multispace\" settings for trailing spaces.\n\t\t\t\t\t\t*lcs-extends*\n  extends:c\tCharacter to show in the last column, when 'wrap' is\n\t\toff and the line continues beyond the right of the\n\t\tscreen.\n\t\t\t\t\t\t*lcs-precedes*\n  precedes:c\tCharacter to show in the first visible column of the\n\t\tphysical line, when there is text preceding the\n\t\tcharacter visible in the first column.\n\t\t\t\t\t\t*lcs-conceal*\n  conceal:c\tCharacter to show in place of concealed text, when\n\t\t'conceallevel' is set to 1.  A space when omitted.\n\t\t\t\t\t\t*lcs-nbsp*\n  nbsp:c\tCharacter to show for a non-breakable space character\n\t\t(0xA0 (160 decimal) and U+202F).  Left blank when\n\t\tomitted.\n\nThe characters ':' and ',' should not be used.  UTF-8 characters can\nbe used.  All characters must be single width. *E1512*\n\nEach character can be specified as hex: >vim\n\tset listchars=eol:\\\\x24\n\tset listchars=eol:\\\\u21b5\n\tset listchars=eol:\\\\U000021b5\n<\tNote that a double backslash is used.  The number of hex characters\nmust be exactly 2 for \\\\x, 4 for \\\\u and 8 for \\\\U.\n\nExamples: >vim\n    set lcs=tab:>-,trail:-\n    set lcs=tab:>-,eol:<,nbsp:%\n    set lcs=extends:>,precedes:<\n<\t|hl-NonText| highlighting will be used for \"eol\", \"extends\" and\n\"precedes\". |hl-Whitespace| for \"nbsp\", \"space\", \"tab\", \"multispace\",\n\"lead\" and \"trail\"."}}, lm = {binding = "lm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langmenu' 'lm'\t\tstring\t(default \"\")\n\t\tglobal\nLanguage to use for menu translation.  Tells which file is loaded\nfrom the \"lang\" directory in 'runtimepath': >vim\n\t\"lang/menu_\" .. &langmenu .. \".vim\"\n<\t(without the spaces).  For example, to always use the Dutch menus, no\nmatter what $LANG is set to: >vim\n\tset langmenu=nl_NL.ISO_8859-1\n<\tWhen 'langmenu' is empty, |v:lang| is used.\nOnly normal file name characters can be used, `/\\*?[|<>` are illegal.\nIf your $LANG is set to a non-English language but you do want to use\nthe English menus: >vim\n\tset langmenu=none\n<\tThis option must be set before loading menus, switching on filetype\ndetection or syntax highlighting.  Once the menus are defined setting\nthis option has no effect.  But you could do this: >vim\n\tsource $VIMRUNTIME/delmenu.vim\n\tset langmenu=de_DE.ISO_8859-1\n\tsource $VIMRUNTIME/menu.vim\n<\tWarning: This deletes all menus that you defined yourself!"}}, lmap = {binding = "lmap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langmap' 'lmap'\tstring\t(default \"\")\n\t\tglobal\nThis option allows switching your keyboard into a special language\nmode.  When you are typing text in Insert mode the characters are\ninserted directly.  When in Normal mode the 'langmap' option takes\ncare of translating these special characters to the original meaning\nof the key.  This means you don't have to change the keyboard mode to\nbe able to execute Normal mode commands.\nThis is the opposite of the 'keymap' option, where characters are\nmapped in Insert mode.\nAlso consider setting 'langremap' to off, to prevent 'langmap' from\napplying to characters resulting from a mapping.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n\nExample (for Greek, in UTF-8):\t\t\t\t*greek*  >vim\n    set langmap=\206\145A,\206\146B,\206\168C,\206\148D,\206\149E,\206\166F,\206\147G,\206\151H,\206\153I,\206\158J,\206\154K,\206\155L,\206\156M,\206\157N,\206\159O,\206\160P,QQ,\206\161R,\206\163S,\206\164T,\206\152U,\206\169V,WW,\206\167X,\206\165Y,\206\150Z,\206\177a,\206\178b,\207\136c,\206\180d,\206\181e,\207\134f,\206\179g,\206\183h,\206\185i,\206\190j,\206\186k,\206\187l,\206\188m,\206\189n,\206\191o,\207\128p,qq,\207\129r,\207\131s,\207\132t,\206\184u,\207\137v,\207\130w,\207\135x,\207\133y,\206\182z\n<\tExample (exchanges meaning of z and y for commands): >vim\n    set langmap=zy,yz,ZY,YZ\n<\nThe 'langmap' option is a list of parts, separated with commas.  Each\npart can be in one of two forms:\n1.  A list of pairs.  Each pair is a \"from\" character immediately\n    followed by the \"to\" character.  Examples: \"aA\", \"aAbBcC\".\n2.  A list of \"from\" characters, a semicolon and a list of \"to\"\n    characters.  Example: \"abc;ABC\"\nExample: \"aA,fgh;FGH,cCdDeE\"\nSpecial characters need to be preceded with a backslash.  These are\n\";\", ',', '\"', '|' and backslash itself.\n\nThis will allow you to activate vim actions without having to switch\nback and forth between the languages.  Your language characters will\nbe understood as normal vim English characters (according to the\nlangmap mappings) in the following cases:\n o Normal/Visual mode (commands, buffer/register names, user mappings)\n o Insert/Replace Mode: Register names after CTRL-R\n o Insert/Replace Mode: Mappings\nCharacters entered in Command-line mode will NOT be affected by\nthis option.   Note that this option can be changed at any time\nallowing to switch between mappings for different languages/encodings.\nUse a mapping to avoid having to type it each time!"}}, loadplugins = {binding = "loadplugins", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'loadplugins' 'lpl'\tboolean\t(default on)\n\t\tglobal\nWhen on the plugin scripts are loaded when starting up |load-plugins|.\nThis option can be reset in your |vimrc| file to disable the loading\nof plugins.\nNote that using the \"-u NONE\" and \"--noplugin\" command line arguments\nreset this option. |-u| |--noplugin|"}}, lop = {binding = "lop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lispoptions' 'lop'\tstring\t(default \"\")\n\t\tlocal to buffer\nComma-separated list of items that influence the Lisp indenting when\nenabled with the |'lisp'| option.  Currently only one item is\nsupported:\n\texpr:1\tuse 'indentexpr' for Lisp indenting when it is set\n\texpr:0\tdo not use 'indentexpr' for Lisp indenting (default)\nNote that when using 'indentexpr' the `=` operator indents all the\nlines, otherwise the first line is not indented (Vi-compatible)."}}, lpl = {binding = "lpl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'loadplugins' 'lpl'\tboolean\t(default on)\n\t\tglobal\nWhen on the plugin scripts are loaded when starting up |load-plugins|.\nThis option can be reset in your |vimrc| file to disable the loading\nof plugins.\nNote that using the \"-u NONE\" and \"--noplugin\" command line arguments\nreset this option. |-u| |--noplugin|"}}, lrm = {binding = "lrm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langremap' 'lrm'\tboolean\t(default off)\n\t\tglobal\nWhen off, setting 'langmap' does not apply to characters resulting from\na mapping.  If setting 'langmap' disables some of your mappings, make\nsure this option is off."}}, ls = {binding = "ls", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'laststatus' 'ls'\tnumber\t(default 2)\n\t\tglobal\nThe value of this option influences when the last window will have a\nstatus line:\n\0090: never\n\0091: only if there are at least two windows\n\0092: always\n\0093: always and ONLY the last window\nThe screen looks nicer with a status line if you have several\nwindows, but it takes another screen line. |status-line|"}}, lsp = {binding = "lsp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'linespace' 'lsp'\tnumber\t(default 0)\n\t\tglobal\n\t\tonly in the GUI\nNumber of pixel lines inserted between characters.  Useful if the font\nuses the full character cell height, making lines touch each other.\nWhen non-zero there is room for underlining.\nWith some fonts there can be too much room between lines (to have\nspace for ascents and descents).  Then it makes sense to set\n'linespace' to a negative value.  This may cause display problems\nthough!"}}, lw = {binding = "lw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lispwords' 'lw'\tstring\t(default is very long)\n\t\tglobal or local to buffer |global-local|\nComma-separated list of words that influence the Lisp indenting when\nenabled with the |'lisp'| option."}}, lz = {binding = "lz", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lazyredraw' 'lz'\tboolean\t(default off)\n\t\tglobal\nWhen this option is set, the screen will not be redrawn while\nexecuting macros, registers and other commands that have not been\ntyped.  Also, updating the window title is postponed.  To force an\nupdate use |:redraw|.\nThis may occasionally cause display errors.  It is only meant to be set\ntemporarily when performing an operation where redrawing may cause\nflickering or cause a slowdown."}}, ma = {binding = "ma", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modifiable' 'ma'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen off the buffer contents cannot be changed.  The 'fileformat' and\n'fileencoding' options also can't be changed.\nCan be reset on startup with the |-M| command line argument."}}, magic = {binding = "magic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'magic'\t\t\tboolean\t(default on)\n\t\tglobal\nChanges the special characters that can be used in search patterns.\nSee |pattern|.\nWARNING: Switching this option off most likely breaks plugins!  That\nis because many patterns assume it's on and will fail when it's off.\nOnly switch it off when working with old Vi scripts.  In any other\nsituation write patterns that work when 'magic' is on.  Include \"\\M\"\nwhen you want to |/\\M|."}}, makeef = {binding = "makeef", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'makeef' 'mef'\t\tstring\t(default \"\")\n\t\tglobal\nName of the errorfile for the |:make| command (see |:make_makeprg|)\nand the |:grep| command.\nWhen it is empty, an internally generated temp file will be used.\nWhen \"##\" is included, it is replaced by a number to make the name\nunique.  This makes sure that the \":make\" command doesn't overwrite an\nexisting file.\nNOT used for the \":cf\" command.  See 'errorfile' for that.\nEnvironment variables are expanded |:set_env|.\nSee |option-backslash| about including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, makeencoding = {binding = "makeencoding", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'makeencoding' 'menc'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nEncoding used for reading the output of external commands.  When empty,\nencoding is not converted.\nThis is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,\n`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,\nand `:laddfile`.\n\nThis would be mostly useful when you use MS-Windows.  If iconv is\nenabled, setting 'makeencoding' to \"char\" has the same effect as\nsetting to the system locale encoding.  Example: >vim\n\tset makeencoding=char\t\" system locale is used\n<"}}, makeprg = {binding = "makeprg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'makeprg' 'mp'\t\tstring\t(default \"make\")\n\t\tglobal or local to buffer |global-local|\nProgram to use for the \":make\" command.  See |:make_makeprg|.\nThis option may contain '%' and '#' characters (see  |:_%| and |:_#|),\nwhich are expanded to the current and alternate file name.  Use |::S|\nto escape file names in case they contain special characters.\nEnvironment variables are expanded |:set_env|.  See |option-backslash|\nabout including spaces and backslashes.\nNote that a '|' must be escaped twice: once for \":set\" and once for\nthe interpretation of a command.  When you use a filter called\n\"myfilter\" do it like this: >vim\n    set makeprg=gmake\\ \\\\\\|\\ myfilter\n<\tThe placeholder \"$*\" can be given (even multiple times) to specify\nwhere the arguments will be included, for example: >vim\n    set makeprg=latex\\ \\\\\\\\nonstopmode\\ \\\\\\\\input\\\\{$*}\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, mat = {binding = "mat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'matchtime' 'mat'\tnumber\t(default 5)\n\t\tglobal\nTenths of a second to show the matching paren, when 'showmatch' is\nset.  Note that this is not in milliseconds, like other options that\nset a time.  This is to be compatible with Nvi."}}, matchpairs = {binding = "matchpairs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'matchpairs' 'mps'\tstring\t(default \"(:),{:},[:]\")\n\t\tlocal to buffer\nCharacters that form pairs.  The |%| command jumps from one to the\nother.\nOnly character pairs are allowed that are different, thus you cannot\njump between two double quotes.\nThe characters must be separated by a colon.\nThe pairs must be separated by a comma.  Example for including '<' and\n'>' (for HTML): >vim\n\tset mps+=<:>\n\n<\tA more exotic example, to jump between the '=' and ';' in an\nassignment, useful for languages like C and Java: >vim\n\tau FileType c,cpp,java set mps+==:;\n\n<\tFor a more advanced way of using \"%\", see the matchit.vim plugin in\nthe $VIMRUNTIME/plugin directory. |add-local-help|"}}, matchtime = {binding = "matchtime", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'matchtime' 'mat'\tnumber\t(default 5)\n\t\tglobal\nTenths of a second to show the matching paren, when 'showmatch' is\nset.  Note that this is not in milliseconds, like other options that\nset a time.  This is to be compatible with Nvi."}}, maxfuncdepth = {binding = "maxfuncdepth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'maxfuncdepth' 'mfd'\tnumber\t(default 100)\n\t\tglobal\nMaximum depth of function calls for user functions.  This normally\ncatches endless recursion.  When using a recursive function with\nmore depth, set 'maxfuncdepth' to a bigger number.  But this will use\nmore memory, there is the danger of failing when memory is exhausted.\nIncreasing this limit above 200 also changes the maximum for Ex\ncommand recursion, see |E169|.\nSee also |:function|.\nAlso used for maximum depth of callback functions."}}, maxmapdepth = {binding = "maxmapdepth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'maxmapdepth' 'mmd'\tnumber\t(default 1000)\n\t\tglobal\nMaximum number of times a mapping is done without resulting in a\ncharacter to be used.  This normally catches endless mappings, like\n\":map x y\" with \":map y x\".  It still does not catch \":map g wg\",\nbecause the 'w' is used before the next mapping is done.  See also\n|key-mapping|."}}, maxmempattern = {binding = "maxmempattern", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'maxmempattern' 'mmp'\tnumber\t(default 1000)\n\t\tglobal\nMaximum amount of memory (in Kbyte) to use for pattern matching.\nThe maximum value is about 2000000.  Use this to work without a limit.\n\t\t\t\t\t\t*E363*\nWhen Vim runs into the limit it gives an error message and mostly\nbehaves like CTRL-C was typed.\nRunning into the limit often means that the pattern is very\ninefficient or too complex.  This may already happen with the pattern\n\"\\(.\\)*\" on a very long line.  \".*\" works much better.\nMight also happen on redraw, when syntax rules try to match a complex\ntext structure.\nVim may run out of memory before hitting the 'maxmempattern' limit, in\nwhich case you get an \"Out of memory\" error instead."}}, mef = {binding = "mef", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'makeef' 'mef'\t\tstring\t(default \"\")\n\t\tglobal\nName of the errorfile for the |:make| command (see |:make_makeprg|)\nand the |:grep| command.\nWhen it is empty, an internally generated temp file will be used.\nWhen \"##\" is included, it is replaced by a number to make the name\nunique.  This makes sure that the \":make\" command doesn't overwrite an\nexisting file.\nNOT used for the \":cf\" command.  See 'errorfile' for that.\nEnvironment variables are expanded |:set_env|.\nSee |option-backslash| about including spaces and backslashes.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, menc = {binding = "menc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'makeencoding' 'menc'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nEncoding used for reading the output of external commands.  When empty,\nencoding is not converted.\nThis is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,\n`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,\nand `:laddfile`.\n\nThis would be mostly useful when you use MS-Windows.  If iconv is\nenabled, setting 'makeencoding' to \"char\" has the same effect as\nsetting to the system locale encoding.  Example: >vim\n\tset makeencoding=char\t\" system locale is used\n<"}}, menuitems = {binding = "menuitems", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'menuitems' 'mis'\tnumber\t(default 25)\n\t\tglobal\nMaximum number of items to use in a menu.  Used for menus that are\ngenerated from a list of items, e.g., the Buffers menu.  Changing this\noption has no direct effect, the menu must be refreshed first."}}, messagesopt = {binding = "messagesopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'messagesopt' 'mopt'\tstring\t(default \"hit-enter,history:500\")\n\t\tglobal\nOption settings for outputting messages.  It can consist of the\nfollowing items.  Items must be separated by a comma.\n\nhit-enter\tUse a |hit-enter| prompt when the message is longer than\n\t\t'cmdheight' size.\n\nwait:{n}\tInstead of using a |hit-enter| prompt, simply wait for\n\t\t{n} milliseconds so that the user has a chance to read\n\t\tthe message.  The maximum value of {n} is 10000.  Use\n\t\0090 to disable the wait (but then the user may miss an\n\t\timportant message).\n\t\tThis item is ignored when \"hit-enter\" is present, but\n\t\trequired when \"hit-enter\" is not present.\n\nhistory:{n}\tDetermines how many entries are remembered in the\n\t\t|:messages| history.  The maximum value is 10000.\n\t\tSetting it to zero clears the message history.\n\t\tThis item must always be present."}}, mfd = {binding = "mfd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'maxfuncdepth' 'mfd'\tnumber\t(default 100)\n\t\tglobal\nMaximum depth of function calls for user functions.  This normally\ncatches endless recursion.  When using a recursive function with\nmore depth, set 'maxfuncdepth' to a bigger number.  But this will use\nmore memory, there is the danger of failing when memory is exhausted.\nIncreasing this limit above 200 also changes the maximum for Ex\ncommand recursion, see |E169|.\nSee also |:function|.\nAlso used for maximum depth of callback functions."}}, mh = {binding = "mh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousehide' 'mh'\tboolean\t(default on)\n\t\tglobal\n\t\tonly in the GUI\nWhen on, the mouse pointer is hidden when characters are typed.\nThe mouse pointer is restored when the mouse is moved."}}, mis = {binding = "mis", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'menuitems' 'mis'\tnumber\t(default 25)\n\t\tglobal\nMaximum number of items to use in a menu.  Used for menus that are\ngenerated from a list of items, e.g., the Buffers menu.  Changing this\noption has no direct effect, the menu must be refreshed first."}}, mkspellmem = {binding = "mkspellmem", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mkspellmem' 'msm'\tstring\t(default \"460000,2000,500\")\n\t\tglobal\nParameters for |:mkspell|.  This tunes when to start compressing the\nword tree.  Compression can be slow when there are many words, but\nit's needed to avoid running out of memory.  The amount of memory used\nper word depends very much on how similar the words are, that's why\nthis tuning is complicated.\n\nThere are three numbers, separated by commas: >\n\t{start},{inc},{added}\n<\nFor most languages the uncompressed word tree fits in memory.  {start}\ngives the amount of memory in Kbyte that can be used before any\ncompression is done.  It should be a bit smaller than the amount of\nmemory that is available to Vim.\n\nWhen going over the {start} limit the {inc} number specifies the\namount of memory in Kbyte that can be allocated before another\ncompression is done.  A low number means compression is done after\nless words are added, which is slow.  A high number means more memory\nwill be allocated.\n\nAfter doing compression, {added} times 1024 words can be added before\nthe {inc} limit is ignored and compression is done when any extra\namount of memory is needed.  A low number means there is a smaller\nchance of hitting the {inc} limit, less memory is used but it's\nslower.\n\nThe languages for which these numbers are important are Italian and\nHungarian.  The default works for when you have about 512 Mbyte.  If\nyou have 1 Gbyte you could use: >vim\n\tset mkspellmem=900000,3000,800\n<\tIf you have less than 512 Mbyte |:mkspell| may fail for some\nlanguages, no matter what you set 'mkspellmem' to.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ml = {binding = "ml", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modeline' 'ml'\t\tboolean\t(default on (off for root))\n\t\tlocal to buffer\nIf 'modeline' is on 'modelines' gives the number of lines that is\nchecked for set commands.  If 'modeline' is off or 'modelines' is zero\nno lines are checked.  See |modeline|."}}, mle = {binding = "mle", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modelineexpr' 'mle'\tboolean\t(default off)\n\t\tglobal\nWhen on allow some options that are an expression to be set in the\nmodeline.  Check the option for whether it is affected by\n'modelineexpr'.  Also see |modeline|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, mls = {binding = "mls", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modelines' 'mls'\tnumber\t(default 5)\n\t\tglobal\nIf 'modeline' is on 'modelines' gives the number of lines that is\nchecked for set commands.  If 'modeline' is off or 'modelines' is zero\nno lines are checked.  See |modeline|."}}, mmd = {binding = "mmd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'maxmapdepth' 'mmd'\tnumber\t(default 1000)\n\t\tglobal\nMaximum number of times a mapping is done without resulting in a\ncharacter to be used.  This normally catches endless mappings, like\n\":map x y\" with \":map y x\".  It still does not catch \":map g wg\",\nbecause the 'w' is used before the next mapping is done.  See also\n|key-mapping|."}}, mmp = {binding = "mmp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'maxmempattern' 'mmp'\tnumber\t(default 1000)\n\t\tglobal\nMaximum amount of memory (in Kbyte) to use for pattern matching.\nThe maximum value is about 2000000.  Use this to work without a limit.\n\t\t\t\t\t\t*E363*\nWhen Vim runs into the limit it gives an error message and mostly\nbehaves like CTRL-C was typed.\nRunning into the limit often means that the pattern is very\ninefficient or too complex.  This may already happen with the pattern\n\"\\(.\\)*\" on a very long line.  \".*\" works much better.\nMight also happen on redraw, when syntax rules try to match a complex\ntext structure.\nVim may run out of memory before hitting the 'maxmempattern' limit, in\nwhich case you get an \"Out of memory\" error instead."}}, mod = {binding = "mod", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modified' 'mod'\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nWhen on, the buffer is considered to be modified.  This option is set\nwhen:\n1. A change was made to the text since it was last written.  Using the\n   |undo| command to go back to the original text will reset the\n   option.  But undoing changes that were made before writing the\n   buffer will set the option again, since the text is different from\n   when it was written.\n2. 'fileformat' or 'fileencoding' is different from its original\n   value.  The original value is set when the buffer is read or\n   written.  A \":set nomodified\" command also resets the original\n   values to the current values and the 'modified' option will be\n   reset.\n   Similarly for 'eol' and 'bomb'.\nThis option is not set when a change is made to the buffer as the\nresult of a BufNewFile, BufRead/BufReadPost, BufWritePost,\nFileAppendPost or VimLeave autocommand event.  See |gzip-example| for\nan explanation.\nWhen 'buftype' is \"nowrite\" or \"nofile\" this option may be set, but\nwill be ignored.\nNote that the text may actually be the same, e.g. 'modified' is set\nwhen using \"rA\" on an \"A\"."}}, modeline = {binding = "modeline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modeline' 'ml'\t\tboolean\t(default on (off for root))\n\t\tlocal to buffer\nIf 'modeline' is on 'modelines' gives the number of lines that is\nchecked for set commands.  If 'modeline' is off or 'modelines' is zero\nno lines are checked.  See |modeline|."}}, modelineexpr = {binding = "modelineexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modelineexpr' 'mle'\tboolean\t(default off)\n\t\tglobal\nWhen on allow some options that are an expression to be set in the\nmodeline.  Check the option for whether it is affected by\n'modelineexpr'.  Also see |modeline|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, modelines = {binding = "modelines", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modelines' 'mls'\tnumber\t(default 5)\n\t\tglobal\nIf 'modeline' is on 'modelines' gives the number of lines that is\nchecked for set commands.  If 'modeline' is off or 'modelines' is zero\nno lines are checked.  See |modeline|."}}, modifiable = {binding = "modifiable", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modifiable' 'ma'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen off the buffer contents cannot be changed.  The 'fileformat' and\n'fileencoding' options also can't be changed.\nCan be reset on startup with the |-M| command line argument."}}, modified = {binding = "modified", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modified' 'mod'\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nWhen on, the buffer is considered to be modified.  This option is set\nwhen:\n1. A change was made to the text since it was last written.  Using the\n   |undo| command to go back to the original text will reset the\n   option.  But undoing changes that were made before writing the\n   buffer will set the option again, since the text is different from\n   when it was written.\n2. 'fileformat' or 'fileencoding' is different from its original\n   value.  The original value is set when the buffer is read or\n   written.  A \":set nomodified\" command also resets the original\n   values to the current values and the 'modified' option will be\n   reset.\n   Similarly for 'eol' and 'bomb'.\nThis option is not set when a change is made to the buffer as the\nresult of a BufNewFile, BufRead/BufReadPost, BufWritePost,\nFileAppendPost or VimLeave autocommand event.  See |gzip-example| for\nan explanation.\nWhen 'buftype' is \"nowrite\" or \"nofile\" this option may be set, but\nwill be ignored.\nNote that the text may actually be the same, e.g. 'modified' is set\nwhen using \"rA\" on an \"A\"."}}, mopt = {binding = "mopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'messagesopt' 'mopt'\tstring\t(default \"hit-enter,history:500\")\n\t\tglobal\nOption settings for outputting messages.  It can consist of the\nfollowing items.  Items must be separated by a comma.\n\nhit-enter\tUse a |hit-enter| prompt when the message is longer than\n\t\t'cmdheight' size.\n\nwait:{n}\tInstead of using a |hit-enter| prompt, simply wait for\n\t\t{n} milliseconds so that the user has a chance to read\n\t\tthe message.  The maximum value of {n} is 10000.  Use\n\t\0090 to disable the wait (but then the user may miss an\n\t\timportant message).\n\t\tThis item is ignored when \"hit-enter\" is present, but\n\t\trequired when \"hit-enter\" is not present.\n\nhistory:{n}\tDetermines how many entries are remembered in the\n\t\t|:messages| history.  The maximum value is 10000.\n\t\tSetting it to zero clears the message history.\n\t\tThis item must always be present."}}, more = {binding = "more", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'more'\t\t\tboolean\t(default on)\n\t\tglobal\nWhen on, listings pause when the whole screen is filled.  You will get\nthe |more-prompt|.  When this option is off there are no pauses, the\nlisting continues until finished."}}, mouse = {binding = "mouse", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mouse'\t\t\tstring\t(default \"nvi\")\n\t\tglobal\nEnables mouse support. For example, to enable the mouse in Normal mode\nand Visual mode: >vim\n\tset mouse=nv\n<\nTo temporarily disable mouse support, hold the shift key while using\nthe mouse.\n\nMouse support can be enabled for different modes:\n\tn\tNormal mode\n\tv\tVisual mode\n\ti\tInsert mode\n\tc\tCommand-line mode\n\th\tall previous modes when editing a help file\n\ta\tall previous modes\n\tr\tfor |hit-enter| and |more-prompt| prompt\n\nLeft-click anywhere in a text buffer to place the cursor there.  This\nworks with operators too, e.g. type |d| then left-click to delete text\nfrom the current cursor position to the position where you clicked.\n\nDrag the |status-line| or vertical separator of a window to resize it.\n\nIf enabled for \"v\" (Visual mode) then double-click selects word-wise,\ntriple-click makes it line-wise, and quadruple-click makes it\nrectangular block-wise.\n\nFor scrolling with a mouse wheel see |scroll-mouse-wheel|.\n\nNote: When enabling the mouse in a terminal, copy/paste will use the\n\"* register if possible. See also 'clipboard'.\n\nRelated options:\n'mousefocus'\twindow focus follows mouse pointer\n'mousemodel'\twhat mouse button does which action\n'mousehide'\thide mouse pointer while typing text\n'selectmode'\twhether to start Select mode or Visual mode"}}, mousef = {binding = "mousef", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousefocus' 'mousef'\tboolean\t(default off)\n\t\tglobal\nThe window that the mouse pointer is on is automatically activated.\nWhen changing the window layout or window focus in another way, the\nmouse pointer is moved to the window with keyboard focus.  Off is the\ndefault because it makes using the pull down menus a little goofy, as\na pointer transit may activate a window unintentionally."}}, mousefocus = {binding = "mousefocus", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousefocus' 'mousef'\tboolean\t(default off)\n\t\tglobal\nThe window that the mouse pointer is on is automatically activated.\nWhen changing the window layout or window focus in another way, the\nmouse pointer is moved to the window with keyboard focus.  Off is the\ndefault because it makes using the pull down menus a little goofy, as\na pointer transit may activate a window unintentionally."}}, mousehide = {binding = "mousehide", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousehide' 'mh'\tboolean\t(default on)\n\t\tglobal\n\t\tonly in the GUI\nWhen on, the mouse pointer is hidden when characters are typed.\nThe mouse pointer is restored when the mouse is moved."}}, mousem = {binding = "mousem", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousemodel' 'mousem'\tstring\t(default \"popup_setpos\")\n\t\tglobal\nSets the model to use for the mouse.  The name mostly specifies what\nthe right mouse button is used for:\n   extend\tRight mouse button extends a selection.  This works\n\t\tlike in an xterm.\n   popup\tRight mouse button pops up a menu.  The shifted left\n\t\tmouse button extends a selection.  This works like\n\t\twith Microsoft Windows.\n   popup_setpos Like \"popup\", but the cursor will be moved to the\n\t\tposition where the mouse was clicked, and thus the\n\t\tselected operation will act upon the clicked object.\n\t\tIf clicking inside a selection, that selection will\n\t\tbe acted upon, i.e. no cursor move.  This implies of\n\t\tcourse, that right clicking outside a selection will\n\t\tend Visual mode.\nOverview of what button does what for each model:\nmouse\t\t    extend\t\tpopup(_setpos) ~\nleft click\t    place cursor\tplace cursor\nleft drag\t    start selection\tstart selection\nshift-left\t    search word\t\textend selection\nright click\t    extend selection\tpopup menu (place cursor)\nright drag\t    extend selection\t-\nmiddle click\t    paste\t\tpaste\n\nIn the \"popup\" model the right mouse button produces a pop-up menu.\nNvim creates a default |popup-menu| but you can redefine it.\n\nNote that you can further refine the meaning of buttons with mappings.\nSee |mouse-overview|.  But mappings are NOT used for modeless selection.\n\nExample: >vim\n    map <S-LeftMouse>     <RightMouse>\n    map <S-LeftDrag>      <RightDrag>\n    map <S-LeftRelease>   <RightRelease>\n    map <2-S-LeftMouse>   <2-RightMouse>\n    map <2-S-LeftDrag>    <2-RightDrag>\n    map <2-S-LeftRelease> <2-RightRelease>\n    map <3-S-LeftMouse>   <3-RightMouse>\n    map <3-S-LeftDrag>    <3-RightDrag>\n    map <3-S-LeftRelease> <3-RightRelease>\n    map <4-S-LeftMouse>   <4-RightMouse>\n    map <4-S-LeftDrag>    <4-RightDrag>\n    map <4-S-LeftRelease> <4-RightRelease>\n<\nMouse commands requiring the CTRL modifier can be simulated by typing\nthe \"g\" key before using the mouse:\n    \"g<LeftMouse>\"  is \"<C-LeftMouse>\t(jump to tag under mouse click)\n    \"g<RightMouse>\" is \"<C-RightMouse>\t(\"CTRL-T\")\n\n*'mousemoveevent'* *'mousemev'* *'nomousemoveevent'* *'nomousemev'* *mouse-hover*\n'mousemoveevent' 'mousemev'\tboolean\t(default off)\n\t\tglobal\nWhen on, mouse move events are delivered to the input queue and are\navailable for mapping |<MouseMove>|. The default, off, avoids the mouse\nmovement overhead except when needed.\nWarning: Setting this option can make pending mappings to be aborted\nwhen the mouse is moved."}}, mousemodel = {binding = "mousemodel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousemodel' 'mousem'\tstring\t(default \"popup_setpos\")\n\t\tglobal\nSets the model to use for the mouse.  The name mostly specifies what\nthe right mouse button is used for:\n   extend\tRight mouse button extends a selection.  This works\n\t\tlike in an xterm.\n   popup\tRight mouse button pops up a menu.  The shifted left\n\t\tmouse button extends a selection.  This works like\n\t\twith Microsoft Windows.\n   popup_setpos Like \"popup\", but the cursor will be moved to the\n\t\tposition where the mouse was clicked, and thus the\n\t\tselected operation will act upon the clicked object.\n\t\tIf clicking inside a selection, that selection will\n\t\tbe acted upon, i.e. no cursor move.  This implies of\n\t\tcourse, that right clicking outside a selection will\n\t\tend Visual mode.\nOverview of what button does what for each model:\nmouse\t\t    extend\t\tpopup(_setpos) ~\nleft click\t    place cursor\tplace cursor\nleft drag\t    start selection\tstart selection\nshift-left\t    search word\t\textend selection\nright click\t    extend selection\tpopup menu (place cursor)\nright drag\t    extend selection\t-\nmiddle click\t    paste\t\tpaste\n\nIn the \"popup\" model the right mouse button produces a pop-up menu.\nNvim creates a default |popup-menu| but you can redefine it.\n\nNote that you can further refine the meaning of buttons with mappings.\nSee |mouse-overview|.  But mappings are NOT used for modeless selection.\n\nExample: >vim\n    map <S-LeftMouse>     <RightMouse>\n    map <S-LeftDrag>      <RightDrag>\n    map <S-LeftRelease>   <RightRelease>\n    map <2-S-LeftMouse>   <2-RightMouse>\n    map <2-S-LeftDrag>    <2-RightDrag>\n    map <2-S-LeftRelease> <2-RightRelease>\n    map <3-S-LeftMouse>   <3-RightMouse>\n    map <3-S-LeftDrag>    <3-RightDrag>\n    map <3-S-LeftRelease> <3-RightRelease>\n    map <4-S-LeftMouse>   <4-RightMouse>\n    map <4-S-LeftDrag>    <4-RightDrag>\n    map <4-S-LeftRelease> <4-RightRelease>\n<\nMouse commands requiring the CTRL modifier can be simulated by typing\nthe \"g\" key before using the mouse:\n    \"g<LeftMouse>\"  is \"<C-LeftMouse>\t(jump to tag under mouse click)\n    \"g<RightMouse>\" is \"<C-RightMouse>\t(\"CTRL-T\")\n\n*'mousemoveevent'* *'mousemev'* *'nomousemoveevent'* *'nomousemev'* *mouse-hover*\n'mousemoveevent' 'mousemev'\tboolean\t(default off)\n\t\tglobal\nWhen on, mouse move events are delivered to the input queue and are\navailable for mapping |<MouseMove>|. The default, off, avoids the mouse\nmovement overhead except when needed.\nWarning: Setting this option can make pending mappings to be aborted\nwhen the mouse is moved."}}, mousescroll = {binding = "mousescroll", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousescroll'\t\tstring\t(default \"ver:3,hor:6\")\n\t\tglobal\nThis option controls the number of lines / columns to scroll by when\nscrolling with a mouse wheel (|scroll-mouse-wheel|). The option is\na comma-separated list. Each part consists of a direction and a count\nas follows:\n\tdirection:count,direction:count\nDirection is one of either \"hor\" or \"ver\". \"hor\" controls horizontal\nscrolling and \"ver\" controls vertical scrolling. Count sets the amount\nto scroll by for the given direction, it should be a non negative\ninteger. Each direction should be set at most once. If a direction\nis omitted, a default value is used (6 for horizontal scrolling and 3\nfor vertical scrolling). You can disable mouse scrolling by using\na count of 0.\n\nExample: >vim\n\tset mousescroll=ver:5,hor:2\n<\tWill make Nvim scroll 5 lines at a time when scrolling vertically, and\nscroll 2 columns at a time when scrolling horizontally."}}, mouset = {binding = "mouset", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousetime' 'mouset'\tnumber\t(default 500)\n\t\tglobal\nDefines the maximum time in msec between two mouse clicks for the\nsecond click to be recognized as a multi click."}}, mousetime = {binding = "mousetime", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousetime' 'mouset'\tnumber\t(default 500)\n\t\tglobal\nDefines the maximum time in msec between two mouse clicks for the\nsecond click to be recognized as a multi click."}}, mp = {binding = "mp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'makeprg' 'mp'\t\tstring\t(default \"make\")\n\t\tglobal or local to buffer |global-local|\nProgram to use for the \":make\" command.  See |:make_makeprg|.\nThis option may contain '%' and '#' characters (see  |:_%| and |:_#|),\nwhich are expanded to the current and alternate file name.  Use |::S|\nto escape file names in case they contain special characters.\nEnvironment variables are expanded |:set_env|.  See |option-backslash|\nabout including spaces and backslashes.\nNote that a '|' must be escaped twice: once for \":set\" and once for\nthe interpretation of a command.  When you use a filter called\n\"myfilter\" do it like this: >vim\n    set makeprg=gmake\\ \\\\\\|\\ myfilter\n<\tThe placeholder \"$*\" can be given (even multiple times) to specify\nwhere the arguments will be included, for example: >vim\n    set makeprg=latex\\ \\\\\\\\nonstopmode\\ \\\\\\\\input\\\\{$*}\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, mps = {binding = "mps", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'matchpairs' 'mps'\tstring\t(default \"(:),{:},[:]\")\n\t\tlocal to buffer\nCharacters that form pairs.  The |%| command jumps from one to the\nother.\nOnly character pairs are allowed that are different, thus you cannot\njump between two double quotes.\nThe characters must be separated by a colon.\nThe pairs must be separated by a comma.  Example for including '<' and\n'>' (for HTML): >vim\n\tset mps+=<:>\n\n<\tA more exotic example, to jump between the '=' and ';' in an\nassignment, useful for languages like C and Java: >vim\n\tau FileType c,cpp,java set mps+==:;\n\n<\tFor a more advanced way of using \"%\", see the matchit.vim plugin in\nthe $VIMRUNTIME/plugin directory. |add-local-help|"}}, msm = {binding = "msm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mkspellmem' 'msm'\tstring\t(default \"460000,2000,500\")\n\t\tglobal\nParameters for |:mkspell|.  This tunes when to start compressing the\nword tree.  Compression can be slow when there are many words, but\nit's needed to avoid running out of memory.  The amount of memory used\nper word depends very much on how similar the words are, that's why\nthis tuning is complicated.\n\nThere are three numbers, separated by commas: >\n\t{start},{inc},{added}\n<\nFor most languages the uncompressed word tree fits in memory.  {start}\ngives the amount of memory in Kbyte that can be used before any\ncompression is done.  It should be a bit smaller than the amount of\nmemory that is available to Vim.\n\nWhen going over the {start} limit the {inc} number specifies the\namount of memory in Kbyte that can be allocated before another\ncompression is done.  A low number means compression is done after\nless words are added, which is slow.  A high number means more memory\nwill be allocated.\n\nAfter doing compression, {added} times 1024 words can be added before\nthe {inc} limit is ignored and compression is done when any extra\namount of memory is needed.  A low number means there is a smaller\nchance of hitting the {inc} limit, less memory is used but it's\nslower.\n\nThe languages for which these numbers are important are Italian and\nHungarian.  The default works for when you have about 512 Mbyte.  If\nyou have 1 Gbyte you could use: >vim\n\tset mkspellmem=900000,3000,800\n<\tIf you have less than 512 Mbyte |:mkspell| may fail for some\nlanguages, no matter what you set 'mkspellmem' to.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nf = {binding = "nf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'nrformats' 'nf'\tstring\t(default \"bin,hex\")\n\t\tlocal to buffer\nThis defines what bases Vim will consider for numbers when using the\nCTRL-A and CTRL-X commands for adding to and subtracting from a number\nrespectively; see |CTRL-A| for more info on these commands.\nalpha\tIf included, single alphabetical characters will be\n\tincremented or decremented.  This is useful for a list with a\n\tletter index a), b), etc.\t\t*octal-nrformats*\noctal\tIf included, numbers that start with a zero will be considered\n\tto be octal.  Example: Using CTRL-A on \"007\" results in \"010\".\nhex\tIf included, numbers starting with \"0x\" or \"0X\" will be\n\tconsidered to be hexadecimal.  Example: Using CTRL-X on\n\t\"0x100\" results in \"0x0ff\".\nbin\tIf included, numbers starting with \"0b\" or \"0B\" will be\n\tconsidered to be binary.  Example: Using CTRL-X on\n\t\"0b1000\" subtracts one, resulting in \"0b0111\".\nunsigned    If included, numbers are recognized as unsigned. Thus a\n\tleading dash or negative sign won't be considered as part of\n\tthe number.  Examples:\n\t    Using CTRL-X on \"2020\" in \"9-2020\" results in \"9-2019\"\n\t    (without \"unsigned\" it would become \"9-2021\").\n\t    Using CTRL-A on \"2020\" in \"9-2020\" results in \"9-2021\"\n\t    (without \"unsigned\" it would become \"9-2019\").\n\t    Using CTRL-X on \"0\" or CTRL-A on \"18446744073709551615\"\n\t    (2^64 - 1) has no effect, overflow is prevented.\nblank\tIf included, treat numbers as signed or unsigned based on\n\tpreceding whitespace.  If a number with a leading dash has its\n\tdash immediately preceded by a non-whitespace character (i.e.,\n\tnot a tab or a \" \"), the negative sign won't be considered as\n\tpart of the number.  For example:\n\t    Using CTRL-A on \"14\" in \"Carbon-14\" results in \"Carbon-15\"\n\t    (without \"blank\" it would become \"Carbon-13\").\n\t    Using CTRL-X on \"8\" in \"Carbon -8\" results in \"Carbon -9\"\n\t    (because -8 is preceded by whitespace.  If \"unsigned\" was\n\t    set, it would result in \"Carbon -7\").\n\tIf this format is included, overflow is prevented as if\n\t\"unsigned\" were set.  If both this format and \"unsigned\" are\n\tincluded, \"unsigned\" will take precedence.\n\nNumbers which simply begin with a digit in the range 1-9 are always\nconsidered decimal.  This also happens for numbers that are not\nrecognized as octal or hex."}}, noacd = {binding = "noacd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autochdir' 'acd'\tboolean\t(default off)\n\t\tglobal\nWhen on, Vim will change the current working directory whenever you\nopen a file, switch buffers, delete a buffer or open/close a window.\nIt will change to the directory containing the file which was opened\nor selected.  When a buffer has no name it also has no directory, thus\nthe current directory won't change when navigating to it.\nNote: When this option is on some plugins may not work."}}, noai = {binding = "noai", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoindent' 'ai'\tboolean\t(default on)\n\t\tlocal to buffer\nCopy indent from current line when starting a new line (typing <CR>\nin Insert mode or when using the \"o\" or \"O\" command).  If you do not\ntype anything on the new line except <BS> or CTRL-D and then type\n<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor\nto another line has the same effect, unless the 'I' flag is included\nin 'cpoptions'.\nWhen autoindent is on, formatting (with the \"gq\" command or when you\nreach 'textwidth' in Insert mode) uses the indentation of the first\nline.\nWhen 'smartindent' or 'cindent' is on the indent is changed in\na different way."}}, noallowrevins = {binding = "noallowrevins", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'allowrevins' 'ari'\tboolean\t(default off)\n\t\tglobal\nAllow CTRL-_ in Insert mode.  This is default off, to avoid that users\nthat accidentally type CTRL-_ instead of SHIFT-_ get into reverse\nInsert mode, and don't know how to get out.  See 'revins'."}}, noar = {binding = "noar", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoread' 'ar'\t\tboolean\t(default on)\n\t\tglobal or local to buffer |global-local|\nWhen a file has been detected to have been changed outside of Vim and\nit has not been changed inside of Vim, automatically read it again.\nWhen the file has been deleted this is not done, so you have the text\nfrom before it was deleted.  When it appears again then it is read.\n|timestamp|\nIf this option has a local value, use this command to switch back to\nusing the global value: >vim\n\tset autoread<\n<"}}, noarab = {binding = "noarab", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabic' 'arab'\t\tboolean\t(default off)\n\t\tlocal to window\nThis option can be set to start editing Arabic text.\nSetting this option will:\n- Set the 'rightleft' option, unless 'termbidi' is set.\n- Set the 'arabicshape' option, unless 'termbidi' is set.\n- Set the 'keymap' option to \"arabic\"; in Insert mode CTRL-^ toggles\n  between typing English and Arabic key mapping.\n- Set the 'delcombine' option\n\nResetting this option will:\n- Reset the 'rightleft' option.\n- Disable the use of 'keymap' (without changing its value).\nNote that 'arabicshape' and 'delcombine' are not reset (it is a global\noption).\nAlso see |arabic.txt|."}}, noarabic = {binding = "noarabic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabic' 'arab'\t\tboolean\t(default off)\n\t\tlocal to window\nThis option can be set to start editing Arabic text.\nSetting this option will:\n- Set the 'rightleft' option, unless 'termbidi' is set.\n- Set the 'arabicshape' option, unless 'termbidi' is set.\n- Set the 'keymap' option to \"arabic\"; in Insert mode CTRL-^ toggles\n  between typing English and Arabic key mapping.\n- Set the 'delcombine' option\n\nResetting this option will:\n- Reset the 'rightleft' option.\n- Disable the use of 'keymap' (without changing its value).\nNote that 'arabicshape' and 'delcombine' are not reset (it is a global\noption).\nAlso see |arabic.txt|."}}, noarabicshape = {binding = "noarabicshape", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabicshape' 'arshape'\tboolean\t(default on)\n\t\tglobal\nWhen on and 'termbidi' is off, the required visual character\ncorrections that need to take place for displaying the Arabic language\ntake effect.  Shaping, in essence, gets enabled; the term is a broad\none which encompasses:\n  a) the changing/morphing of characters based on their location\n     within a word (initial, medial, final and stand-alone).\n  b) the enabling of the ability to compose characters\n  c) the enabling of the required combining of some characters\nWhen disabled the display shows each character's true stand-alone\nform.\nArabic is a complex language which requires other settings, for\nfurther details see |arabic.txt|."}}, noari = {binding = "noari", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'allowrevins' 'ari'\tboolean\t(default off)\n\t\tglobal\nAllow CTRL-_ in Insert mode.  This is default off, to avoid that users\nthat accidentally type CTRL-_ instead of SHIFT-_ get into reverse\nInsert mode, and don't know how to get out.  See 'revins'."}}, noarshape = {binding = "noarshape", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'arabicshape' 'arshape'\tboolean\t(default on)\n\t\tglobal\nWhen on and 'termbidi' is off, the required visual character\ncorrections that need to take place for displaying the Arabic language\ntake effect.  Shaping, in essence, gets enabled; the term is a broad\none which encompasses:\n  a) the changing/morphing of characters based on their location\n     within a word (initial, medial, final and stand-alone).\n  b) the enabling of the ability to compose characters\n  c) the enabling of the required combining of some characters\nWhen disabled the display shows each character's true stand-alone\nform.\nArabic is a complex language which requires other settings, for\nfurther details see |arabic.txt|."}}, noautochdir = {binding = "noautochdir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autochdir' 'acd'\tboolean\t(default off)\n\t\tglobal\nWhen on, Vim will change the current working directory whenever you\nopen a file, switch buffers, delete a buffer or open/close a window.\nIt will change to the directory containing the file which was opened\nor selected.  When a buffer has no name it also has no directory, thus\nthe current directory won't change when navigating to it.\nNote: When this option is on some plugins may not work."}}, noautoindent = {binding = "noautoindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoindent' 'ai'\tboolean\t(default on)\n\t\tlocal to buffer\nCopy indent from current line when starting a new line (typing <CR>\nin Insert mode or when using the \"o\" or \"O\" command).  If you do not\ntype anything on the new line except <BS> or CTRL-D and then type\n<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor\nto another line has the same effect, unless the 'I' flag is included\nin 'cpoptions'.\nWhen autoindent is on, formatting (with the \"gq\" command or when you\nreach 'textwidth' in Insert mode) uses the indentation of the first\nline.\nWhen 'smartindent' or 'cindent' is on the indent is changed in\na different way."}}, noautoread = {binding = "noautoread", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autoread' 'ar'\t\tboolean\t(default on)\n\t\tglobal or local to buffer |global-local|\nWhen a file has been detected to have been changed outside of Vim and\nit has not been changed inside of Vim, automatically read it again.\nWhen the file has been deleted this is not done, so you have the text\nfrom before it was deleted.  When it appears again then it is read.\n|timestamp|\nIf this option has a local value, use this command to switch back to\nusing the global value: >vim\n\tset autoread<\n<"}}, noautowrite = {binding = "noautowrite", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowrite' 'aw'\tboolean\t(default off)\n\t\tglobal\nWrite the contents of the file, if it has been modified, on each\n`:next`, `:rewind`, `:last`, `:first`, `:previous`, `:stop`,\n`:suspend`, `:tag`, `:!`, `:make`, CTRL-] and CTRL-^ command; and when\na `:buffer`, CTRL-O, CTRL-I, '{A-Z0-9}, or `{A-Z0-9} command takes one\nto another file.\nA buffer is not written if it becomes hidden, e.g. when 'bufhidden' is\nset to \"hide\" and `:next` is used.\nNote that for some commands the 'autowrite' option is not used, see\n'autowriteall' for that.\nSome buffers will not be written, specifically when 'buftype' is\n\"nowrite\", \"nofile\", \"terminal\" or \"prompt\".\nUSE WITH CARE: If you make temporary changes to a buffer that you\ndon't want to be saved this option may cause it to be saved anyway.\nRenaming the buffer with \":file {name}\" may help avoid this."}}, noautowriteall = {binding = "noautowriteall", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowriteall' 'awa'\tboolean\t(default off)\n\t\tglobal\nLike 'autowrite', but also used for commands \":edit\", \":enew\", \":quit\",\n\":qall\", \":exit\", \":xit\", \":recover\" and closing the Vim window.\nSetting this option also implies that Vim behaves like 'autowrite' has\nbeen set."}}, noaw = {binding = "noaw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowrite' 'aw'\tboolean\t(default off)\n\t\tglobal\nWrite the contents of the file, if it has been modified, on each\n`:next`, `:rewind`, `:last`, `:first`, `:previous`, `:stop`,\n`:suspend`, `:tag`, `:!`, `:make`, CTRL-] and CTRL-^ command; and when\na `:buffer`, CTRL-O, CTRL-I, '{A-Z0-9}, or `{A-Z0-9} command takes one\nto another file.\nA buffer is not written if it becomes hidden, e.g. when 'bufhidden' is\nset to \"hide\" and `:next` is used.\nNote that for some commands the 'autowrite' option is not used, see\n'autowriteall' for that.\nSome buffers will not be written, specifically when 'buftype' is\n\"nowrite\", \"nofile\", \"terminal\" or \"prompt\".\nUSE WITH CARE: If you make temporary changes to a buffer that you\ndon't want to be saved this option may cause it to be saved anyway.\nRenaming the buffer with \":file {name}\" may help avoid this."}}, noawa = {binding = "noawa", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'autowriteall' 'awa'\tboolean\t(default off)\n\t\tglobal\nLike 'autowrite', but also used for commands \":edit\", \":enew\", \":quit\",\n\":qall\", \":exit\", \":xit\", \":recover\" and closing the Vim window.\nSetting this option also implies that Vim behaves like 'autowrite' has\nbeen set."}}, nobackup = {binding = "nobackup", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backup' 'bk'\t\tboolean\t(default off)\n\t\tglobal\nMake a backup before overwriting a file.  Leave it around after the\nfile has been successfully written.  If you do not want to keep the\nbackup file, but you do want a backup while the file is being\nwritten, reset this option and set the 'writebackup' option (this is\nthe default).  If you do not want a backup file at all reset both\noptions (use this if your file system is almost full).  See the\n|backup-table| for more explanations.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nWhen 'patchmode' is set, the backup may be renamed to become the\noldest version of a file."}}, nobin = {binding = "nobin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'binary' 'bin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nThis option should be set before editing a binary file.  You can also\nuse the |-b| Vim argument.  When this option is switched on a few\noptions will be changed (also when it already was on):\n\t'textwidth'  will be set to 0\n\t'wrapmargin' will be set to 0\n\t'modeline'   will be off\n\t'expandtab'  will be off\nAlso, 'fileformat' and 'fileformats' options will not be used, the\nfile is read and written like 'fileformat' was \"unix\" (a single <NL>\nseparates lines).\nThe 'fileencoding' and 'fileencodings' options will not be used, the\nfile is read without conversion.\nNOTE: When you start editing a(nother) file while the 'bin' option is\non, settings from autocommands may change the settings again (e.g.,\n'textwidth'), causing trouble when editing.  You might want to set\n'bin' again when the file has been loaded.\nThe previous values of these options are remembered and restored when\n'bin' is switched from on to off.  Each buffer has its own set of\nsaved option values.\nTo edit a file with 'binary' set you can use the |++bin| argument.\nThis avoids you have to do \":set bin\", which would have effect for all\nfiles you edit.\nWhen writing a file the <EOL> for the last line is only written if\nthere was one in the original file (normally Vim appends an <EOL> to\nthe last line if there is none; this would make the file longer).  See\nthe 'endofline' option."}}, nobinary = {binding = "nobinary", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'binary' 'bin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nThis option should be set before editing a binary file.  You can also\nuse the |-b| Vim argument.  When this option is switched on a few\noptions will be changed (also when it already was on):\n\t'textwidth'  will be set to 0\n\t'wrapmargin' will be set to 0\n\t'modeline'   will be off\n\t'expandtab'  will be off\nAlso, 'fileformat' and 'fileformats' options will not be used, the\nfile is read and written like 'fileformat' was \"unix\" (a single <NL>\nseparates lines).\nThe 'fileencoding' and 'fileencodings' options will not be used, the\nfile is read without conversion.\nNOTE: When you start editing a(nother) file while the 'bin' option is\non, settings from autocommands may change the settings again (e.g.,\n'textwidth'), causing trouble when editing.  You might want to set\n'bin' again when the file has been loaded.\nThe previous values of these options are remembered and restored when\n'bin' is switched from on to off.  Each buffer has its own set of\nsaved option values.\nTo edit a file with 'binary' set you can use the |++bin| argument.\nThis avoids you have to do \":set bin\", which would have effect for all\nfiles you edit.\nWhen writing a file the <EOL> for the last line is only written if\nthere was one in the original file (normally Vim appends an <EOL> to\nthe last line if there is none; this would make the file longer).  See\nthe 'endofline' option."}}, nobk = {binding = "nobk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'backup' 'bk'\t\tboolean\t(default off)\n\t\tglobal\nMake a backup before overwriting a file.  Leave it around after the\nfile has been successfully written.  If you do not want to keep the\nbackup file, but you do want a backup while the file is being\nwritten, reset this option and set the 'writebackup' option (this is\nthe default).  If you do not want a backup file at all reset both\noptions (use this if your file system is almost full).  See the\n|backup-table| for more explanations.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nWhen 'patchmode' is set, the backup may be renamed to become the\noldest version of a file."}}, nobl = {binding = "nobl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'buflisted' 'bl'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen this option is set, the buffer shows up in the buffer list.  If\nit is reset it is not used for \":bnext\", \"ls\", the Buffers menu, etc.\nThis option is reset by Vim for buffers that are only used to remember\na file name or marks.  Vim sets it when starting to edit a buffer.\nBut not when moving to a buffer with \":buffer\"."}}, nobomb = {binding = "nobomb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'bomb'\t\t\tboolean\t(default off)\n\t\tlocal to buffer\nWhen writing a file and the following conditions are met, a BOM (Byte\nOrder Mark) is prepended to the file:\n- this option is on\n- the 'binary' option is off\n- 'fileencoding' is \"utf-8\", \"ucs-2\", \"ucs-4\" or one of the little/big\n  endian variants.\nSome applications use the BOM to recognize the encoding of the file.\nOften used for UCS-2 files on MS-Windows.  For other applications it\ncauses trouble, for example: \"cat file1 file2\" makes the BOM of file2\nappear halfway through the resulting file.  Gcc doesn't accept a BOM.\nWhen Vim reads a file and 'fileencodings' starts with \"ucs-bom\", a\ncheck for the presence of the BOM is done and 'bomb' set accordingly.\nUnless 'binary' is set, it is removed from the first line, so that you\ndon't see it when editing.  When you don't change the options, the BOM\nwill be restored when writing the file."}}, nobreakindent = {binding = "nobreakindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakindent' 'bri'\tboolean\t(default off)\n\t\tlocal to window\nEvery wrapped line will continue visually indented (same amount of\nspace as the beginning of that line), thus preserving horizontal blocks\nof text."}}, nobri = {binding = "nobri", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'breakindent' 'bri'\tboolean\t(default off)\n\t\tlocal to window\nEvery wrapped line will continue visually indented (same amount of\nspace as the beginning of that line), thus preserving horizontal blocks\nof text."}}, nobuflisted = {binding = "nobuflisted", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'buflisted' 'bl'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen this option is set, the buffer shows up in the buffer list.  If\nit is reset it is not used for \":bnext\", \"ls\", the Buffers menu, etc.\nThis option is reset by Vim for buffers that are only used to remember\na file name or marks.  Vim sets it when starting to edit a buffer.\nBut not when moving to a buffer with \":buffer\"."}}, nocdh = {binding = "nocdh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cdhome' 'cdh'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, |:cd|, |:tcd| and |:lcd| without an argument changes the\ncurrent working directory to the |$HOME| directory like in Unix.\nWhen off, those commands just print the current directory name.\nOn Unix this option has no effect.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nocdhome = {binding = "nocdhome", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cdhome' 'cdh'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, |:cd|, |:tcd| and |:lcd| without an argument changes the\ncurrent working directory to the |$HOME| directory like in Unix.\nWhen off, those commands just print the current directory name.\nOn Unix this option has no effect.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nocf = {binding = "nocf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'confirm' 'cf'\t\tboolean\t(default off)\n\t\tglobal\nWhen 'confirm' is on, certain operations that would normally\nfail because of unsaved changes to a buffer, e.g. \":q\" and \":e\",\ninstead raise a dialog asking if you wish to save the current\nfile(s).  You can still use a ! to unconditionally |abandon| a buffer.\nIf 'confirm' is off you can still activate confirmation for one\ncommand only (this is most useful in mappings) with the |:confirm|\ncommand.\nAlso see the |confirm()| function and the 'v' flag in 'guioptions'."}}, noci = {binding = "noci", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'copyindent' 'ci'\tboolean\t(default off)\n\t\tlocal to buffer\nCopy the structure of the existing lines indent when autoindenting a\nnew line.  Normally the new indent is reconstructed by a series of\ntabs followed by spaces as required (unless |'expandtab'| is enabled,\nin which case only spaces are used).  Enabling this option makes the\nnew line copy whatever characters were used for indenting on the\nexisting line.  'expandtab' has no effect on these characters, a Tab\nremains a Tab.  If the new indent is greater than on the existing\nline, the remaining space is filled in the normal manner.\nSee 'preserveindent'."}}, nocin = {binding = "nocin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cindent' 'cin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nEnables automatic C program indenting.  See 'cinkeys' to set the keys\nthat trigger reindenting in insert mode and 'cinoptions' to set your\npreferred indent style.\nIf 'indentexpr' is not empty, it overrules 'cindent'.\nIf 'lisp' is not on and both 'indentexpr' and 'equalprg' are empty,\nthe \"=\" operator indents using this algorithm rather than calling an\nexternal program.\nSee |C-indenting|.\nWhen you don't like the way 'cindent' works, try the 'smartindent'\noption or 'indentexpr'."}}, nocindent = {binding = "nocindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cindent' 'cin'\t\tboolean\t(default off)\n\t\tlocal to buffer\nEnables automatic C program indenting.  See 'cinkeys' to set the keys\nthat trigger reindenting in insert mode and 'cinoptions' to set your\npreferred indent style.\nIf 'indentexpr' is not empty, it overrules 'cindent'.\nIf 'lisp' is not on and both 'indentexpr' and 'equalprg' are empty,\nthe \"=\" operator indents using this algorithm rather than calling an\nexternal program.\nSee |C-indenting|.\nWhen you don't like the way 'cindent' works, try the 'smartindent'\noption or 'indentexpr'."}}, noconfirm = {binding = "noconfirm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'confirm' 'cf'\t\tboolean\t(default off)\n\t\tglobal\nWhen 'confirm' is on, certain operations that would normally\nfail because of unsaved changes to a buffer, e.g. \":q\" and \":e\",\ninstead raise a dialog asking if you wish to save the current\nfile(s).  You can still use a ! to unconditionally |abandon| a buffer.\nIf 'confirm' is off you can still activate confirmation for one\ncommand only (this is most useful in mappings) with the |:confirm|\ncommand.\nAlso see the |confirm()| function and the 'v' flag in 'guioptions'."}}, nocopyindent = {binding = "nocopyindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'copyindent' 'ci'\tboolean\t(default off)\n\t\tlocal to buffer\nCopy the structure of the existing lines indent when autoindenting a\nnew line.  Normally the new indent is reconstructed by a series of\ntabs followed by spaces as required (unless |'expandtab'| is enabled,\nin which case only spaces are used).  Enabling this option makes the\nnew line copy whatever characters were used for indenting on the\nexisting line.  'expandtab' has no effect on these characters, a Tab\nremains a Tab.  If the new indent is greater than on the existing\nline, the remaining space is filled in the normal manner.\nSee 'preserveindent'."}}, nocrb = {binding = "nocrb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorbind' 'crb'\tboolean\t(default off)\n\t\tlocal to window\nWhen this option is set, as the cursor in the current\nwindow moves other cursorbound windows (windows that also have\nthis option set) move their cursors to the corresponding line and\ncolumn.  This option is useful for viewing the\ndifferences between two versions of a file (see 'diff'); in diff mode,\ninserted and deleted lines (though not characters within a line) are\ntaken into account."}}, nocuc = {binding = "nocuc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorcolumn' 'cuc'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the screen column of the cursor with CursorColumn\n|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing\nslower.\nIf you only want the highlighting in the current window you can use\nthese autocommands: >vim\n\tau WinLeave * set nocursorline nocursorcolumn\n\tau WinEnter * set cursorline cursorcolumn\n<"}}, nocul = {binding = "nocul", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorline' 'cul'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the text line of the cursor with CursorLine |hl-CursorLine|.\nUseful to easily spot the cursor.  Will make screen redrawing slower.\nWhen Visual mode is active the highlighting isn't used to make it\neasier to see the selected text."}}, nocursorbind = {binding = "nocursorbind", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorbind' 'crb'\tboolean\t(default off)\n\t\tlocal to window\nWhen this option is set, as the cursor in the current\nwindow moves other cursorbound windows (windows that also have\nthis option set) move their cursors to the corresponding line and\ncolumn.  This option is useful for viewing the\ndifferences between two versions of a file (see 'diff'); in diff mode,\ninserted and deleted lines (though not characters within a line) are\ntaken into account."}}, nocursorcolumn = {binding = "nocursorcolumn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorcolumn' 'cuc'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the screen column of the cursor with CursorColumn\n|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing\nslower.\nIf you only want the highlighting in the current window you can use\nthese autocommands: >vim\n\tau WinLeave * set nocursorline nocursorcolumn\n\tau WinEnter * set cursorline cursorcolumn\n<"}}, nocursorline = {binding = "nocursorline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'cursorline' 'cul'\tboolean\t(default off)\n\t\tlocal to window\nHighlight the text line of the cursor with CursorLine |hl-CursorLine|.\nUseful to easily spot the cursor.  Will make screen redrawing slower.\nWhen Visual mode is active the highlighting isn't used to make it\neasier to see the selected text."}}, nodeco = {binding = "nodeco", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'delcombine' 'deco'\tboolean\t(default off)\n\t\tglobal\nIf editing Unicode and this option is set, backspace and Normal mode\n\"x\" delete each combining character on its own.  When it is off (the\ndefault) the character along with its combining characters are\ndeleted.\nNote: When 'delcombine' is set \"xx\" may work differently from \"2x\"!\n\nThis is useful for Arabic, Hebrew and many other languages where one\nmay have combining characters overtop of base characters, and want\nto remove only the combining ones."}}, nodelcombine = {binding = "nodelcombine", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'delcombine' 'deco'\tboolean\t(default off)\n\t\tglobal\nIf editing Unicode and this option is set, backspace and Normal mode\n\"x\" delete each combining character on its own.  When it is off (the\ndefault) the character along with its combining characters are\ndeleted.\nNote: When 'delcombine' is set \"xx\" may work differently from \"2x\"!\n\nThis is useful for Arabic, Hebrew and many other languages where one\nmay have combining characters overtop of base characters, and want\nto remove only the combining ones."}}, nodg = {binding = "nodg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'digraph' 'dg'\t\tboolean\t(default off)\n\t\tglobal\nEnable the entering of digraphs in Insert mode with {char1} <BS>\n{char2}.  See |digraphs|."}}, nodiff = {binding = "nodiff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'diff'\t\t\tboolean\t(default off)\n\t\tlocal to window\nJoin the current window in the group of windows that shows differences\nbetween files.  See |diff-mode|."}}, nodigraph = {binding = "nodigraph", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'digraph' 'dg'\t\tboolean\t(default off)\n\t\tglobal\nEnable the entering of digraphs in Insert mode with {char1} <BS>\n{char2}.  See |digraphs|."}}, noea = {binding = "noea", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'equalalways' 'ea'\tboolean\t(default on)\n\t\tglobal\nWhen on, all the windows are automatically made the same size after\nsplitting or closing a window.  This also happens the moment the\noption is switched on.  When off, splitting a window will reduce the\nsize of the current window and leave the other windows the same.  When\nclosing a window the extra lines are given to the window next to it\n(depending on 'splitbelow' and 'splitright').\nWhen mixing vertically and horizontally split windows, a minimal size\nis computed and some windows may be larger if there is room.  The\n'eadirection' option tells in which direction the size is affected.\nChanging the height and width of a window can be avoided by setting\n'winfixheight' and 'winfixwidth', respectively.\nIf a window size is specified when creating a new window sizes are\ncurrently not equalized (it's complicated, but may be implemented in\nthe future)."}}, noeb = {binding = "noeb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorbells' 'eb'\tboolean\t(default off)\n\t\tglobal\nRing the bell (beep or screen flash) for error messages.  This only\nmakes a difference for error messages, the bell will be used always\nfor a lot of errors without a message (e.g., hitting <Esc> in Normal\nmode).  See 'visualbell' to make the bell behave like a screen flash\nor do nothing. See 'belloff' to finetune when to ring the bell."}}, noemo = {binding = "noemo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'emoji' 'emo'\t\tboolean\t(default on)\n\t\tglobal\nWhen on all Unicode emoji characters are considered to be full width.\nThis excludes \"text emoji\" characters, which are normally displayed as\nsingle width. However, such \"text emoji\" are treated as full-width\nemoji if they are followed by the U+FE0F variant selector.\n\nUnfortunately there is no good specification for this and it has been\ndetermined on trial-and-error basis.  Use the |setcellwidths()|\nfunction to change the behavior."}}, noemoji = {binding = "noemoji", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'emoji' 'emo'\t\tboolean\t(default on)\n\t\tglobal\nWhen on all Unicode emoji characters are considered to be full width.\nThis excludes \"text emoji\" characters, which are normally displayed as\nsingle width. However, such \"text emoji\" are treated as full-width\nemoji if they are followed by the U+FE0F variant selector.\n\nUnfortunately there is no good specification for this and it has been\ndetermined on trial-and-error basis.  Use the |setcellwidths()|\nfunction to change the behavior."}}, noendoffile = {binding = "noendoffile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endoffile' 'eof'\tboolean\t(default off)\n\t\tlocal to buffer\nIndicates that a CTRL-Z character was found at the end of the file\nwhen reading it.  Normally only happens when 'fileformat' is \"dos\".\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no CTRL-Z will be written at the\nend of the file.\nSee |eol-and-eof| for example settings."}}, noendofline = {binding = "noendofline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endofline' 'eol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no <EOL> will be written for the\nlast line in the file.  This option is automatically set or reset when\nstarting to edit a new file, depending on whether file has an <EOL>\nfor the last line in the file.  Normally you don't have to set or\nreset this option.\nWhen 'binary' is off and 'fixeol' is on the value is not used when\nwriting the file.  When 'binary' is on or 'fixeol' is off it is used\nto remember the presence of a <EOL> for the last line in the file, so\nthat when you write the file the situation from the original file can\nbe kept.  But you can change it if you want to.\nSee |eol-and-eof| for example settings."}}, noeof = {binding = "noeof", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endoffile' 'eof'\tboolean\t(default off)\n\t\tlocal to buffer\nIndicates that a CTRL-Z character was found at the end of the file\nwhen reading it.  Normally only happens when 'fileformat' is \"dos\".\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no CTRL-Z will be written at the\nend of the file.\nSee |eol-and-eof| for example settings."}}, noeol = {binding = "noeol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'endofline' 'eol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is off and the 'binary' option\nis on, or 'fixeol' option is off, no <EOL> will be written for the\nlast line in the file.  This option is automatically set or reset when\nstarting to edit a new file, depending on whether file has an <EOL>\nfor the last line in the file.  Normally you don't have to set or\nreset this option.\nWhen 'binary' is off and 'fixeol' is on the value is not used when\nwriting the file.  When 'binary' is on or 'fixeol' is off it is used\nto remember the presence of a <EOL> for the last line in the file, so\nthat when you write the file the situation from the original file can\nbe kept.  But you can change it if you want to.\nSee |eol-and-eof| for example settings."}}, noequalalways = {binding = "noequalalways", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'equalalways' 'ea'\tboolean\t(default on)\n\t\tglobal\nWhen on, all the windows are automatically made the same size after\nsplitting or closing a window.  This also happens the moment the\noption is switched on.  When off, splitting a window will reduce the\nsize of the current window and leave the other windows the same.  When\nclosing a window the extra lines are given to the window next to it\n(depending on 'splitbelow' and 'splitright').\nWhen mixing vertically and horizontally split windows, a minimal size\nis computed and some windows may be larger if there is room.  The\n'eadirection' option tells in which direction the size is affected.\nChanging the height and width of a window can be avoided by setting\n'winfixheight' and 'winfixwidth', respectively.\nIf a window size is specified when creating a new window sizes are\ncurrently not equalized (it's complicated, but may be implemented in\nthe future)."}}, noerrorbells = {binding = "noerrorbells", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'errorbells' 'eb'\tboolean\t(default off)\n\t\tglobal\nRing the bell (beep or screen flash) for error messages.  This only\nmakes a difference for error messages, the bell will be used always\nfor a lot of errors without a message (e.g., hitting <Esc> in Normal\nmode).  See 'visualbell' to make the bell behave like a screen flash\nor do nothing. See 'belloff' to finetune when to ring the bell."}}, noet = {binding = "noet", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'expandtab' 'et'\tboolean\t(default off)\n\t\tlocal to buffer\nIn Insert mode: Use the appropriate number of spaces to insert a\n<Tab>.  Spaces are used in indents with the '>' and '<' commands and\nwhen 'autoindent' is on.  To insert a real tab when 'expandtab' is\non, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|."}}, noex = {binding = "noex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'exrc' 'ex'\t\tboolean\t(default off)\n\t\tglobal\nEnables project-local configuration. Nvim will execute any .nvim.lua,\n.nvimrc, or .exrc file found in the |current-directory|, if the file is\nin the |trust| list. Use |:trust| to manage trusted files. See also\n|vim.secure.read()|.\n\nTo get its own location, Lua exrc files can use |debug.getinfo()|.\n\nCompare 'exrc' to |editorconfig|:\n- 'exrc' can execute any code; editorconfig only specifies settings.\n- 'exrc' is Nvim-specific; editorconfig works in other editors.\n\nTo achieve project-local LSP configuration:\n1. Enable 'exrc'.\n2. Place LSP configs at \".nvim/lsp/*.lua\" in your project root.\n3. Create \".nvim.lua\" in your project root directory with this line: >lua\n     vim.cmd[[set runtimepath+=.nvim]]\n<\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, noexpandtab = {binding = "noexpandtab", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'expandtab' 'et'\tboolean\t(default off)\n\t\tlocal to buffer\nIn Insert mode: Use the appropriate number of spaces to insert a\n<Tab>.  Spaces are used in indents with the '>' and '<' commands and\nwhen 'autoindent' is on.  To insert a real tab when 'expandtab' is\non, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|."}}, noexrc = {binding = "noexrc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'exrc' 'ex'\t\tboolean\t(default off)\n\t\tglobal\nEnables project-local configuration. Nvim will execute any .nvim.lua,\n.nvimrc, or .exrc file found in the |current-directory|, if the file is\nin the |trust| list. Use |:trust| to manage trusted files. See also\n|vim.secure.read()|.\n\nTo get its own location, Lua exrc files can use |debug.getinfo()|.\n\nCompare 'exrc' to |editorconfig|:\n- 'exrc' can execute any code; editorconfig only specifies settings.\n- 'exrc' is Nvim-specific; editorconfig works in other editors.\n\nTo achieve project-local LSP configuration:\n1. Enable 'exrc'.\n2. Place LSP configs at \".nvim/lsp/*.lua\" in your project root.\n3. Create \".nvim.lua\" in your project root directory with this line: >lua\n     vim.cmd[[set runtimepath+=.nvim]]\n<\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nofen = {binding = "nofen", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldenable' 'fen'\tboolean\t(default on)\n\t\tlocal to window\nWhen off, all folds are open.  This option can be used to quickly\nswitch between showing all text unfolded and viewing the text with\nfolds (including manually opened or closed folds).  It can be toggled\nwith the |zi| command.  The 'foldcolumn' will remain blank when\n'foldenable' is off.\nThis option is set by commands that create a new fold or close a fold.\nSee |folding|."}}, nofic = {binding = "nofic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileignorecase' 'fic'\tboolean\t(default on for systems where case in file\n                                 names is normally ignored)\n\t\tglobal\nWhen set case is ignored when using file names and directories.\nSee 'wildignorecase' for only ignoring case when doing completion."}}, nofileignorecase = {binding = "nofileignorecase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fileignorecase' 'fic'\tboolean\t(default on for systems where case in file\n                                 names is normally ignored)\n\t\tglobal\nWhen set case is ignored when using file names and directories.\nSee 'wildignorecase' for only ignoring case when doing completion."}}, nofixendofline = {binding = "nofixendofline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fixendofline' 'fixeol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is on, <EOL> at the end of file\nwill be restored if missing.  Turn this option off if you want to\npreserve the situation from the original file.\nWhen the 'binary' option is set the value of this option doesn't\nmatter.\nSee the 'endofline' option.\nSee |eol-and-eof| for example settings."}}, nofixeol = {binding = "nofixeol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fixendofline' 'fixeol'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen writing a file and this option is on, <EOL> at the end of file\nwill be restored if missing.  Turn this option off if you want to\npreserve the situation from the original file.\nWhen the 'binary' option is set the value of this option doesn't\nmatter.\nSee the 'endofline' option.\nSee |eol-and-eof| for example settings."}}, nofoldenable = {binding = "nofoldenable", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'foldenable' 'fen'\tboolean\t(default on)\n\t\tlocal to window\nWhen off, all folds are open.  This option can be used to quickly\nswitch between showing all text unfolded and viewing the text with\nfolds (including manually opened or closed folds).  It can be toggled\nwith the |zi| command.  The 'foldcolumn' will remain blank when\n'foldenable' is off.\nThis option is set by commands that create a new fold or close a fold.\nSee |folding|."}}, nofs = {binding = "nofs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fsync' 'fs'\t\tboolean\t(default on)\n\t\tglobal\nWhen on, the OS function fsync() will be called after saving a file\n(|:write|, |writefile()|, \226\128\166), |swap-file|, |undo-persistence| and |shada-file|.\nThis flushes the file to disk, ensuring that it is safely written.\nSlow on some systems: writing buffers, quitting Nvim, and other\noperations may sometimes take a few seconds.\n\nFiles are ALWAYS flushed ('fsync' is ignored) when:\n- |CursorHold| event is triggered\n- |:preserve| is called\n- system signals low battery life\n- Nvim exits abnormally\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nofsync = {binding = "nofsync", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'fsync' 'fs'\t\tboolean\t(default on)\n\t\tglobal\nWhen on, the OS function fsync() will be called after saving a file\n(|:write|, |writefile()|, \226\128\166), |swap-file|, |undo-persistence| and |shada-file|.\nThis flushes the file to disk, ensuring that it is safely written.\nSlow on some systems: writing buffers, quitting Nvim, and other\noperations may sometimes take a few seconds.\n\nFiles are ALWAYS flushed ('fsync' is ignored) when:\n- |CursorHold| event is triggered\n- |:preserve| is called\n- system signals low battery life\n- Nvim exits abnormally\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nogd = {binding = "nogd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'gdefault' 'gd'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, the \":substitute\" flag 'g' is default on.  This means that\nall matches in a line are substituted instead of one.  When a 'g' flag\nis given to a \":substitute\" command, this will toggle the substitution\nof all or one match.  See |complex-change|.\n\n\tcommand\t\t'gdefault' on\t'gdefault' off\t~\n\t:s///\t\t  subst. all\t  subst. one\n\t:s///g\t\t  subst. one\t  subst. all\n\t:s///gg\t\t  subst. all\t  subst. one\n\nNOTE: Setting this option may break plugins that rely on the default\nbehavior of the 'g' flag. This will also make the 'g' flag have the\nopposite effect of that documented in |:s_g|."}}, nogdefault = {binding = "nogdefault", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'gdefault' 'gd'\t\tboolean\t(default off)\n\t\tglobal\nWhen on, the \":substitute\" flag 'g' is default on.  This means that\nall matches in a line are substituted instead of one.  When a 'g' flag\nis given to a \":substitute\" command, this will toggle the substitution\nof all or one match.  See |complex-change|.\n\n\tcommand\t\t'gdefault' on\t'gdefault' off\t~\n\t:s///\t\t  subst. all\t  subst. one\n\t:s///g\t\t  subst. one\t  subst. all\n\t:s///gg\t\t  subst. all\t  subst. one\n\nNOTE: Setting this option may break plugins that rely on the default\nbehavior of the 'g' flag. This will also make the 'g' flag have the\nopposite effect of that documented in |:s_g|."}}, nohid = {binding = "nohid", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hidden' 'hid'\t\tboolean\t(default on)\n\t\tglobal\nWhen off a buffer is unloaded (including loss of undo information)\nwhen it is |abandon|ed.  When on a buffer becomes hidden when it is\n|abandon|ed.  A buffer displayed in another window does not become\nhidden, of course.\n\nCommands that move through the buffer list sometimes hide a buffer\nalthough the 'hidden' option is off when these three are true:\n- the buffer is modified\n- 'autowrite' is off or writing is not possible\n- the '!' flag was used\nAlso see |windows|.\n\nTo hide a specific buffer use the 'bufhidden' option.\n'hidden' is set for one command with \":hide {command}\" |:hide|."}}, nohidden = {binding = "nohidden", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hidden' 'hid'\t\tboolean\t(default on)\n\t\tglobal\nWhen off a buffer is unloaded (including loss of undo information)\nwhen it is |abandon|ed.  When on a buffer becomes hidden when it is\n|abandon|ed.  A buffer displayed in another window does not become\nhidden, of course.\n\nCommands that move through the buffer list sometimes hide a buffer\nalthough the 'hidden' option is off when these three are true:\n- the buffer is modified\n- 'autowrite' is off or writing is not possible\n- the '!' flag was used\nAlso see |windows|.\n\nTo hide a specific buffer use the 'bufhidden' option.\n'hidden' is set for one command with \":hide {command}\" |:hide|."}}, nohls = {binding = "nohls", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hlsearch' 'hls'\tboolean\t(default on)\n\t\tglobal\nWhen there is a previous search pattern, highlight all its matches.\nThe |hl-Search| highlight group determines the highlighting for all\nmatches not under the cursor while the |hl-CurSearch| highlight group\n(if defined) determines the highlighting for the match under the\ncursor. If |hl-CurSearch| is not defined, then |hl-Search| is used for\nboth. Note that only the matching text is highlighted, any offsets\nare not applied.\nSee also: 'incsearch' and |:match|.\nWhen you get bored looking at the highlighted matches, you can turn it\noff with |:nohlsearch|.  This does not change the option value, as\nsoon as you use a search command, the highlighting comes back.\n'redrawtime' specifies the maximum time spent on finding matches.\nWhen the search pattern can match an end-of-line, Vim will try to\nhighlight all of the matched text.  However, this depends on where the\nsearch starts.  This will be the first line in the window or the first\nline below a closed fold.  A match in a previous line which is not\ndrawn may not continue in a newly drawn line.\nYou can specify whether the highlight status is restored on startup\nwith the 'h' flag in 'shada' |shada-h|."}}, nohlsearch = {binding = "nohlsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'hlsearch' 'hls'\tboolean\t(default on)\n\t\tglobal\nWhen there is a previous search pattern, highlight all its matches.\nThe |hl-Search| highlight group determines the highlighting for all\nmatches not under the cursor while the |hl-CurSearch| highlight group\n(if defined) determines the highlighting for the match under the\ncursor. If |hl-CurSearch| is not defined, then |hl-Search| is used for\nboth. Note that only the matching text is highlighted, any offsets\nare not applied.\nSee also: 'incsearch' and |:match|.\nWhen you get bored looking at the highlighted matches, you can turn it\noff with |:nohlsearch|.  This does not change the option value, as\nsoon as you use a search command, the highlighting comes back.\n'redrawtime' specifies the maximum time spent on finding matches.\nWhen the search pattern can match an end-of-line, Vim will try to\nhighlight all of the matched text.  However, this depends on where the\nsearch starts.  This will be the first line in the window or the first\nline below a closed fold.  A match in a previous line which is not\ndrawn may not continue in a newly drawn line.\nYou can specify whether the highlight status is restored on startup\nwith the 'h' flag in 'shada' |shada-h|."}}, noic = {binding = "noic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ignorecase' 'ic'\tboolean\t(default off)\n\t\tglobal\nIgnore case in search patterns, |cmdline-completion|, when\nsearching in the tags file, and |expr-==|.\nAlso see 'smartcase' and 'tagcase'.\nCan be overruled by using \"\\c\" or \"\\C\" in the pattern, see\n|/ignorecase|."}}, noicon = {binding = "noicon", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'icon'\t\t\tboolean\t(default off, on when title can be restored)\n\t\tglobal\nWhen on, the icon text of the window will be set to the value of\n'iconstring' (if it is not empty), or to the name of the file\ncurrently being edited.  Only the last part of the name is used.\nOverridden by the 'iconstring' option.\nOnly works if the terminal supports setting window icons."}}, noignorecase = {binding = "noignorecase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ignorecase' 'ic'\tboolean\t(default off)\n\t\tglobal\nIgnore case in search patterns, |cmdline-completion|, when\nsearching in the tags file, and |expr-==|.\nAlso see 'smartcase' and 'tagcase'.\nCan be overruled by using \"\\c\" or \"\\C\" in the pattern, see\n|/ignorecase|."}}, noincsearch = {binding = "noincsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'incsearch' 'is'\tboolean\t(default on)\n\t\tglobal\nWhile typing a search command, show where the pattern, as it was typed\nso far, matches.  The matched string is highlighted.  If the pattern\nis invalid or not found, nothing is shown.  The screen will be updated\noften, this is only useful on fast terminals.\nNote that the match will be shown, but the cursor will return to its\noriginal position when no match is found and when pressing <Esc>.  You\nstill need to finish the search command with <Enter> to move the\ncursor to the match.\nYou can use the CTRL-G and CTRL-T keys to move to the next and\nprevious match. |c_CTRL-G| |c_CTRL-T|\nVim only searches for about half a second.  With a complicated\npattern and/or a lot of text the match may not be found.  This is to\navoid that Vim hangs while you are typing the pattern.\nThe |hl-IncSearch| highlight group determines the highlighting.\nWhen 'hlsearch' is on, all matched strings are highlighted too while\ntyping a search command. See also: 'hlsearch'.\nIf you don't want to turn 'hlsearch' on, but want to highlight all\nmatches while searching, you can turn on and off 'hlsearch' with\nautocmd.  Example: >vim\n\taugroup vimrc-incsearch-highlight\n\t  autocmd!\n\t  autocmd CmdlineEnter [\\/\\?] :set hlsearch\n\t  autocmd CmdlineLeave [\\/\\?] :set nohlsearch\n\taugroup END\n<\nCTRL-L can be used to add one character from after the current match\nto the command line.  If 'ignorecase' and 'smartcase' are set and the\ncommand line has no uppercase characters, the added character is\nconverted to lowercase.\nCTRL-R CTRL-W can be used to add the word at the end of the current\nmatch, excluding the characters that were already typed."}}, noinf = {binding = "noinf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'infercase' 'inf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen doing keyword completion in insert mode |ins-completion|, and\n'ignorecase' is also on, the case of the match is adjusted depending\non the typed text.  If the typed text contains a lowercase letter\nwhere the match has an upper case letter, the completed part is made\nlowercase.  If the typed text has no lowercase letters and the match\nhas a lowercase letter where the typed text has an uppercase letter,\nand there is a letter before it, the completed part is made uppercase.\nWith 'noinfercase' the match is used as-is."}}, noinfercase = {binding = "noinfercase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'infercase' 'inf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen doing keyword completion in insert mode |ins-completion|, and\n'ignorecase' is also on, the case of the match is adjusted depending\non the typed text.  If the typed text contains a lowercase letter\nwhere the match has an upper case letter, the completed part is made\nlowercase.  If the typed text has no lowercase letters and the match\nhas a lowercase letter where the typed text has an uppercase letter,\nand there is a letter before it, the completed part is made uppercase.\nWith 'noinfercase' the match is used as-is."}}, nois = {binding = "nois", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'incsearch' 'is'\tboolean\t(default on)\n\t\tglobal\nWhile typing a search command, show where the pattern, as it was typed\nso far, matches.  The matched string is highlighted.  If the pattern\nis invalid or not found, nothing is shown.  The screen will be updated\noften, this is only useful on fast terminals.\nNote that the match will be shown, but the cursor will return to its\noriginal position when no match is found and when pressing <Esc>.  You\nstill need to finish the search command with <Enter> to move the\ncursor to the match.\nYou can use the CTRL-G and CTRL-T keys to move to the next and\nprevious match. |c_CTRL-G| |c_CTRL-T|\nVim only searches for about half a second.  With a complicated\npattern and/or a lot of text the match may not be found.  This is to\navoid that Vim hangs while you are typing the pattern.\nThe |hl-IncSearch| highlight group determines the highlighting.\nWhen 'hlsearch' is on, all matched strings are highlighted too while\ntyping a search command. See also: 'hlsearch'.\nIf you don't want to turn 'hlsearch' on, but want to highlight all\nmatches while searching, you can turn on and off 'hlsearch' with\nautocmd.  Example: >vim\n\taugroup vimrc-incsearch-highlight\n\t  autocmd!\n\t  autocmd CmdlineEnter [\\/\\?] :set hlsearch\n\t  autocmd CmdlineLeave [\\/\\?] :set nohlsearch\n\taugroup END\n<\nCTRL-L can be used to add one character from after the current match\nto the command line.  If 'ignorecase' and 'smartcase' are set and the\ncommand line has no uppercase characters, the added character is\nconverted to lowercase.\nCTRL-R CTRL-W can be used to add the word at the end of the current\nmatch, excluding the characters that were already typed."}}, nojoinspaces = {binding = "nojoinspaces", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'joinspaces' 'js'\tboolean\t(default off)\n\t\tglobal\nInsert two spaces after a '.', '?' and '!' with a join command.\nOtherwise only one space is inserted."}}, nojs = {binding = "nojs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'joinspaces' 'js'\tboolean\t(default off)\n\t\tglobal\nInsert two spaces after a '.', '?' and '!' with a join command.\nOtherwise only one space is inserted."}}, nolangremap = {binding = "nolangremap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langremap' 'lrm'\tboolean\t(default off)\n\t\tglobal\nWhen off, setting 'langmap' does not apply to characters resulting from\na mapping.  If setting 'langmap' disables some of your mappings, make\nsure this option is off."}}, nolazyredraw = {binding = "nolazyredraw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lazyredraw' 'lz'\tboolean\t(default off)\n\t\tglobal\nWhen this option is set, the screen will not be redrawn while\nexecuting macros, registers and other commands that have not been\ntyped.  Also, updating the window title is postponed.  To force an\nupdate use |:redraw|.\nThis may occasionally cause display errors.  It is only meant to be set\ntemporarily when performing an operation where redrawing may cause\nflickering or cause a slowdown."}}, nolbr = {binding = "nolbr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'linebreak' 'lbr'\tboolean\t(default off)\n\t\tlocal to window\nIf on, Vim will wrap long lines at a character in 'breakat' rather\nthan at the last character that fits on the screen.  Unlike\n'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,\nit only affects the way the file is displayed, not its contents.\nIf 'breakindent' is set, line is visually indented. Then, the value\nof 'showbreak' is used to put in front of wrapped lines. This option\nis not used when the 'wrap' option is off.\nNote that <Tab> characters after an <EOL> are mostly not displayed\nwith the right amount of white space."}}, nolinebreak = {binding = "nolinebreak", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'linebreak' 'lbr'\tboolean\t(default off)\n\t\tlocal to window\nIf on, Vim will wrap long lines at a character in 'breakat' rather\nthan at the last character that fits on the screen.  Unlike\n'wrapmargin' and 'textwidth', this does not insert <EOL>s in the file,\nit only affects the way the file is displayed, not its contents.\nIf 'breakindent' is set, line is visually indented. Then, the value\nof 'showbreak' is used to put in front of wrapped lines. This option\nis not used when the 'wrap' option is off.\nNote that <Tab> characters after an <EOL> are mostly not displayed\nwith the right amount of white space."}}, nolisp = {binding = "nolisp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lisp'\t\t\tboolean\t(default off)\n\t\tlocal to buffer\nLisp mode: When <Enter> is typed in insert mode set the indent for\nthe next line to Lisp standards (well, sort of).  Also happens with\n\"cc\" or \"S\".  'autoindent' must also be on for this to work.  The 'p'\nflag in 'cpoptions' changes the method of indenting: Vi compatible or\nbetter.  Also see 'lispwords'.\nThe '-' character is included in keyword characters.  Redefines the\n\"=\" operator to use this same indentation algorithm rather than\ncalling an external program if 'equalprg' is empty."}}, nolist = {binding = "nolist", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'list'\t\t\tboolean\t(default off)\n\t\tlocal to window\nList mode: By default, show tabs as \">\", trailing spaces as \"-\", and\nnon-breakable space characters as \"+\". Useful to see the difference\nbetween tabs and spaces and for trailing blanks. Further changed by\nthe 'listchars' option.\n\nWhen 'listchars' does not contain \"tab\" field, tabs are shown as \"^I\"\nor \"<09>\", like how unprintable characters are displayed.\n\nThe cursor is displayed at the start of the space a Tab character\noccupies, not at the end as usual in Normal mode.  To get this cursor\nposition while displaying Tabs with spaces, use: >vim\n\tset list lcs=tab:\\ \\\n<\nNote that list mode will also affect formatting (set with 'textwidth'\nor 'wrapmargin') when 'cpoptions' includes 'L'.  See 'listchars' for\nchanging the way tabs are displayed."}}, noloadplugins = {binding = "noloadplugins", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'loadplugins' 'lpl'\tboolean\t(default on)\n\t\tglobal\nWhen on the plugin scripts are loaded when starting up |load-plugins|.\nThis option can be reset in your |vimrc| file to disable the loading\nof plugins.\nNote that using the \"-u NONE\" and \"--noplugin\" command line arguments\nreset this option. |-u| |--noplugin|"}}, nolpl = {binding = "nolpl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'loadplugins' 'lpl'\tboolean\t(default on)\n\t\tglobal\nWhen on the plugin scripts are loaded when starting up |load-plugins|.\nThis option can be reset in your |vimrc| file to disable the loading\nof plugins.\nNote that using the \"-u NONE\" and \"--noplugin\" command line arguments\nreset this option. |-u| |--noplugin|"}}, nolrm = {binding = "nolrm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'langremap' 'lrm'\tboolean\t(default off)\n\t\tglobal\nWhen off, setting 'langmap' does not apply to characters resulting from\na mapping.  If setting 'langmap' disables some of your mappings, make\nsure this option is off."}}, nolz = {binding = "nolz", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'lazyredraw' 'lz'\tboolean\t(default off)\n\t\tglobal\nWhen this option is set, the screen will not be redrawn while\nexecuting macros, registers and other commands that have not been\ntyped.  Also, updating the window title is postponed.  To force an\nupdate use |:redraw|.\nThis may occasionally cause display errors.  It is only meant to be set\ntemporarily when performing an operation where redrawing may cause\nflickering or cause a slowdown."}}, noma = {binding = "noma", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modifiable' 'ma'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen off the buffer contents cannot be changed.  The 'fileformat' and\n'fileencoding' options also can't be changed.\nCan be reset on startup with the |-M| command line argument."}}, nomagic = {binding = "nomagic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'magic'\t\t\tboolean\t(default on)\n\t\tglobal\nChanges the special characters that can be used in search patterns.\nSee |pattern|.\nWARNING: Switching this option off most likely breaks plugins!  That\nis because many patterns assume it's on and will fail when it's off.\nOnly switch it off when working with old Vi scripts.  In any other\nsituation write patterns that work when 'magic' is on.  Include \"\\M\"\nwhen you want to |/\\M|."}}, nomh = {binding = "nomh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousehide' 'mh'\tboolean\t(default on)\n\t\tglobal\n\t\tonly in the GUI\nWhen on, the mouse pointer is hidden when characters are typed.\nThe mouse pointer is restored when the mouse is moved."}}, noml = {binding = "noml", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modeline' 'ml'\t\tboolean\t(default on (off for root))\n\t\tlocal to buffer\nIf 'modeline' is on 'modelines' gives the number of lines that is\nchecked for set commands.  If 'modeline' is off or 'modelines' is zero\nno lines are checked.  See |modeline|."}}, nomle = {binding = "nomle", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modelineexpr' 'mle'\tboolean\t(default off)\n\t\tglobal\nWhen on allow some options that are an expression to be set in the\nmodeline.  Check the option for whether it is affected by\n'modelineexpr'.  Also see |modeline|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nomod = {binding = "nomod", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modified' 'mod'\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nWhen on, the buffer is considered to be modified.  This option is set\nwhen:\n1. A change was made to the text since it was last written.  Using the\n   |undo| command to go back to the original text will reset the\n   option.  But undoing changes that were made before writing the\n   buffer will set the option again, since the text is different from\n   when it was written.\n2. 'fileformat' or 'fileencoding' is different from its original\n   value.  The original value is set when the buffer is read or\n   written.  A \":set nomodified\" command also resets the original\n   values to the current values and the 'modified' option will be\n   reset.\n   Similarly for 'eol' and 'bomb'.\nThis option is not set when a change is made to the buffer as the\nresult of a BufNewFile, BufRead/BufReadPost, BufWritePost,\nFileAppendPost or VimLeave autocommand event.  See |gzip-example| for\nan explanation.\nWhen 'buftype' is \"nowrite\" or \"nofile\" this option may be set, but\nwill be ignored.\nNote that the text may actually be the same, e.g. 'modified' is set\nwhen using \"rA\" on an \"A\"."}}, nomodeline = {binding = "nomodeline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modeline' 'ml'\t\tboolean\t(default on (off for root))\n\t\tlocal to buffer\nIf 'modeline' is on 'modelines' gives the number of lines that is\nchecked for set commands.  If 'modeline' is off or 'modelines' is zero\nno lines are checked.  See |modeline|."}}, nomodelineexpr = {binding = "nomodelineexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modelineexpr' 'mle'\tboolean\t(default off)\n\t\tglobal\nWhen on allow some options that are an expression to be set in the\nmodeline.  Check the option for whether it is affected by\n'modelineexpr'.  Also see |modeline|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, nomodifiable = {binding = "nomodifiable", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modifiable' 'ma'\tboolean\t(default on)\n\t\tlocal to buffer\nWhen off the buffer contents cannot be changed.  The 'fileformat' and\n'fileencoding' options also can't be changed.\nCan be reset on startup with the |-M| command line argument."}}, nomodified = {binding = "nomodified", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'modified' 'mod'\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nWhen on, the buffer is considered to be modified.  This option is set\nwhen:\n1. A change was made to the text since it was last written.  Using the\n   |undo| command to go back to the original text will reset the\n   option.  But undoing changes that were made before writing the\n   buffer will set the option again, since the text is different from\n   when it was written.\n2. 'fileformat' or 'fileencoding' is different from its original\n   value.  The original value is set when the buffer is read or\n   written.  A \":set nomodified\" command also resets the original\n   values to the current values and the 'modified' option will be\n   reset.\n   Similarly for 'eol' and 'bomb'.\nThis option is not set when a change is made to the buffer as the\nresult of a BufNewFile, BufRead/BufReadPost, BufWritePost,\nFileAppendPost or VimLeave autocommand event.  See |gzip-example| for\nan explanation.\nWhen 'buftype' is \"nowrite\" or \"nofile\" this option may be set, but\nwill be ignored.\nNote that the text may actually be the same, e.g. 'modified' is set\nwhen using \"rA\" on an \"A\"."}}, nomore = {binding = "nomore", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'more'\t\t\tboolean\t(default on)\n\t\tglobal\nWhen on, listings pause when the whole screen is filled.  You will get\nthe |more-prompt|.  When this option is off there are no pauses, the\nlisting continues until finished."}}, nomousef = {binding = "nomousef", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousefocus' 'mousef'\tboolean\t(default off)\n\t\tglobal\nThe window that the mouse pointer is on is automatically activated.\nWhen changing the window layout or window focus in another way, the\nmouse pointer is moved to the window with keyboard focus.  Off is the\ndefault because it makes using the pull down menus a little goofy, as\na pointer transit may activate a window unintentionally."}}, nomousefocus = {binding = "nomousefocus", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousefocus' 'mousef'\tboolean\t(default off)\n\t\tglobal\nThe window that the mouse pointer is on is automatically activated.\nWhen changing the window layout or window focus in another way, the\nmouse pointer is moved to the window with keyboard focus.  Off is the\ndefault because it makes using the pull down menus a little goofy, as\na pointer transit may activate a window unintentionally."}}, nomousehide = {binding = "nomousehide", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'mousehide' 'mh'\tboolean\t(default on)\n\t\tglobal\n\t\tonly in the GUI\nWhen on, the mouse pointer is hidden when characters are typed.\nThe mouse pointer is restored when the mouse is moved."}}, nonu = {binding = "nonu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'number' 'nu'\t\tboolean\t(default off)\n\t\tlocal to window\nPrint the line number in front of each line.  When the 'n' option is\nexcluded from 'cpoptions' a wrapped line will not use the column of\nline numbers.\nUse the 'numberwidth' option to adjust the room for the line number.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nFor highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the\n|:sign-define| \"numhl\" argument.\n\t\t\t\t\t*number_relativenumber*\nThe 'relativenumber' option changes the displayed number to be\nrelative to the cursor.  Together with 'number' there are these\nfour combinations (cursor in line 3):\n\n\t'nonu'          'nu'            'nonu'          'nu'\n\t'nornu'         'nornu'         'rnu'           'rnu'\n>\n    |apple          |  1 apple      |  2 apple      |  2 apple\n    |pear           |  2 pear       |  1 pear       |  1 pear\n    |nobody         |  3 nobody     |  0 nobody     |3   nobody\n    |there          |  4 there      |  1 there      |  1 there\n<"}}, nonumber = {binding = "nonumber", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'number' 'nu'\t\tboolean\t(default off)\n\t\tlocal to window\nPrint the line number in front of each line.  When the 'n' option is\nexcluded from 'cpoptions' a wrapped line will not use the column of\nline numbers.\nUse the 'numberwidth' option to adjust the room for the line number.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nFor highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the\n|:sign-define| \"numhl\" argument.\n\t\t\t\t\t*number_relativenumber*\nThe 'relativenumber' option changes the displayed number to be\nrelative to the cursor.  Together with 'number' there are these\nfour combinations (cursor in line 3):\n\n\t'nonu'          'nu'            'nonu'          'nu'\n\t'nornu'         'nornu'         'rnu'           'rnu'\n>\n    |apple          |  1 apple      |  2 apple      |  2 apple\n    |pear           |  2 pear       |  1 pear       |  1 pear\n    |nobody         |  3 nobody     |  0 nobody     |3   nobody\n    |there          |  4 there      |  1 there      |  1 there\n<"}}, nopi = {binding = "nopi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'preserveindent' 'pi'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen changing the indent of the current line, preserve as much of the\nindent structure as possible.  Normally the indent is replaced by a\nseries of tabs followed by spaces as required (unless |'expandtab'| is\nenabled, in which case only spaces are used).  Enabling this option\nmeans the indent will preserve as many existing characters as possible\nfor indenting, and only add additional tabs or spaces as required.\n'expandtab' does not apply to the preserved white space, a Tab remains\na Tab.\nNOTE: When using \">>\" multiple times the resulting indent is a mix of\ntabs and spaces.  You might not like this.\nAlso see 'copyindent'.\nUse |:retab| to clean up white space."}}, nopreserveindent = {binding = "nopreserveindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'preserveindent' 'pi'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen changing the indent of the current line, preserve as much of the\nindent structure as possible.  Normally the indent is replaced by a\nseries of tabs followed by spaces as required (unless |'expandtab'| is\nenabled, in which case only spaces are used).  Enabling this option\nmeans the indent will preserve as many existing characters as possible\nfor indenting, and only add additional tabs or spaces as required.\n'expandtab' does not apply to the preserved white space, a Tab remains\na Tab.\nNOTE: When using \">>\" multiple times the resulting indent is a mix of\ntabs and spaces.  You might not like this.\nAlso see 'copyindent'.\nUse |:retab| to clean up white space."}}, nopreviewwindow = {binding = "nopreviewwindow", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'previewwindow' 'pvw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nIdentifies the preview window.  Only one window can have this option\nset.  It's normally not set directly, but by using one of the commands\n|:ptag|, |:pedit|, etc."}}, nopvw = {binding = "nopvw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'previewwindow' 'pvw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nIdentifies the preview window.  Only one window can have this option\nset.  It's normally not set directly, but by using one of the commands\n|:ptag|, |:pedit|, etc."}}, noreadonly = {binding = "noreadonly", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'readonly' 'ro'\t\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nIf on, writes fail unless you use a '!'.  Protects you from\naccidentally overwriting a file.  Default on when Vim is started\nin read-only mode (\"vim -R\") or when the executable is called \"view\".\nWhen using \":w!\" the 'readonly' option is reset for the current\nbuffer, unless the 'Z' flag is in 'cpoptions'.\nWhen using the \":view\" command the 'readonly' option is set for the\nnewly edited buffer.\nSee 'modifiable' for disallowing changes to the buffer."}}, norelativenumber = {binding = "norelativenumber", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'relativenumber' 'rnu'\tboolean\t(default off)\n\t\tlocal to window\nShow the line number relative to the line with the cursor in front of\neach line. Relative line numbers help you use the |count| you can\nprecede some vertical motion commands (e.g. j k + -) with, without\nhaving to calculate it yourself. Especially useful in combination with\nother commands (e.g. y d c < > gq gw =).\nWhen the 'n' option is excluded from 'cpoptions' a wrapped\nline will not use the column of line numbers.\nThe 'numberwidth' option can be used to set the room used for the line\nnumber.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nSee |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for\nthe number.\n\nThe number in front of the cursor line also depends on the value of\n'number', see |number_relativenumber| for all combinations of the two\noptions."}}, norevins = {binding = "norevins", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'revins' 'ri'\t\tboolean\t(default off)\n\t\tglobal\nInserting characters in Insert mode will work backwards.  See \"typing\nbackwards\" |ins-reverse|.  This option can be toggled with the CTRL-_\ncommand in Insert mode, when 'allowrevins' is set."}}, nori = {binding = "nori", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'revins' 'ri'\t\tboolean\t(default off)\n\t\tglobal\nInserting characters in Insert mode will work backwards.  See \"typing\nbackwards\" |ins-reverse|.  This option can be toggled with the CTRL-_\ncommand in Insert mode, when 'allowrevins' is set."}}, norightleft = {binding = "norightleft", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rightleft' 'rl'\tboolean\t(default off)\n\t\tlocal to window\nWhen on, display orientation becomes right-to-left, i.e., characters\nthat are stored in the file appear from the right to the left.\nUsing this option, it is possible to edit files for languages that\nare written from the right to the left such as Hebrew and Arabic.\nThis option is per window, so it is possible to edit mixed files\nsimultaneously, or to view the same file in both ways (this is\nuseful whenever you have a mixed text file with both right-to-left\nand left-to-right strings so that both sets are displayed properly\nin different windows).  Also see |rileft.txt|."}}, norl = {binding = "norl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rightleft' 'rl'\tboolean\t(default off)\n\t\tlocal to window\nWhen on, display orientation becomes right-to-left, i.e., characters\nthat are stored in the file appear from the right to the left.\nUsing this option, it is possible to edit files for languages that\nare written from the right to the left such as Hebrew and Arabic.\nThis option is per window, so it is possible to edit mixed files\nsimultaneously, or to view the same file in both ways (this is\nuseful whenever you have a mixed text file with both right-to-left\nand left-to-right strings so that both sets are displayed properly\nin different windows).  Also see |rileft.txt|."}}, nornu = {binding = "nornu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'relativenumber' 'rnu'\tboolean\t(default off)\n\t\tlocal to window\nShow the line number relative to the line with the cursor in front of\neach line. Relative line numbers help you use the |count| you can\nprecede some vertical motion commands (e.g. j k + -) with, without\nhaving to calculate it yourself. Especially useful in combination with\nother commands (e.g. y d c < > gq gw =).\nWhen the 'n' option is excluded from 'cpoptions' a wrapped\nline will not use the column of line numbers.\nThe 'numberwidth' option can be used to set the room used for the line\nnumber.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nSee |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for\nthe number.\n\nThe number in front of the cursor line also depends on the value of\n'number', see |number_relativenumber| for all combinations of the two\noptions."}}, noro = {binding = "noro", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'readonly' 'ro'\t\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nIf on, writes fail unless you use a '!'.  Protects you from\naccidentally overwriting a file.  Default on when Vim is started\nin read-only mode (\"vim -R\") or when the executable is called \"view\".\nWhen using \":w!\" the 'readonly' option is reset for the current\nbuffer, unless the 'Z' flag is in 'cpoptions'.\nWhen using the \":view\" command the 'readonly' option is set for the\nnewly edited buffer.\nSee 'modifiable' for disallowing changes to the buffer."}}, noru = {binding = "noru", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ruler' 'ru'\t\tboolean\t(default on)\n\t\tglobal\nShow the line and column number of the cursor position, separated by a\ncomma.  When there is room, the relative position of the displayed\ntext in the file is shown on the far right:\n\tTop\tfirst line is visible\n\tBot\tlast line is visible\n\tAll\tfirst and last line are visible\n\00945%\trelative position in the file\nIf 'rulerformat' is set, it will determine the contents of the ruler.\nEach window has its own ruler.  If a window has a status line, the\nruler is shown there.  If a window doesn't have a status line and\n'cmdheight' is zero, the ruler is not shown.  Otherwise it is shown in\nthe last line of the screen.  If the statusline is given by\n'statusline' (i.e. not empty), this option takes precedence over\n'ruler' and 'rulerformat'.\nIf the number of characters displayed is different from the number of\nbytes in the text (e.g., for a TAB or a multibyte character), both\nthe text column (byte number) and the screen column are shown,\nseparated with a dash.\nFor an empty line \"0-1\" is shown.\nFor an empty buffer the line number will also be zero: \"0,0-1\".\nIf you don't want to see the ruler all the time but want to know where\nyou are, use \"g CTRL-G\" |g_CTRL-G|."}}, noruler = {binding = "noruler", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ruler' 'ru'\t\tboolean\t(default on)\n\t\tglobal\nShow the line and column number of the cursor position, separated by a\ncomma.  When there is room, the relative position of the displayed\ntext in the file is shown on the far right:\n\tTop\tfirst line is visible\n\tBot\tlast line is visible\n\tAll\tfirst and last line are visible\n\00945%\trelative position in the file\nIf 'rulerformat' is set, it will determine the contents of the ruler.\nEach window has its own ruler.  If a window has a status line, the\nruler is shown there.  If a window doesn't have a status line and\n'cmdheight' is zero, the ruler is not shown.  Otherwise it is shown in\nthe last line of the screen.  If the statusline is given by\n'statusline' (i.e. not empty), this option takes precedence over\n'ruler' and 'rulerformat'.\nIf the number of characters displayed is different from the number of\nbytes in the text (e.g., for a TAB or a multibyte character), both\nthe text column (byte number) and the screen column are shown,\nseparated with a dash.\nFor an empty line \"0-1\" is shown.\nFor an empty buffer the line number will also be zero: \"0,0-1\".\nIf you don't want to see the ruler all the time but want to know where\nyou are, use \"g CTRL-G\" |g_CTRL-G|."}}, nosb = {binding = "nosb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitbelow' 'sb'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window below the current\none. |:split|"}}, nosc = {binding = "nosc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showcmd' 'sc'\t\tboolean\t(default on)\n\t\tglobal\nShow (partial) command in the last line of the screen.  Set this\noption off if your terminal is slow.\nIn Visual mode the size of the selected area is shown:\n- When selecting characters within a line, the number of characters.\n  If the number of bytes is different it is also displayed: \"2-6\"\n  means two characters and six bytes.\n- When selecting more than one line, the number of lines.\n- When selecting a block, the size in screen characters:\n  {lines}x{columns}.\nThis information can be displayed in an alternative location using the\n'showcmdloc' option, useful when 'cmdheight' is 0."}}, noscb = {binding = "noscb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollbind' 'scb'\tboolean\t(default off)\n\t\tlocal to window\nSee also |scroll-binding|.  When this option is set, scrolling the\ncurrent window also scrolls other scrollbind windows (windows that\nalso have this option set).  This option is useful for viewing the\ndifferences between two versions of a file, see 'diff'.\nSee |'scrollopt'| for options that determine how this option should be\ninterpreted.\nThis option is mostly reset when splitting a window to edit another\nfile.  This means that \":split | edit file\" results in two windows\nwith scroll-binding, but \":split file\" does not."}}, noscrollbind = {binding = "noscrollbind", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollbind' 'scb'\tboolean\t(default off)\n\t\tlocal to window\nSee also |scroll-binding|.  When this option is set, scrolling the\ncurrent window also scrolls other scrollbind windows (windows that\nalso have this option set).  This option is useful for viewing the\ndifferences between two versions of a file, see 'diff'.\nSee |'scrollopt'| for options that determine how this option should be\ninterpreted.\nThis option is mostly reset when splitting a window to edit another\nfile.  This means that \":split | edit file\" results in two windows\nwith scroll-binding, but \":split file\" does not."}}, noscs = {binding = "noscs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartcase' 'scs'\tboolean\t(default off)\n\t\tglobal\nOverride the 'ignorecase' option if the search pattern contains upper\ncase characters.  Only used when the search pattern is typed and\n'ignorecase' option is on.  Used for the commands \"/\", \"?\", \"n\", \"N\",\n\":g\" and \":s\".  Not used for \"*\", \"#\", \"gd\", tag search, etc.  After\n\"*\" and \"#\" you can make 'smartcase' used by doing a \"/\" command,\nrecalling the search pattern from history and hitting <Enter>."}}, nosft = {binding = "nosft", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showfulltag' 'sft'\tboolean\t(default off)\n\t\tglobal\nWhen completing a word in insert mode (see |ins-completion|) from the\ntags file, show both the tag name and a tidied-up form of the search\npattern (if there is one) as possible matches.  Thus, if you have\nmatched a C function, you can see a template for what arguments are\nrequired (coding style permitting).\nNote that this doesn't work well together with having \"longest\" in\n'completeopt', because the completion from the search pattern may not\nmatch the typed text."}}, noshellslash = {binding = "noshellslash", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellslash' 'ssl'\tboolean\t(default on, Windows: off)\n\t\tglobal\n\t\tonly modifiable in MS-Windows\nWhen set, a forward slash is used when expanding file names.  This is\nuseful when a Unix-like shell is used instead of cmd.exe.  Backward\nslashes can still be typed, but they are changed to forward slashes by\nVim.\nNote that setting or resetting this option has no effect for some\nexisting file names, thus this option needs to be set before opening\nany file for best results.  This might change in the future.\n'shellslash' only works when a backslash can be used as a path\nseparator.  To test if this is so use: >vim\n\tif exists('+shellslash')\n<\tAlso see 'completeslash'."}}, noshelltemp = {binding = "noshelltemp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shelltemp' 'stmp'\tboolean\t(default on)\n\t\tglobal\nWhen on, use temp files for shell commands.  When off use a pipe.\nWhen using a pipe is not possible temp files are used anyway.\nThe advantage of using a pipe is that nobody can read the temp file\nand the 'shell' command does not need to support redirection.\nThe advantage of using a temp file is that the file type and encoding\ncan be detected.\nThe |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,\n|FilterWritePost| autocommands event are not triggered when\n'shelltemp' is off.\n|system()| does not respect this option, it always uses pipes."}}, noshiftround = {binding = "noshiftround", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shiftround' 'sr'\tboolean\t(default off)\n\t\tglobal\nRound indent to multiple of 'shiftwidth'.  Applies to > and <\ncommands.  CTRL-T and CTRL-D in Insert mode always round the indent to\na multiple of 'shiftwidth' (this is Vi compatible)."}}, noshowcmd = {binding = "noshowcmd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showcmd' 'sc'\t\tboolean\t(default on)\n\t\tglobal\nShow (partial) command in the last line of the screen.  Set this\noption off if your terminal is slow.\nIn Visual mode the size of the selected area is shown:\n- When selecting characters within a line, the number of characters.\n  If the number of bytes is different it is also displayed: \"2-6\"\n  means two characters and six bytes.\n- When selecting more than one line, the number of lines.\n- When selecting a block, the size in screen characters:\n  {lines}x{columns}.\nThis information can be displayed in an alternative location using the\n'showcmdloc' option, useful when 'cmdheight' is 0."}}, noshowfulltag = {binding = "noshowfulltag", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showfulltag' 'sft'\tboolean\t(default off)\n\t\tglobal\nWhen completing a word in insert mode (see |ins-completion|) from the\ntags file, show both the tag name and a tidied-up form of the search\npattern (if there is one) as possible matches.  Thus, if you have\nmatched a C function, you can see a template for what arguments are\nrequired (coding style permitting).\nNote that this doesn't work well together with having \"longest\" in\n'completeopt', because the completion from the search pattern may not\nmatch the typed text."}}, noshowmatch = {binding = "noshowmatch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmatch' 'sm'\tboolean\t(default off)\n\t\tglobal\nWhen a bracket is inserted, briefly jump to the matching one.  The\njump is only done if the match can be seen on the screen.  The time to\nshow the match can be set with 'matchtime'.\nA Beep is given if there is no match (no matter if the match can be\nseen or not).\nWhen the 'm' flag is not included in 'cpoptions', typing a character\nwill immediately move the cursor back to where it belongs.\nSee the \"sm\" field in 'guicursor' for setting the cursor shape and\nblinking when showing the match.\nThe 'matchpairs' option can be used to specify the characters to show\nmatches for.  'rightleft' and 'revins' are used to look for opposite\nmatches.\nAlso see the matchparen plugin for highlighting the match when moving\naround |pi_paren.txt|.\nNote: Use of the short form is rated PG."}}, noshowmode = {binding = "noshowmode", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmode' 'smd'\tboolean\t(default on)\n\t\tglobal\nIf in Insert, Replace or Visual mode put a message on the last line.\nThe |hl-ModeMsg| highlight group determines the highlighting.\nThe option has no effect when 'cmdheight' is zero."}}, nosi = {binding = "nosi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartindent' 'si'\tboolean\t(default off)\n\t\tlocal to buffer\nDo smart autoindenting when starting a new line.  Works for C-like\nprograms, but can also be used for other languages.  'cindent' does\nsomething like this, works better in most cases, but is more strict,\nsee |C-indenting|.  When 'cindent' is on or 'indentexpr' is set,\nsetting 'si' has no effect.  'indentexpr' is a more advanced\nalternative.\nNormally 'autoindent' should also be on when using 'smartindent'.\nAn indent is automatically inserted:\n- After a line ending in \"{\".\n- After a line starting with a keyword from 'cinwords'.\n- Before a line starting with \"}\" (only with the \"O\" command).\nWhen typing '}' as the first character in a new line, that line is\ngiven the same indent as the matching \"{\".\nWhen typing '#' as the first character in a new line, the indent for\nthat line is removed, the '#' is put in the first column.  The indent\nis restored for the next line.  If you don't want this, use this\nmapping: \":inoremap # X^H#\", where ^H is entered with CTRL-V CTRL-H.\nWhen using the \">>\" command, lines starting with '#' are not shifted\nright."}}, nosm = {binding = "nosm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmatch' 'sm'\tboolean\t(default off)\n\t\tglobal\nWhen a bracket is inserted, briefly jump to the matching one.  The\njump is only done if the match can be seen on the screen.  The time to\nshow the match can be set with 'matchtime'.\nA Beep is given if there is no match (no matter if the match can be\nseen or not).\nWhen the 'm' flag is not included in 'cpoptions', typing a character\nwill immediately move the cursor back to where it belongs.\nSee the \"sm\" field in 'guicursor' for setting the cursor shape and\nblinking when showing the match.\nThe 'matchpairs' option can be used to specify the characters to show\nmatches for.  'rightleft' and 'revins' are used to look for opposite\nmatches.\nAlso see the matchparen plugin for highlighting the match when moving\naround |pi_paren.txt|.\nNote: Use of the short form is rated PG."}}, nosmartcase = {binding = "nosmartcase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartcase' 'scs'\tboolean\t(default off)\n\t\tglobal\nOverride the 'ignorecase' option if the search pattern contains upper\ncase characters.  Only used when the search pattern is typed and\n'ignorecase' option is on.  Used for the commands \"/\", \"?\", \"n\", \"N\",\n\":g\" and \":s\".  Not used for \"*\", \"#\", \"gd\", tag search, etc.  After\n\"*\" and \"#\" you can make 'smartcase' used by doing a \"/\" command,\nrecalling the search pattern from history and hitting <Enter>."}}, nosmartindent = {binding = "nosmartindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartindent' 'si'\tboolean\t(default off)\n\t\tlocal to buffer\nDo smart autoindenting when starting a new line.  Works for C-like\nprograms, but can also be used for other languages.  'cindent' does\nsomething like this, works better in most cases, but is more strict,\nsee |C-indenting|.  When 'cindent' is on or 'indentexpr' is set,\nsetting 'si' has no effect.  'indentexpr' is a more advanced\nalternative.\nNormally 'autoindent' should also be on when using 'smartindent'.\nAn indent is automatically inserted:\n- After a line ending in \"{\".\n- After a line starting with a keyword from 'cinwords'.\n- Before a line starting with \"}\" (only with the \"O\" command).\nWhen typing '}' as the first character in a new line, that line is\ngiven the same indent as the matching \"{\".\nWhen typing '#' as the first character in a new line, the indent for\nthat line is removed, the '#' is put in the first column.  The indent\nis restored for the next line.  If you don't want this, use this\nmapping: \":inoremap # X^H#\", where ^H is entered with CTRL-V CTRL-H.\nWhen using the \">>\" command, lines starting with '#' are not shifted\nright."}}, nosmarttab = {binding = "nosmarttab", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smarttab' 'sta'\tboolean\t(default on)\n\t\tglobal\nWhen on, a <Tab> in front of a line inserts blanks according to\n'shiftwidth'.  'tabstop' or 'softtabstop' is used in other places.  A\n<BS> will delete a 'shiftwidth' worth of space at the start of the\nline.\nWhen off, a <Tab> always inserts blanks according to 'tabstop' or\n'softtabstop'.  'shiftwidth' is only used for shifting text left or\nright |shift-left-right|.\nWhat gets inserted (a <Tab> or spaces) depends on the 'expandtab'\noption.  Also see |ins-expandtab|.  When 'expandtab' is not set, the\nnumber of spaces is minimized by using <Tab>s."}}, nosmd = {binding = "nosmd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmode' 'smd'\tboolean\t(default on)\n\t\tglobal\nIf in Insert, Replace or Visual mode put a message on the last line.\nThe |hl-ModeMsg| highlight group determines the highlighting.\nThe option has no effect when 'cmdheight' is zero."}}, nosmoothscroll = {binding = "nosmoothscroll", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smoothscroll' 'sms'\tboolean\t(default off)\n\t\tlocal to window\nScrolling works with screen lines.  When 'wrap' is set and the first\nline in the window wraps part of it may not be visible, as if it is\nabove the window. \"<<<\" is displayed at the start of the first line,\nhighlighted with |hl-NonText|.\nYou may also want to add \"lastline\" to the 'display' option to show as\nmuch of the last line as possible.\nNOTE: partly implemented, doesn't work yet for |gj| and |gk|."}}, nosms = {binding = "nosms", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smoothscroll' 'sms'\tboolean\t(default off)\n\t\tlocal to window\nScrolling works with screen lines.  When 'wrap' is set and the first\nline in the window wraps part of it may not be visible, as if it is\nabove the window. \"<<<\" is displayed at the start of the first line,\nhighlighted with |hl-NonText|.\nYou may also want to add \"lastline\" to the 'display' option to show as\nmuch of the last line as possible.\nNOTE: partly implemented, doesn't work yet for |gj| and |gk|."}}, nosol = {binding = "nosol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'startofline' 'sol'\tboolean\t(default off)\n\t\tglobal\nWhen \"on\" the commands listed below move the cursor to the first\nnon-blank of the line.  When off the cursor is kept in the same column\n(if possible).  This applies to the commands:\n- CTRL-D, CTRL-U, CTRL-B, CTRL-F, \"G\", \"H\", \"M\", \"L\", \"gg\"\n- \"d\", \"<<\", \"==\" and \">>\" with a linewise operator\n  (|operator-resulting-pos|)\n- \"%\" with a count\n- buffer changing commands (CTRL-^, :bnext, :bNext, etc.)\n- Ex commands that only have a line number, e.g., \":25\" or \":+\".\nIn case of buffer changing commands the cursor is placed at the column\nwhere it was the last time the buffer was edited."}}, nospell = {binding = "nospell", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spell'\t\t\tboolean\t(default off)\n\t\tlocal to window\nWhen on spell checking will be done.  See |spell|.\nThe languages are specified with 'spelllang'."}}, nosplitbelow = {binding = "nosplitbelow", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitbelow' 'sb'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window below the current\none. |:split|"}}, nosplitright = {binding = "nosplitright", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitright' 'spr'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window right of the\ncurrent one. |:vsplit|"}}, nospr = {binding = "nospr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitright' 'spr'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window right of the\ncurrent one. |:vsplit|"}}, nosr = {binding = "nosr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shiftround' 'sr'\tboolean\t(default off)\n\t\tglobal\nRound indent to multiple of 'shiftwidth'.  Applies to > and <\ncommands.  CTRL-T and CTRL-D in Insert mode always round the indent to\na multiple of 'shiftwidth' (this is Vi compatible)."}}, nossl = {binding = "nossl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellslash' 'ssl'\tboolean\t(default on, Windows: off)\n\t\tglobal\n\t\tonly modifiable in MS-Windows\nWhen set, a forward slash is used when expanding file names.  This is\nuseful when a Unix-like shell is used instead of cmd.exe.  Backward\nslashes can still be typed, but they are changed to forward slashes by\nVim.\nNote that setting or resetting this option has no effect for some\nexisting file names, thus this option needs to be set before opening\nany file for best results.  This might change in the future.\n'shellslash' only works when a backslash can be used as a path\nseparator.  To test if this is so use: >vim\n\tif exists('+shellslash')\n<\tAlso see 'completeslash'."}}, nosta = {binding = "nosta", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smarttab' 'sta'\tboolean\t(default on)\n\t\tglobal\nWhen on, a <Tab> in front of a line inserts blanks according to\n'shiftwidth'.  'tabstop' or 'softtabstop' is used in other places.  A\n<BS> will delete a 'shiftwidth' worth of space at the start of the\nline.\nWhen off, a <Tab> always inserts blanks according to 'tabstop' or\n'softtabstop'.  'shiftwidth' is only used for shifting text left or\nright |shift-left-right|.\nWhat gets inserted (a <Tab> or spaces) depends on the 'expandtab'\noption.  Also see |ins-expandtab|.  When 'expandtab' is not set, the\nnumber of spaces is minimized by using <Tab>s."}}, nostartofline = {binding = "nostartofline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'startofline' 'sol'\tboolean\t(default off)\n\t\tglobal\nWhen \"on\" the commands listed below move the cursor to the first\nnon-blank of the line.  When off the cursor is kept in the same column\n(if possible).  This applies to the commands:\n- CTRL-D, CTRL-U, CTRL-B, CTRL-F, \"G\", \"H\", \"M\", \"L\", \"gg\"\n- \"d\", \"<<\", \"==\" and \">>\" with a linewise operator\n  (|operator-resulting-pos|)\n- \"%\" with a count\n- buffer changing commands (CTRL-^, :bnext, :bNext, etc.)\n- Ex commands that only have a line number, e.g., \":25\" or \":+\".\nIn case of buffer changing commands the cursor is placed at the column\nwhere it was the last time the buffer was edited."}}, nostmp = {binding = "nostmp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shelltemp' 'stmp'\tboolean\t(default on)\n\t\tglobal\nWhen on, use temp files for shell commands.  When off use a pipe.\nWhen using a pipe is not possible temp files are used anyway.\nThe advantage of using a pipe is that nobody can read the temp file\nand the 'shell' command does not need to support redirection.\nThe advantage of using a temp file is that the file type and encoding\ncan be detected.\nThe |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,\n|FilterWritePost| autocommands event are not triggered when\n'shelltemp' is off.\n|system()| does not respect this option, it always uses pipes."}}, noswapfile = {binding = "noswapfile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'swapfile' 'swf'\tboolean\t(default on)\n\t\tlocal to buffer\nUse a swapfile for the buffer.  This option can be reset when a\nswapfile is not wanted for a specific buffer.  For example, with\nconfidential information that even root must not be able to access.\nCareful: All text will be in memory:\n\t- Don't use this for big files.\n\t- Recovery will be impossible!\nA swapfile will only be present when |'updatecount'| is non-zero and\n'swapfile' is set.\nWhen 'swapfile' is reset, the swap file for the current buffer is\nimmediately deleted.  When 'swapfile' is set, and 'updatecount' is\nnon-zero, a swap file is immediately created.\nAlso see |swap-file|.\nIf you want to open a new buffer without creating a swap file for it,\nuse the |:noswapfile| modifier.\nSee 'directory' for where the swap file is created.\n\nThis option is used together with 'bufhidden' and 'buftype' to\nspecify special kinds of buffers.   See |special-buffers|."}}, noswf = {binding = "noswf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'swapfile' 'swf'\tboolean\t(default on)\n\t\tlocal to buffer\nUse a swapfile for the buffer.  This option can be reset when a\nswapfile is not wanted for a specific buffer.  For example, with\nconfidential information that even root must not be able to access.\nCareful: All text will be in memory:\n\t- Don't use this for big files.\n\t- Recovery will be impossible!\nA swapfile will only be present when |'updatecount'| is non-zero and\n'swapfile' is set.\nWhen 'swapfile' is reset, the swap file for the current buffer is\nimmediately deleted.  When 'swapfile' is set, and 'updatecount' is\nnon-zero, a swap file is immediately created.\nAlso see |swap-file|.\nIf you want to open a new buffer without creating a swap file for it,\nuse the |:noswapfile| modifier.\nSee 'directory' for where the swap file is created.\n\nThis option is used together with 'bufhidden' and 'buftype' to\nspecify special kinds of buffers.   See |special-buffers|."}}, notagbsearch = {binding = "notagbsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagbsearch' 'tbs'\tboolean\t(default on)\n\t\tglobal\nWhen searching for a tag (e.g., for the |:ta| command), Vim can either\nuse a binary search or a linear search in a tags file.  Binary\nsearching makes searching for a tag a LOT faster, but a linear search\nwill find more tags if the tags file wasn't properly sorted.\nVim normally assumes that your tags files are sorted, or indicate that\nthey are not sorted.  Only when this is not the case does the\n'tagbsearch' option need to be switched off.\n\nWhen 'tagbsearch' is on, binary searching is first used in the tags\nfiles.  In certain situations, Vim will do a linear search instead for\ncertain files, or retry all files with a linear search.  When\n'tagbsearch' is off, only a linear search is done.\n\nLinear searching is done anyway, for one file, when Vim finds a line\nat the start of the file indicating that it's not sorted: >\n   !_TAG_FILE_SORTED\0090\t/some comment/\n<\t[The whitespace before and after the '0' must be a single <Tab>]\n\nWhen a binary search was done and no match was found in any of the\nfiles listed in 'tags', and case is ignored or a pattern is used\ninstead of a normal tag name, a retry is done with a linear search.\nTags in unsorted tags files, and matches with different case will only\nbe found in the retry.\n\nIf a tag file indicates that it is case-fold sorted, the second,\nlinear search can be avoided when case is ignored.  Use a value of '2'\nin the \"!_TAG_FILE_SORTED\" line for this.  A tag file can be case-fold\nsorted with the -f switch to \"sort\" in most unices, as in the command:\n\"sort -f -o tags tags\".  For Universal ctags and Exuberant ctags\nversion 5.x or higher (at least 5.5) the --sort=foldcase switch can be\nused for this as well.  Note that case must be folded to uppercase for\nthis to work.\n\nBy default, tag searches are case-sensitive.  Case is ignored when\n'ignorecase' is set and 'tagcase' is \"followic\", or when 'tagcase' is\n\"ignore\".\nAlso when 'tagcase' is \"followscs\" and 'smartcase' is set, or\n'tagcase' is \"smart\", and the pattern contains only lowercase\ncharacters.\n\nWhen 'tagbsearch' is off, tags searching is slower when a full match\nexists, but faster when no full match exists.  Tags in unsorted tags\nfiles may only be found with 'tagbsearch' off.\nWhen the tags file is not sorted, or sorted in a wrong way (not on\nASCII byte value), 'tagbsearch' should be off, or the line given above\nmust be included in the tags file.\nThis option doesn't affect commands that find all matching tags (e.g.,\ncommand-line completion and \":help\")."}}, notagrelative = {binding = "notagrelative", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagrelative' 'tr'\tboolean\t(default on)\n\t\tglobal\nIf on and using a tags file in another directory, file names in that\ntags file are relative to the directory where the tags file is."}}, notagstack = {binding = "notagstack", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagstack' 'tgst'\tboolean\t(default on)\n\t\tglobal\nWhen on, the |tagstack| is used normally.  When off, a \":tag\" or\n\":tselect\" command with an argument will not push the tag onto the\ntagstack.  A following \":tag\" without an argument, a \":pop\" command or\nany other command that uses the tagstack will use the unmodified\ntagstack, but does change the pointer to the active entry.\nResetting this option is useful when using a \":tag\" command in a\nmapping which should not change the tagstack."}}, notbidi = {binding = "notbidi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termbidi' 'tbidi'\tboolean\t(default off)\n\t\tglobal\nThe terminal is in charge of Bi-directionality of text (as specified\nby Unicode).  The terminal is also expected to do the required shaping\nthat some languages (such as Arabic) require.\nSetting this option implies that 'rightleft' will not be set when\n'arabic' is set and the value of 'arabicshape' will be ignored.\nNote that setting 'termbidi' has the immediate effect that\n'arabicshape' is ignored, but 'rightleft' isn't changed automatically.\nFor further details see |arabic.txt|."}}, notbs = {binding = "notbs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagbsearch' 'tbs'\tboolean\t(default on)\n\t\tglobal\nWhen searching for a tag (e.g., for the |:ta| command), Vim can either\nuse a binary search or a linear search in a tags file.  Binary\nsearching makes searching for a tag a LOT faster, but a linear search\nwill find more tags if the tags file wasn't properly sorted.\nVim normally assumes that your tags files are sorted, or indicate that\nthey are not sorted.  Only when this is not the case does the\n'tagbsearch' option need to be switched off.\n\nWhen 'tagbsearch' is on, binary searching is first used in the tags\nfiles.  In certain situations, Vim will do a linear search instead for\ncertain files, or retry all files with a linear search.  When\n'tagbsearch' is off, only a linear search is done.\n\nLinear searching is done anyway, for one file, when Vim finds a line\nat the start of the file indicating that it's not sorted: >\n   !_TAG_FILE_SORTED\0090\t/some comment/\n<\t[The whitespace before and after the '0' must be a single <Tab>]\n\nWhen a binary search was done and no match was found in any of the\nfiles listed in 'tags', and case is ignored or a pattern is used\ninstead of a normal tag name, a retry is done with a linear search.\nTags in unsorted tags files, and matches with different case will only\nbe found in the retry.\n\nIf a tag file indicates that it is case-fold sorted, the second,\nlinear search can be avoided when case is ignored.  Use a value of '2'\nin the \"!_TAG_FILE_SORTED\" line for this.  A tag file can be case-fold\nsorted with the -f switch to \"sort\" in most unices, as in the command:\n\"sort -f -o tags tags\".  For Universal ctags and Exuberant ctags\nversion 5.x or higher (at least 5.5) the --sort=foldcase switch can be\nused for this as well.  Note that case must be folded to uppercase for\nthis to work.\n\nBy default, tag searches are case-sensitive.  Case is ignored when\n'ignorecase' is set and 'tagcase' is \"followic\", or when 'tagcase' is\n\"ignore\".\nAlso when 'tagcase' is \"followscs\" and 'smartcase' is set, or\n'tagcase' is \"smart\", and the pattern contains only lowercase\ncharacters.\n\nWhen 'tagbsearch' is off, tags searching is slower when a full match\nexists, but faster when no full match exists.  Tags in unsorted tags\nfiles may only be found with 'tagbsearch' off.\nWhen the tags file is not sorted, or sorted in a wrong way (not on\nASCII byte value), 'tagbsearch' should be off, or the line given above\nmust be included in the tags file.\nThis option doesn't affect commands that find all matching tags (e.g.,\ncommand-line completion and \":help\")."}}, notermbidi = {binding = "notermbidi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termbidi' 'tbidi'\tboolean\t(default off)\n\t\tglobal\nThe terminal is in charge of Bi-directionality of text (as specified\nby Unicode).  The terminal is also expected to do the required shaping\nthat some languages (such as Arabic) require.\nSetting this option implies that 'rightleft' will not be set when\n'arabic' is set and the value of 'arabicshape' will be ignored.\nNote that setting 'termbidi' has the immediate effect that\n'arabicshape' is ignored, but 'rightleft' isn't changed automatically.\nFor further details see |arabic.txt|."}}, notermguicolors = {binding = "notermguicolors", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termguicolors' 'tgc'\tboolean\t(default off)\n\t\tglobal\nEnables 24-bit RGB color in the |TUI|.  Uses \"gui\" |:highlight|\nattributes instead of \"cterm\" attributes. |guifg|\nRequires an ISO-8613-3 compatible terminal.\n\nNvim will automatically attempt to determine if the host terminal\nsupports 24-bit color and will enable this option if it does\n(unless explicitly disabled by the user)."}}, notermsync = {binding = "notermsync", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termsync'\t\tboolean\t(default on)\n\t\tglobal\nIf the host terminal supports it, buffer all screen updates\nmade during a redraw cycle so that each screen is displayed in\nthe terminal all at once. This can prevent tearing or flickering\nwhen the terminal updates faster than Nvim can redraw."}}, notgc = {binding = "notgc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termguicolors' 'tgc'\tboolean\t(default off)\n\t\tglobal\nEnables 24-bit RGB color in the |TUI|.  Uses \"gui\" |:highlight|\nattributes instead of \"cterm\" attributes. |guifg|\nRequires an ISO-8613-3 compatible terminal.\n\nNvim will automatically attempt to determine if the host terminal\nsupports 24-bit color and will enable this option if it does\n(unless explicitly disabled by the user)."}}, notgst = {binding = "notgst", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagstack' 'tgst'\tboolean\t(default on)\n\t\tglobal\nWhen on, the |tagstack| is used normally.  When off, a \":tag\" or\n\":tselect\" command with an argument will not push the tag onto the\ntagstack.  A following \":tag\" without an argument, a \":pop\" command or\nany other command that uses the tagstack will use the unmodified\ntagstack, but does change the pointer to the active entry.\nResetting this option is useful when using a \":tag\" command in a\nmapping which should not change the tagstack."}}, notildeop = {binding = "notildeop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tildeop' 'top'\t\tboolean\t(default off)\n\t\tglobal\nWhen on: The tilde command \"~\" behaves like an operator."}}, notimeout = {binding = "notimeout", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'timeout' 'to'\t\tboolean\t(default on)\n\t\tglobal\nThis option and 'timeoutlen' determine the behavior when part of a\nmapped key sequence has been received. For example, if <c-f> is\npressed and 'timeout' is set, Nvim will wait 'timeoutlen' milliseconds\nfor any key that can follow <c-f> in a mapping."}}, notitle = {binding = "notitle", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'title'\t\t\tboolean\t(default off)\n\t\tglobal\nWhen on, the title of the window will be set to the value of\n'titlestring' (if it is not empty), or to:\n\tfilename [+=-] (path) - Nvim\nWhere:\n\tfilename\tthe name of the file being edited\n\t-\t\tindicates the file cannot be modified, 'ma' off\n\t+\t\tindicates the file was modified\n\t=\t\tindicates the file is read-only\n\t=+\t\tindicates the file is read-only and modified\n\t(path)\t\tis the path of the file being edited\n\t- Nvim\t\tthe server name |v:servername| or \"Nvim\""}}, noto = {binding = "noto", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'timeout' 'to'\t\tboolean\t(default on)\n\t\tglobal\nThis option and 'timeoutlen' determine the behavior when part of a\nmapped key sequence has been received. For example, if <c-f> is\npressed and 'timeout' is set, Nvim will wait 'timeoutlen' milliseconds\nfor any key that can follow <c-f> in a mapping."}}, notop = {binding = "notop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tildeop' 'top'\t\tboolean\t(default off)\n\t\tglobal\nWhen on: The tilde command \"~\" behaves like an operator."}}, notr = {binding = "notr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagrelative' 'tr'\tboolean\t(default on)\n\t\tglobal\nIf on and using a tags file in another directory, file names in that\ntags file are relative to the directory where the tags file is."}}, nottimeout = {binding = "nottimeout", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ttimeout'\t\tboolean\t(default on)\n\t\tglobal\nThis option and 'ttimeoutlen' determine the behavior when part of a\nkey code sequence has been received by the |TUI|.\n\nFor example if <Esc> (the \\x1b byte) is received and 'ttimeout' is\nset, Nvim waits 'ttimeoutlen' milliseconds for the terminal to\ncomplete a key code sequence. If no input arrives before the timeout,\na single <Esc> is assumed. Many TUI cursor key codes start with <Esc>.\n\nOn very slow systems this may fail, causing cursor keys not to work\nsometimes.  If you discover this problem you can \":set ttimeoutlen=9999\".\nNvim will wait for the next character to arrive after an <Esc>."}}, noudf = {binding = "noudf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undofile' 'udf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen on, Vim automatically saves undo history to an undo file when\nwriting a buffer to a file, and restores undo history from the same\nfile on buffer read.\nThe directory where the undo file is stored is specified by 'undodir'.\nFor more information about this feature see |undo-persistence|.\nThe undo file is not read when 'undoreload' causes the buffer from\nbefore a reload to be saved for undo.\nWhen 'undofile' is turned off the undo file is NOT deleted."}}, noundofile = {binding = "noundofile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undofile' 'udf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen on, Vim automatically saves undo history to an undo file when\nwriting a buffer to a file, and restores undo history from the same\nfile on buffer read.\nThe directory where the undo file is stored is specified by 'undodir'.\nFor more information about this feature see |undo-persistence|.\nThe undo file is not read when 'undoreload' causes the buffer from\nbefore a reload to be saved for undo.\nWhen 'undofile' is turned off the undo file is NOT deleted."}}, novb = {binding = "novb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'visualbell' 'vb'\tboolean\t(default off)\n\t\tglobal\nUse visual bell instead of beeping.  Also see 'errorbells'."}}, novisualbell = {binding = "novisualbell", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'visualbell' 'vb'\tboolean\t(default off)\n\t\tglobal\nUse visual bell instead of beeping.  Also see 'errorbells'."}}, nowa = {binding = "nowa", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writeany' 'wa'\t\tboolean\t(default off)\n\t\tglobal\nAllows writing to any file with no need for \"!\" override."}}, nowarn = {binding = "nowarn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'warn'\t\t\tboolean\t(default on)\n\t\tglobal\nGive a warning message when a shell command is used while the buffer\nhas been changed."}}, nowb = {binding = "nowb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writebackup' 'wb'\tboolean\t(default on)\n\t\tglobal\nMake a backup before overwriting a file.  The backup is removed after\nthe file was successfully written, unless the 'backup' option is\nalso on.\nWARNING: Switching this option off means that when Vim fails to write\nyour buffer correctly and then, for whatever reason, Vim exits, you\nlose both the original file and what you were writing.  Only reset\nthis option if your file system is almost full and it makes the write\nfail (and make sure not to exit Vim until the write was successful).\nSee |backup-table| for another explanation.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nDepending on 'backupcopy' the backup is a new file or the original\nfile renamed (and a new file is written)."}}, nowfb = {binding = "nowfb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixbuf' 'wfb'\tboolean\t(default off)\n\t\tlocal to window\nIf enabled, the window and the buffer it is displaying are paired.\nFor example, attempting to change the buffer with |:edit| will fail.\nOther commands which change a window's buffer such as |:cnext| will\nalso skip any window with 'winfixbuf' enabled.  However if an Ex\ncommand has a \"!\" modifier, it can force switching buffers."}}, nowfh = {binding = "nowfh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixheight' 'wfh'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window height when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.  Set by default for the\n|preview-window| and |quickfix-window|.\nThe height may be changed anyway when running out of room."}}, nowfw = {binding = "nowfw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixwidth' 'wfw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window width when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.\nThe width may be changed anyway when running out of room."}}, nowic = {binding = "nowic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildignorecase' 'wic'\tboolean\t(default off)\n\t\tglobal\nWhen set case is ignored when completing file names and directories.\nHas no effect when 'fileignorecase' is set.\nDoes not apply when the shell is used to expand wildcards, which\nhappens when there are special characters."}}, nowildignorecase = {binding = "nowildignorecase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildignorecase' 'wic'\tboolean\t(default off)\n\t\tglobal\nWhen set case is ignored when completing file names and directories.\nHas no effect when 'fileignorecase' is set.\nDoes not apply when the shell is used to expand wildcards, which\nhappens when there are special characters."}}, nowildmenu = {binding = "nowildmenu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildmenu' 'wmnu'\tboolean\t(default on)\n\t\tglobal\nWhen 'wildmenu' is on, command-line completion operates in an enhanced\nmode.  On pressing 'wildchar' (usually <Tab>) to invoke completion,\nthe possible matches are shown.\nWhen 'wildoptions' contains \"pum\", then the completion matches are\nshown in a popup menu.  Otherwise they are displayed just above the\ncommand line, with the first match highlighted (overwriting the status\nline, if there is one).\nKeys that show the previous/next match, such as <Tab> or\nCTRL-P/CTRL-N, cause the highlight to move to the appropriate match.\n'wildmode' must specify \"full\": \"longest\" and \"list\" do not start\n'wildmenu' mode. You can check the current mode with |wildmenumode()|.\nThe menu is cancelled when a key is hit that is not used for selecting\na completion.\n\nWhile the menu is active these keys have special meanings:\nCTRL-P\t\t- go to the previous entry\nCTRL-N\t\t- go to the next entry\n<Left> <Right>\t- select previous/next match (like CTRL-P/CTRL-N)\n<PageUp>\t- select a match several entries back\n<PageDown>\t- select a match several entries further\n<Up>\t\t- in filename/menu name completion: move up into\n\t\t  parent directory or parent menu.\n<Down>\t\t- in filename/menu name completion: move into a\n\t\t  subdirectory or submenu.\n<CR>\t\t- in menu completion, when the cursor is just after a\n\t\t  dot: move into a submenu.\nCTRL-E\t\t- end completion, go back to what was there before\n\t\t  selecting a match.\nCTRL-Y\t\t- accept the currently selected match and stop\n\t\t  completion.\n\nIf you want <Left> and <Right> to move the cursor instead of selecting\na different match, use this: >vim\n\tcnoremap <Left> <Space><BS><Left>\n\tcnoremap <Right> <Space><BS><Right>\n<\n|hl-WildMenu| highlights the current match."}}, nowinfixbuf = {binding = "nowinfixbuf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixbuf' 'wfb'\tboolean\t(default off)\n\t\tlocal to window\nIf enabled, the window and the buffer it is displaying are paired.\nFor example, attempting to change the buffer with |:edit| will fail.\nOther commands which change a window's buffer such as |:cnext| will\nalso skip any window with 'winfixbuf' enabled.  However if an Ex\ncommand has a \"!\" modifier, it can force switching buffers."}}, nowinfixheight = {binding = "nowinfixheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixheight' 'wfh'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window height when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.  Set by default for the\n|preview-window| and |quickfix-window|.\nThe height may be changed anyway when running out of room."}}, nowinfixwidth = {binding = "nowinfixwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixwidth' 'wfw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window width when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.\nThe width may be changed anyway when running out of room."}}, nowmnu = {binding = "nowmnu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildmenu' 'wmnu'\tboolean\t(default on)\n\t\tglobal\nWhen 'wildmenu' is on, command-line completion operates in an enhanced\nmode.  On pressing 'wildchar' (usually <Tab>) to invoke completion,\nthe possible matches are shown.\nWhen 'wildoptions' contains \"pum\", then the completion matches are\nshown in a popup menu.  Otherwise they are displayed just above the\ncommand line, with the first match highlighted (overwriting the status\nline, if there is one).\nKeys that show the previous/next match, such as <Tab> or\nCTRL-P/CTRL-N, cause the highlight to move to the appropriate match.\n'wildmode' must specify \"full\": \"longest\" and \"list\" do not start\n'wildmenu' mode. You can check the current mode with |wildmenumode()|.\nThe menu is cancelled when a key is hit that is not used for selecting\na completion.\n\nWhile the menu is active these keys have special meanings:\nCTRL-P\t\t- go to the previous entry\nCTRL-N\t\t- go to the next entry\n<Left> <Right>\t- select previous/next match (like CTRL-P/CTRL-N)\n<PageUp>\t- select a match several entries back\n<PageDown>\t- select a match several entries further\n<Up>\t\t- in filename/menu name completion: move up into\n\t\t  parent directory or parent menu.\n<Down>\t\t- in filename/menu name completion: move into a\n\t\t  subdirectory or submenu.\n<CR>\t\t- in menu completion, when the cursor is just after a\n\t\t  dot: move into a submenu.\nCTRL-E\t\t- end completion, go back to what was there before\n\t\t  selecting a match.\nCTRL-Y\t\t- accept the currently selected match and stop\n\t\t  completion.\n\nIf you want <Left> and <Right> to move the cursor instead of selecting\na different match, use this: >vim\n\tcnoremap <Left> <Space><BS><Left>\n\tcnoremap <Right> <Space><BS><Right>\n<\n|hl-WildMenu| highlights the current match."}}, nowrap = {binding = "nowrap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrap'\t\t\tboolean\t(default on)\n\t\tlocal to window\nThis option changes how text is displayed.  It doesn't change the text\nin the buffer, see 'textwidth' for that.\nWhen on, lines longer than the width of the window will wrap and\ndisplaying continues on the next line.  When off lines will not wrap\nand only part of long lines will be displayed.  When the cursor is\nmoved to a part that is not shown, the screen will scroll\nhorizontally.\nThe line will be broken in the middle of a word if necessary.  See\n'linebreak' to get the break at a word boundary.\nTo make scrolling horizontally a bit more useful, try this: >vim\n\tset sidescroll=5\n\tset listchars+=precedes:<,extends:>\n<\tSee 'sidescroll', 'listchars' and |wrap-off|.\nThis option can't be set from a |modeline| when the 'diff' option is\non.\nIf 'nowrap' was set from a |modeline| or in the |sandbox|, '>' is used\nas the |lcs-extends| character regardless of the value of the 'list'\nand 'listchars' options.  This is to prevent malicious code outside\nthe viewport from going unnoticed.  Use `:setlocal nowrap` manually\nafterwards to disable this behavior."}}, nowrapscan = {binding = "nowrapscan", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrapscan' 'ws'\t\tboolean\t(default on)\n\t\tglobal\nSearches wrap around the end of the file.  Also applies to |]s| and\n|[s|, searching for spelling mistakes."}}, nowrite = {binding = "nowrite", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'write'\t\t\tboolean\t(default on)\n\t\tglobal\nAllows writing files.  When not set, writing a file is not allowed.\nCan be used for a view-only mode, where modifications to the text are\nstill allowed.  Can be reset with the |-m| or |-M| command line\nargument.  Filtering text is still possible, even though this requires\nwriting a temporary file."}}, nowriteany = {binding = "nowriteany", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writeany' 'wa'\t\tboolean\t(default off)\n\t\tglobal\nAllows writing to any file with no need for \"!\" override."}}, nowritebackup = {binding = "nowritebackup", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writebackup' 'wb'\tboolean\t(default on)\n\t\tglobal\nMake a backup before overwriting a file.  The backup is removed after\nthe file was successfully written, unless the 'backup' option is\nalso on.\nWARNING: Switching this option off means that when Vim fails to write\nyour buffer correctly and then, for whatever reason, Vim exits, you\nlose both the original file and what you were writing.  Only reset\nthis option if your file system is almost full and it makes the write\nfail (and make sure not to exit Vim until the write was successful).\nSee |backup-table| for another explanation.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nDepending on 'backupcopy' the backup is a new file or the original\nfile renamed (and a new file is written)."}}, nows = {binding = "nows", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrapscan' 'ws'\t\tboolean\t(default on)\n\t\tglobal\nSearches wrap around the end of the file.  Also applies to |]s| and\n|[s|, searching for spelling mistakes."}}, nrformats = {binding = "nrformats", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'nrformats' 'nf'\tstring\t(default \"bin,hex\")\n\t\tlocal to buffer\nThis defines what bases Vim will consider for numbers when using the\nCTRL-A and CTRL-X commands for adding to and subtracting from a number\nrespectively; see |CTRL-A| for more info on these commands.\nalpha\tIf included, single alphabetical characters will be\n\tincremented or decremented.  This is useful for a list with a\n\tletter index a), b), etc.\t\t*octal-nrformats*\noctal\tIf included, numbers that start with a zero will be considered\n\tto be octal.  Example: Using CTRL-A on \"007\" results in \"010\".\nhex\tIf included, numbers starting with \"0x\" or \"0X\" will be\n\tconsidered to be hexadecimal.  Example: Using CTRL-X on\n\t\"0x100\" results in \"0x0ff\".\nbin\tIf included, numbers starting with \"0b\" or \"0B\" will be\n\tconsidered to be binary.  Example: Using CTRL-X on\n\t\"0b1000\" subtracts one, resulting in \"0b0111\".\nunsigned    If included, numbers are recognized as unsigned. Thus a\n\tleading dash or negative sign won't be considered as part of\n\tthe number.  Examples:\n\t    Using CTRL-X on \"2020\" in \"9-2020\" results in \"9-2019\"\n\t    (without \"unsigned\" it would become \"9-2021\").\n\t    Using CTRL-A on \"2020\" in \"9-2020\" results in \"9-2021\"\n\t    (without \"unsigned\" it would become \"9-2019\").\n\t    Using CTRL-X on \"0\" or CTRL-A on \"18446744073709551615\"\n\t    (2^64 - 1) has no effect, overflow is prevented.\nblank\tIf included, treat numbers as signed or unsigned based on\n\tpreceding whitespace.  If a number with a leading dash has its\n\tdash immediately preceded by a non-whitespace character (i.e.,\n\tnot a tab or a \" \"), the negative sign won't be considered as\n\tpart of the number.  For example:\n\t    Using CTRL-A on \"14\" in \"Carbon-14\" results in \"Carbon-15\"\n\t    (without \"blank\" it would become \"Carbon-13\").\n\t    Using CTRL-X on \"8\" in \"Carbon -8\" results in \"Carbon -9\"\n\t    (because -8 is preceded by whitespace.  If \"unsigned\" was\n\t    set, it would result in \"Carbon -7\").\n\tIf this format is included, overflow is prevented as if\n\t\"unsigned\" were set.  If both this format and \"unsigned\" are\n\tincluded, \"unsigned\" will take precedence.\n\nNumbers which simply begin with a digit in the range 1-9 are always\nconsidered decimal.  This also happens for numbers that are not\nrecognized as octal or hex."}}, nu = {binding = "nu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'number' 'nu'\t\tboolean\t(default off)\n\t\tlocal to window\nPrint the line number in front of each line.  When the 'n' option is\nexcluded from 'cpoptions' a wrapped line will not use the column of\nline numbers.\nUse the 'numberwidth' option to adjust the room for the line number.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nFor highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the\n|:sign-define| \"numhl\" argument.\n\t\t\t\t\t*number_relativenumber*\nThe 'relativenumber' option changes the displayed number to be\nrelative to the cursor.  Together with 'number' there are these\nfour combinations (cursor in line 3):\n\n\t'nonu'          'nu'            'nonu'          'nu'\n\t'nornu'         'nornu'         'rnu'           'rnu'\n>\n    |apple          |  1 apple      |  2 apple      |  2 apple\n    |pear           |  2 pear       |  1 pear       |  1 pear\n    |nobody         |  3 nobody     |  0 nobody     |3   nobody\n    |there          |  4 there      |  1 there      |  1 there\n<"}}, number = {binding = "number", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'number' 'nu'\t\tboolean\t(default off)\n\t\tlocal to window\nPrint the line number in front of each line.  When the 'n' option is\nexcluded from 'cpoptions' a wrapped line will not use the column of\nline numbers.\nUse the 'numberwidth' option to adjust the room for the line number.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nFor highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the\n|:sign-define| \"numhl\" argument.\n\t\t\t\t\t*number_relativenumber*\nThe 'relativenumber' option changes the displayed number to be\nrelative to the cursor.  Together with 'number' there are these\nfour combinations (cursor in line 3):\n\n\t'nonu'          'nu'            'nonu'          'nu'\n\t'nornu'         'nornu'         'rnu'           'rnu'\n>\n    |apple          |  1 apple      |  2 apple      |  2 apple\n    |pear           |  2 pear       |  1 pear       |  1 pear\n    |nobody         |  3 nobody     |  0 nobody     |3   nobody\n    |there          |  4 there      |  1 there      |  1 there\n<"}}, numberwidth = {binding = "numberwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'numberwidth' 'nuw'\tnumber\t(default 4)\n\t\tlocal to window\nMinimal number of columns to use for the line number.  Only relevant\nwhen the 'number' or 'relativenumber' option is set or printing lines\nwith a line number. Since one space is always between the number and\nthe text, there is one less character for the number itself.\nThe value is the minimum width.  A bigger width is used when needed to\nfit the highest line number in the buffer respectively the number of\nrows in the window, depending on whether 'number' or 'relativenumber'\nis set. Thus with the Vim default of 4 there is room for a line number\nup to 999. When the buffer has 1000 lines five columns will be used.\nThe minimum value is 1, the maximum value is 20."}}, nuw = {binding = "nuw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'numberwidth' 'nuw'\tnumber\t(default 4)\n\t\tlocal to window\nMinimal number of columns to use for the line number.  Only relevant\nwhen the 'number' or 'relativenumber' option is set or printing lines\nwith a line number. Since one space is always between the number and\nthe text, there is one less character for the number itself.\nThe value is the minimum width.  A bigger width is used when needed to\nfit the highest line number in the buffer respectively the number of\nrows in the window, depending on whether 'number' or 'relativenumber'\nis set. Thus with the Vim default of 4 there is room for a line number\nup to 999. When the buffer has 1000 lines five columns will be used.\nThe minimum value is 1, the maximum value is 20."}}, ofu = {binding = "ofu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'omnifunc' 'ofu'\tstring\t(default \"\")\n\t\tlocal to buffer\nThis option specifies a function to be used for Insert mode omni\ncompletion with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O|\nSee |complete-functions| for an explanation of how the function is\ninvoked and what it should return.  The value can be the name of a\nfunction, a |lambda| or a |Funcref|. See |option-value-function| for\nmore information.\nThis option is usually set by a filetype plugin:\n|:filetype-plugin-on|\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, omnifunc = {binding = "omnifunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'omnifunc' 'ofu'\tstring\t(default \"\")\n\t\tlocal to buffer\nThis option specifies a function to be used for Insert mode omni\ncompletion with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O|\nSee |complete-functions| for an explanation of how the function is\ninvoked and what it should return.  The value can be the name of a\nfunction, a |lambda| or a |Funcref|. See |option-value-function| for\nmore information.\nThis option is usually set by a filetype plugin:\n|:filetype-plugin-on|\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, operatorfunc = {binding = "operatorfunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'operatorfunc' 'opfunc'\tstring\t(default \"\")\n\t\tglobal\nThis option specifies a function to be called by the |g@| operator.\nSee |:map-operator| for more info and an example.  The value can be\nthe name of a function, a |lambda| or a |Funcref|. See\n|option-value-function| for more information.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, opfunc = {binding = "opfunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'operatorfunc' 'opfunc'\tstring\t(default \"\")\n\t\tglobal\nThis option specifies a function to be called by the |g@| operator.\nSee |:map-operator| for more info and an example.  The value can be\nthe name of a function, a |lambda| or a |Funcref|. See\n|option-value-function| for more information.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, pa = {binding = "pa", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'path' 'pa'\t\tstring\t(default \".,,\")\n\t\tglobal or local to buffer |global-local|\nThis is a list of directories which will be searched when using the\n|gf|, [f, ]f, ^Wf, |:find|, |:sfind|, |:tabfind| and other commands,\nprovided that the file being searched for has a relative path (not\nstarting with \"/\", \"./\" or \"../\").  The directories in the 'path'\noption may be relative or absolute.\n- Use commas to separate directory names: >vim\n\tset path=.,/usr/local/include,/usr/include\n<\t- Spaces can also be used to separate directory names.  To have a\n  space in a directory name, precede it with an extra backslash, and\n  escape the space: >vim\n\tset path=.,/dir/with\\\\\\ space\n<\t- To include a comma in a directory name precede it with an extra\n  backslash: >vim\n\tset path=.,/dir/with\\\\,comma\n<\t- To search relative to the directory of the current file, use: >vim\n\tset path=.\n<\t- To search in the current directory use an empty string between two\n  commas: >vim\n\tset path=,,\n<\t- A directory name may end in a ':' or '/'.\n- Environment variables are expanded |:set_env|.\n- When using |netrw| URLs can be used.  For example, adding\n  \"https://www.vim.org\" will make \":find index.html\" work.\n- Search upwards and downwards in a directory tree using \"*\", \"**\" and\n  \";\".  See |file-searching| for info and syntax.\n- Careful with '\\' characters, type two to get one in the option: >vim\n\tset path=.,c:\\\\include\n<\t  Or just use '/' instead: >vim\n\tset path=.,c:/include\n<\tDon't forget \".\" or files won't even be found in the same directory as\nthe file!\nThe maximum length is limited.  How much depends on the system, mostly\nit is something like 256 or 1024 characters.\nYou can check if all the include files are found, using the value of\n'path', see |:checkpath|.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\ndirectories from the list.  This avoids problems when a future version\nuses another default.  To remove the current directory use: >vim\n\tset path-=\n<\tTo add the current directory use: >vim\n\tset path+=\n<\tTo use an environment variable, you probably need to replace the\nseparator.  Here is an example to append $INCL, in which directory\nnames are separated with a semicolon: >vim\n\tlet &path = &path .. \",\" .. substitute($INCL, ';', ',', 'g')\n<\tReplace the ';' with a ':' or whatever separator is used.  Note that\nthis doesn't work when $INCL contains a comma or white space."}}, packpath = {binding = "packpath", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'packpath' 'pp'\t\tstring\t(default see 'runtimepath')\n\t\tglobal\nDirectories used to find packages.\nSee |packages| and |packages-runtimepath|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, para = {binding = "para", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'paragraphs' 'para'\tstring\t(default \"IPLPPPQPP TPHPLIPpLpItpplpipbp\")\n\t\tglobal\nSpecifies the nroff macros that separate paragraphs.  These are pairs\nof two letters (see |object-motions|)."}}, paragraphs = {binding = "paragraphs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'paragraphs' 'para'\tstring\t(default \"IPLPPPQPP TPHPLIPpLpItpplpipbp\")\n\t\tglobal\nSpecifies the nroff macros that separate paragraphs.  These are pairs\nof two letters (see |object-motions|)."}}, patchexpr = {binding = "patchexpr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'patchexpr' 'pex'\tstring\t(default \"\")\n\t\tglobal\nExpression which is evaluated to apply a patch to a file and generate\nthe resulting new version of the file.  See |diff-patchexpr|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, patchmode = {binding = "patchmode", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'patchmode' 'pm'\tstring\t(default \"\")\n\t\tglobal\nWhen non-empty the oldest version of a file is kept.  This can be used\nto keep the original version of a file if you are changing files in a\nsource distribution.  Only the first time that a file is written a\ncopy of the original file will be kept.  The name of the copy is the\nname of the original file with the string in the 'patchmode' option\nappended.  This option should start with a dot.  Use a string like\n\".orig\" or \".org\".  'backupdir' must not be empty for this to work\n(Detail: The backup file is renamed to the patchmode file after the\nnew file has been successfully written, that's why it must be possible\nto write a backup file).  If there was no file to be backed up, an\nempty file is created.\nWhen the 'backupskip' pattern matches, a patchmode file is not made.\nUsing 'patchmode' for compressed files appends the extension at the\nend (e.g., \"file.gz.orig\"), thus the resulting name isn't always\nrecognized as a compressed file.\nOnly normal file name characters can be used, `/\\*?[|<>` are illegal."}}, path = {binding = "path", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'path' 'pa'\t\tstring\t(default \".,,\")\n\t\tglobal or local to buffer |global-local|\nThis is a list of directories which will be searched when using the\n|gf|, [f, ]f, ^Wf, |:find|, |:sfind|, |:tabfind| and other commands,\nprovided that the file being searched for has a relative path (not\nstarting with \"/\", \"./\" or \"../\").  The directories in the 'path'\noption may be relative or absolute.\n- Use commas to separate directory names: >vim\n\tset path=.,/usr/local/include,/usr/include\n<\t- Spaces can also be used to separate directory names.  To have a\n  space in a directory name, precede it with an extra backslash, and\n  escape the space: >vim\n\tset path=.,/dir/with\\\\\\ space\n<\t- To include a comma in a directory name precede it with an extra\n  backslash: >vim\n\tset path=.,/dir/with\\\\,comma\n<\t- To search relative to the directory of the current file, use: >vim\n\tset path=.\n<\t- To search in the current directory use an empty string between two\n  commas: >vim\n\tset path=,,\n<\t- A directory name may end in a ':' or '/'.\n- Environment variables are expanded |:set_env|.\n- When using |netrw| URLs can be used.  For example, adding\n  \"https://www.vim.org\" will make \":find index.html\" work.\n- Search upwards and downwards in a directory tree using \"*\", \"**\" and\n  \";\".  See |file-searching| for info and syntax.\n- Careful with '\\' characters, type two to get one in the option: >vim\n\tset path=.,c:\\\\include\n<\t  Or just use '/' instead: >vim\n\tset path=.,c:/include\n<\tDon't forget \".\" or files won't even be found in the same directory as\nthe file!\nThe maximum length is limited.  How much depends on the system, mostly\nit is something like 256 or 1024 characters.\nYou can check if all the include files are found, using the value of\n'path', see |:checkpath|.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\ndirectories from the list.  This avoids problems when a future version\nuses another default.  To remove the current directory use: >vim\n\tset path-=\n<\tTo add the current directory use: >vim\n\tset path+=\n<\tTo use an environment variable, you probably need to replace the\nseparator.  Here is an example to append $INCL, in which directory\nnames are separated with a semicolon: >vim\n\tlet &path = &path .. \",\" .. substitute($INCL, ';', ',', 'g')\n<\tReplace the ';' with a ':' or whatever separator is used.  Note that\nthis doesn't work when $INCL contains a comma or white space."}}, pb = {binding = "pb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pumblend' 'pb'\t\tnumber\t(default 0)\n\t\tglobal\nEnables pseudo-transparency for the |popup-menu|. Valid values are in\nthe range of 0 for fully opaque popupmenu (disabled) to 100 for fully\ntransparent background. Values between 0-30 are typically most useful.\n\nIt is possible to override the level for individual highlights within\nthe popupmenu using |highlight-blend|. For instance, to enable\ntransparency but force the current selected element to be fully opaque: >vim\n\n\tset pumblend=15\n\thi PmenuSel blend=0\n<\nUI-dependent. Works best with RGB colors. 'termguicolors'"}}, pex = {binding = "pex", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'patchexpr' 'pex'\tstring\t(default \"\")\n\t\tglobal\nExpression which is evaluated to apply a patch to a file and generate\nthe resulting new version of the file.  See |diff-patchexpr|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ph = {binding = "ph", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pumheight' 'ph'\tnumber\t(default 0)\n\t\tglobal\nMaximum number of items to show in the popup menu\n(|ins-completion-menu|). Zero means \"use available screen space\"."}}, pi = {binding = "pi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'preserveindent' 'pi'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen changing the indent of the current line, preserve as much of the\nindent structure as possible.  Normally the indent is replaced by a\nseries of tabs followed by spaces as required (unless |'expandtab'| is\nenabled, in which case only spaces are used).  Enabling this option\nmeans the indent will preserve as many existing characters as possible\nfor indenting, and only add additional tabs or spaces as required.\n'expandtab' does not apply to the preserved white space, a Tab remains\na Tab.\nNOTE: When using \">>\" multiple times the resulting indent is a mix of\ntabs and spaces.  You might not like this.\nAlso see 'copyindent'.\nUse |:retab| to clean up white space."}}, pm = {binding = "pm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'patchmode' 'pm'\tstring\t(default \"\")\n\t\tglobal\nWhen non-empty the oldest version of a file is kept.  This can be used\nto keep the original version of a file if you are changing files in a\nsource distribution.  Only the first time that a file is written a\ncopy of the original file will be kept.  The name of the copy is the\nname of the original file with the string in the 'patchmode' option\nappended.  This option should start with a dot.  Use a string like\n\".orig\" or \".org\".  'backupdir' must not be empty for this to work\n(Detail: The backup file is renamed to the patchmode file after the\nnew file has been successfully written, that's why it must be possible\nto write a backup file).  If there was no file to be backed up, an\nempty file is created.\nWhen the 'backupskip' pattern matches, a patchmode file is not made.\nUsing 'patchmode' for compressed files appends the extension at the\nend (e.g., \"file.gz.orig\"), thus the resulting name isn't always\nrecognized as a compressed file.\nOnly normal file name characters can be used, `/\\*?[|<>` are illegal."}}, pp = {binding = "pp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'packpath' 'pp'\t\tstring\t(default see 'runtimepath')\n\t\tglobal\nDirectories used to find packages.\nSee |packages| and |packages-runtimepath|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, preserveindent = {binding = "preserveindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'preserveindent' 'pi'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen changing the indent of the current line, preserve as much of the\nindent structure as possible.  Normally the indent is replaced by a\nseries of tabs followed by spaces as required (unless |'expandtab'| is\nenabled, in which case only spaces are used).  Enabling this option\nmeans the indent will preserve as many existing characters as possible\nfor indenting, and only add additional tabs or spaces as required.\n'expandtab' does not apply to the preserved white space, a Tab remains\na Tab.\nNOTE: When using \">>\" multiple times the resulting indent is a mix of\ntabs and spaces.  You might not like this.\nAlso see 'copyindent'.\nUse |:retab| to clean up white space."}}, previewheight = {binding = "previewheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'previewheight' 'pvh'\tnumber\t(default 12)\n\t\tglobal\nDefault height for a preview window.  Used for |:ptag| and associated\ncommands.  Used for |CTRL-W_}| when no count is given."}}, previewwindow = {binding = "previewwindow", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'previewwindow' 'pvw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nIdentifies the preview window.  Only one window can have this option\nset.  It's normally not set directly, but by using one of the commands\n|:ptag|, |:pedit|, etc."}}, pumblend = {binding = "pumblend", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pumblend' 'pb'\t\tnumber\t(default 0)\n\t\tglobal\nEnables pseudo-transparency for the |popup-menu|. Valid values are in\nthe range of 0 for fully opaque popupmenu (disabled) to 100 for fully\ntransparent background. Values between 0-30 are typically most useful.\n\nIt is possible to override the level for individual highlights within\nthe popupmenu using |highlight-blend|. For instance, to enable\ntransparency but force the current selected element to be fully opaque: >vim\n\n\tset pumblend=15\n\thi PmenuSel blend=0\n<\nUI-dependent. Works best with RGB colors. 'termguicolors'"}}, pumheight = {binding = "pumheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pumheight' 'ph'\tnumber\t(default 0)\n\t\tglobal\nMaximum number of items to show in the popup menu\n(|ins-completion-menu|). Zero means \"use available screen space\"."}}, pumwidth = {binding = "pumwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pumwidth' 'pw'\t\tnumber\t(default 15)\n\t\tglobal\nMinimum width for the popup menu (|ins-completion-menu|).  If the\ncursor column + 'pumwidth' exceeds screen width, the popup menu is\nnudged to fit on the screen."}}, pvh = {binding = "pvh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'previewheight' 'pvh'\tnumber\t(default 12)\n\t\tglobal\nDefault height for a preview window.  Used for |:ptag| and associated\ncommands.  Used for |CTRL-W_}| when no count is given."}}, pvw = {binding = "pvw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'previewwindow' 'pvw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nIdentifies the preview window.  Only one window can have this option\nset.  It's normally not set directly, but by using one of the commands\n|:ptag|, |:pedit|, etc."}}, pw = {binding = "pw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pumwidth' 'pw'\t\tnumber\t(default 15)\n\t\tglobal\nMinimum width for the popup menu (|ins-completion-menu|).  If the\ncursor column + 'pumwidth' exceeds screen width, the popup menu is\nnudged to fit on the screen."}}, pyx = {binding = "pyx", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pyxversion' 'pyx'\tnumber\t(default 3)\n\t\tglobal\nSpecifies the python version used for pyx* functions and commands\n|python_x|.  As only Python 3 is supported, this always has the value\n`3`. Setting any other value is an error.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, pyxversion = {binding = "pyxversion", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'pyxversion' 'pyx'\tnumber\t(default 3)\n\t\tglobal\nSpecifies the python version used for pyx* functions and commands\n|python_x|.  As only Python 3 is supported, this always has the value\n`3`. Setting any other value is an error.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, qe = {binding = "qe", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'quoteescape' 'qe'\tstring\t(default \"\\\")\n\t\tlocal to buffer\nThe characters that are used to escape quotes in a string.  Used for\nobjects like a', a\" and a` |a'|.\nWhen one of the characters in this option is found inside a string,\nthe following character will be skipped.  The default value makes the\ntext \"foo\\\"bar\\\\\" considered to be one string."}}, qftf = {binding = "qftf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'quickfixtextfunc' 'qftf'\tstring\t(default \"\")\n\t\tglobal\nThis option specifies a function to be used to get the text to display\nin the quickfix and location list windows.  This can be used to\ncustomize the information displayed in the quickfix or location window\nfor each entry in the corresponding quickfix or location list.  See\n|quickfix-window-function| for an explanation of how to write the\nfunction and an example.  The value can be the name of a function, a\n|lambda| or a |Funcref|. See |option-value-function| for more\ninformation.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, quickfixtextfunc = {binding = "quickfixtextfunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'quickfixtextfunc' 'qftf'\tstring\t(default \"\")\n\t\tglobal\nThis option specifies a function to be used to get the text to display\nin the quickfix and location list windows.  This can be used to\ncustomize the information displayed in the quickfix or location window\nfor each entry in the corresponding quickfix or location list.  See\n|quickfix-window-function| for an explanation of how to write the\nfunction and an example.  The value can be the name of a function, a\n|lambda| or a |Funcref|. See |option-value-function| for more\ninformation.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, quoteescape = {binding = "quoteescape", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'quoteescape' 'qe'\tstring\t(default \"\\\")\n\t\tlocal to buffer\nThe characters that are used to escape quotes in a string.  Used for\nobjects like a', a\" and a` |a'|.\nWhen one of the characters in this option is found inside a string,\nthe following character will be skipped.  The default value makes the\ntext \"foo\\\"bar\\\\\" considered to be one string."}}, rdb = {binding = "rdb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'redrawdebug' 'rdb'\tstring\t(default \"\")\n\t\tglobal\nFlags to change the way redrawing works, for debugging purposes.\nMost useful with 'writedelay' set to some reasonable value.\nSupports the following flags:\n    compositor\tIndicate each redraw event handled by the compositor\n\t\tby briefly flashing the redrawn regions in colors\n\t\tindicating the redraw type. These are the highlight\n\t\tgroups used (and their default colors):\n\tRedrawDebugNormal   gui=reverse   normal redraw passed through\n\tRedrawDebugClear    guibg=Yellow  clear event passed through\n\tRedrawDebugComposed guibg=Green   redraw event modified by the\n\t\t\t\t\t  compositor (due to\n\t\t\t\t\t  overlapping grids, etc)\n\tRedrawDebugRecompose guibg=Red    redraw generated by the\n\t\t\t\t\t  compositor itself, due to a\n\t\t\t\t\t  grid being moved or deleted.\n    line\tintroduce a delay after each line drawn on the screen.\n\t\tWhen using the TUI or another single-grid UI, \"compositor\"\n\t\tgives more information and should be preferred (every\n\t\tline is processed as a separate event by the compositor)\n    flush\tintroduce a delay after each \"flush\" event.\n    nothrottle\tTurn off throttling of the message grid. This is an\n\t\toptimization that joins many small scrolls to one\n\t\tlarger scroll when drawing the message area (with\n\t\t'display' msgsep flag active).\n    invalid\tEnable stricter checking (abort) of inconsistencies\n\t\tof the internal screen state. This is mostly\n\t\tuseful when running nvim inside a debugger (and\n\t\tthe test suite).\n    nodelta\tSend all internally redrawn cells to the UI, even if\n\t\tthey are unchanged from the already displayed state."}}, rdt = {binding = "rdt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'redrawtime' 'rdt'\tnumber\t(default 2000)\n\t\tglobal\nTime in milliseconds for redrawing the display.  Applies to\n'hlsearch', 'inccommand', |:match| highlighting, syntax highlighting,\nand async |LanguageTree:parse()|.\nWhen redrawing takes more than this many milliseconds no further\nmatches will be highlighted.\nFor syntax highlighting the time applies per window.  When over the\nlimit syntax highlighting is disabled until |CTRL-L| is used.\nThis is used to avoid that Vim hangs when using a very complicated\npattern."}}, re = {binding = "re", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'regexpengine' 're'\tnumber\t(default 0)\n\t\tglobal\nThis selects the default regexp engine. |two-engines|\nThe possible values are:\n\0090\tautomatic selection\n\0091\told engine\n\0092\tNFA engine\nNote that when using the NFA engine and the pattern contains something\nthat is not supported the pattern will not match.  This is only useful\nfor debugging the regexp engine.\nUsing automatic selection enables Vim to switch the engine, if the\ndefault engine becomes too costly.  E.g., when the NFA engine uses too\nmany states.  This should prevent Vim from hanging on a combination of\na complex pattern with long text."}}, readonly = {binding = "readonly", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'readonly' 'ro'\t\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nIf on, writes fail unless you use a '!'.  Protects you from\naccidentally overwriting a file.  Default on when Vim is started\nin read-only mode (\"vim -R\") or when the executable is called \"view\".\nWhen using \":w!\" the 'readonly' option is reset for the current\nbuffer, unless the 'Z' flag is in 'cpoptions'.\nWhen using the \":view\" command the 'readonly' option is set for the\nnewly edited buffer.\nSee 'modifiable' for disallowing changes to the buffer."}}, redrawdebug = {binding = "redrawdebug", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'redrawdebug' 'rdb'\tstring\t(default \"\")\n\t\tglobal\nFlags to change the way redrawing works, for debugging purposes.\nMost useful with 'writedelay' set to some reasonable value.\nSupports the following flags:\n    compositor\tIndicate each redraw event handled by the compositor\n\t\tby briefly flashing the redrawn regions in colors\n\t\tindicating the redraw type. These are the highlight\n\t\tgroups used (and their default colors):\n\tRedrawDebugNormal   gui=reverse   normal redraw passed through\n\tRedrawDebugClear    guibg=Yellow  clear event passed through\n\tRedrawDebugComposed guibg=Green   redraw event modified by the\n\t\t\t\t\t  compositor (due to\n\t\t\t\t\t  overlapping grids, etc)\n\tRedrawDebugRecompose guibg=Red    redraw generated by the\n\t\t\t\t\t  compositor itself, due to a\n\t\t\t\t\t  grid being moved or deleted.\n    line\tintroduce a delay after each line drawn on the screen.\n\t\tWhen using the TUI or another single-grid UI, \"compositor\"\n\t\tgives more information and should be preferred (every\n\t\tline is processed as a separate event by the compositor)\n    flush\tintroduce a delay after each \"flush\" event.\n    nothrottle\tTurn off throttling of the message grid. This is an\n\t\toptimization that joins many small scrolls to one\n\t\tlarger scroll when drawing the message area (with\n\t\t'display' msgsep flag active).\n    invalid\tEnable stricter checking (abort) of inconsistencies\n\t\tof the internal screen state. This is mostly\n\t\tuseful when running nvim inside a debugger (and\n\t\tthe test suite).\n    nodelta\tSend all internally redrawn cells to the UI, even if\n\t\tthey are unchanged from the already displayed state."}}, redrawtime = {binding = "redrawtime", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'redrawtime' 'rdt'\tnumber\t(default 2000)\n\t\tglobal\nTime in milliseconds for redrawing the display.  Applies to\n'hlsearch', 'inccommand', |:match| highlighting, syntax highlighting,\nand async |LanguageTree:parse()|.\nWhen redrawing takes more than this many milliseconds no further\nmatches will be highlighted.\nFor syntax highlighting the time applies per window.  When over the\nlimit syntax highlighting is disabled until |CTRL-L| is used.\nThis is used to avoid that Vim hangs when using a very complicated\npattern."}}, regexpengine = {binding = "regexpengine", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'regexpengine' 're'\tnumber\t(default 0)\n\t\tglobal\nThis selects the default regexp engine. |two-engines|\nThe possible values are:\n\0090\tautomatic selection\n\0091\told engine\n\0092\tNFA engine\nNote that when using the NFA engine and the pattern contains something\nthat is not supported the pattern will not match.  This is only useful\nfor debugging the regexp engine.\nUsing automatic selection enables Vim to switch the engine, if the\ndefault engine becomes too costly.  E.g., when the NFA engine uses too\nmany states.  This should prevent Vim from hanging on a combination of\na complex pattern with long text."}}, relativenumber = {binding = "relativenumber", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'relativenumber' 'rnu'\tboolean\t(default off)\n\t\tlocal to window\nShow the line number relative to the line with the cursor in front of\neach line. Relative line numbers help you use the |count| you can\nprecede some vertical motion commands (e.g. j k + -) with, without\nhaving to calculate it yourself. Especially useful in combination with\nother commands (e.g. y d c < > gq gw =).\nWhen the 'n' option is excluded from 'cpoptions' a wrapped\nline will not use the column of line numbers.\nThe 'numberwidth' option can be used to set the room used for the line\nnumber.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nSee |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for\nthe number.\n\nThe number in front of the cursor line also depends on the value of\n'number', see |number_relativenumber| for all combinations of the two\noptions."}}, report = {binding = "report", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'report'\t\tnumber\t(default 2)\n\t\tglobal\nThreshold for reporting number of lines changed.  When the number of\nchanged lines is more than 'report' a message will be given for most\n\":\" commands.  If you want it always, set 'report' to 0.\nFor the \":substitute\" command the number of substitutions is used\ninstead of the number of lines."}}, revins = {binding = "revins", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'revins' 'ri'\t\tboolean\t(default off)\n\t\tglobal\nInserting characters in Insert mode will work backwards.  See \"typing\nbackwards\" |ins-reverse|.  This option can be toggled with the CTRL-_\ncommand in Insert mode, when 'allowrevins' is set."}}, ri = {binding = "ri", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'revins' 'ri'\t\tboolean\t(default off)\n\t\tglobal\nInserting characters in Insert mode will work backwards.  See \"typing\nbackwards\" |ins-reverse|.  This option can be toggled with the CTRL-_\ncommand in Insert mode, when 'allowrevins' is set."}}, rightleft = {binding = "rightleft", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rightleft' 'rl'\tboolean\t(default off)\n\t\tlocal to window\nWhen on, display orientation becomes right-to-left, i.e., characters\nthat are stored in the file appear from the right to the left.\nUsing this option, it is possible to edit files for languages that\nare written from the right to the left such as Hebrew and Arabic.\nThis option is per window, so it is possible to edit mixed files\nsimultaneously, or to view the same file in both ways (this is\nuseful whenever you have a mixed text file with both right-to-left\nand left-to-right strings so that both sets are displayed properly\nin different windows).  Also see |rileft.txt|."}}, rightleftcmd = {binding = "rightleftcmd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rightleftcmd' 'rlc'\tstring\t(default \"search\")\n\t\tlocal to window\nEach word in this option enables the command line editing to work in\nright-to-left mode for a group of commands:\n\n\tsearch\t\t\"/\" and \"?\" commands\n\nThis is useful for languages such as Hebrew, Arabic and Farsi.\nThe 'rightleft' option must be set for 'rightleftcmd' to take effect."}}, rl = {binding = "rl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rightleft' 'rl'\tboolean\t(default off)\n\t\tlocal to window\nWhen on, display orientation becomes right-to-left, i.e., characters\nthat are stored in the file appear from the right to the left.\nUsing this option, it is possible to edit files for languages that\nare written from the right to the left such as Hebrew and Arabic.\nThis option is per window, so it is possible to edit mixed files\nsimultaneously, or to view the same file in both ways (this is\nuseful whenever you have a mixed text file with both right-to-left\nand left-to-right strings so that both sets are displayed properly\nin different windows).  Also see |rileft.txt|."}}, rlc = {binding = "rlc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rightleftcmd' 'rlc'\tstring\t(default \"search\")\n\t\tlocal to window\nEach word in this option enables the command line editing to work in\nright-to-left mode for a group of commands:\n\n\tsearch\t\t\"/\" and \"?\" commands\n\nThis is useful for languages such as Hebrew, Arabic and Farsi.\nThe 'rightleft' option must be set for 'rightleftcmd' to take effect."}}, rnu = {binding = "rnu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'relativenumber' 'rnu'\tboolean\t(default off)\n\t\tlocal to window\nShow the line number relative to the line with the cursor in front of\neach line. Relative line numbers help you use the |count| you can\nprecede some vertical motion commands (e.g. j k + -) with, without\nhaving to calculate it yourself. Especially useful in combination with\nother commands (e.g. y d c < > gq gw =).\nWhen the 'n' option is excluded from 'cpoptions' a wrapped\nline will not use the column of line numbers.\nThe 'numberwidth' option can be used to set the room used for the line\nnumber.\nWhen a long, wrapped line doesn't start with the first character, '-'\ncharacters are put before the number.\nSee |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for\nthe number.\n\nThe number in front of the cursor line also depends on the value of\n'number', see |number_relativenumber| for all combinations of the two\noptions."}}, ro = {binding = "ro", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'readonly' 'ro'\t\tboolean\t(default off)\n\t\tlocal to buffer  |local-noglobal|\nIf on, writes fail unless you use a '!'.  Protects you from\naccidentally overwriting a file.  Default on when Vim is started\nin read-only mode (\"vim -R\") or when the executable is called \"view\".\nWhen using \":w!\" the 'readonly' option is reset for the current\nbuffer, unless the 'Z' flag is in 'cpoptions'.\nWhen using the \":view\" command the 'readonly' option is set for the\nnewly edited buffer.\nSee 'modifiable' for disallowing changes to the buffer."}}, rtp = {binding = "rtp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'runtimepath' 'rtp'\tstring\t(default \"$XDG_CONFIG_HOME/nvim,\n                                               $XDG_CONFIG_DIRS[1]/nvim,\n                                               $XDG_CONFIG_DIRS[2]/nvim,\n                                               \226\128\166\n                                               $XDG_DATA_HOME/nvim[-data]/site,\n                                               $XDG_DATA_DIRS[1]/nvim/site,\n                                               $XDG_DATA_DIRS[2]/nvim/site,\n                                               \226\128\166\n                                               $VIMRUNTIME,\n                                               \226\128\166\n                                               $XDG_DATA_DIRS[2]/nvim/site/after,\n                                               $XDG_DATA_DIRS[1]/nvim/site/after,\n                                               $XDG_DATA_HOME/nvim[-data]/site/after,\n                                               \226\128\166\n                                               $XDG_CONFIG_DIRS[2]/nvim/after,\n                                               $XDG_CONFIG_DIRS[1]/nvim/after,\n                                               $XDG_CONFIG_HOME/nvim/after\")\n\t\tglobal\nList of directories to be searched for these runtime files:\n  filetype.lua\tfiletypes |new-filetype|\n  autoload/\tautomatically loaded scripts |autoload-functions|\n  colors/\tcolor scheme files |:colorscheme|\n  compiler/\tcompiler files |:compiler|\n  doc/\t\tdocumentation |write-local-help|\n  ftplugin/\tfiletype plugins |write-filetype-plugin|\n  indent/\tindent scripts |indent-expression|\n  keymap/\tkey mapping files |mbyte-keymap|\n  lang/\t\tmenu translations |:menutrans|\n  lsp/\t\tLSP client configurations |lsp-config|\n  lua/\t\t|Lua| plugins\n  menu.vim\tGUI menus |menu.vim|\n  pack/\t\tpackages |:packadd|\n  parser/\t|treesitter| syntax parsers\n  plugin/\tplugin scripts |write-plugin|\n  queries/\t|treesitter| queries\n  rplugin/\t|remote-plugin| scripts\n  spell/\tspell checking files |spell|\n  syntax/\tsyntax files |mysyntaxfile|\n  tutor/\ttutorial files |:Tutor|\n\nAnd any other file searched for with the |:runtime| command.\n\nDefaults are setup to search these locations:\n1. Your home directory, for personal preferences.\n   Given by `stdpath(\"config\")`.  |$XDG_CONFIG_HOME|\n2. Directories which must contain configuration files according to\n   |xdg| ($XDG_CONFIG_DIRS, defaults to /etc/xdg).  This also contains\n   preferences from system administrator.\n3. Data home directory, for plugins installed by user.\n   Given by `stdpath(\"data\")/site`.  |$XDG_DATA_HOME|\n4. nvim/site subdirectories for each directory in $XDG_DATA_DIRS.\n   This is for plugins which were installed by system administrator,\n   but are not part of the Nvim distribution. XDG_DATA_DIRS defaults\n   to /usr/local/share/:/usr/share/, so system administrators are\n   expected to install site plugins to /usr/share/nvim/site.\n5. Session state directory, for state data such as swap, backupdir,\n   viewdir, undodir, etc.\n   Given by `stdpath(\"state\")`.  |$XDG_STATE_HOME|\n6. $VIMRUNTIME, for files distributed with Nvim.\n\t\t\t\t\t\t*after-directory*\n7, 8, 9, 10. In after/ subdirectories of 1, 2, 3 and 4, with reverse\n   ordering.  This is for preferences to overrule or add to the\n   distributed defaults or system-wide settings (rarely needed).\n\n\t\t\t\t\t\t*packages-runtimepath*\n\"start\" packages will also be searched (|runtime-search-path|) for\nruntime files after these, though such packages are not explicitly\nreported in &runtimepath. But \"opt\" packages are explicitly added to\n&runtimepath by |:packadd|.\n\nNote that, unlike 'path', no wildcards like \"**\" are allowed.  Normal\nwildcards are allowed, but can significantly slow down searching for\nruntime files.  For speed, use as few items as possible and avoid\nwildcards.\nSee |:runtime|.\nExample: >vim\n\tset runtimepath=~/vimruntime,/mygroup/vim,$VIMRUNTIME\n<\tThis will use the directory \"~/vimruntime\" first (containing your\npersonal Nvim runtime files), then \"/mygroup/vim\", and finally\n\"$VIMRUNTIME\" (the default runtime files).\nYou can put a directory before $VIMRUNTIME to find files which replace\ndistributed runtime files.  You can put a directory after $VIMRUNTIME\nto find files which add to distributed runtime files.\n\nWith |--clean| the home directory entries are not included."}}, ru = {binding = "ru", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ruler' 'ru'\t\tboolean\t(default on)\n\t\tglobal\nShow the line and column number of the cursor position, separated by a\ncomma.  When there is room, the relative position of the displayed\ntext in the file is shown on the far right:\n\tTop\tfirst line is visible\n\tBot\tlast line is visible\n\tAll\tfirst and last line are visible\n\00945%\trelative position in the file\nIf 'rulerformat' is set, it will determine the contents of the ruler.\nEach window has its own ruler.  If a window has a status line, the\nruler is shown there.  If a window doesn't have a status line and\n'cmdheight' is zero, the ruler is not shown.  Otherwise it is shown in\nthe last line of the screen.  If the statusline is given by\n'statusline' (i.e. not empty), this option takes precedence over\n'ruler' and 'rulerformat'.\nIf the number of characters displayed is different from the number of\nbytes in the text (e.g., for a TAB or a multibyte character), both\nthe text column (byte number) and the screen column are shown,\nseparated with a dash.\nFor an empty line \"0-1\" is shown.\nFor an empty buffer the line number will also be zero: \"0,0-1\".\nIf you don't want to see the ruler all the time but want to know where\nyou are, use \"g CTRL-G\" |g_CTRL-G|."}}, ruf = {binding = "ruf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rulerformat' 'ruf'\tstring\t(default \"\")\n\t\tglobal\nWhen this option is not empty, it determines the content of the ruler\nstring, as displayed for the 'ruler' option.\nThe format of this option is like that of 'statusline'.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nThe default ruler width is 17 characters.  To make the ruler 15\ncharacters wide, put \"%15(\" at the start and \"%)\" at the end.\nExample: >vim\n\tset rulerformat=%15(%c%V\\ %p%%%)\n<"}}, ruler = {binding = "ruler", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ruler' 'ru'\t\tboolean\t(default on)\n\t\tglobal\nShow the line and column number of the cursor position, separated by a\ncomma.  When there is room, the relative position of the displayed\ntext in the file is shown on the far right:\n\tTop\tfirst line is visible\n\tBot\tlast line is visible\n\tAll\tfirst and last line are visible\n\00945%\trelative position in the file\nIf 'rulerformat' is set, it will determine the contents of the ruler.\nEach window has its own ruler.  If a window has a status line, the\nruler is shown there.  If a window doesn't have a status line and\n'cmdheight' is zero, the ruler is not shown.  Otherwise it is shown in\nthe last line of the screen.  If the statusline is given by\n'statusline' (i.e. not empty), this option takes precedence over\n'ruler' and 'rulerformat'.\nIf the number of characters displayed is different from the number of\nbytes in the text (e.g., for a TAB or a multibyte character), both\nthe text column (byte number) and the screen column are shown,\nseparated with a dash.\nFor an empty line \"0-1\" is shown.\nFor an empty buffer the line number will also be zero: \"0,0-1\".\nIf you don't want to see the ruler all the time but want to know where\nyou are, use \"g CTRL-G\" |g_CTRL-G|."}}, rulerformat = {binding = "rulerformat", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'rulerformat' 'ruf'\tstring\t(default \"\")\n\t\tglobal\nWhen this option is not empty, it determines the content of the ruler\nstring, as displayed for the 'ruler' option.\nThe format of this option is like that of 'statusline'.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nThe default ruler width is 17 characters.  To make the ruler 15\ncharacters wide, put \"%15(\" at the start and \"%)\" at the end.\nExample: >vim\n\tset rulerformat=%15(%c%V\\ %p%%%)\n<"}}, runtimepath = {binding = "runtimepath", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'runtimepath' 'rtp'\tstring\t(default \"$XDG_CONFIG_HOME/nvim,\n                                               $XDG_CONFIG_DIRS[1]/nvim,\n                                               $XDG_CONFIG_DIRS[2]/nvim,\n                                               \226\128\166\n                                               $XDG_DATA_HOME/nvim[-data]/site,\n                                               $XDG_DATA_DIRS[1]/nvim/site,\n                                               $XDG_DATA_DIRS[2]/nvim/site,\n                                               \226\128\166\n                                               $VIMRUNTIME,\n                                               \226\128\166\n                                               $XDG_DATA_DIRS[2]/nvim/site/after,\n                                               $XDG_DATA_DIRS[1]/nvim/site/after,\n                                               $XDG_DATA_HOME/nvim[-data]/site/after,\n                                               \226\128\166\n                                               $XDG_CONFIG_DIRS[2]/nvim/after,\n                                               $XDG_CONFIG_DIRS[1]/nvim/after,\n                                               $XDG_CONFIG_HOME/nvim/after\")\n\t\tglobal\nList of directories to be searched for these runtime files:\n  filetype.lua\tfiletypes |new-filetype|\n  autoload/\tautomatically loaded scripts |autoload-functions|\n  colors/\tcolor scheme files |:colorscheme|\n  compiler/\tcompiler files |:compiler|\n  doc/\t\tdocumentation |write-local-help|\n  ftplugin/\tfiletype plugins |write-filetype-plugin|\n  indent/\tindent scripts |indent-expression|\n  keymap/\tkey mapping files |mbyte-keymap|\n  lang/\t\tmenu translations |:menutrans|\n  lsp/\t\tLSP client configurations |lsp-config|\n  lua/\t\t|Lua| plugins\n  menu.vim\tGUI menus |menu.vim|\n  pack/\t\tpackages |:packadd|\n  parser/\t|treesitter| syntax parsers\n  plugin/\tplugin scripts |write-plugin|\n  queries/\t|treesitter| queries\n  rplugin/\t|remote-plugin| scripts\n  spell/\tspell checking files |spell|\n  syntax/\tsyntax files |mysyntaxfile|\n  tutor/\ttutorial files |:Tutor|\n\nAnd any other file searched for with the |:runtime| command.\n\nDefaults are setup to search these locations:\n1. Your home directory, for personal preferences.\n   Given by `stdpath(\"config\")`.  |$XDG_CONFIG_HOME|\n2. Directories which must contain configuration files according to\n   |xdg| ($XDG_CONFIG_DIRS, defaults to /etc/xdg).  This also contains\n   preferences from system administrator.\n3. Data home directory, for plugins installed by user.\n   Given by `stdpath(\"data\")/site`.  |$XDG_DATA_HOME|\n4. nvim/site subdirectories for each directory in $XDG_DATA_DIRS.\n   This is for plugins which were installed by system administrator,\n   but are not part of the Nvim distribution. XDG_DATA_DIRS defaults\n   to /usr/local/share/:/usr/share/, so system administrators are\n   expected to install site plugins to /usr/share/nvim/site.\n5. Session state directory, for state data such as swap, backupdir,\n   viewdir, undodir, etc.\n   Given by `stdpath(\"state\")`.  |$XDG_STATE_HOME|\n6. $VIMRUNTIME, for files distributed with Nvim.\n\t\t\t\t\t\t*after-directory*\n7, 8, 9, 10. In after/ subdirectories of 1, 2, 3 and 4, with reverse\n   ordering.  This is for preferences to overrule or add to the\n   distributed defaults or system-wide settings (rarely needed).\n\n\t\t\t\t\t\t*packages-runtimepath*\n\"start\" packages will also be searched (|runtime-search-path|) for\nruntime files after these, though such packages are not explicitly\nreported in &runtimepath. But \"opt\" packages are explicitly added to\n&runtimepath by |:packadd|.\n\nNote that, unlike 'path', no wildcards like \"**\" are allowed.  Normal\nwildcards are allowed, but can significantly slow down searching for\nruntime files.  For speed, use as few items as possible and avoid\nwildcards.\nSee |:runtime|.\nExample: >vim\n\tset runtimepath=~/vimruntime,/mygroup/vim,$VIMRUNTIME\n<\tThis will use the directory \"~/vimruntime\" first (containing your\npersonal Nvim runtime files), then \"/mygroup/vim\", and finally\n\"$VIMRUNTIME\" (the default runtime files).\nYou can put a directory before $VIMRUNTIME to find files which replace\ndistributed runtime files.  You can put a directory after $VIMRUNTIME\nto find files which add to distributed runtime files.\n\nWith |--clean| the home directory entries are not included."}}, sb = {binding = "sb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitbelow' 'sb'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window below the current\none. |:split|"}}, sbo = {binding = "sbo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollopt' 'sbo'\tstring\t(default \"ver,jump\")\n\t\tglobal\nThis is a comma-separated list of words that specifies how\n'scrollbind' windows should behave.  'sbo' stands for ScrollBind\nOptions.\nThe following words are available:\n    ver\t\tBind vertical scrolling for 'scrollbind' windows\n    hor\t\tBind horizontal scrolling for 'scrollbind' windows\n    jump\tApplies to the offset between two windows for vertical\n\t\tscrolling.  This offset is the difference in the first\n\t\tdisplayed line of the bound windows.  When moving\n\t\taround in a window, another 'scrollbind' window may\n\t\treach a position before the start or after the end of\n\t\tthe buffer.  The offset is not changed though, when\n\t\tmoving back the 'scrollbind' window will try to scroll\n\t\tto the desired position when possible.\n\t\tWhen now making that window the current one, two\n\t\tthings can be done with the relative offset:\n\t\0091. When \"jump\" is not included, the relative offset is\n\t\t   adjusted for the scroll position in the new current\n\t\t   window.  When going back to the other window, the\n\t\t   new relative offset will be used.\n\t\0092. When \"jump\" is included, the other windows are\n\t\t   scrolled to keep the same relative offset.  When\n\t\t   going back to the other window, it still uses the\n\t\t   same relative offset.\nAlso see |scroll-binding|.\nWhen 'diff' mode is active there always is vertical scroll binding,\neven when \"ver\" isn't there."}}, sbr = {binding = "sbr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showbreak' 'sbr'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nString to put at the start of lines that have been wrapped.  Useful\nvalues are \"> \" or \"+++ \": >vim\n\tlet &showbreak = \"> \"\n\tlet &showbreak = '+++ '\n<\tOnly printable single-cell characters are allowed, excluding <Tab> and\ncomma (in a future version the comma might be used to separate the\npart that is shown at the end and at the start of a line).\nThe |hl-NonText| highlight group determines the highlighting.\nNote that tabs after the showbreak will be displayed differently.\nIf you want the 'showbreak' to appear in between line numbers, add the\n\"n\" flag to 'cpoptions'.\nA window-local value overrules a global value.  If the global value is\nset and you want no value in the current window use NONE: >vim\n\tsetlocal showbreak=NONE\n<"}}, sc = {binding = "sc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showcmd' 'sc'\t\tboolean\t(default on)\n\t\tglobal\nShow (partial) command in the last line of the screen.  Set this\noption off if your terminal is slow.\nIn Visual mode the size of the selected area is shown:\n- When selecting characters within a line, the number of characters.\n  If the number of bytes is different it is also displayed: \"2-6\"\n  means two characters and six bytes.\n- When selecting more than one line, the number of lines.\n- When selecting a block, the size in screen characters:\n  {lines}x{columns}.\nThis information can be displayed in an alternative location using the\n'showcmdloc' option, useful when 'cmdheight' is 0."}}, scb = {binding = "scb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollbind' 'scb'\tboolean\t(default off)\n\t\tlocal to window\nSee also |scroll-binding|.  When this option is set, scrolling the\ncurrent window also scrolls other scrollbind windows (windows that\nalso have this option set).  This option is useful for viewing the\ndifferences between two versions of a file, see 'diff'.\nSee |'scrollopt'| for options that determine how this option should be\ninterpreted.\nThis option is mostly reset when splitting a window to edit another\nfile.  This means that \":split | edit file\" results in two windows\nwith scroll-binding, but \":split file\" does not."}}, scbk = {binding = "scbk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollback' 'scbk'\tnumber\t(default 10000)\n\t\tlocal to buffer\nMaximum number of lines kept beyond the visible screen. Lines at the\ntop are deleted if new lines exceed this limit.\nMinimum is 1, maximum is 100000.\nOnly in |terminal| buffers.\n\nNote: Lines that are not visible and kept in scrollback are not\nreflown when the terminal buffer is resized horizontally."}}, scl = {binding = "scl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'signcolumn' 'scl'\tstring\t(default \"auto\")\n\t\tlocal to window\nWhen and how to draw the signcolumn. Valid values are:\n   \"auto\"\tonly when there is a sign to display\n   \"auto:[1-9]\" resize to accommodate multiple signs up to the\n                given number (maximum 9), e.g. \"auto:4\"\n   \"auto:[1-8]-[2-9]\"\n                resize to accommodate multiple signs up to the\n\t\tgiven maximum number (maximum 9) while keeping\n\t\tat least the given minimum (maximum 8) fixed\n\t\tspace. The minimum number should always be less\n\t\tthan the maximum number, e.g. \"auto:2-5\"\n   \"no\"\t\tnever\n   \"yes\"\talways\n   \"yes:[1-9]\"  always, with fixed space for signs up to the given\n                number (maximum 9), e.g. \"yes:3\"\n   \"number\"\tdisplay signs in the 'number' column. If the number\n\t\tcolumn is not present, then behaves like \"auto\"."}}, scr = {binding = "scr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scroll' 'scr'\t\tnumber\t(default half the window height)\n\t\tlocal to window  |local-noglobal|\nNumber of lines to scroll with CTRL-U and CTRL-D commands.  Will be\nset to half the number of lines in the window when the window size\nchanges.  This may happen when enabling the |status-line| or\n'tabline' option after setting the 'scroll' option.\nIf you give a count to the CTRL-U or CTRL-D command it will\nbe used as the new value for 'scroll'.  Reset to half the window\nheight with \":set scroll=0\"."}}, scroll = {binding = "scroll", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scroll' 'scr'\t\tnumber\t(default half the window height)\n\t\tlocal to window  |local-noglobal|\nNumber of lines to scroll with CTRL-U and CTRL-D commands.  Will be\nset to half the number of lines in the window when the window size\nchanges.  This may happen when enabling the |status-line| or\n'tabline' option after setting the 'scroll' option.\nIf you give a count to the CTRL-U or CTRL-D command it will\nbe used as the new value for 'scroll'.  Reset to half the window\nheight with \":set scroll=0\"."}}, scrollback = {binding = "scrollback", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollback' 'scbk'\tnumber\t(default 10000)\n\t\tlocal to buffer\nMaximum number of lines kept beyond the visible screen. Lines at the\ntop are deleted if new lines exceed this limit.\nMinimum is 1, maximum is 100000.\nOnly in |terminal| buffers.\n\nNote: Lines that are not visible and kept in scrollback are not\nreflown when the terminal buffer is resized horizontally."}}, scrollbind = {binding = "scrollbind", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollbind' 'scb'\tboolean\t(default off)\n\t\tlocal to window\nSee also |scroll-binding|.  When this option is set, scrolling the\ncurrent window also scrolls other scrollbind windows (windows that\nalso have this option set).  This option is useful for viewing the\ndifferences between two versions of a file, see 'diff'.\nSee |'scrollopt'| for options that determine how this option should be\ninterpreted.\nThis option is mostly reset when splitting a window to edit another\nfile.  This means that \":split | edit file\" results in two windows\nwith scroll-binding, but \":split file\" does not."}}, scrolljump = {binding = "scrolljump", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrolljump' 'sj'\tnumber\t(default 1)\n\t\tglobal\nMinimal number of lines to scroll when the cursor gets off the\nscreen (e.g., with \"j\").  Not used for scroll commands (e.g., CTRL-E,\nCTRL-D).  Useful if your terminal scrolls very slowly.\nWhen set to a negative number from -1 to -100 this is used as the\npercentage of the window height.  Thus -50 scrolls half the window\nheight."}}, scrolloff = {binding = "scrolloff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrolloff' 'so'\tnumber\t(default 0)\n\t\tglobal or local to window |global-local|\nMinimal number of screen lines to keep above and below the cursor.\nThis will make some context visible around where you are working.  If\nyou set it to a very large value (999) the cursor line will always be\nin the middle of the window (except at the start or end of the file or\nwhen long lines wrap).\nAfter using the local value, go back the global value with one of\nthese two: >vim\n\tsetlocal scrolloff<\n\tsetlocal scrolloff=-1\n<\tFor scrolling horizontally see 'sidescrolloff'."}}, scrollopt = {binding = "scrollopt", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrollopt' 'sbo'\tstring\t(default \"ver,jump\")\n\t\tglobal\nThis is a comma-separated list of words that specifies how\n'scrollbind' windows should behave.  'sbo' stands for ScrollBind\nOptions.\nThe following words are available:\n    ver\t\tBind vertical scrolling for 'scrollbind' windows\n    hor\t\tBind horizontal scrolling for 'scrollbind' windows\n    jump\tApplies to the offset between two windows for vertical\n\t\tscrolling.  This offset is the difference in the first\n\t\tdisplayed line of the bound windows.  When moving\n\t\taround in a window, another 'scrollbind' window may\n\t\treach a position before the start or after the end of\n\t\tthe buffer.  The offset is not changed though, when\n\t\tmoving back the 'scrollbind' window will try to scroll\n\t\tto the desired position when possible.\n\t\tWhen now making that window the current one, two\n\t\tthings can be done with the relative offset:\n\t\0091. When \"jump\" is not included, the relative offset is\n\t\t   adjusted for the scroll position in the new current\n\t\t   window.  When going back to the other window, the\n\t\t   new relative offset will be used.\n\t\0092. When \"jump\" is included, the other windows are\n\t\t   scrolled to keep the same relative offset.  When\n\t\t   going back to the other window, it still uses the\n\t\t   same relative offset.\nAlso see |scroll-binding|.\nWhen 'diff' mode is active there always is vertical scroll binding,\neven when \"ver\" isn't there."}}, scs = {binding = "scs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartcase' 'scs'\tboolean\t(default off)\n\t\tglobal\nOverride the 'ignorecase' option if the search pattern contains upper\ncase characters.  Only used when the search pattern is typed and\n'ignorecase' option is on.  Used for the commands \"/\", \"?\", \"n\", \"N\",\n\":g\" and \":s\".  Not used for \"*\", \"#\", \"gd\", tag search, etc.  After\n\"*\" and \"#\" you can make 'smartcase' used by doing a \"/\" command,\nrecalling the search pattern from history and hitting <Enter>."}}, sd = {binding = "sd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shada' 'sd'\t\tstring\t(default for\n                                   Win32:  !,'100,<50,s10,h,rA:,rB:\n                                   others: !,'100,<50,s10,h)\n\t\tglobal\nWhen non-empty, the shada file is read upon startup and written\nwhen exiting Vim (see |shada-file|).  The string should be a comma-\nseparated list of parameters, each consisting of a single character\nidentifying the particular parameter, followed by a number or string\nwhich specifies the value of that parameter.  If a particular\ncharacter is left out, then the default value is used for that\nparameter.  The following is a list of the identifying characters and\nthe effect of their value.\nCHAR\tVALUE\t~\n\t\t\t\t\t\t*shada-!*\n!\tWhen included, save and restore global variables that start\n\twith an uppercase letter, and don't contain a lowercase\n\tletter.  Thus \"KEEPTHIS and \"K_L_M\" are stored, but \"KeepThis\"\n\tand \"_K_L_M\" are not.  Nested List and Dict items may not be\n\tread back correctly, you end up with an empty item.\n\t\t\t\t\t\t*shada-quote*\n\"\tMaximum number of lines saved for each register.  Old name of\n\tthe '<' item, with the disadvantage that you need to put a\n\tbackslash before the \", otherwise it will be recognized as the\n\tstart of a comment!\n\t\t\t\t\t\t*shada-%*\n%\tWhen included, save and restore the buffer list.  If Vim is\n\tstarted with a file name argument, the buffer list is not\n\trestored.  If Vim is started without a file name argument, the\n\tbuffer list is restored from the shada file.  Quickfix\n\t('buftype'), unlisted ('buflisted'), unnamed and buffers on\n\tremovable media (|shada-r|) are not saved.\n\tWhen followed by a number, the number specifies the maximum\n\tnumber of buffers that are stored.  Without a number all\n\tbuffers are stored.\n\t\t\t\t\t\t*shada-'*\n'\tMaximum number of previously edited files for which the marks\n\tare remembered.  This parameter must always be included when\n\t'shada' is non-empty.\n\tIncluding this item also means that the |jumplist| and the\n\t|changelist| are stored in the shada file.\n\t\t\t\t\t\t*shada-/*\n/\tMaximum number of items in the search pattern history to be\n\tsaved.  If non-zero, then the previous search and substitute\n\tpatterns are also saved.  When not included, the value of\n\t'history' is used.\n\t\t\t\t\t\t*shada-:*\n:\tMaximum number of items in the command-line history to be\n\tsaved.  When not included, the value of 'history' is used.\n\t\t\t\t\t\t*shada-<*\n<\tMaximum number of lines saved for each register.  If zero then\n\tregisters are not saved.  When not included, all lines are\n\tsaved.  '\"' is the old name for this item.\n\tAlso see the 's' item below: limit specified in KiB.\n\t\t\t\t\t\t*shada-@*\n@\tMaximum number of items in the input-line history to be\n\tsaved.  When not included, the value of 'history' is used.\n\t\t\t\t\t\t*shada-c*\nc\tDummy option, kept for compatibility reasons.  Has no actual\n\teffect: ShaDa always uses UTF-8 and 'encoding' value is fixed\n\tto UTF-8 as well.\n\t\t\t\t\t\t*shada-f*\nf\tWhether file marks need to be stored.  If zero, file marks ('0\n\tto '9, 'A to 'Z) are not stored.  When not present or when\n\tnon-zero, they are all stored.  '0 is used for the current\n\tcursor position (when exiting or when doing |:wshada|).\n\t\t\t\t\t\t*shada-h*\nh\tDisable the effect of 'hlsearch' when loading the shada\n\tfile.  When not included, it depends on whether \":nohlsearch\"\n\thas been used since the last search command.\n\t\t\t\t\t\t*shada-n*\nn\tName of the shada file.  The name must immediately follow\n\tthe 'n'.  Must be at the end of the option!  If the\n\t'shadafile' option is set, that file name overrides the one\n\tgiven here with 'shada'.  Environment variables are\n\texpanded when opening the file, not when setting the option.\n\t\t\t\t\t\t*shada-r*\nr\tRemovable media.  The argument is a string (up to the next\n\t',').  This parameter can be given several times.  Each\n\tspecifies the start of a path for which no marks will be\n\tstored.  This is to avoid removable media.  For Windows you\n\tcould use \"ra:,rb:\".  You can also use it for temp files,\n\te.g., for Unix: \"r/tmp\".  Case is ignored.\n\t\t\t\t\t\t*shada-s*\ns\tMaximum size of an item contents in KiB.  If zero then nothing\n\tis saved.  Unlike Vim this applies to all items, except for\n\tthe buffer list and header.  Full item size is off by three\n\tunsigned integers: with `s10` maximum item size may be 1 byte\n\t(type: 7-bit integer) + 9 bytes (timestamp: up to 64-bit\n\tinteger) + 3 bytes (item size: up to 16-bit integer because\n\0092^8 < 10240 < 2^16) + 10240 bytes (requested maximum item\n\tcontents size) = 10253 bytes.\n\nExample: >vim\n    set shada='50,<1000,s100,:0,n~/nvim/shada\n<\n'50\t\tMarks will be remembered for the last 50 files you\n\t\tedited.\n<1000\t\tContents of registers (up to 1000 lines each) will be\n\t\tremembered.\ns100\t\tItems with contents occupying more then 100 KiB are\n\t\tskipped.\n:0\t\tCommand-line history will not be saved.\nn~/nvim/shada\tThe name of the file to use is \"~/nvim/shada\".\nno /\t\tSince '/' is not specified, the default will be used,\n\t\tthat is, save all of the search history, and also the\n\t\tprevious search and substitute patterns.\nno %\t\tThe buffer list will not be saved nor read back.\nno h\t\t'hlsearch' highlighting will be restored.\n\nWhen setting 'shada' from an empty value you can use |:rshada| to\nload the contents of the file, this is not done automatically.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, sdf = {binding = "sdf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shadafile' 'sdf'\tstring\t(default \"\")\n\t\tglobal\nWhen non-empty, overrides the file name used for |shada| (viminfo).\nWhen equal to \"NONE\" no shada file will be read or written.\nThis option can be set with the |-i| command line flag.  The |--clean|\ncommand line flag sets it to \"NONE\".\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, sect = {binding = "sect", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sections' 'sect'\tstring\t(default \"SHNHH HUnhsh\")\n\t\tglobal\nSpecifies the nroff macros that separate sections.  These are pairs of\ntwo letters (See |object-motions|).  The default makes a section start\nat the nroff macros \".SH\", \".NH\", \".H\", \".HU\", \".nh\" and \".sh\"."}}, sections = {binding = "sections", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sections' 'sect'\tstring\t(default \"SHNHH HUnhsh\")\n\t\tglobal\nSpecifies the nroff macros that separate sections.  These are pairs of\ntwo letters (See |object-motions|).  The default makes a section start\nat the nroff macros \".SH\", \".NH\", \".H\", \".HU\", \".nh\" and \".sh\"."}}, sel = {binding = "sel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'selection' 'sel'\tstring\t(default \"inclusive\")\n\t\tglobal\nThis option defines the behavior of the selection.  It is only used\nin Visual and Select mode.\nPossible values:\n   value\tpast line     inclusive ~\n   old\t\t   no\t\tyes\n   inclusive\t   yes\t\tyes\n   exclusive\t   yes\t\tno\n\"past line\" means that the cursor is allowed to be positioned one\ncharacter past the line.\n\"inclusive\" means that the last character of the selection is included\nin an operation.  For example, when \"x\" is used to delete the\nselection.\nWhen \"old\" is used and 'virtualedit' allows the cursor to move past\nthe end of line the line break still isn't included.\nWhen \"exclusive\" is used, cursor position in visual mode will be\nadjusted for inclusive motions |inclusive-motion-selection-exclusive|.\n\nNote:\n- When \"exclusive\" is used and selecting from the end backwards, you\n  cannot include the last character of a line, when starting in Normal\n  mode and 'virtualedit' empty.\n- when \"exclusive\" is used with a single character visual selection,\n  Vim will behave as if the 'selection' is inclusive (in other words,\n  you cannot visually select an empty region)."}}, selection = {binding = "selection", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'selection' 'sel'\tstring\t(default \"inclusive\")\n\t\tglobal\nThis option defines the behavior of the selection.  It is only used\nin Visual and Select mode.\nPossible values:\n   value\tpast line     inclusive ~\n   old\t\t   no\t\tyes\n   inclusive\t   yes\t\tyes\n   exclusive\t   yes\t\tno\n\"past line\" means that the cursor is allowed to be positioned one\ncharacter past the line.\n\"inclusive\" means that the last character of the selection is included\nin an operation.  For example, when \"x\" is used to delete the\nselection.\nWhen \"old\" is used and 'virtualedit' allows the cursor to move past\nthe end of line the line break still isn't included.\nWhen \"exclusive\" is used, cursor position in visual mode will be\nadjusted for inclusive motions |inclusive-motion-selection-exclusive|.\n\nNote:\n- When \"exclusive\" is used and selecting from the end backwards, you\n  cannot include the last character of a line, when starting in Normal\n  mode and 'virtualedit' empty.\n- when \"exclusive\" is used with a single character visual selection,\n  Vim will behave as if the 'selection' is inclusive (in other words,\n  you cannot visually select an empty region)."}}, selectmode = {binding = "selectmode", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'selectmode' 'slm'\tstring\t(default \"\")\n\t\tglobal\nThis is a comma-separated list of words, which specifies when to start\nSelect mode instead of Visual mode, when a selection is started.\nPossible values:\n   mouse\twhen using the mouse\n   key\t\twhen using shifted special keys\n   cmd\t\twhen using \"v\", \"V\" or CTRL-V\nSee |Select-mode|."}}, sessionoptions = {binding = "sessionoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sessionoptions' 'ssop'\tstring\t(default \"blank,buffers,curdir,folds,help,tabpages,winsize,terminal\")\n\t\tglobal\nChanges the effect of the |:mksession| command.  It is a comma-\nseparated list of words.  Each word enables saving and restoring\nsomething:\n   word\t\tsave and restore ~\n   blank\tempty windows\n   buffers\thidden and unloaded buffers, not just those in windows\n   curdir\tthe current directory\n   folds\tmanually created folds, opened/closed folds and local\n\t\tfold options\n   globals\tglobal variables that start with an uppercase letter\n\t\tand contain at least one lowercase letter.  Only\n\t\tString and Number types are stored.\n   help\t\tthe help window\n   localoptions\toptions and mappings local to a window or buffer (not\n\t\tglobal values for local options)\n   options\tall options and mappings (also global values for local\n\t\toptions)\n   skiprtp\texclude 'runtimepath' and 'packpath' from the options\n   resize\tsize of the Vim window: 'lines' and 'columns'\n   sesdir\tthe directory in which the session file is located\n\t\twill become the current directory (useful with\n\t\tprojects accessed over a network from different\n\t\tsystems)\n   tabpages\tall tab pages; without this only the current tab page\n\t\tis restored, so that you can make a session for each\n\t\ttab page separately\n   terminal\tinclude terminal windows where the command can be\n\t\trestored\n   winpos\tposition of the whole Vim window\n   winsize\twindow sizes\n   slash\t|deprecated| Always enabled. Uses \"/\" in filenames.\n   unix\t\t|deprecated| Always enabled. Uses \"\\n\" line endings.\n\nDon't include both \"curdir\" and \"sesdir\". When neither is included\nfilenames are stored as absolute paths.\nIf you leave out \"options\" many things won't work well after restoring\nthe session."}}, sft = {binding = "sft", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showfulltag' 'sft'\tboolean\t(default off)\n\t\tglobal\nWhen completing a word in insert mode (see |ins-completion|) from the\ntags file, show both the tag name and a tidied-up form of the search\npattern (if there is one) as possible matches.  Thus, if you have\nmatched a C function, you can see a template for what arguments are\nrequired (coding style permitting).\nNote that this doesn't work well together with having \"longest\" in\n'completeopt', because the completion from the search pattern may not\nmatch the typed text."}}, sh = {binding = "sh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shell' 'sh'\t\tstring\t(default $SHELL or \"sh\", Win32: \"cmd.exe\")\n\t\tglobal\nName of the shell to use for ! and :! commands.  When changing the\nvalue also check these options: 'shellpipe', 'shellslash'\n'shellredir', 'shellquote', 'shellxquote' and 'shellcmdflag'.\nIt is allowed to give an argument to the command, e.g.  \"csh -f\".\nSee |option-backslash| about including spaces and backslashes.\nEnvironment variables are expanded |:set_env|.\n\nIf the name of the shell contains a space, you need to enclose it in\nquotes.  Example with quotes: >vim\n\tset shell=\\\"c:\\program\\ files\\unix\\sh.exe\\\"\\ -f\n<\tNote the backslash before each quote (to avoid starting a comment) and\neach space (to avoid ending the option value), so better use |:let-&|\nlike this: >vim\n\tlet &shell='\"C:\\Program Files\\unix\\sh.exe\" -f'\n<\tAlso note that the \"-f\" is not inside the quotes, because it is not\npart of the command name.\n\t\t\t\t\t\t*shell-unquoting*\nRules regarding quotes:\n1. Option is split on space and tab characters that are not inside\n   quotes: \"abc def\" runs shell named \"abc\" with additional argument\n   \"def\", '\"abc def\"' runs shell named \"abc def\" with no additional\n   arguments (here and below: additional means \226\128\156additional to\n   'shellcmdflag'\226\128\157).\n2. Quotes in option may be present in any position and any number:\n   '\"abc\"', '\"a\"bc', 'a\"b\"c', 'ab\"c\"' and '\"a\"b\"c\"' are all equivalent\n   to just \"abc\".\n3. Inside quotes backslash preceding backslash means one backslash.\n   Backslash preceding quote means one quote. Backslash preceding\n   anything else means backslash and next character literally:\n   '\"a\\\\b\"' is the same as \"a\\b\", '\"a\\\\\"b\"' runs shell named literally\n   'a\"b', '\"a\\b\"' is the same as \"a\\b\" again.\n4. Outside of quotes backslash always means itself, it cannot be used\n   to escape quote: 'a\\\"b\"' is the same as \"a\\b\".\nNote that such processing is done after |:set| did its own round of\nunescaping, so to keep yourself sane use |:let-&| like shown above.\n\t\t\t\t\t\t*shell-powershell*\nTo use PowerShell: >vim\n\tlet &shell = executable('pwsh') ? 'pwsh' : 'powershell'\n\tlet &shellcmdflag = '-NoLogo -NonInteractive -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.UTF8Encoding]::new();$PSDefaultParameterValues[''Out-File:Encoding'']=''utf8'';$PSStyle.OutputRendering=''plaintext'';Remove-Alias -Force -ErrorAction SilentlyContinue tee;'\n\tlet &shellredir = '2>&1 | %%{ \"$_\" } | Out-File %s; exit $LastExitCode'\n\tlet &shellpipe  = '2>&1 | %%{ \"$_\" } | tee %s; exit $LastExitCode'\n\tset shellquote= shellxquote=\n\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shada = {binding = "shada", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shada' 'sd'\t\tstring\t(default for\n                                   Win32:  !,'100,<50,s10,h,rA:,rB:\n                                   others: !,'100,<50,s10,h)\n\t\tglobal\nWhen non-empty, the shada file is read upon startup and written\nwhen exiting Vim (see |shada-file|).  The string should be a comma-\nseparated list of parameters, each consisting of a single character\nidentifying the particular parameter, followed by a number or string\nwhich specifies the value of that parameter.  If a particular\ncharacter is left out, then the default value is used for that\nparameter.  The following is a list of the identifying characters and\nthe effect of their value.\nCHAR\tVALUE\t~\n\t\t\t\t\t\t*shada-!*\n!\tWhen included, save and restore global variables that start\n\twith an uppercase letter, and don't contain a lowercase\n\tletter.  Thus \"KEEPTHIS and \"K_L_M\" are stored, but \"KeepThis\"\n\tand \"_K_L_M\" are not.  Nested List and Dict items may not be\n\tread back correctly, you end up with an empty item.\n\t\t\t\t\t\t*shada-quote*\n\"\tMaximum number of lines saved for each register.  Old name of\n\tthe '<' item, with the disadvantage that you need to put a\n\tbackslash before the \", otherwise it will be recognized as the\n\tstart of a comment!\n\t\t\t\t\t\t*shada-%*\n%\tWhen included, save and restore the buffer list.  If Vim is\n\tstarted with a file name argument, the buffer list is not\n\trestored.  If Vim is started without a file name argument, the\n\tbuffer list is restored from the shada file.  Quickfix\n\t('buftype'), unlisted ('buflisted'), unnamed and buffers on\n\tremovable media (|shada-r|) are not saved.\n\tWhen followed by a number, the number specifies the maximum\n\tnumber of buffers that are stored.  Without a number all\n\tbuffers are stored.\n\t\t\t\t\t\t*shada-'*\n'\tMaximum number of previously edited files for which the marks\n\tare remembered.  This parameter must always be included when\n\t'shada' is non-empty.\n\tIncluding this item also means that the |jumplist| and the\n\t|changelist| are stored in the shada file.\n\t\t\t\t\t\t*shada-/*\n/\tMaximum number of items in the search pattern history to be\n\tsaved.  If non-zero, then the previous search and substitute\n\tpatterns are also saved.  When not included, the value of\n\t'history' is used.\n\t\t\t\t\t\t*shada-:*\n:\tMaximum number of items in the command-line history to be\n\tsaved.  When not included, the value of 'history' is used.\n\t\t\t\t\t\t*shada-<*\n<\tMaximum number of lines saved for each register.  If zero then\n\tregisters are not saved.  When not included, all lines are\n\tsaved.  '\"' is the old name for this item.\n\tAlso see the 's' item below: limit specified in KiB.\n\t\t\t\t\t\t*shada-@*\n@\tMaximum number of items in the input-line history to be\n\tsaved.  When not included, the value of 'history' is used.\n\t\t\t\t\t\t*shada-c*\nc\tDummy option, kept for compatibility reasons.  Has no actual\n\teffect: ShaDa always uses UTF-8 and 'encoding' value is fixed\n\tto UTF-8 as well.\n\t\t\t\t\t\t*shada-f*\nf\tWhether file marks need to be stored.  If zero, file marks ('0\n\tto '9, 'A to 'Z) are not stored.  When not present or when\n\tnon-zero, they are all stored.  '0 is used for the current\n\tcursor position (when exiting or when doing |:wshada|).\n\t\t\t\t\t\t*shada-h*\nh\tDisable the effect of 'hlsearch' when loading the shada\n\tfile.  When not included, it depends on whether \":nohlsearch\"\n\thas been used since the last search command.\n\t\t\t\t\t\t*shada-n*\nn\tName of the shada file.  The name must immediately follow\n\tthe 'n'.  Must be at the end of the option!  If the\n\t'shadafile' option is set, that file name overrides the one\n\tgiven here with 'shada'.  Environment variables are\n\texpanded when opening the file, not when setting the option.\n\t\t\t\t\t\t*shada-r*\nr\tRemovable media.  The argument is a string (up to the next\n\t',').  This parameter can be given several times.  Each\n\tspecifies the start of a path for which no marks will be\n\tstored.  This is to avoid removable media.  For Windows you\n\tcould use \"ra:,rb:\".  You can also use it for temp files,\n\te.g., for Unix: \"r/tmp\".  Case is ignored.\n\t\t\t\t\t\t*shada-s*\ns\tMaximum size of an item contents in KiB.  If zero then nothing\n\tis saved.  Unlike Vim this applies to all items, except for\n\tthe buffer list and header.  Full item size is off by three\n\tunsigned integers: with `s10` maximum item size may be 1 byte\n\t(type: 7-bit integer) + 9 bytes (timestamp: up to 64-bit\n\tinteger) + 3 bytes (item size: up to 16-bit integer because\n\0092^8 < 10240 < 2^16) + 10240 bytes (requested maximum item\n\tcontents size) = 10253 bytes.\n\nExample: >vim\n    set shada='50,<1000,s100,:0,n~/nvim/shada\n<\n'50\t\tMarks will be remembered for the last 50 files you\n\t\tedited.\n<1000\t\tContents of registers (up to 1000 lines each) will be\n\t\tremembered.\ns100\t\tItems with contents occupying more then 100 KiB are\n\t\tskipped.\n:0\t\tCommand-line history will not be saved.\nn~/nvim/shada\tThe name of the file to use is \"~/nvim/shada\".\nno /\t\tSince '/' is not specified, the default will be used,\n\t\tthat is, save all of the search history, and also the\n\t\tprevious search and substitute patterns.\nno %\t\tThe buffer list will not be saved nor read back.\nno h\t\t'hlsearch' highlighting will be restored.\n\nWhen setting 'shada' from an empty value you can use |:rshada| to\nload the contents of the file, this is not done automatically.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shadafile = {binding = "shadafile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shadafile' 'sdf'\tstring\t(default \"\")\n\t\tglobal\nWhen non-empty, overrides the file name used for |shada| (viminfo).\nWhen equal to \"NONE\" no shada file will be read or written.\nThis option can be set with the |-i| command line flag.  The |--clean|\ncommand line flag sets it to \"NONE\".\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shcf = {binding = "shcf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellcmdflag' 'shcf'\tstring\t(default \"-c\"; Windows: \"/s /c\")\n\t\tglobal\nFlag passed to the shell to execute \"!\" and \":!\" commands; e.g.,\n`bash.exe -c ls` or `cmd.exe /s /c \"dir\"`.  For MS-Windows, the\ndefault is set according to the value of 'shell', to reduce the need\nto set this option by the user.\nOn Unix it can have more than one flag.  Each white space separated\npart is passed as an argument to the shell command.\nSee |option-backslash| about including spaces and backslashes.\nSee |shell-unquoting| which talks about separating this option into\nmultiple arguments.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shell = {binding = "shell", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shell' 'sh'\t\tstring\t(default $SHELL or \"sh\", Win32: \"cmd.exe\")\n\t\tglobal\nName of the shell to use for ! and :! commands.  When changing the\nvalue also check these options: 'shellpipe', 'shellslash'\n'shellredir', 'shellquote', 'shellxquote' and 'shellcmdflag'.\nIt is allowed to give an argument to the command, e.g.  \"csh -f\".\nSee |option-backslash| about including spaces and backslashes.\nEnvironment variables are expanded |:set_env|.\n\nIf the name of the shell contains a space, you need to enclose it in\nquotes.  Example with quotes: >vim\n\tset shell=\\\"c:\\program\\ files\\unix\\sh.exe\\\"\\ -f\n<\tNote the backslash before each quote (to avoid starting a comment) and\neach space (to avoid ending the option value), so better use |:let-&|\nlike this: >vim\n\tlet &shell='\"C:\\Program Files\\unix\\sh.exe\" -f'\n<\tAlso note that the \"-f\" is not inside the quotes, because it is not\npart of the command name.\n\t\t\t\t\t\t*shell-unquoting*\nRules regarding quotes:\n1. Option is split on space and tab characters that are not inside\n   quotes: \"abc def\" runs shell named \"abc\" with additional argument\n   \"def\", '\"abc def\"' runs shell named \"abc def\" with no additional\n   arguments (here and below: additional means \226\128\156additional to\n   'shellcmdflag'\226\128\157).\n2. Quotes in option may be present in any position and any number:\n   '\"abc\"', '\"a\"bc', 'a\"b\"c', 'ab\"c\"' and '\"a\"b\"c\"' are all equivalent\n   to just \"abc\".\n3. Inside quotes backslash preceding backslash means one backslash.\n   Backslash preceding quote means one quote. Backslash preceding\n   anything else means backslash and next character literally:\n   '\"a\\\\b\"' is the same as \"a\\b\", '\"a\\\\\"b\"' runs shell named literally\n   'a\"b', '\"a\\b\"' is the same as \"a\\b\" again.\n4. Outside of quotes backslash always means itself, it cannot be used\n   to escape quote: 'a\\\"b\"' is the same as \"a\\b\".\nNote that such processing is done after |:set| did its own round of\nunescaping, so to keep yourself sane use |:let-&| like shown above.\n\t\t\t\t\t\t*shell-powershell*\nTo use PowerShell: >vim\n\tlet &shell = executable('pwsh') ? 'pwsh' : 'powershell'\n\tlet &shellcmdflag = '-NoLogo -NonInteractive -ExecutionPolicy RemoteSigned -Command [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.UTF8Encoding]::new();$PSDefaultParameterValues[''Out-File:Encoding'']=''utf8'';$PSStyle.OutputRendering=''plaintext'';Remove-Alias -Force -ErrorAction SilentlyContinue tee;'\n\tlet &shellredir = '2>&1 | %%{ \"$_\" } | Out-File %s; exit $LastExitCode'\n\tlet &shellpipe  = '2>&1 | %%{ \"$_\" } | tee %s; exit $LastExitCode'\n\tset shellquote= shellxquote=\n\n<\tThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shellcmdflag = {binding = "shellcmdflag", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellcmdflag' 'shcf'\tstring\t(default \"-c\"; Windows: \"/s /c\")\n\t\tglobal\nFlag passed to the shell to execute \"!\" and \":!\" commands; e.g.,\n`bash.exe -c ls` or `cmd.exe /s /c \"dir\"`.  For MS-Windows, the\ndefault is set according to the value of 'shell', to reduce the need\nto set this option by the user.\nOn Unix it can have more than one flag.  Each white space separated\npart is passed as an argument to the shell command.\nSee |option-backslash| about including spaces and backslashes.\nSee |shell-unquoting| which talks about separating this option into\nmultiple arguments.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shellpipe = {binding = "shellpipe", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellpipe' 'sp'\tstring\t(default \">\", \"| tee\", \"|& tee\" or \"2>&1| tee\")\n\t\tglobal\nString to be used to put the output of the \":make\" command in the\nerror file.  See also |:make_makeprg|.  See |option-backslash| about\nincluding spaces and backslashes.\nThe name of the temporary file can be represented by \"%s\" if necessary\n(the file name is appended automatically if no %s appears in the value\nof this option).\nFor MS-Windows the default is \"2>&1| tee\".  The stdout and stderr are\nsaved in a file and echoed to the screen.\nFor Unix the default is \"| tee\".  The stdout of the compiler is saved\nin a file and echoed to the screen.  If the 'shell' option is \"csh\" or\n\"tcsh\" after initializations, the default becomes \"|& tee\".  If the\n'shell' option is \"sh\", \"ksh\", \"mksh\", \"pdksh\", \"zsh\", \"zsh-beta\",\n\"bash\", \"fish\", \"ash\" or \"dash\" the default becomes \"2>&1| tee\".  This\nmeans that stderr is also included.  Before using the 'shell' option a\npath is removed, thus \"/bin/sh\" uses \"sh\".\nThe initialization of this option is done after reading the vimrc\nand the other initializations, so that when the 'shell' option is set\nthere, the 'shellpipe' option changes automatically, unless it was\nexplicitly set before.\nWhen 'shellpipe' is set to an empty string, no redirection of the\n\":make\" output will be done.  This is useful if you use a 'makeprg'\nthat writes to 'makeef' by itself.  If you want no piping, but do\nwant to include the 'makeef', set 'shellpipe' to a single space.\nDon't forget to precede the space with a backslash: \":set sp=\\ \".\nIn the future pipes may be used for filtering and this option will\nbecome obsolete (at least for Unix).\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shellquote = {binding = "shellquote", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellquote' 'shq'\tstring\t(default \"\"; Windows, when 'shell'\n                                        contains \"sh\" somewhere: \"\\\"\")\n\t\tglobal\nQuoting character(s), put around the command passed to the shell, for\nthe \"!\" and \":!\" commands.  The redirection is kept outside of the\nquoting.  See 'shellxquote' to include the redirection.  It's\nprobably not useful to set both options.\nThis is an empty string by default.  Only known to be useful for\nthird-party shells on Windows systems, such as the MKS Korn Shell\nor bash, where it should be \"\\\"\".  The default is adjusted according\nthe value of 'shell', to reduce the need to set this option by the\nuser.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shellredir = {binding = "shellredir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellredir' 'srr'\tstring\t(default \">\", \">&\" or \">%s 2>&1\")\n\t\tglobal\nString to be used to put the output of a filter command in a temporary\nfile.  See also |:!|.  See |option-backslash| about including spaces\nand backslashes.\nThe name of the temporary file can be represented by \"%s\" if necessary\n(the file name is appended automatically if no %s appears in the value\nof this option).\nThe default is \">\".  For Unix, if the 'shell' option is \"csh\" or\n\"tcsh\" during initializations, the default becomes \">&\".  If the\n'shell' option is \"sh\", \"ksh\", \"mksh\", \"pdksh\", \"zsh\", \"zsh-beta\",\n\"bash\" or \"fish\", the default becomes \">%s 2>&1\".  This means that\nstderr is also included.  For Win32, the Unix checks are done and\nadditionally \"cmd\" is checked for, which makes the default \">%s 2>&1\".\nAlso, the same names with \".exe\" appended are checked for.\nThe initialization of this option is done after reading the vimrc\nand the other initializations, so that when the 'shell' option is set\nthere, the 'shellredir' option changes automatically unless it was\nexplicitly set before.\nIn the future pipes may be used for filtering and this option will\nbecome obsolete (at least for Unix).\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shellslash = {binding = "shellslash", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellslash' 'ssl'\tboolean\t(default on, Windows: off)\n\t\tglobal\n\t\tonly modifiable in MS-Windows\nWhen set, a forward slash is used when expanding file names.  This is\nuseful when a Unix-like shell is used instead of cmd.exe.  Backward\nslashes can still be typed, but they are changed to forward slashes by\nVim.\nNote that setting or resetting this option has no effect for some\nexisting file names, thus this option needs to be set before opening\nany file for best results.  This might change in the future.\n'shellslash' only works when a backslash can be used as a path\nseparator.  To test if this is so use: >vim\n\tif exists('+shellslash')\n<\tAlso see 'completeslash'."}}, shelltemp = {binding = "shelltemp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shelltemp' 'stmp'\tboolean\t(default on)\n\t\tglobal\nWhen on, use temp files for shell commands.  When off use a pipe.\nWhen using a pipe is not possible temp files are used anyway.\nThe advantage of using a pipe is that nobody can read the temp file\nand the 'shell' command does not need to support redirection.\nThe advantage of using a temp file is that the file type and encoding\ncan be detected.\nThe |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,\n|FilterWritePost| autocommands event are not triggered when\n'shelltemp' is off.\n|system()| does not respect this option, it always uses pipes."}}, shellxescape = {binding = "shellxescape", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellxescape' 'sxe'\tstring\t(default \"\")\n\t\tglobal\nWhen 'shellxquote' is set to \"(\" then the characters listed in this\noption will be escaped with a '^' character.  This makes it possible\nto execute most external commands with cmd.exe.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shellxquote = {binding = "shellxquote", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellxquote' 'sxq'\tstring\t(default \"\", Windows: \"\\\"\")\n\t\tglobal\nQuoting character(s), put around the command passed to the shell, for\nthe \"!\" and \":!\" commands.  Includes the redirection.  See\n'shellquote' to exclude the redirection.  It's probably not useful\nto set both options.\nWhen the value is '(' then ')' is appended. When the value is '\"('\nthen ')\"' is appended.\nWhen the value is '(' then also see 'shellxescape'.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, shiftround = {binding = "shiftround", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shiftround' 'sr'\tboolean\t(default off)\n\t\tglobal\nRound indent to multiple of 'shiftwidth'.  Applies to > and <\ncommands.  CTRL-T and CTRL-D in Insert mode always round the indent to\na multiple of 'shiftwidth' (this is Vi compatible)."}}, shiftwidth = {binding = "shiftwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shiftwidth' 'sw'\tnumber\t(default 8)\n\t\tlocal to buffer\nNumber of spaces to use for each step of (auto)indent.  Used for\n|'cindent'|, |>>|, |<<|, etc.\nWhen zero the 'tabstop' value will be used.  Use the |shiftwidth()|\nfunction to get the effective shiftwidth value."}}, shm = {binding = "shm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shortmess' 'shm'\tstring\t(default \"ltToOCF\")\n\t\tglobal\nThis option helps to avoid all the |hit-enter| prompts caused by file\nmessages, for example with CTRL-G, and to avoid some other messages.\nIt is a list of flags:\n flag\tmeaning when present\t~\n  l\tuse \"999L, 888B\" instead of \"999 lines, 888 bytes\"\t*shm-l*\n  m\tuse \"[+]\" instead of \"[Modified]\"\t\t\t*shm-m*\n  r\tuse \"[RO]\" instead of \"[readonly]\"\t\t\t*shm-r*\n  w\tuse \"[w]\" instead of \"written\" for file write message\t*shm-w*\n\tand \"[a]\" instead of \"appended\" for ':w >> file' command\n  a\tall of the above abbreviations\t\t\t\t*shm-a*\n\n  o\toverwrite message for writing a file with subsequent\t*shm-o*\n\tmessage for reading a file (useful for \":wn\" or when\n\t'autowrite' on)\n  O\tmessage for reading a file overwrites any previous\t*shm-O*\n\tmessage;  also for quickfix message (e.g., \":cn\")\n  s\tdon't give \"search hit BOTTOM, continuing at TOP\" or\t*shm-s*\n\t\"search hit TOP, continuing at BOTTOM\" messages; when using\n\tthe search count do not show \"W\" before the count message\n\t(see |shm-S| below)\n  t\ttruncate file message at the start if it is too long\t*shm-t*\n\tto fit on the command-line, \"<\" will appear in the left most\n\tcolumn; ignored in Ex mode\n  T\ttruncate other messages in the middle if they are too\t*shm-T*\n\tlong to fit on the command line; \"...\" will appear in the\n\tmiddle; ignored in Ex mode\n  W\tdon't give \"written\" or \"[w]\" when writing a file\t*shm-W*\n  A\tdon't give the \"ATTENTION\" message when an existing\t*shm-A*\n\tswap file is found\n  I\tdon't give the intro message when starting Vim,\t\t*shm-I*\n\tsee |:intro|\n  c\tdon't give |ins-completion-menu| messages; for\t\t*shm-c*\n\texample, \"-- XXX completion (YYY)\", \"match 1 of 2\", \"The only\n\tmatch\", \"Pattern not found\", \"Back at original\", etc.\n  C\tdon't give messages while scanning for ins-completion\t*shm-C*\n\titems, for instance \"scanning tags\"\n  q\tdo not show \"recording @a\" when recording a macro\t*shm-q*\n  F\tdon't give the file info when editing a file, like\t*shm-F*\n\t`:silent` was used for the command; note that this also\n\taffects messages from 'autoread' reloading\n  S\tdo not show search count message when searching, e.g.\t*shm-S*\n\t\"[1/5]\". When the \"S\" flag is not present (e.g. search count\n\tis shown), the \"search hit BOTTOM, continuing at TOP\" and\n\t\"search hit TOP, continuing at BOTTOM\" messages are only\n\tindicated by a \"W\" (Mnemonic: Wrapped) letter before the\n\tsearch count statistics.\n\nThis gives you the opportunity to avoid that a change between buffers\nrequires you to hit <Enter>, but still gives as useful a message as\npossible for the space available.  To get the whole message that you\nwould have got with 'shm' empty, use \":file!\"\nUseful values:\n    shm=\tNo abbreviation of message.\n    shm=a\tAbbreviation, but no loss of information.\n    shm=at\tAbbreviation, and truncate message when necessary."}}, shortmess = {binding = "shortmess", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shortmess' 'shm'\tstring\t(default \"ltToOCF\")\n\t\tglobal\nThis option helps to avoid all the |hit-enter| prompts caused by file\nmessages, for example with CTRL-G, and to avoid some other messages.\nIt is a list of flags:\n flag\tmeaning when present\t~\n  l\tuse \"999L, 888B\" instead of \"999 lines, 888 bytes\"\t*shm-l*\n  m\tuse \"[+]\" instead of \"[Modified]\"\t\t\t*shm-m*\n  r\tuse \"[RO]\" instead of \"[readonly]\"\t\t\t*shm-r*\n  w\tuse \"[w]\" instead of \"written\" for file write message\t*shm-w*\n\tand \"[a]\" instead of \"appended\" for ':w >> file' command\n  a\tall of the above abbreviations\t\t\t\t*shm-a*\n\n  o\toverwrite message for writing a file with subsequent\t*shm-o*\n\tmessage for reading a file (useful for \":wn\" or when\n\t'autowrite' on)\n  O\tmessage for reading a file overwrites any previous\t*shm-O*\n\tmessage;  also for quickfix message (e.g., \":cn\")\n  s\tdon't give \"search hit BOTTOM, continuing at TOP\" or\t*shm-s*\n\t\"search hit TOP, continuing at BOTTOM\" messages; when using\n\tthe search count do not show \"W\" before the count message\n\t(see |shm-S| below)\n  t\ttruncate file message at the start if it is too long\t*shm-t*\n\tto fit on the command-line, \"<\" will appear in the left most\n\tcolumn; ignored in Ex mode\n  T\ttruncate other messages in the middle if they are too\t*shm-T*\n\tlong to fit on the command line; \"...\" will appear in the\n\tmiddle; ignored in Ex mode\n  W\tdon't give \"written\" or \"[w]\" when writing a file\t*shm-W*\n  A\tdon't give the \"ATTENTION\" message when an existing\t*shm-A*\n\tswap file is found\n  I\tdon't give the intro message when starting Vim,\t\t*shm-I*\n\tsee |:intro|\n  c\tdon't give |ins-completion-menu| messages; for\t\t*shm-c*\n\texample, \"-- XXX completion (YYY)\", \"match 1 of 2\", \"The only\n\tmatch\", \"Pattern not found\", \"Back at original\", etc.\n  C\tdon't give messages while scanning for ins-completion\t*shm-C*\n\titems, for instance \"scanning tags\"\n  q\tdo not show \"recording @a\" when recording a macro\t*shm-q*\n  F\tdon't give the file info when editing a file, like\t*shm-F*\n\t`:silent` was used for the command; note that this also\n\taffects messages from 'autoread' reloading\n  S\tdo not show search count message when searching, e.g.\t*shm-S*\n\t\"[1/5]\". When the \"S\" flag is not present (e.g. search count\n\tis shown), the \"search hit BOTTOM, continuing at TOP\" and\n\t\"search hit TOP, continuing at BOTTOM\" messages are only\n\tindicated by a \"W\" (Mnemonic: Wrapped) letter before the\n\tsearch count statistics.\n\nThis gives you the opportunity to avoid that a change between buffers\nrequires you to hit <Enter>, but still gives as useful a message as\npossible for the space available.  To get the whole message that you\nwould have got with 'shm' empty, use \":file!\"\nUseful values:\n    shm=\tNo abbreviation of message.\n    shm=a\tAbbreviation, but no loss of information.\n    shm=at\tAbbreviation, and truncate message when necessary."}}, showbreak = {binding = "showbreak", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showbreak' 'sbr'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nString to put at the start of lines that have been wrapped.  Useful\nvalues are \"> \" or \"+++ \": >vim\n\tlet &showbreak = \"> \"\n\tlet &showbreak = '+++ '\n<\tOnly printable single-cell characters are allowed, excluding <Tab> and\ncomma (in a future version the comma might be used to separate the\npart that is shown at the end and at the start of a line).\nThe |hl-NonText| highlight group determines the highlighting.\nNote that tabs after the showbreak will be displayed differently.\nIf you want the 'showbreak' to appear in between line numbers, add the\n\"n\" flag to 'cpoptions'.\nA window-local value overrules a global value.  If the global value is\nset and you want no value in the current window use NONE: >vim\n\tsetlocal showbreak=NONE\n<"}}, showcmd = {binding = "showcmd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showcmd' 'sc'\t\tboolean\t(default on)\n\t\tglobal\nShow (partial) command in the last line of the screen.  Set this\noption off if your terminal is slow.\nIn Visual mode the size of the selected area is shown:\n- When selecting characters within a line, the number of characters.\n  If the number of bytes is different it is also displayed: \"2-6\"\n  means two characters and six bytes.\n- When selecting more than one line, the number of lines.\n- When selecting a block, the size in screen characters:\n  {lines}x{columns}.\nThis information can be displayed in an alternative location using the\n'showcmdloc' option, useful when 'cmdheight' is 0."}}, showcmdloc = {binding = "showcmdloc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showcmdloc' 'sloc'\tstring\t(default \"last\")\n\t\tglobal\nThis option can be used to display the (partially) entered command in\nanother location.  Possible values are:\n  last\t\tLast line of the screen (default).\n  statusline\tStatus line of the current window.\n  tabline\tFirst line of the screen if 'showtabline' is enabled.\nSetting this option to \"statusline\" or \"tabline\" means that these will\nbe redrawn whenever the command changes, which can be on every key\npressed.\nThe %S 'statusline' item can be used in 'statusline' or 'tabline' to\nplace the text.  Without a custom 'statusline' or 'tabline' it will be\ndisplayed in a convenient location."}}, showfulltag = {binding = "showfulltag", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showfulltag' 'sft'\tboolean\t(default off)\n\t\tglobal\nWhen completing a word in insert mode (see |ins-completion|) from the\ntags file, show both the tag name and a tidied-up form of the search\npattern (if there is one) as possible matches.  Thus, if you have\nmatched a C function, you can see a template for what arguments are\nrequired (coding style permitting).\nNote that this doesn't work well together with having \"longest\" in\n'completeopt', because the completion from the search pattern may not\nmatch the typed text."}}, showmatch = {binding = "showmatch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmatch' 'sm'\tboolean\t(default off)\n\t\tglobal\nWhen a bracket is inserted, briefly jump to the matching one.  The\njump is only done if the match can be seen on the screen.  The time to\nshow the match can be set with 'matchtime'.\nA Beep is given if there is no match (no matter if the match can be\nseen or not).\nWhen the 'm' flag is not included in 'cpoptions', typing a character\nwill immediately move the cursor back to where it belongs.\nSee the \"sm\" field in 'guicursor' for setting the cursor shape and\nblinking when showing the match.\nThe 'matchpairs' option can be used to specify the characters to show\nmatches for.  'rightleft' and 'revins' are used to look for opposite\nmatches.\nAlso see the matchparen plugin for highlighting the match when moving\naround |pi_paren.txt|.\nNote: Use of the short form is rated PG."}}, showmode = {binding = "showmode", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmode' 'smd'\tboolean\t(default on)\n\t\tglobal\nIf in Insert, Replace or Visual mode put a message on the last line.\nThe |hl-ModeMsg| highlight group determines the highlighting.\nThe option has no effect when 'cmdheight' is zero."}}, showtabline = {binding = "showtabline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showtabline' 'stal'\tnumber\t(default 1)\n\t\tglobal\nThe value of this option specifies when the line with tab page labels\nwill be displayed:\n\0090: never\n\0091: only if there are at least two tab pages\n\0092: always\nThis is both for the GUI and non-GUI implementation of the tab pages\nline.\nSee |tab-page| for more information about tab pages."}}, shq = {binding = "shq", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellquote' 'shq'\tstring\t(default \"\"; Windows, when 'shell'\n                                        contains \"sh\" somewhere: \"\\\"\")\n\t\tglobal\nQuoting character(s), put around the command passed to the shell, for\nthe \"!\" and \":!\" commands.  The redirection is kept outside of the\nquoting.  See 'shellxquote' to include the redirection.  It's\nprobably not useful to set both options.\nThis is an empty string by default.  Only known to be useful for\nthird-party shells on Windows systems, such as the MKS Korn Shell\nor bash, where it should be \"\\\"\".  The default is adjusted according\nthe value of 'shell', to reduce the need to set this option by the\nuser.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, si = {binding = "si", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartindent' 'si'\tboolean\t(default off)\n\t\tlocal to buffer\nDo smart autoindenting when starting a new line.  Works for C-like\nprograms, but can also be used for other languages.  'cindent' does\nsomething like this, works better in most cases, but is more strict,\nsee |C-indenting|.  When 'cindent' is on or 'indentexpr' is set,\nsetting 'si' has no effect.  'indentexpr' is a more advanced\nalternative.\nNormally 'autoindent' should also be on when using 'smartindent'.\nAn indent is automatically inserted:\n- After a line ending in \"{\".\n- After a line starting with a keyword from 'cinwords'.\n- Before a line starting with \"}\" (only with the \"O\" command).\nWhen typing '}' as the first character in a new line, that line is\ngiven the same indent as the matching \"{\".\nWhen typing '#' as the first character in a new line, the indent for\nthat line is removed, the '#' is put in the first column.  The indent\nis restored for the next line.  If you don't want this, use this\nmapping: \":inoremap # X^H#\", where ^H is entered with CTRL-V CTRL-H.\nWhen using the \">>\" command, lines starting with '#' are not shifted\nright."}}, sidescroll = {binding = "sidescroll", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sidescroll' 'ss'\tnumber\t(default 1)\n\t\tglobal\nThe minimal number of columns to scroll horizontally.  Used only when\nthe 'wrap' option is off and the cursor is moved off of the screen.\nWhen it is zero the cursor will be put in the middle of the screen.\nWhen using a slow terminal set it to a large number or 0.  Not used\nfor \"zh\" and \"zl\" commands."}}, sidescrolloff = {binding = "sidescrolloff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sidescrolloff' 'siso'\tnumber\t(default 0)\n\t\tglobal or local to window |global-local|\nThe minimal number of screen columns to keep to the left and to the\nright of the cursor if 'nowrap' is set.  Setting this option to a\nvalue greater than 0 while having |'sidescroll'| also at a non-zero\nvalue makes some context visible in the line you are scrolling in\nhorizontally (except at beginning of the line).  Setting this option\nto a large value (like 999) has the effect of keeping the cursor\nhorizontally centered in the window, as long as one does not come too\nclose to the beginning of the line.\nAfter using the local value, go back the global value with one of\nthese two: >vim\n\tsetlocal sidescrolloff<\n\tsetlocal sidescrolloff=-1\n<\nExample: Try this together with 'sidescroll' and 'listchars' as\n\t in the following example to never allow the cursor to move\n\t onto the \"extends\" character: >vim\n\n\t set nowrap sidescroll=1 listchars=extends:>,precedes:<\n\t set sidescrolloff=1\n<"}}, signcolumn = {binding = "signcolumn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'signcolumn' 'scl'\tstring\t(default \"auto\")\n\t\tlocal to window\nWhen and how to draw the signcolumn. Valid values are:\n   \"auto\"\tonly when there is a sign to display\n   \"auto:[1-9]\" resize to accommodate multiple signs up to the\n                given number (maximum 9), e.g. \"auto:4\"\n   \"auto:[1-8]-[2-9]\"\n                resize to accommodate multiple signs up to the\n\t\tgiven maximum number (maximum 9) while keeping\n\t\tat least the given minimum (maximum 8) fixed\n\t\tspace. The minimum number should always be less\n\t\tthan the maximum number, e.g. \"auto:2-5\"\n   \"no\"\t\tnever\n   \"yes\"\talways\n   \"yes:[1-9]\"  always, with fixed space for signs up to the given\n                number (maximum 9), e.g. \"yes:3\"\n   \"number\"\tdisplay signs in the 'number' column. If the number\n\t\tcolumn is not present, then behaves like \"auto\"."}}, siso = {binding = "siso", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sidescrolloff' 'siso'\tnumber\t(default 0)\n\t\tglobal or local to window |global-local|\nThe minimal number of screen columns to keep to the left and to the\nright of the cursor if 'nowrap' is set.  Setting this option to a\nvalue greater than 0 while having |'sidescroll'| also at a non-zero\nvalue makes some context visible in the line you are scrolling in\nhorizontally (except at beginning of the line).  Setting this option\nto a large value (like 999) has the effect of keeping the cursor\nhorizontally centered in the window, as long as one does not come too\nclose to the beginning of the line.\nAfter using the local value, go back the global value with one of\nthese two: >vim\n\tsetlocal sidescrolloff<\n\tsetlocal sidescrolloff=-1\n<\nExample: Try this together with 'sidescroll' and 'listchars' as\n\t in the following example to never allow the cursor to move\n\t onto the \"extends\" character: >vim\n\n\t set nowrap sidescroll=1 listchars=extends:>,precedes:<\n\t set sidescrolloff=1\n<"}}, sj = {binding = "sj", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrolljump' 'sj'\tnumber\t(default 1)\n\t\tglobal\nMinimal number of lines to scroll when the cursor gets off the\nscreen (e.g., with \"j\").  Not used for scroll commands (e.g., CTRL-E,\nCTRL-D).  Useful if your terminal scrolls very slowly.\nWhen set to a negative number from -1 to -100 this is used as the\npercentage of the window height.  Thus -50 scrolls half the window\nheight."}}, slm = {binding = "slm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'selectmode' 'slm'\tstring\t(default \"\")\n\t\tglobal\nThis is a comma-separated list of words, which specifies when to start\nSelect mode instead of Visual mode, when a selection is started.\nPossible values:\n   mouse\twhen using the mouse\n   key\t\twhen using shifted special keys\n   cmd\t\twhen using \"v\", \"V\" or CTRL-V\nSee |Select-mode|."}}, sloc = {binding = "sloc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showcmdloc' 'sloc'\tstring\t(default \"last\")\n\t\tglobal\nThis option can be used to display the (partially) entered command in\nanother location.  Possible values are:\n  last\t\tLast line of the screen (default).\n  statusline\tStatus line of the current window.\n  tabline\tFirst line of the screen if 'showtabline' is enabled.\nSetting this option to \"statusline\" or \"tabline\" means that these will\nbe redrawn whenever the command changes, which can be on every key\npressed.\nThe %S 'statusline' item can be used in 'statusline' or 'tabline' to\nplace the text.  Without a custom 'statusline' or 'tabline' it will be\ndisplayed in a convenient location."}}, sm = {binding = "sm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmatch' 'sm'\tboolean\t(default off)\n\t\tglobal\nWhen a bracket is inserted, briefly jump to the matching one.  The\njump is only done if the match can be seen on the screen.  The time to\nshow the match can be set with 'matchtime'.\nA Beep is given if there is no match (no matter if the match can be\nseen or not).\nWhen the 'm' flag is not included in 'cpoptions', typing a character\nwill immediately move the cursor back to where it belongs.\nSee the \"sm\" field in 'guicursor' for setting the cursor shape and\nblinking when showing the match.\nThe 'matchpairs' option can be used to specify the characters to show\nmatches for.  'rightleft' and 'revins' are used to look for opposite\nmatches.\nAlso see the matchparen plugin for highlighting the match when moving\naround |pi_paren.txt|.\nNote: Use of the short form is rated PG."}}, smartcase = {binding = "smartcase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartcase' 'scs'\tboolean\t(default off)\n\t\tglobal\nOverride the 'ignorecase' option if the search pattern contains upper\ncase characters.  Only used when the search pattern is typed and\n'ignorecase' option is on.  Used for the commands \"/\", \"?\", \"n\", \"N\",\n\":g\" and \":s\".  Not used for \"*\", \"#\", \"gd\", tag search, etc.  After\n\"*\" and \"#\" you can make 'smartcase' used by doing a \"/\" command,\nrecalling the search pattern from history and hitting <Enter>."}}, smartindent = {binding = "smartindent", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smartindent' 'si'\tboolean\t(default off)\n\t\tlocal to buffer\nDo smart autoindenting when starting a new line.  Works for C-like\nprograms, but can also be used for other languages.  'cindent' does\nsomething like this, works better in most cases, but is more strict,\nsee |C-indenting|.  When 'cindent' is on or 'indentexpr' is set,\nsetting 'si' has no effect.  'indentexpr' is a more advanced\nalternative.\nNormally 'autoindent' should also be on when using 'smartindent'.\nAn indent is automatically inserted:\n- After a line ending in \"{\".\n- After a line starting with a keyword from 'cinwords'.\n- Before a line starting with \"}\" (only with the \"O\" command).\nWhen typing '}' as the first character in a new line, that line is\ngiven the same indent as the matching \"{\".\nWhen typing '#' as the first character in a new line, the indent for\nthat line is removed, the '#' is put in the first column.  The indent\nis restored for the next line.  If you don't want this, use this\nmapping: \":inoremap # X^H#\", where ^H is entered with CTRL-V CTRL-H.\nWhen using the \">>\" command, lines starting with '#' are not shifted\nright."}}, smarttab = {binding = "smarttab", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smarttab' 'sta'\tboolean\t(default on)\n\t\tglobal\nWhen on, a <Tab> in front of a line inserts blanks according to\n'shiftwidth'.  'tabstop' or 'softtabstop' is used in other places.  A\n<BS> will delete a 'shiftwidth' worth of space at the start of the\nline.\nWhen off, a <Tab> always inserts blanks according to 'tabstop' or\n'softtabstop'.  'shiftwidth' is only used for shifting text left or\nright |shift-left-right|.\nWhat gets inserted (a <Tab> or spaces) depends on the 'expandtab'\noption.  Also see |ins-expandtab|.  When 'expandtab' is not set, the\nnumber of spaces is minimized by using <Tab>s."}}, smc = {binding = "smc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'synmaxcol' 'smc'\tnumber\t(default 3000)\n\t\tlocal to buffer\nMaximum column in which to search for syntax items.  In long lines the\ntext after this column is not highlighted and following lines may not\nbe highlighted correctly, because the syntax state is cleared.\nThis helps to avoid very slow redrawing for an XML file that is one\nlong line.\nSet to zero to remove the limit."}}, smd = {binding = "smd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showmode' 'smd'\tboolean\t(default on)\n\t\tglobal\nIf in Insert, Replace or Visual mode put a message on the last line.\nThe |hl-ModeMsg| highlight group determines the highlighting.\nThe option has no effect when 'cmdheight' is zero."}}, smoothscroll = {binding = "smoothscroll", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smoothscroll' 'sms'\tboolean\t(default off)\n\t\tlocal to window\nScrolling works with screen lines.  When 'wrap' is set and the first\nline in the window wraps part of it may not be visible, as if it is\nabove the window. \"<<<\" is displayed at the start of the first line,\nhighlighted with |hl-NonText|.\nYou may also want to add \"lastline\" to the 'display' option to show as\nmuch of the last line as possible.\nNOTE: partly implemented, doesn't work yet for |gj| and |gk|."}}, sms = {binding = "sms", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smoothscroll' 'sms'\tboolean\t(default off)\n\t\tlocal to window\nScrolling works with screen lines.  When 'wrap' is set and the first\nline in the window wraps part of it may not be visible, as if it is\nabove the window. \"<<<\" is displayed at the start of the first line,\nhighlighted with |hl-NonText|.\nYou may also want to add \"lastline\" to the 'display' option to show as\nmuch of the last line as possible.\nNOTE: partly implemented, doesn't work yet for |gj| and |gk|."}}, so = {binding = "so", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'scrolloff' 'so'\tnumber\t(default 0)\n\t\tglobal or local to window |global-local|\nMinimal number of screen lines to keep above and below the cursor.\nThis will make some context visible around where you are working.  If\nyou set it to a very large value (999) the cursor line will always be\nin the middle of the window (except at the start or end of the file or\nwhen long lines wrap).\nAfter using the local value, go back the global value with one of\nthese two: >vim\n\tsetlocal scrolloff<\n\tsetlocal scrolloff=-1\n<\tFor scrolling horizontally see 'sidescrolloff'."}}, softtabstop = {binding = "softtabstop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'softtabstop' 'sts'\tnumber\t(default 0)\n\t\tlocal to buffer\nNumber of spaces that a <Tab> counts for while performing editing\noperations, like inserting a <Tab> or using <BS>.  It \"feels\" like\n<Tab>s are being inserted, while in fact a mix of spaces and <Tab>s is\nused.  This is useful to keep the 'ts' setting at its standard value\nof 8, while being able to edit like it is set to 'sts'.  However,\ncommands like \"x\" still work on the actual characters.\nWhen 'sts' is zero, this feature is off.\nWhen 'sts' is negative, the value of 'shiftwidth' is used.\nSee also |ins-expandtab|.  When 'expandtab' is not set, the number of\nspaces is minimized by using <Tab>s.\nThe 'L' flag in 'cpoptions' changes how tabs are used when 'list' is\nset.\n\nThe value of 'softtabstop' will be ignored if |'varsofttabstop'| is set\nto anything other than an empty string."}}, sol = {binding = "sol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'startofline' 'sol'\tboolean\t(default off)\n\t\tglobal\nWhen \"on\" the commands listed below move the cursor to the first\nnon-blank of the line.  When off the cursor is kept in the same column\n(if possible).  This applies to the commands:\n- CTRL-D, CTRL-U, CTRL-B, CTRL-F, \"G\", \"H\", \"M\", \"L\", \"gg\"\n- \"d\", \"<<\", \"==\" and \">>\" with a linewise operator\n  (|operator-resulting-pos|)\n- \"%\" with a count\n- buffer changing commands (CTRL-^, :bnext, :bNext, etc.)\n- Ex commands that only have a line number, e.g., \":25\" or \":+\".\nIn case of buffer changing commands the cursor is placed at the column\nwhere it was the last time the buffer was edited."}}, sp = {binding = "sp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellpipe' 'sp'\tstring\t(default \">\", \"| tee\", \"|& tee\" or \"2>&1| tee\")\n\t\tglobal\nString to be used to put the output of the \":make\" command in the\nerror file.  See also |:make_makeprg|.  See |option-backslash| about\nincluding spaces and backslashes.\nThe name of the temporary file can be represented by \"%s\" if necessary\n(the file name is appended automatically if no %s appears in the value\nof this option).\nFor MS-Windows the default is \"2>&1| tee\".  The stdout and stderr are\nsaved in a file and echoed to the screen.\nFor Unix the default is \"| tee\".  The stdout of the compiler is saved\nin a file and echoed to the screen.  If the 'shell' option is \"csh\" or\n\"tcsh\" after initializations, the default becomes \"|& tee\".  If the\n'shell' option is \"sh\", \"ksh\", \"mksh\", \"pdksh\", \"zsh\", \"zsh-beta\",\n\"bash\", \"fish\", \"ash\" or \"dash\" the default becomes \"2>&1| tee\".  This\nmeans that stderr is also included.  Before using the 'shell' option a\npath is removed, thus \"/bin/sh\" uses \"sh\".\nThe initialization of this option is done after reading the vimrc\nand the other initializations, so that when the 'shell' option is set\nthere, the 'shellpipe' option changes automatically, unless it was\nexplicitly set before.\nWhen 'shellpipe' is set to an empty string, no redirection of the\n\":make\" output will be done.  This is useful if you use a 'makeprg'\nthat writes to 'makeef' by itself.  If you want no piping, but do\nwant to include the 'makeef', set 'shellpipe' to a single space.\nDon't forget to precede the space with a backslash: \":set sp=\\ \".\nIn the future pipes may be used for filtering and this option will\nbecome obsolete (at least for Unix).\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, spc = {binding = "spc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spellcapcheck' 'spc'\tstring\t(default \"[.?!]\\_[\\])'\"\\t ]\\+\")\n\t\tlocal to buffer\nPattern to locate the end of a sentence.  The following word will be\nchecked to start with a capital letter.  If not then it is highlighted\nwith SpellCap |hl-SpellCap| (unless the word is also badly spelled).\nWhen this check is not wanted make this option empty.\nOnly used when 'spell' is set.\nBe careful with special characters, see |option-backslash| about\nincluding spaces and backslashes.\nTo set this option automatically depending on the language, see\n|set-spc-auto|."}}, spell = {binding = "spell", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spell'\t\t\tboolean\t(default off)\n\t\tlocal to window\nWhen on spell checking will be done.  See |spell|.\nThe languages are specified with 'spelllang'."}}, spellcapcheck = {binding = "spellcapcheck", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spellcapcheck' 'spc'\tstring\t(default \"[.?!]\\_[\\])'\"\\t ]\\+\")\n\t\tlocal to buffer\nPattern to locate the end of a sentence.  The following word will be\nchecked to start with a capital letter.  If not then it is highlighted\nwith SpellCap |hl-SpellCap| (unless the word is also badly spelled).\nWhen this check is not wanted make this option empty.\nOnly used when 'spell' is set.\nBe careful with special characters, see |option-backslash| about\nincluding spaces and backslashes.\nTo set this option automatically depending on the language, see\n|set-spc-auto|."}}, spellfile = {binding = "spellfile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spellfile' 'spf'\tstring\t(default \"\")\n\t\tlocal to buffer\nName of the word list file where words are added for the |zg| and |zw|\ncommands.  It must end in \".{encoding}.add\".  You need to include the\npath, otherwise the file is placed in the current directory.\nThe path may include characters from 'isfname', ' ', ',', '@' and ':'.\n\t\t\t\t\t\t\t*E765*\nIt may also be a comma-separated list of names.  A count before the\n|zg| and |zw| commands can be used to access each.  This allows using\na personal word list file and a project word list file.\nWhen a word is added while this option is empty Vim will set it for\nyou: Using the first directory in 'runtimepath' that is writable.  If\nthere is no \"spell\" directory yet it will be created.  For the file\nname the first language name that appears in 'spelllang' is used,\nignoring the region.\nThe resulting \".spl\" file will be used for spell checking, it does not\nhave to appear in 'spelllang'.\nNormally one file is used for all regions, but you can add the region\nname if you want to.  However, it will then only be used when\n'spellfile' is set to it, for entries in 'spelllang' only files\nwithout region name will be found.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, spelllang = {binding = "spelllang", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spelllang' 'spl'\tstring\t(default \"en\")\n\t\tlocal to buffer\nA comma-separated list of word list names.  When the 'spell' option is\non spellchecking will be done for these languages.  Example: >vim\n\tset spelllang=en_us,nl,medical\n<\tThis means US English, Dutch and medical words are recognized.  Words\nthat are not recognized will be highlighted.\nThe word list name must consist of alphanumeric characters, a dash or\nan underscore.  It should not include a comma or dot.  Using a dash is\nrecommended to separate the two letter language name from a\nspecification.  Thus \"en-rare\" is used for rare English words.\nA region name must come last and have the form \"_xx\", where \"xx\" is\nthe two-letter, lower case region name.  You can use more than one\nregion by listing them: \"en_us,en_ca\" supports both US and Canadian\nEnglish, but not words specific for Australia, New Zealand or Great\nBritain. (Note: currently en_au and en_nz dictionaries are older than\nen_ca, en_gb and en_us).\nIf the name \"cjk\" is included East Asian characters are excluded from\nspell checking.  This is useful when editing text that also has Asian\nwords.\nNote that the \"medical\" dictionary does not exist, it is just an\nexample of a longer name.\n\t\t\t\t\t\t*E757*\nAs a special case the name of a .spl file can be given as-is.  The\nfirst \"_xx\" in the name is removed and used as the region name\n(_xx is an underscore, two letters and followed by a non-letter).\nThis is mainly for testing purposes.  You must make sure the correct\nencoding is used, Vim doesn't check it.\nHow the related spell files are found is explained here: |spell-load|.\n\nIf the |spellfile.vim| plugin is active and you use a language name\nfor which Vim cannot find the .spl file in 'runtimepath' the plugin\nwill ask you if you want to download the file.\n\nAfter this option has been set successfully, Vim will source the files\n\"spell/LANG.vim\" in 'runtimepath'.  \"LANG\" is the value of 'spelllang'\nup to the first character that is not an ASCII letter or number and\nnot a dash.  Also see |set-spc-auto|."}}, spelloptions = {binding = "spelloptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spelloptions' 'spo'\tstring\t(default \"\")\n\t\tlocal to buffer\nA comma-separated list of options for spell checking:\ncamel\t\tWhen a word is CamelCased, assume \"Cased\" is a\n\t\tseparate word: every upper-case character in a word\n\t\tthat comes after a lower case character indicates the\n\t\tstart of a new word.\nnoplainbuffer\tOnly spellcheck a buffer when 'syntax' is enabled,\n\t\tor when extmarks are set within the buffer. Only\n\t\tdesignated regions of the buffer are spellchecked in\n\t\tthis case."}}, spellsuggest = {binding = "spellsuggest", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spellsuggest' 'sps'\tstring\t(default \"best\")\n\t\tglobal\nMethods used for spelling suggestions.  Both for the |z=| command and\nthe |spellsuggest()| function.  This is a comma-separated list of\nitems:\n\nbest\t\tInternal method that works best for English.  Finds\n\t\tchanges like \"fast\" and uses a bit of sound-a-like\n\t\tscoring to improve the ordering.\n\ndouble\t\tInternal method that uses two methods and mixes the\n\t\tresults.  The first method is \"fast\", the other method\n\t\tcomputes how much the suggestion sounds like the bad\n\t\tword.  That only works when the language specifies\n\t\tsound folding.  Can be slow and doesn't always give\n\t\tbetter results.\n\nfast\t\tInternal method that only checks for simple changes:\n\t\tcharacter inserts/deletes/swaps.  Works well for\n\t\tsimple typing mistakes.\n\n{number}\tThe maximum number of suggestions listed for |z=|.\n\t\tNot used for |spellsuggest()|.  The number of\n\t\tsuggestions is never more than the value of 'lines'\n\t\tminus two.\n\ntimeout:{millisec}   Limit the time searching for suggestions to\n\t\t{millisec} milliseconds.  Applies to the following\n\t\tmethods.  When omitted the limit is 5000. When\n\t\tnegative there is no limit.\n\nfile:{filename} Read file {filename}, which must have two columns,\n\t\tseparated by a slash.  The first column contains the\n\t\tbad word, the second column the suggested good word.\n\t\tExample:\n\t\t\ttheribal/terrible ~\n\t\tUse this for common mistakes that do not appear at the\n\t\ttop of the suggestion list with the internal methods.\n\t\tLines without a slash are ignored, use this for\n\t\tcomments.\n\t\tThe word in the second column must be correct,\n\t\totherwise it will not be used.  Add the word to an\n\t\t\".add\" file if it is currently flagged as a spelling\n\t\tmistake.\n\t\tThe file is used for all languages.\n\nexpr:{expr}\tEvaluate expression {expr}.  Use a function to avoid\n\t\ttrouble with spaces.  Best is to call a function\n\t\twithout arguments, see |expr-option-function|.\n\t\t|v:val| holds the badly spelled word.  The expression\n\t\tmust evaluate to a List of Lists, each with a\n\t\tsuggestion and a score.\n\t\tExample:\n\t\t\t[['the', 33], ['that', 44]] ~\n\t\tSet 'verbose' and use |z=| to see the scores that the\n\t\tinternal methods use.  A lower score is better.\n\t\tThis may invoke |spellsuggest()| if you temporarily\n\t\tset 'spellsuggest' to exclude the \"expr:\" part.\n\t\tErrors are silently ignored, unless you set the\n\t\t'verbose' option to a non-zero value.\n\nOnly one of \"best\", \"double\" or \"fast\" may be used.  The others may\nappear several times in any order.  Example: >vim\n\tset sps=file:~/.config/nvim/sugg,best,expr:MySuggest()\n<\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, spf = {binding = "spf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spellfile' 'spf'\tstring\t(default \"\")\n\t\tlocal to buffer\nName of the word list file where words are added for the |zg| and |zw|\ncommands.  It must end in \".{encoding}.add\".  You need to include the\npath, otherwise the file is placed in the current directory.\nThe path may include characters from 'isfname', ' ', ',', '@' and ':'.\n\t\t\t\t\t\t\t*E765*\nIt may also be a comma-separated list of names.  A count before the\n|zg| and |zw| commands can be used to access each.  This allows using\na personal word list file and a project word list file.\nWhen a word is added while this option is empty Vim will set it for\nyou: Using the first directory in 'runtimepath' that is writable.  If\nthere is no \"spell\" directory yet it will be created.  For the file\nname the first language name that appears in 'spelllang' is used,\nignoring the region.\nThe resulting \".spl\" file will be used for spell checking, it does not\nhave to appear in 'spelllang'.\nNormally one file is used for all regions, but you can add the region\nname if you want to.  However, it will then only be used when\n'spellfile' is set to it, for entries in 'spelllang' only files\nwithout region name will be found.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, spk = {binding = "spk", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitkeep' 'spk'\tstring\t(default \"cursor\")\n\t\tglobal\nThe value of this option determines the scroll behavior when opening,\nclosing or resizing horizontal splits.\n\nPossible values are:\n  cursor\tKeep the same relative cursor position.\n  screen\tKeep the text on the same screen line.\n  topline\tKeep the topline the same.\n\nFor the \"screen\" and \"topline\" values, the cursor position will be\nchanged when necessary. In this case, the jumplist will be populated\nwith the previous cursor position. For \"screen\", the text cannot always\nbe kept on the same screen line when 'wrap' is enabled."}}, spl = {binding = "spl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spelllang' 'spl'\tstring\t(default \"en\")\n\t\tlocal to buffer\nA comma-separated list of word list names.  When the 'spell' option is\non spellchecking will be done for these languages.  Example: >vim\n\tset spelllang=en_us,nl,medical\n<\tThis means US English, Dutch and medical words are recognized.  Words\nthat are not recognized will be highlighted.\nThe word list name must consist of alphanumeric characters, a dash or\nan underscore.  It should not include a comma or dot.  Using a dash is\nrecommended to separate the two letter language name from a\nspecification.  Thus \"en-rare\" is used for rare English words.\nA region name must come last and have the form \"_xx\", where \"xx\" is\nthe two-letter, lower case region name.  You can use more than one\nregion by listing them: \"en_us,en_ca\" supports both US and Canadian\nEnglish, but not words specific for Australia, New Zealand or Great\nBritain. (Note: currently en_au and en_nz dictionaries are older than\nen_ca, en_gb and en_us).\nIf the name \"cjk\" is included East Asian characters are excluded from\nspell checking.  This is useful when editing text that also has Asian\nwords.\nNote that the \"medical\" dictionary does not exist, it is just an\nexample of a longer name.\n\t\t\t\t\t\t*E757*\nAs a special case the name of a .spl file can be given as-is.  The\nfirst \"_xx\" in the name is removed and used as the region name\n(_xx is an underscore, two letters and followed by a non-letter).\nThis is mainly for testing purposes.  You must make sure the correct\nencoding is used, Vim doesn't check it.\nHow the related spell files are found is explained here: |spell-load|.\n\nIf the |spellfile.vim| plugin is active and you use a language name\nfor which Vim cannot find the .spl file in 'runtimepath' the plugin\nwill ask you if you want to download the file.\n\nAfter this option has been set successfully, Vim will source the files\n\"spell/LANG.vim\" in 'runtimepath'.  \"LANG\" is the value of 'spelllang'\nup to the first character that is not an ASCII letter or number and\nnot a dash.  Also see |set-spc-auto|."}}, splitbelow = {binding = "splitbelow", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitbelow' 'sb'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window below the current\none. |:split|"}}, splitkeep = {binding = "splitkeep", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitkeep' 'spk'\tstring\t(default \"cursor\")\n\t\tglobal\nThe value of this option determines the scroll behavior when opening,\nclosing or resizing horizontal splits.\n\nPossible values are:\n  cursor\tKeep the same relative cursor position.\n  screen\tKeep the text on the same screen line.\n  topline\tKeep the topline the same.\n\nFor the \"screen\" and \"topline\" values, the cursor position will be\nchanged when necessary. In this case, the jumplist will be populated\nwith the previous cursor position. For \"screen\", the text cannot always\nbe kept on the same screen line when 'wrap' is enabled."}}, splitright = {binding = "splitright", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitright' 'spr'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window right of the\ncurrent one. |:vsplit|"}}, spo = {binding = "spo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spelloptions' 'spo'\tstring\t(default \"\")\n\t\tlocal to buffer\nA comma-separated list of options for spell checking:\ncamel\t\tWhen a word is CamelCased, assume \"Cased\" is a\n\t\tseparate word: every upper-case character in a word\n\t\tthat comes after a lower case character indicates the\n\t\tstart of a new word.\nnoplainbuffer\tOnly spellcheck a buffer when 'syntax' is enabled,\n\t\tor when extmarks are set within the buffer. Only\n\t\tdesignated regions of the buffer are spellchecked in\n\t\tthis case."}}, spr = {binding = "spr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'splitright' 'spr'\tboolean\t(default off)\n\t\tglobal\nWhen on, splitting a window will put the new window right of the\ncurrent one. |:vsplit|"}}, sps = {binding = "sps", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'spellsuggest' 'sps'\tstring\t(default \"best\")\n\t\tglobal\nMethods used for spelling suggestions.  Both for the |z=| command and\nthe |spellsuggest()| function.  This is a comma-separated list of\nitems:\n\nbest\t\tInternal method that works best for English.  Finds\n\t\tchanges like \"fast\" and uses a bit of sound-a-like\n\t\tscoring to improve the ordering.\n\ndouble\t\tInternal method that uses two methods and mixes the\n\t\tresults.  The first method is \"fast\", the other method\n\t\tcomputes how much the suggestion sounds like the bad\n\t\tword.  That only works when the language specifies\n\t\tsound folding.  Can be slow and doesn't always give\n\t\tbetter results.\n\nfast\t\tInternal method that only checks for simple changes:\n\t\tcharacter inserts/deletes/swaps.  Works well for\n\t\tsimple typing mistakes.\n\n{number}\tThe maximum number of suggestions listed for |z=|.\n\t\tNot used for |spellsuggest()|.  The number of\n\t\tsuggestions is never more than the value of 'lines'\n\t\tminus two.\n\ntimeout:{millisec}   Limit the time searching for suggestions to\n\t\t{millisec} milliseconds.  Applies to the following\n\t\tmethods.  When omitted the limit is 5000. When\n\t\tnegative there is no limit.\n\nfile:{filename} Read file {filename}, which must have two columns,\n\t\tseparated by a slash.  The first column contains the\n\t\tbad word, the second column the suggested good word.\n\t\tExample:\n\t\t\ttheribal/terrible ~\n\t\tUse this for common mistakes that do not appear at the\n\t\ttop of the suggestion list with the internal methods.\n\t\tLines without a slash are ignored, use this for\n\t\tcomments.\n\t\tThe word in the second column must be correct,\n\t\totherwise it will not be used.  Add the word to an\n\t\t\".add\" file if it is currently flagged as a spelling\n\t\tmistake.\n\t\tThe file is used for all languages.\n\nexpr:{expr}\tEvaluate expression {expr}.  Use a function to avoid\n\t\ttrouble with spaces.  Best is to call a function\n\t\twithout arguments, see |expr-option-function|.\n\t\t|v:val| holds the badly spelled word.  The expression\n\t\tmust evaluate to a List of Lists, each with a\n\t\tsuggestion and a score.\n\t\tExample:\n\t\t\t[['the', 33], ['that', 44]] ~\n\t\tSet 'verbose' and use |z=| to see the scores that the\n\t\tinternal methods use.  A lower score is better.\n\t\tThis may invoke |spellsuggest()| if you temporarily\n\t\tset 'spellsuggest' to exclude the \"expr:\" part.\n\t\tErrors are silently ignored, unless you set the\n\t\t'verbose' option to a non-zero value.\n\nOnly one of \"best\", \"double\" or \"fast\" may be used.  The others may\nappear several times in any order.  Example: >vim\n\tset sps=file:~/.config/nvim/sugg,best,expr:MySuggest()\n<\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, sr = {binding = "sr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shiftround' 'sr'\tboolean\t(default off)\n\t\tglobal\nRound indent to multiple of 'shiftwidth'.  Applies to > and <\ncommands.  CTRL-T and CTRL-D in Insert mode always round the indent to\na multiple of 'shiftwidth' (this is Vi compatible)."}}, srr = {binding = "srr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellredir' 'srr'\tstring\t(default \">\", \">&\" or \">%s 2>&1\")\n\t\tglobal\nString to be used to put the output of a filter command in a temporary\nfile.  See also |:!|.  See |option-backslash| about including spaces\nand backslashes.\nThe name of the temporary file can be represented by \"%s\" if necessary\n(the file name is appended automatically if no %s appears in the value\nof this option).\nThe default is \">\".  For Unix, if the 'shell' option is \"csh\" or\n\"tcsh\" during initializations, the default becomes \">&\".  If the\n'shell' option is \"sh\", \"ksh\", \"mksh\", \"pdksh\", \"zsh\", \"zsh-beta\",\n\"bash\" or \"fish\", the default becomes \">%s 2>&1\".  This means that\nstderr is also included.  For Win32, the Unix checks are done and\nadditionally \"cmd\" is checked for, which makes the default \">%s 2>&1\".\nAlso, the same names with \".exe\" appended are checked for.\nThe initialization of this option is done after reading the vimrc\nand the other initializations, so that when the 'shell' option is set\nthere, the 'shellredir' option changes automatically unless it was\nexplicitly set before.\nIn the future pipes may be used for filtering and this option will\nbecome obsolete (at least for Unix).\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ss = {binding = "ss", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sidescroll' 'ss'\tnumber\t(default 1)\n\t\tglobal\nThe minimal number of columns to scroll horizontally.  Used only when\nthe 'wrap' option is off and the cursor is moved off of the screen.\nWhen it is zero the cursor will be put in the middle of the screen.\nWhen using a slow terminal set it to a large number or 0.  Not used\nfor \"zh\" and \"zl\" commands."}}, ssl = {binding = "ssl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellslash' 'ssl'\tboolean\t(default on, Windows: off)\n\t\tglobal\n\t\tonly modifiable in MS-Windows\nWhen set, a forward slash is used when expanding file names.  This is\nuseful when a Unix-like shell is used instead of cmd.exe.  Backward\nslashes can still be typed, but they are changed to forward slashes by\nVim.\nNote that setting or resetting this option has no effect for some\nexisting file names, thus this option needs to be set before opening\nany file for best results.  This might change in the future.\n'shellslash' only works when a backslash can be used as a path\nseparator.  To test if this is so use: >vim\n\tif exists('+shellslash')\n<\tAlso see 'completeslash'."}}, ssop = {binding = "ssop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'sessionoptions' 'ssop'\tstring\t(default \"blank,buffers,curdir,folds,help,tabpages,winsize,terminal\")\n\t\tglobal\nChanges the effect of the |:mksession| command.  It is a comma-\nseparated list of words.  Each word enables saving and restoring\nsomething:\n   word\t\tsave and restore ~\n   blank\tempty windows\n   buffers\thidden and unloaded buffers, not just those in windows\n   curdir\tthe current directory\n   folds\tmanually created folds, opened/closed folds and local\n\t\tfold options\n   globals\tglobal variables that start with an uppercase letter\n\t\tand contain at least one lowercase letter.  Only\n\t\tString and Number types are stored.\n   help\t\tthe help window\n   localoptions\toptions and mappings local to a window or buffer (not\n\t\tglobal values for local options)\n   options\tall options and mappings (also global values for local\n\t\toptions)\n   skiprtp\texclude 'runtimepath' and 'packpath' from the options\n   resize\tsize of the Vim window: 'lines' and 'columns'\n   sesdir\tthe directory in which the session file is located\n\t\twill become the current directory (useful with\n\t\tprojects accessed over a network from different\n\t\tsystems)\n   tabpages\tall tab pages; without this only the current tab page\n\t\tis restored, so that you can make a session for each\n\t\ttab page separately\n   terminal\tinclude terminal windows where the command can be\n\t\trestored\n   winpos\tposition of the whole Vim window\n   winsize\twindow sizes\n   slash\t|deprecated| Always enabled. Uses \"/\" in filenames.\n   unix\t\t|deprecated| Always enabled. Uses \"\\n\" line endings.\n\nDon't include both \"curdir\" and \"sesdir\". When neither is included\nfilenames are stored as absolute paths.\nIf you leave out \"options\" many things won't work well after restoring\nthe session."}}, sta = {binding = "sta", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'smarttab' 'sta'\tboolean\t(default on)\n\t\tglobal\nWhen on, a <Tab> in front of a line inserts blanks according to\n'shiftwidth'.  'tabstop' or 'softtabstop' is used in other places.  A\n<BS> will delete a 'shiftwidth' worth of space at the start of the\nline.\nWhen off, a <Tab> always inserts blanks according to 'tabstop' or\n'softtabstop'.  'shiftwidth' is only used for shifting text left or\nright |shift-left-right|.\nWhat gets inserted (a <Tab> or spaces) depends on the 'expandtab'\noption.  Also see |ins-expandtab|.  When 'expandtab' is not set, the\nnumber of spaces is minimized by using <Tab>s."}}, stal = {binding = "stal", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'showtabline' 'stal'\tnumber\t(default 1)\n\t\tglobal\nThe value of this option specifies when the line with tab page labels\nwill be displayed:\n\0090: never\n\0091: only if there are at least two tab pages\n\0092: always\nThis is both for the GUI and non-GUI implementation of the tab pages\nline.\nSee |tab-page| for more information about tab pages."}}, startofline = {binding = "startofline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'startofline' 'sol'\tboolean\t(default off)\n\t\tglobal\nWhen \"on\" the commands listed below move the cursor to the first\nnon-blank of the line.  When off the cursor is kept in the same column\n(if possible).  This applies to the commands:\n- CTRL-D, CTRL-U, CTRL-B, CTRL-F, \"G\", \"H\", \"M\", \"L\", \"gg\"\n- \"d\", \"<<\", \"==\" and \">>\" with a linewise operator\n  (|operator-resulting-pos|)\n- \"%\" with a count\n- buffer changing commands (CTRL-^, :bnext, :bNext, etc.)\n- Ex commands that only have a line number, e.g., \":25\" or \":+\".\nIn case of buffer changing commands the cursor is placed at the column\nwhere it was the last time the buffer was edited."}}, statuscolumn = {binding = "statuscolumn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'statuscolumn' 'stc'\tstring\t(default \"\")\n\t\tlocal to window\nWhen non-empty, this option determines the content of the area to the\nside of a window, normally containing the fold, sign and number columns.\nThe format of this option is like that of 'statusline'.\n\nSome of the items from the 'statusline' format are different for\n'statuscolumn':\n\n%l\tline number column for currently drawn line\n%s\tsign column for currently drawn line\n%C\tfold column for currently drawn line\n\nThe 'statuscolumn' width follows that of the default columns and\nadapts to the |'numberwidth'|, |'signcolumn'| and |'foldcolumn'| option\nvalues (regardless of whether the sign and fold items are present).\nAdditionally, the 'statuscolumn' grows with the size of the evaluated\nformat string, up to a point (following the maximum size of the default\nfold, sign and number columns). Shrinking only happens when the number\nof lines in a buffer changes, or the 'statuscolumn' option is set.\n\nThe |v:lnum|    variable holds the line number to be drawn.\nThe |v:relnum|  variable holds the relative line number to be drawn.\nThe |v:virtnum| variable is negative when drawing virtual lines, zero\n\t      when drawing the actual buffer line, and positive when\n\t      drawing the wrapped part of a buffer line.\n\nWhen using |v:relnum|, keep in mind that cursor movement by itself will\nnot cause the 'statuscolumn' to update unless |'relativenumber'| is set.\n\nNOTE: The %@ click execute function item is supported as well but the\nspecified function will be the same for each row in the same column.\nIt cannot be switched out through a dynamic 'statuscolumn' format, the\nhandler should be written with this in mind.\n\nExamples: >vim\n\t\" Line number with bar separator and click handlers:\n\tset statuscolumn=%@SignCb@%s%=%T%@NumCb@%l\226\148\130%T\n\n\t\" Line numbers in hexadecimal for non wrapped part of lines:\n\tlet &stc='%=%{v:virtnum>0?\"\":printf(\"%x\",v:lnum)} '\n\n\t\" Human readable line numbers with thousands separator:\n\tlet &stc='%{substitute(v:lnum,\"\\\\d\\\\zs\\\\ze\\\\'\n\t\t   . '%(\\\\d\\\\d\\\\d\\\\)\\\\+$\",\",\",\"g\")}'\n\n\t\" Both relative and absolute line numbers with different\n\t\" highlighting for odd and even relative numbers:\n\tlet &stc='%#NonText#%{&nu?v:lnum:\"\"}' .\n\t '%=%{&rnu&&(v:lnum%2)?\"\\ \".v:relnum:\"\"}' .\n\t '%#LineNr#%{&rnu&&!(v:lnum%2)?\"\\ \".v:relnum:\"\"}'\n\n<\tWARNING: this expression is evaluated for each screen line so defining\nan expensive expression can negatively affect render performance."}}, statusline = {binding = "statusline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'statusline' 'stl'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nSets the |status-line|.\n\nThe option consists of printf style '%' items interspersed with\nnormal text.  Each status line item is of the form:\n  %-0{minwid}.{maxwid}{item}\nAll fields except the {item} are optional.  A single percent sign can\nbe given as \"%%\".\n\n\t\t\t\t\t\t*stl-%!*\nWhen the option starts with \"%!\" then it is used as an expression,\nevaluated and the result is used as the option value.  Example: >vim\n\tset statusline=%!MyStatusLine()\n<\tThe *g:statusline_winid* variable will be set to the |window-ID| of the\nwindow that the status line belongs to.\nThe result can contain %{} items that will be evaluated too.\nNote that the \"%!\" expression is evaluated in the context of the\ncurrent window and buffer, while %{} items are evaluated in the\ncontext of the window that the statusline belongs to.\n\nWhen there is error while evaluating the option then it will be made\nempty to avoid further errors.  Otherwise screen updating would loop.\nWhen the result contains unprintable characters the result is\nunpredictable.\n\nNote that the only effect of 'ruler' when this option is set (and\n'laststatus' is 2 or 3) is controlling the output of |CTRL-G|.\n\nfield\t    meaning ~\n-\t    Left justify the item.  The default is right justified\n\t    when minwid is larger than the length of the item.\n0\t    Leading zeroes in numeric items.  Overridden by \"-\".\nminwid\t    Minimum width of the item, padding as set by \"-\" & \"0\".\n\t    Value must be 50 or less.\nmaxwid\t    Maximum width of the item.  Truncation occurs with a \"<\"\n\t    on the left for text items.  Numeric items will be\n\t    shifted down to maxwid-2 digits followed by \">\"number\n\t    where number is the amount of missing digits, much like\n\t    an exponential notation.\nitem\t    A one letter code as described below.\n\nFollowing is a description of the possible statusline items.  The\nsecond character in \"item\" is the type:\n\tN for number\n\tS for string\n\tF for flags as described below\n\t- not applicable\n\nitem  meaning ~\nf S   Path to the file in the buffer, as typed or relative to current\n      directory.\nF S   Full path to the file in the buffer.\nt S   File name (tail) of file in the buffer.\nm F   Modified flag, text is \"[+]\"; \"[-]\" if 'modifiable' is off.\nM F   Modified flag, text is \",+\" or \",-\".\nr F   Readonly flag, text is \"[RO]\".\nR F   Readonly flag, text is \",RO\".\nh F   Help buffer flag, text is \"[help]\".\nH F   Help buffer flag, text is \",HLP\".\nw F   Preview window flag, text is \"[Preview]\".\nW F   Preview window flag, text is \",PRV\".\ny F   Type of file in the buffer, e.g., \"[vim]\".  See 'filetype'.\nY F   Type of file in the buffer, e.g., \",VIM\".  See 'filetype'.\nq S   \"[Quickfix List]\", \"[Location List]\" or empty.\nk S   Value of \"b:keymap_name\" or 'keymap' when |:lmap| mappings are\n      being used: \"<keymap>\"\nn N   Buffer number.\nb N   Value of character under cursor.\nB N   As above, in hexadecimal.\no N   Byte number in file of byte under cursor, first byte is 1.\n      Mnemonic: Offset from start of file (with one added)\nO N   As above, in hexadecimal.\nl N   Line number.\nL N   Number of lines in buffer.\nc N   Column number (byte index).\nv N   Virtual column number (screen column).\nV N   Virtual column number as -{num}.  Not displayed if equal to 'c'.\np N   Percentage through file in lines as in |CTRL-G|.\nP S   Percentage through file of displayed window.  This is like the\n      percentage described for 'ruler'.  Always 3 in length, unless\n      translated.\nS S   'showcmd' content, see 'showcmdloc'.\na S   Argument list status as in default title.  ({current} of {max})\n      Empty if the argument file count is zero or one.\n{ NF  Evaluate expression between \"%{\" and \"}\" and substitute result.\n      Note that there is no \"%\" before the closing \"}\".  The\n      expression cannot contain a \"}\" character, call a function to\n      work around that.  See |stl-%{| below.\n`{%` -  This is almost same as \"{\" except the result of the expression is\n      re-evaluated as a statusline format string.  Thus if the\n      return value of expr contains \"%\" items they will get expanded.\n      The expression can contain the \"}\" character, the end of\n      expression is denoted by \"%}\".\n      For example: >vim\n\tfunc! Stl_filename() abort\n\t    return \"%t\"\n\tendfunc\n<\t        `stl=%{Stl_filename()}`   results in `\"%t\"`\n        `stl=%{%Stl_filename()%}` results in `\"Name of current file\"`\n%} -  End of \"{%\" expression\n( -   Start of item group.  Can be used for setting the width and\n      alignment of a section.  Must be followed by %) somewhere.\n) -   End of item group.  No width fields allowed.\nT N   For 'tabline': start of tab page N label.  Use %T or %X to end\n      the label.  Clicking this label with left mouse button switches\n      to the specified tab page, while clicking it with middle mouse\n      button closes the specified tab page.\nX N   For 'tabline': start of close tab N label.  Use %X or %T to end\n      the label, e.g.: %3Xclose%X.  Use %999X for a \"close current\n      tab\" label.  Clicking this label with left mouse button closes\n      the specified tab page.\n@ N   Start of execute function label. Use %X or %T to end the label,\n      e.g.: %10@SwitchBuffer@foo.c%X.  Clicking this label runs the\n      specified function: in the example when clicking once using left\n      mouse button on \"foo.c\", a `SwitchBuffer(10, 1, 'l', '    ')`\n      expression will be run.  The specified function receives the\n      following arguments in order:\n      1. minwid field value or zero if no N was specified\n      2. number of mouse clicks to detect multiple clicks\n      3. mouse button used: \"l\", \"r\" or \"m\" for left, right or middle\n         button respectively; one should not rely on third argument\n         being only \"l\", \"r\" or \"m\": any other non-empty string value\n         that contains only ASCII lower case letters may be expected\n         for other mouse buttons\n      4. modifiers pressed: string which contains \"s\" if shift\n         modifier was pressed, \"c\" for control, \"a\" for alt and \"m\"\n         for meta; currently if modifier is not pressed string\n         contains space instead, but one should not rely on presence\n         of spaces or specific order of modifiers: use |stridx()| to\n         test whether some modifier is present; string is guaranteed\n         to contain only ASCII letters and spaces, one letter per\n         modifier; \"?\" modifier may also be present, but its presence\n         is a bug that denotes that new mouse button recognition was\n         added without modifying code that reacts on mouse clicks on\n         this label.\n      Use |getmousepos()|.winid in the specified function to get the\n      corresponding window id of the clicked item.\n< -   Where to truncate line if too long.  Default is at the start.\n      No width fields allowed.\n= -   Separation point between alignment sections.  Each section will\n      be separated by an equal number of spaces.  With one %= what\n      comes after it will be right-aligned.  With two %= there is a\n      middle part, with white space left and right of it.\n      No width fields allowed.\n# -   Set highlight group.  The name must follow and then a # again.\n      Thus use %#HLname# for highlight group HLname.  The same\n      highlighting is used, also for the statusline of non-current\n      windows.\n* -   Set highlight group to User{N}, where {N} is taken from the\n      minwid field, e.g. %1*.  Restore normal highlight with %* or %0*.\n      The difference between User{N} and StatusLine will be applied to\n      StatusLineNC for the statusline of non-current windows.\n      The number N must be between 1 and 9.  See |hl-User1..9|\n\nWhen displaying a flag, Vim removes the leading comma, if any, when\nthat flag comes right after plaintext.  This will make a nice display\nwhen flags are used like in the examples below.\n\nWhen all items in a group becomes an empty string (i.e. flags that are\nnot set) and a minwid is not set for the group, the whole group will\nbecome empty.  This will make a group like the following disappear\ncompletely from the statusline when none of the flags are set. >vim\n\tset statusline=...%(\\ [%M%R%H]%)...\n<\tBeware that an expression is evaluated each and every time the status\nline is displayed.\n\t\t\t*stl-%{* *g:actual_curbuf* *g:actual_curwin*\nWhile evaluating %{} the current buffer and current window will be set\ntemporarily to that of the window (and buffer) whose statusline is\ncurrently being drawn.  The expression will evaluate in this context.\nThe variable \"g:actual_curbuf\" is set to the `bufnr()` number of the\nreal current buffer and \"g:actual_curwin\" to the |window-ID| of the\nreal current window.  These values are strings.\n\nThe 'statusline' option will be evaluated in the |sandbox| if set from\na modeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'statusline' |textlock|.\n\nIf the statusline is not updated when you want it (e.g., after setting\na variable that's used in an expression), you can force an update by\nusing `:redrawstatus`.\n\nA result of all digits is regarded a number for display purposes.\nOtherwise the result is taken as flag text and applied to the rules\ndescribed above.\n\nWatch out for errors in expressions.  They may render Vim unusable!\nIf you are stuck, hold down ':' or 'Q' to get a prompt, then quit and\nedit your vimrc or whatever with \"vim --clean\" to get it right.\n\nExamples:\nEmulate standard status line with 'ruler' set >vim\n  set statusline=%<%f\\ %h%w%m%r%=%-14.(%l,%c%V%)\\ %P\n<\tSimilar, but add ASCII value of char under the cursor (like \"ga\") >vim\n  set statusline=%<%f%h%m%r%=%b\\ 0x%B\\ \\ %l,%c%V\\ %P\n<\tDisplay byte count and byte value, modified flag in red. >vim\n  set statusline=%<%f%=\\ [%1*%M%*%n%R%H]\\ %-19(%3l,%02c%03V%)%O'%02b'\n  hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red\n<\tDisplay a ,GZ flag if a compressed file is loaded >vim\n  set statusline=...%r%{VarExists('b:gzflag','\\ [GZ]')}%h...\n<\tIn the |:autocmd|'s: >vim\n  let b:gzflag = 1\n<\tAnd: >vim\n  unlet b:gzflag\n<\tAnd define this function: >vim\n  function VarExists(var, val)\n      if exists(a:var) | return a:val | else | return '' | endif\n  endfunction\n<"}}, stc = {binding = "stc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'statuscolumn' 'stc'\tstring\t(default \"\")\n\t\tlocal to window\nWhen non-empty, this option determines the content of the area to the\nside of a window, normally containing the fold, sign and number columns.\nThe format of this option is like that of 'statusline'.\n\nSome of the items from the 'statusline' format are different for\n'statuscolumn':\n\n%l\tline number column for currently drawn line\n%s\tsign column for currently drawn line\n%C\tfold column for currently drawn line\n\nThe 'statuscolumn' width follows that of the default columns and\nadapts to the |'numberwidth'|, |'signcolumn'| and |'foldcolumn'| option\nvalues (regardless of whether the sign and fold items are present).\nAdditionally, the 'statuscolumn' grows with the size of the evaluated\nformat string, up to a point (following the maximum size of the default\nfold, sign and number columns). Shrinking only happens when the number\nof lines in a buffer changes, or the 'statuscolumn' option is set.\n\nThe |v:lnum|    variable holds the line number to be drawn.\nThe |v:relnum|  variable holds the relative line number to be drawn.\nThe |v:virtnum| variable is negative when drawing virtual lines, zero\n\t      when drawing the actual buffer line, and positive when\n\t      drawing the wrapped part of a buffer line.\n\nWhen using |v:relnum|, keep in mind that cursor movement by itself will\nnot cause the 'statuscolumn' to update unless |'relativenumber'| is set.\n\nNOTE: The %@ click execute function item is supported as well but the\nspecified function will be the same for each row in the same column.\nIt cannot be switched out through a dynamic 'statuscolumn' format, the\nhandler should be written with this in mind.\n\nExamples: >vim\n\t\" Line number with bar separator and click handlers:\n\tset statuscolumn=%@SignCb@%s%=%T%@NumCb@%l\226\148\130%T\n\n\t\" Line numbers in hexadecimal for non wrapped part of lines:\n\tlet &stc='%=%{v:virtnum>0?\"\":printf(\"%x\",v:lnum)} '\n\n\t\" Human readable line numbers with thousands separator:\n\tlet &stc='%{substitute(v:lnum,\"\\\\d\\\\zs\\\\ze\\\\'\n\t\t   . '%(\\\\d\\\\d\\\\d\\\\)\\\\+$\",\",\",\"g\")}'\n\n\t\" Both relative and absolute line numbers with different\n\t\" highlighting for odd and even relative numbers:\n\tlet &stc='%#NonText#%{&nu?v:lnum:\"\"}' .\n\t '%=%{&rnu&&(v:lnum%2)?\"\\ \".v:relnum:\"\"}' .\n\t '%#LineNr#%{&rnu&&!(v:lnum%2)?\"\\ \".v:relnum:\"\"}'\n\n<\tWARNING: this expression is evaluated for each screen line so defining\nan expensive expression can negatively affect render performance."}}, stl = {binding = "stl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'statusline' 'stl'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nSets the |status-line|.\n\nThe option consists of printf style '%' items interspersed with\nnormal text.  Each status line item is of the form:\n  %-0{minwid}.{maxwid}{item}\nAll fields except the {item} are optional.  A single percent sign can\nbe given as \"%%\".\n\n\t\t\t\t\t\t*stl-%!*\nWhen the option starts with \"%!\" then it is used as an expression,\nevaluated and the result is used as the option value.  Example: >vim\n\tset statusline=%!MyStatusLine()\n<\tThe *g:statusline_winid* variable will be set to the |window-ID| of the\nwindow that the status line belongs to.\nThe result can contain %{} items that will be evaluated too.\nNote that the \"%!\" expression is evaluated in the context of the\ncurrent window and buffer, while %{} items are evaluated in the\ncontext of the window that the statusline belongs to.\n\nWhen there is error while evaluating the option then it will be made\nempty to avoid further errors.  Otherwise screen updating would loop.\nWhen the result contains unprintable characters the result is\nunpredictable.\n\nNote that the only effect of 'ruler' when this option is set (and\n'laststatus' is 2 or 3) is controlling the output of |CTRL-G|.\n\nfield\t    meaning ~\n-\t    Left justify the item.  The default is right justified\n\t    when minwid is larger than the length of the item.\n0\t    Leading zeroes in numeric items.  Overridden by \"-\".\nminwid\t    Minimum width of the item, padding as set by \"-\" & \"0\".\n\t    Value must be 50 or less.\nmaxwid\t    Maximum width of the item.  Truncation occurs with a \"<\"\n\t    on the left for text items.  Numeric items will be\n\t    shifted down to maxwid-2 digits followed by \">\"number\n\t    where number is the amount of missing digits, much like\n\t    an exponential notation.\nitem\t    A one letter code as described below.\n\nFollowing is a description of the possible statusline items.  The\nsecond character in \"item\" is the type:\n\tN for number\n\tS for string\n\tF for flags as described below\n\t- not applicable\n\nitem  meaning ~\nf S   Path to the file in the buffer, as typed or relative to current\n      directory.\nF S   Full path to the file in the buffer.\nt S   File name (tail) of file in the buffer.\nm F   Modified flag, text is \"[+]\"; \"[-]\" if 'modifiable' is off.\nM F   Modified flag, text is \",+\" or \",-\".\nr F   Readonly flag, text is \"[RO]\".\nR F   Readonly flag, text is \",RO\".\nh F   Help buffer flag, text is \"[help]\".\nH F   Help buffer flag, text is \",HLP\".\nw F   Preview window flag, text is \"[Preview]\".\nW F   Preview window flag, text is \",PRV\".\ny F   Type of file in the buffer, e.g., \"[vim]\".  See 'filetype'.\nY F   Type of file in the buffer, e.g., \",VIM\".  See 'filetype'.\nq S   \"[Quickfix List]\", \"[Location List]\" or empty.\nk S   Value of \"b:keymap_name\" or 'keymap' when |:lmap| mappings are\n      being used: \"<keymap>\"\nn N   Buffer number.\nb N   Value of character under cursor.\nB N   As above, in hexadecimal.\no N   Byte number in file of byte under cursor, first byte is 1.\n      Mnemonic: Offset from start of file (with one added)\nO N   As above, in hexadecimal.\nl N   Line number.\nL N   Number of lines in buffer.\nc N   Column number (byte index).\nv N   Virtual column number (screen column).\nV N   Virtual column number as -{num}.  Not displayed if equal to 'c'.\np N   Percentage through file in lines as in |CTRL-G|.\nP S   Percentage through file of displayed window.  This is like the\n      percentage described for 'ruler'.  Always 3 in length, unless\n      translated.\nS S   'showcmd' content, see 'showcmdloc'.\na S   Argument list status as in default title.  ({current} of {max})\n      Empty if the argument file count is zero or one.\n{ NF  Evaluate expression between \"%{\" and \"}\" and substitute result.\n      Note that there is no \"%\" before the closing \"}\".  The\n      expression cannot contain a \"}\" character, call a function to\n      work around that.  See |stl-%{| below.\n`{%` -  This is almost same as \"{\" except the result of the expression is\n      re-evaluated as a statusline format string.  Thus if the\n      return value of expr contains \"%\" items they will get expanded.\n      The expression can contain the \"}\" character, the end of\n      expression is denoted by \"%}\".\n      For example: >vim\n\tfunc! Stl_filename() abort\n\t    return \"%t\"\n\tendfunc\n<\t        `stl=%{Stl_filename()}`   results in `\"%t\"`\n        `stl=%{%Stl_filename()%}` results in `\"Name of current file\"`\n%} -  End of \"{%\" expression\n( -   Start of item group.  Can be used for setting the width and\n      alignment of a section.  Must be followed by %) somewhere.\n) -   End of item group.  No width fields allowed.\nT N   For 'tabline': start of tab page N label.  Use %T or %X to end\n      the label.  Clicking this label with left mouse button switches\n      to the specified tab page, while clicking it with middle mouse\n      button closes the specified tab page.\nX N   For 'tabline': start of close tab N label.  Use %X or %T to end\n      the label, e.g.: %3Xclose%X.  Use %999X for a \"close current\n      tab\" label.  Clicking this label with left mouse button closes\n      the specified tab page.\n@ N   Start of execute function label. Use %X or %T to end the label,\n      e.g.: %10@SwitchBuffer@foo.c%X.  Clicking this label runs the\n      specified function: in the example when clicking once using left\n      mouse button on \"foo.c\", a `SwitchBuffer(10, 1, 'l', '    ')`\n      expression will be run.  The specified function receives the\n      following arguments in order:\n      1. minwid field value or zero if no N was specified\n      2. number of mouse clicks to detect multiple clicks\n      3. mouse button used: \"l\", \"r\" or \"m\" for left, right or middle\n         button respectively; one should not rely on third argument\n         being only \"l\", \"r\" or \"m\": any other non-empty string value\n         that contains only ASCII lower case letters may be expected\n         for other mouse buttons\n      4. modifiers pressed: string which contains \"s\" if shift\n         modifier was pressed, \"c\" for control, \"a\" for alt and \"m\"\n         for meta; currently if modifier is not pressed string\n         contains space instead, but one should not rely on presence\n         of spaces or specific order of modifiers: use |stridx()| to\n         test whether some modifier is present; string is guaranteed\n         to contain only ASCII letters and spaces, one letter per\n         modifier; \"?\" modifier may also be present, but its presence\n         is a bug that denotes that new mouse button recognition was\n         added without modifying code that reacts on mouse clicks on\n         this label.\n      Use |getmousepos()|.winid in the specified function to get the\n      corresponding window id of the clicked item.\n< -   Where to truncate line if too long.  Default is at the start.\n      No width fields allowed.\n= -   Separation point between alignment sections.  Each section will\n      be separated by an equal number of spaces.  With one %= what\n      comes after it will be right-aligned.  With two %= there is a\n      middle part, with white space left and right of it.\n      No width fields allowed.\n# -   Set highlight group.  The name must follow and then a # again.\n      Thus use %#HLname# for highlight group HLname.  The same\n      highlighting is used, also for the statusline of non-current\n      windows.\n* -   Set highlight group to User{N}, where {N} is taken from the\n      minwid field, e.g. %1*.  Restore normal highlight with %* or %0*.\n      The difference between User{N} and StatusLine will be applied to\n      StatusLineNC for the statusline of non-current windows.\n      The number N must be between 1 and 9.  See |hl-User1..9|\n\nWhen displaying a flag, Vim removes the leading comma, if any, when\nthat flag comes right after plaintext.  This will make a nice display\nwhen flags are used like in the examples below.\n\nWhen all items in a group becomes an empty string (i.e. flags that are\nnot set) and a minwid is not set for the group, the whole group will\nbecome empty.  This will make a group like the following disappear\ncompletely from the statusline when none of the flags are set. >vim\n\tset statusline=...%(\\ [%M%R%H]%)...\n<\tBeware that an expression is evaluated each and every time the status\nline is displayed.\n\t\t\t*stl-%{* *g:actual_curbuf* *g:actual_curwin*\nWhile evaluating %{} the current buffer and current window will be set\ntemporarily to that of the window (and buffer) whose statusline is\ncurrently being drawn.  The expression will evaluate in this context.\nThe variable \"g:actual_curbuf\" is set to the `bufnr()` number of the\nreal current buffer and \"g:actual_curwin\" to the |window-ID| of the\nreal current window.  These values are strings.\n\nThe 'statusline' option will be evaluated in the |sandbox| if set from\na modeline, see |sandbox-option|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nIt is not allowed to change text or jump to another window while\nevaluating 'statusline' |textlock|.\n\nIf the statusline is not updated when you want it (e.g., after setting\na variable that's used in an expression), you can force an update by\nusing `:redrawstatus`.\n\nA result of all digits is regarded a number for display purposes.\nOtherwise the result is taken as flag text and applied to the rules\ndescribed above.\n\nWatch out for errors in expressions.  They may render Vim unusable!\nIf you are stuck, hold down ':' or 'Q' to get a prompt, then quit and\nedit your vimrc or whatever with \"vim --clean\" to get it right.\n\nExamples:\nEmulate standard status line with 'ruler' set >vim\n  set statusline=%<%f\\ %h%w%m%r%=%-14.(%l,%c%V%)\\ %P\n<\tSimilar, but add ASCII value of char under the cursor (like \"ga\") >vim\n  set statusline=%<%f%h%m%r%=%b\\ 0x%B\\ \\ %l,%c%V\\ %P\n<\tDisplay byte count and byte value, modified flag in red. >vim\n  set statusline=%<%f%=\\ [%1*%M%*%n%R%H]\\ %-19(%3l,%02c%03V%)%O'%02b'\n  hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red\n<\tDisplay a ,GZ flag if a compressed file is loaded >vim\n  set statusline=...%r%{VarExists('b:gzflag','\\ [GZ]')}%h...\n<\tIn the |:autocmd|'s: >vim\n  let b:gzflag = 1\n<\tAnd: >vim\n  unlet b:gzflag\n<\tAnd define this function: >vim\n  function VarExists(var, val)\n      if exists(a:var) | return a:val | else | return '' | endif\n  endfunction\n<"}}, stmp = {binding = "stmp", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shelltemp' 'stmp'\tboolean\t(default on)\n\t\tglobal\nWhen on, use temp files for shell commands.  When off use a pipe.\nWhen using a pipe is not possible temp files are used anyway.\nThe advantage of using a pipe is that nobody can read the temp file\nand the 'shell' command does not need to support redirection.\nThe advantage of using a temp file is that the file type and encoding\ncan be detected.\nThe |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,\n|FilterWritePost| autocommands event are not triggered when\n'shelltemp' is off.\n|system()| does not respect this option, it always uses pipes."}}, sts = {binding = "sts", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'softtabstop' 'sts'\tnumber\t(default 0)\n\t\tlocal to buffer\nNumber of spaces that a <Tab> counts for while performing editing\noperations, like inserting a <Tab> or using <BS>.  It \"feels\" like\n<Tab>s are being inserted, while in fact a mix of spaces and <Tab>s is\nused.  This is useful to keep the 'ts' setting at its standard value\nof 8, while being able to edit like it is set to 'sts'.  However,\ncommands like \"x\" still work on the actual characters.\nWhen 'sts' is zero, this feature is off.\nWhen 'sts' is negative, the value of 'shiftwidth' is used.\nSee also |ins-expandtab|.  When 'expandtab' is not set, the number of\nspaces is minimized by using <Tab>s.\nThe 'L' flag in 'cpoptions' changes how tabs are used when 'list' is\nset.\n\nThe value of 'softtabstop' will be ignored if |'varsofttabstop'| is set\nto anything other than an empty string."}}, su = {binding = "su", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'suffixes' 'su'\t\tstring\t(default \".bak,~,.o,.h,.info,.swp,.obj\")\n\t\tglobal\nFiles with these suffixes get a lower priority when multiple files\nmatch a wildcard.  See |suffixes|.  Commas can be used to separate the\nsuffixes.  Spaces after the comma are ignored.  A dot is also seen as\nthe start of a suffix.  To avoid a dot or comma being recognized as a\nseparator, precede it with a backslash (see |option-backslash| about\nincluding spaces and backslashes).\nSee 'wildignore' for completely ignoring files.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\nsuffixes from the list.  This avoids problems when a future version\nuses another default."}}, sua = {binding = "sua", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'suffixesadd' 'sua'\tstring\t(default \"\")\n\t\tlocal to buffer\nComma-separated list of suffixes, which are used when searching for a\nfile for the \"gf\", \"[I\", etc. commands.  Example: >vim\n\tset suffixesadd=.java\n<"}}, suffixes = {binding = "suffixes", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'suffixes' 'su'\t\tstring\t(default \".bak,~,.o,.h,.info,.swp,.obj\")\n\t\tglobal\nFiles with these suffixes get a lower priority when multiple files\nmatch a wildcard.  See |suffixes|.  Commas can be used to separate the\nsuffixes.  Spaces after the comma are ignored.  A dot is also seen as\nthe start of a suffix.  To avoid a dot or comma being recognized as a\nseparator, precede it with a backslash (see |option-backslash| about\nincluding spaces and backslashes).\nSee 'wildignore' for completely ignoring files.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\nsuffixes from the list.  This avoids problems when a future version\nuses another default."}}, suffixesadd = {binding = "suffixesadd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'suffixesadd' 'sua'\tstring\t(default \"\")\n\t\tlocal to buffer\nComma-separated list of suffixes, which are used when searching for a\nfile for the \"gf\", \"[I\", etc. commands.  Example: >vim\n\tset suffixesadd=.java\n<"}}, sw = {binding = "sw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shiftwidth' 'sw'\tnumber\t(default 8)\n\t\tlocal to buffer\nNumber of spaces to use for each step of (auto)indent.  Used for\n|'cindent'|, |>>|, |<<|, etc.\nWhen zero the 'tabstop' value will be used.  Use the |shiftwidth()|\nfunction to get the effective shiftwidth value."}}, swapfile = {binding = "swapfile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'swapfile' 'swf'\tboolean\t(default on)\n\t\tlocal to buffer\nUse a swapfile for the buffer.  This option can be reset when a\nswapfile is not wanted for a specific buffer.  For example, with\nconfidential information that even root must not be able to access.\nCareful: All text will be in memory:\n\t- Don't use this for big files.\n\t- Recovery will be impossible!\nA swapfile will only be present when |'updatecount'| is non-zero and\n'swapfile' is set.\nWhen 'swapfile' is reset, the swap file for the current buffer is\nimmediately deleted.  When 'swapfile' is set, and 'updatecount' is\nnon-zero, a swap file is immediately created.\nAlso see |swap-file|.\nIf you want to open a new buffer without creating a swap file for it,\nuse the |:noswapfile| modifier.\nSee 'directory' for where the swap file is created.\n\nThis option is used together with 'bufhidden' and 'buftype' to\nspecify special kinds of buffers.   See |special-buffers|."}}, swb = {binding = "swb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'switchbuf' 'swb'\tstring\t(default \"uselast\")\n\t\tglobal\nThis option controls the behavior when switching between buffers.\nThis option is checked, when\n- jumping to errors with the |quickfix| commands (|:cc|, |:cn|, |:cp|,\n  etc.).\n- jumping to a tag using the |:stag| command.\n- opening a file using the |CTRL-W_f| or |CTRL-W_F| command.\n- jumping to a buffer using a buffer split command (e.g.  |:sbuffer|,\n  |:sbnext|, or |:sbrewind|).\nPossible values (comma-separated list):\n   useopen\tIf included, jump to the first open window in the\n\t\tcurrent tab page that contains the specified buffer\n\t\t(if there is one).  Otherwise: Do not examine other\n\t\twindows.\n   usetab\tLike \"useopen\", but also consider windows in other tab\n\t\tpages.\n   split\tIf included, split the current window before loading\n\t\ta buffer for a |quickfix| command that display errors.\n\t\tOtherwise: do not split, use current window (when used\n\t\tin the quickfix window: the previously used window or\n\t\tsplit if there is no other window).\n   vsplit\tJust like \"split\" but split vertically.\n   newtab\tLike \"split\", but open a new tab page.  Overrules\n\t\t\"split\" when both are present.\n   uselast\tIf included, jump to the previously used window when\n\t\tjumping to errors with |quickfix| commands.\nIf a window has 'winfixbuf' enabled, 'switchbuf' is currently not\napplied to the split window."}}, swf = {binding = "swf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'swapfile' 'swf'\tboolean\t(default on)\n\t\tlocal to buffer\nUse a swapfile for the buffer.  This option can be reset when a\nswapfile is not wanted for a specific buffer.  For example, with\nconfidential information that even root must not be able to access.\nCareful: All text will be in memory:\n\t- Don't use this for big files.\n\t- Recovery will be impossible!\nA swapfile will only be present when |'updatecount'| is non-zero and\n'swapfile' is set.\nWhen 'swapfile' is reset, the swap file for the current buffer is\nimmediately deleted.  When 'swapfile' is set, and 'updatecount' is\nnon-zero, a swap file is immediately created.\nAlso see |swap-file|.\nIf you want to open a new buffer without creating a swap file for it,\nuse the |:noswapfile| modifier.\nSee 'directory' for where the swap file is created.\n\nThis option is used together with 'bufhidden' and 'buftype' to\nspecify special kinds of buffers.   See |special-buffers|."}}, switchbuf = {binding = "switchbuf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'switchbuf' 'swb'\tstring\t(default \"uselast\")\n\t\tglobal\nThis option controls the behavior when switching between buffers.\nThis option is checked, when\n- jumping to errors with the |quickfix| commands (|:cc|, |:cn|, |:cp|,\n  etc.).\n- jumping to a tag using the |:stag| command.\n- opening a file using the |CTRL-W_f| or |CTRL-W_F| command.\n- jumping to a buffer using a buffer split command (e.g.  |:sbuffer|,\n  |:sbnext|, or |:sbrewind|).\nPossible values (comma-separated list):\n   useopen\tIf included, jump to the first open window in the\n\t\tcurrent tab page that contains the specified buffer\n\t\t(if there is one).  Otherwise: Do not examine other\n\t\twindows.\n   usetab\tLike \"useopen\", but also consider windows in other tab\n\t\tpages.\n   split\tIf included, split the current window before loading\n\t\ta buffer for a |quickfix| command that display errors.\n\t\tOtherwise: do not split, use current window (when used\n\t\tin the quickfix window: the previously used window or\n\t\tsplit if there is no other window).\n   vsplit\tJust like \"split\" but split vertically.\n   newtab\tLike \"split\", but open a new tab page.  Overrules\n\t\t\"split\" when both are present.\n   uselast\tIf included, jump to the previously used window when\n\t\tjumping to errors with |quickfix| commands.\nIf a window has 'winfixbuf' enabled, 'switchbuf' is currently not\napplied to the split window."}}, sxe = {binding = "sxe", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellxescape' 'sxe'\tstring\t(default \"\")\n\t\tglobal\nWhen 'shellxquote' is set to \"(\" then the characters listed in this\noption will be escaped with a '^' character.  This makes it possible\nto execute most external commands with cmd.exe.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, sxq = {binding = "sxq", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'shellxquote' 'sxq'\tstring\t(default \"\", Windows: \"\\\"\")\n\t\tglobal\nQuoting character(s), put around the command passed to the shell, for\nthe \"!\" and \":!\" commands.  Includes the redirection.  See\n'shellquote' to exclude the redirection.  It's probably not useful\nto set both options.\nWhen the value is '(' then ')' is appended. When the value is '\"('\nthen ')\"' is appended.\nWhen the value is '(' then also see 'shellxescape'.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, syn = {binding = "syn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'syntax' 'syn'\t\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nWhen this option is set, the syntax with this name is loaded, unless\nsyntax highlighting has been switched off with \":syntax off\".\nOtherwise this option does not always reflect the current syntax (the\nb:current_syntax variable does).\nThis option is most useful in a modeline, for a file which syntax is\nnot automatically recognized.  Example, in an IDL file: >c\n\t/* vim: set syntax=idl : */\n<\tWhen a dot appears in the value then this separates two filetype\nnames.  Example: >c\n\t/* vim: set syntax=c.doxygen : */\n<\tThis will use the \"c\" syntax first, then the \"doxygen\" syntax.\nNote that the second one must be prepared to be loaded as an addition,\notherwise it will be skipped.  More than one dot may appear.\nTo switch off syntax highlighting for the current file, use: >vim\n\tset syntax=OFF\n<\tTo switch syntax highlighting on according to the current value of the\n'filetype' option: >vim\n\tset syntax=ON\n<\tWhat actually happens when setting the 'syntax' option is that the\nSyntax autocommand event is triggered with the value as argument.\nThis option is not copied to another buffer, independent of the 's' or\n'S' flag in 'cpoptions'.\nOnly alphanumeric characters, '.', '-' and '_' can be used."}}, synmaxcol = {binding = "synmaxcol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'synmaxcol' 'smc'\tnumber\t(default 3000)\n\t\tlocal to buffer\nMaximum column in which to search for syntax items.  In long lines the\ntext after this column is not highlighted and following lines may not\nbe highlighted correctly, because the syntax state is cleared.\nThis helps to avoid very slow redrawing for an XML file that is one\nlong line.\nSet to zero to remove the limit."}}, syntax = {binding = "syntax", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'syntax' 'syn'\t\tstring\t(default \"\")\n\t\tlocal to buffer  |local-noglobal|\nWhen this option is set, the syntax with this name is loaded, unless\nsyntax highlighting has been switched off with \":syntax off\".\nOtherwise this option does not always reflect the current syntax (the\nb:current_syntax variable does).\nThis option is most useful in a modeline, for a file which syntax is\nnot automatically recognized.  Example, in an IDL file: >c\n\t/* vim: set syntax=idl : */\n<\tWhen a dot appears in the value then this separates two filetype\nnames.  Example: >c\n\t/* vim: set syntax=c.doxygen : */\n<\tThis will use the \"c\" syntax first, then the \"doxygen\" syntax.\nNote that the second one must be prepared to be loaded as an addition,\notherwise it will be skipped.  More than one dot may appear.\nTo switch off syntax highlighting for the current file, use: >vim\n\tset syntax=OFF\n<\tTo switch syntax highlighting on according to the current value of the\n'filetype' option: >vim\n\tset syntax=ON\n<\tWhat actually happens when setting the 'syntax' option is that the\nSyntax autocommand event is triggered with the value as argument.\nThis option is not copied to another buffer, independent of the 's' or\n'S' flag in 'cpoptions'.\nOnly alphanumeric characters, '.', '-' and '_' can be used."}}, tabclose = {binding = "tabclose", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabclose' 'tcl'\tstring\t(default \"\")\n\t\tglobal\nThis option controls the behavior when closing tab pages (e.g., using\n|:tabclose|).  When empty Vim goes to the next (right) tab page.\n\nPossible values (comma-separated list):\n   left\t\tIf included, go to the previous tab page instead of\n\t\tthe next one.\n   uselast\tIf included, go to the previously used tab page if\n\t\tpossible.  This option takes precedence over the\n\t\tothers."}}, tabline = {binding = "tabline", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabline' 'tal'\t\tstring\t(default \"\")\n\t\tglobal\nWhen non-empty, this option determines the content of the tab pages\nline at the top of the Vim window.  When empty Vim will use a default\ntab pages line.  See |setting-tabline| for more info.\n\nThe tab pages line only appears as specified with the 'showtabline'\noption and only when there is no GUI tab line.  When 'e' is in\n'guioptions' and the GUI supports a tab line 'guitablabel' is used\ninstead.  Note that the two tab pages lines are very different.\n\nThe value is evaluated like with 'statusline'.  You can use\n|tabpagenr()|, |tabpagewinnr()| and |tabpagebuflist()| to figure out\nthe text to be displayed.  Use \"%1T\" for the first label, \"%2T\" for\nthe second one, etc.  Use \"%X\" items for closing labels.\n\nWhen changing something that is used in 'tabline' that does not\ntrigger it to be updated, use |:redrawtabline|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nKeep in mind that only one of the tab pages is the current one, others\nare invisible and you can't jump to their windows."}}, tabpagemax = {binding = "tabpagemax", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabpagemax' 'tpm'\tnumber\t(default 50)\n\t\tglobal\nMaximum number of tab pages to be opened by the |-p| command line\nargument or the \":tab all\" command. |tabpage|"}}, tabstop = {binding = "tabstop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabstop' 'ts'\t\tnumber\t(default 8)\n\t\tlocal to buffer\nNumber of spaces that a <Tab> in the file counts for.  Also see\nthe |:retab| command, and the 'softtabstop' option.\n\nNote: Setting 'tabstop' to any other value than 8 can make your file\nappear wrong in many places.\nThe value must be more than 0 and less than 10000.\n\nThere are five main ways to use tabs in Vim:\n1. Always keep 'tabstop' at 8, set 'softtabstop' and 'shiftwidth' to 4\n   (or 3 or whatever you prefer) and use 'noexpandtab'.  Then Vim\n   will use a mix of tabs and spaces, but typing <Tab> and <BS> will\n   behave like a tab appears every 4 (or 3) characters.\n   This is the recommended way, the file will look the same with other\n   tools and when listing it in a terminal.\n2. Set 'softtabstop' and 'shiftwidth' to whatever you prefer and use\n   'expandtab'.  This way you will always insert spaces.  The\n   formatting will never be messed up when 'tabstop' is changed (leave\n   it at 8 just in case).  The file will be a bit larger.\n   You do need to check if no Tabs exist in the file.  You can get rid\n   of them by first setting 'expandtab' and using `%retab!`, making\n   sure the value of 'tabstop' is set correctly.\n3. Set 'tabstop' and 'shiftwidth' to whatever you prefer and use\n   'expandtab'.  This way you will always insert spaces.  The\n   formatting will never be messed up when 'tabstop' is changed.\n   You do need to check if no Tabs exist in the file, just like in the\n   item just above.\n4. Set 'tabstop' and 'shiftwidth' to whatever you prefer and use a\n   |modeline| to set these values when editing the file again.  Only\n   works when using Vim to edit the file, other tools assume a tabstop\n   is worth 8 spaces.\n5. Always set 'tabstop' and 'shiftwidth' to the same value, and\n   'noexpandtab'.  This should then work (for initial indents only)\n   for any tabstop setting that people use.  It might be nice to have\n   tabs after the first non-blank inserted as spaces if you do this\n   though.  Otherwise aligned comments will be wrong when 'tabstop' is\n   changed.\n\nThe value of 'tabstop' will be ignored if |'vartabstop'| is set to\nanything other than an empty string."}}, tag = {binding = "tag", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tags' 'tag'\t\tstring\t(default \"./tags;,tags\")\n\t\tglobal or local to buffer |global-local|\nFilenames for the tag command, separated by spaces or commas.  To\ninclude a space or comma in a file name, precede it with backslashes\n(see |option-backslash| about including spaces/commas and backslashes).\nWhen a file name starts with \"./\", the '.' is replaced with the path\nof the current file.  But only when the 'd' flag is not included in\n'cpoptions'.  Environment variables are expanded |:set_env|.  Also see\n|tags-option|.\n\"*\", \"**\" and other wildcards can be used to search for tags files in\na directory tree.  See |file-searching|.  E.g., \"/lib/**/tags\" will\nfind all files named \"tags\" below \"/lib\".  The filename itself cannot\ncontain wildcards, it is used as-is.  E.g., \"/lib/**/tags?\" will find\nfiles called \"tags?\".\nThe |tagfiles()| function can be used to get a list of the file names\nactually used.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\nfile names from the list.  This avoids problems when a future version\nuses another default."}}, tagbsearch = {binding = "tagbsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagbsearch' 'tbs'\tboolean\t(default on)\n\t\tglobal\nWhen searching for a tag (e.g., for the |:ta| command), Vim can either\nuse a binary search or a linear search in a tags file.  Binary\nsearching makes searching for a tag a LOT faster, but a linear search\nwill find more tags if the tags file wasn't properly sorted.\nVim normally assumes that your tags files are sorted, or indicate that\nthey are not sorted.  Only when this is not the case does the\n'tagbsearch' option need to be switched off.\n\nWhen 'tagbsearch' is on, binary searching is first used in the tags\nfiles.  In certain situations, Vim will do a linear search instead for\ncertain files, or retry all files with a linear search.  When\n'tagbsearch' is off, only a linear search is done.\n\nLinear searching is done anyway, for one file, when Vim finds a line\nat the start of the file indicating that it's not sorted: >\n   !_TAG_FILE_SORTED\0090\t/some comment/\n<\t[The whitespace before and after the '0' must be a single <Tab>]\n\nWhen a binary search was done and no match was found in any of the\nfiles listed in 'tags', and case is ignored or a pattern is used\ninstead of a normal tag name, a retry is done with a linear search.\nTags in unsorted tags files, and matches with different case will only\nbe found in the retry.\n\nIf a tag file indicates that it is case-fold sorted, the second,\nlinear search can be avoided when case is ignored.  Use a value of '2'\nin the \"!_TAG_FILE_SORTED\" line for this.  A tag file can be case-fold\nsorted with the -f switch to \"sort\" in most unices, as in the command:\n\"sort -f -o tags tags\".  For Universal ctags and Exuberant ctags\nversion 5.x or higher (at least 5.5) the --sort=foldcase switch can be\nused for this as well.  Note that case must be folded to uppercase for\nthis to work.\n\nBy default, tag searches are case-sensitive.  Case is ignored when\n'ignorecase' is set and 'tagcase' is \"followic\", or when 'tagcase' is\n\"ignore\".\nAlso when 'tagcase' is \"followscs\" and 'smartcase' is set, or\n'tagcase' is \"smart\", and the pattern contains only lowercase\ncharacters.\n\nWhen 'tagbsearch' is off, tags searching is slower when a full match\nexists, but faster when no full match exists.  Tags in unsorted tags\nfiles may only be found with 'tagbsearch' off.\nWhen the tags file is not sorted, or sorted in a wrong way (not on\nASCII byte value), 'tagbsearch' should be off, or the line given above\nmust be included in the tags file.\nThis option doesn't affect commands that find all matching tags (e.g.,\ncommand-line completion and \":help\")."}}, tagcase = {binding = "tagcase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagcase' 'tc'\t\tstring\t(default \"followic\")\n\t\tglobal or local to buffer |global-local|\nThis option specifies how case is handled when searching the tags\nfile:\n   followic\tFollow the 'ignorecase' option\n   followscs    Follow the 'smartcase' and 'ignorecase' options\n   ignore\tIgnore case\n   match\tMatch case\n   smart\tIgnore case unless an upper case letter is used"}}, tagfunc = {binding = "tagfunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagfunc' 'tfu'\t\tstring\t(default \"\")\n\t\tlocal to buffer\nThis option specifies a function to be used to perform tag searches.\nThe function gets the tag pattern and should return a List of matching\ntags.  See |tag-function| for an explanation of how to write the\nfunction and an example.  The value can be the name of a function, a\n|lambda| or a |Funcref|. See |option-value-function| for more\ninformation.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, taglength = {binding = "taglength", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'taglength' 'tl'\tnumber\t(default 0)\n\t\tglobal\nIf non-zero, tags are significant up to this number of characters."}}, tagrelative = {binding = "tagrelative", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagrelative' 'tr'\tboolean\t(default on)\n\t\tglobal\nIf on and using a tags file in another directory, file names in that\ntags file are relative to the directory where the tags file is."}}, tags = {binding = "tags", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tags' 'tag'\t\tstring\t(default \"./tags;,tags\")\n\t\tglobal or local to buffer |global-local|\nFilenames for the tag command, separated by spaces or commas.  To\ninclude a space or comma in a file name, precede it with backslashes\n(see |option-backslash| about including spaces/commas and backslashes).\nWhen a file name starts with \"./\", the '.' is replaced with the path\nof the current file.  But only when the 'd' flag is not included in\n'cpoptions'.  Environment variables are expanded |:set_env|.  Also see\n|tags-option|.\n\"*\", \"**\" and other wildcards can be used to search for tags files in\na directory tree.  See |file-searching|.  E.g., \"/lib/**/tags\" will\nfind all files named \"tags\" below \"/lib\".  The filename itself cannot\ncontain wildcards, it is used as-is.  E.g., \"/lib/**/tags?\" will find\nfiles called \"tags?\".\nThe |tagfiles()| function can be used to get a list of the file names\nactually used.\nThe use of |:set+=| and |:set-=| is preferred when adding or removing\nfile names from the list.  This avoids problems when a future version\nuses another default."}}, tagstack = {binding = "tagstack", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagstack' 'tgst'\tboolean\t(default on)\n\t\tglobal\nWhen on, the |tagstack| is used normally.  When off, a \":tag\" or\n\":tselect\" command with an argument will not push the tag onto the\ntagstack.  A following \":tag\" without an argument, a \":pop\" command or\nany other command that uses the tagstack will use the unmodified\ntagstack, but does change the pointer to the active entry.\nResetting this option is useful when using a \":tag\" command in a\nmapping which should not change the tagstack."}}, tal = {binding = "tal", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabline' 'tal'\t\tstring\t(default \"\")\n\t\tglobal\nWhen non-empty, this option determines the content of the tab pages\nline at the top of the Vim window.  When empty Vim will use a default\ntab pages line.  See |setting-tabline| for more info.\n\nThe tab pages line only appears as specified with the 'showtabline'\noption and only when there is no GUI tab line.  When 'e' is in\n'guioptions' and the GUI supports a tab line 'guitablabel' is used\ninstead.  Note that the two tab pages lines are very different.\n\nThe value is evaluated like with 'statusline'.  You can use\n|tabpagenr()|, |tabpagewinnr()| and |tabpagebuflist()| to figure out\nthe text to be displayed.  Use \"%1T\" for the first label, \"%2T\" for\nthe second one, etc.  Use \"%X\" items for closing labels.\n\nWhen changing something that is used in 'tabline' that does not\ntrigger it to be updated, use |:redrawtabline|.\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nKeep in mind that only one of the tab pages is the current one, others\nare invisible and you can't jump to their windows."}}, tbidi = {binding = "tbidi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termbidi' 'tbidi'\tboolean\t(default off)\n\t\tglobal\nThe terminal is in charge of Bi-directionality of text (as specified\nby Unicode).  The terminal is also expected to do the required shaping\nthat some languages (such as Arabic) require.\nSetting this option implies that 'rightleft' will not be set when\n'arabic' is set and the value of 'arabicshape' will be ignored.\nNote that setting 'termbidi' has the immediate effect that\n'arabicshape' is ignored, but 'rightleft' isn't changed automatically.\nFor further details see |arabic.txt|."}}, tbs = {binding = "tbs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagbsearch' 'tbs'\tboolean\t(default on)\n\t\tglobal\nWhen searching for a tag (e.g., for the |:ta| command), Vim can either\nuse a binary search or a linear search in a tags file.  Binary\nsearching makes searching for a tag a LOT faster, but a linear search\nwill find more tags if the tags file wasn't properly sorted.\nVim normally assumes that your tags files are sorted, or indicate that\nthey are not sorted.  Only when this is not the case does the\n'tagbsearch' option need to be switched off.\n\nWhen 'tagbsearch' is on, binary searching is first used in the tags\nfiles.  In certain situations, Vim will do a linear search instead for\ncertain files, or retry all files with a linear search.  When\n'tagbsearch' is off, only a linear search is done.\n\nLinear searching is done anyway, for one file, when Vim finds a line\nat the start of the file indicating that it's not sorted: >\n   !_TAG_FILE_SORTED\0090\t/some comment/\n<\t[The whitespace before and after the '0' must be a single <Tab>]\n\nWhen a binary search was done and no match was found in any of the\nfiles listed in 'tags', and case is ignored or a pattern is used\ninstead of a normal tag name, a retry is done with a linear search.\nTags in unsorted tags files, and matches with different case will only\nbe found in the retry.\n\nIf a tag file indicates that it is case-fold sorted, the second,\nlinear search can be avoided when case is ignored.  Use a value of '2'\nin the \"!_TAG_FILE_SORTED\" line for this.  A tag file can be case-fold\nsorted with the -f switch to \"sort\" in most unices, as in the command:\n\"sort -f -o tags tags\".  For Universal ctags and Exuberant ctags\nversion 5.x or higher (at least 5.5) the --sort=foldcase switch can be\nused for this as well.  Note that case must be folded to uppercase for\nthis to work.\n\nBy default, tag searches are case-sensitive.  Case is ignored when\n'ignorecase' is set and 'tagcase' is \"followic\", or when 'tagcase' is\n\"ignore\".\nAlso when 'tagcase' is \"followscs\" and 'smartcase' is set, or\n'tagcase' is \"smart\", and the pattern contains only lowercase\ncharacters.\n\nWhen 'tagbsearch' is off, tags searching is slower when a full match\nexists, but faster when no full match exists.  Tags in unsorted tags\nfiles may only be found with 'tagbsearch' off.\nWhen the tags file is not sorted, or sorted in a wrong way (not on\nASCII byte value), 'tagbsearch' should be off, or the line given above\nmust be included in the tags file.\nThis option doesn't affect commands that find all matching tags (e.g.,\ncommand-line completion and \":help\")."}}, tc = {binding = "tc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagcase' 'tc'\t\tstring\t(default \"followic\")\n\t\tglobal or local to buffer |global-local|\nThis option specifies how case is handled when searching the tags\nfile:\n   followic\tFollow the 'ignorecase' option\n   followscs    Follow the 'smartcase' and 'ignorecase' options\n   ignore\tIgnore case\n   match\tMatch case\n   smart\tIgnore case unless an upper case letter is used"}}, tcl = {binding = "tcl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabclose' 'tcl'\tstring\t(default \"\")\n\t\tglobal\nThis option controls the behavior when closing tab pages (e.g., using\n|:tabclose|).  When empty Vim goes to the next (right) tab page.\n\nPossible values (comma-separated list):\n   left\t\tIf included, go to the previous tab page instead of\n\t\tthe next one.\n   uselast\tIf included, go to the previously used tab page if\n\t\tpossible.  This option takes precedence over the\n\t\tothers."}}, termbidi = {binding = "termbidi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termbidi' 'tbidi'\tboolean\t(default off)\n\t\tglobal\nThe terminal is in charge of Bi-directionality of text (as specified\nby Unicode).  The terminal is also expected to do the required shaping\nthat some languages (such as Arabic) require.\nSetting this option implies that 'rightleft' will not be set when\n'arabic' is set and the value of 'arabicshape' will be ignored.\nNote that setting 'termbidi' has the immediate effect that\n'arabicshape' is ignored, but 'rightleft' isn't changed automatically.\nFor further details see |arabic.txt|."}}, termguicolors = {binding = "termguicolors", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termguicolors' 'tgc'\tboolean\t(default off)\n\t\tglobal\nEnables 24-bit RGB color in the |TUI|.  Uses \"gui\" |:highlight|\nattributes instead of \"cterm\" attributes. |guifg|\nRequires an ISO-8613-3 compatible terminal.\n\nNvim will automatically attempt to determine if the host terminal\nsupports 24-bit color and will enable this option if it does\n(unless explicitly disabled by the user)."}}, termpastefilter = {binding = "termpastefilter", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termpastefilter' 'tpf'\tstring\t(default \"BS,HT,ESC,DEL\")\n\t\tglobal\nA comma-separated list of options for specifying control characters\nto be removed from the text pasted into the terminal window. The\nsupported values are:\n\n   BS\t    Backspace\n\n   HT\t    TAB\n\n   FF\t    Form feed\n\n   ESC\t    Escape\n\n   DEL\t    DEL\n\n   C0\t    Other control characters, excluding Line feed and\n\t    Carriage return < ' '\n\n   C1\t    Control characters 0x80...0x9F"}}, termsync = {binding = "termsync", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termsync'\t\tboolean\t(default on)\n\t\tglobal\nIf the host terminal supports it, buffer all screen updates\nmade during a redraw cycle so that each screen is displayed in\nthe terminal all at once. This can prevent tearing or flickering\nwhen the terminal updates faster than Nvim can redraw."}}, textwidth = {binding = "textwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'textwidth' 'tw'\tnumber\t(default 0)\n\t\tlocal to buffer\nMaximum width of text that is being inserted.  A longer line will be\nbroken after white space to get this width.  A zero value disables\nthis.\nWhen 'textwidth' is zero, 'wrapmargin' may be used.  See also\n'formatoptions' and |ins-textwidth|.\nWhen 'formatexpr' is set it will be used to break the line."}}, tfu = {binding = "tfu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagfunc' 'tfu'\t\tstring\t(default \"\")\n\t\tlocal to buffer\nThis option specifies a function to be used to perform tag searches.\nThe function gets the tag pattern and should return a List of matching\ntags.  See |tag-function| for an explanation of how to write the\nfunction and an example.  The value can be the name of a function, a\n|lambda| or a |Funcref|. See |option-value-function| for more\ninformation.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, tgc = {binding = "tgc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termguicolors' 'tgc'\tboolean\t(default off)\n\t\tglobal\nEnables 24-bit RGB color in the |TUI|.  Uses \"gui\" |:highlight|\nattributes instead of \"cterm\" attributes. |guifg|\nRequires an ISO-8613-3 compatible terminal.\n\nNvim will automatically attempt to determine if the host terminal\nsupports 24-bit color and will enable this option if it does\n(unless explicitly disabled by the user)."}}, tgst = {binding = "tgst", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagstack' 'tgst'\tboolean\t(default on)\n\t\tglobal\nWhen on, the |tagstack| is used normally.  When off, a \":tag\" or\n\":tselect\" command with an argument will not push the tag onto the\ntagstack.  A following \":tag\" without an argument, a \":pop\" command or\nany other command that uses the tagstack will use the unmodified\ntagstack, but does change the pointer to the active entry.\nResetting this option is useful when using a \":tag\" command in a\nmapping which should not change the tagstack."}}, thesaurus = {binding = "thesaurus", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'thesaurus' 'tsr'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nList of file names, separated by commas, that are used to lookup words\nfor thesaurus completion commands |i_CTRL-X_CTRL-T|.  See\n|compl-thesaurus|.\n\nThis option is not used if 'thesaurusfunc' is set, either for the\nbuffer or globally.\n\nTo include a comma in a file name precede it with a backslash.  Spaces\nafter a comma are ignored, otherwise spaces are included in the file\nname.  See |option-backslash| about using backslashes.  The use of\n|:set+=| and |:set-=| is preferred when adding or removing directories\nfrom the list.  This avoids problems when a future version uses\nanother default.  Backticks cannot be used in this option for security\nreasons."}}, thesaurusfunc = {binding = "thesaurusfunc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'thesaurusfunc' 'tsrfu'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nThis option specifies a function to be used for thesaurus completion\nwith CTRL-X CTRL-T. |i_CTRL-X_CTRL-T| See |compl-thesaurusfunc|.\nThe value can be the name of a function, a |lambda| or a |Funcref|.\nSee |option-value-function| for more information.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, tildeop = {binding = "tildeop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tildeop' 'top'\t\tboolean\t(default off)\n\t\tglobal\nWhen on: The tilde command \"~\" behaves like an operator."}}, timeout = {binding = "timeout", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'timeout' 'to'\t\tboolean\t(default on)\n\t\tglobal\nThis option and 'timeoutlen' determine the behavior when part of a\nmapped key sequence has been received. For example, if <c-f> is\npressed and 'timeout' is set, Nvim will wait 'timeoutlen' milliseconds\nfor any key that can follow <c-f> in a mapping."}}, timeoutlen = {binding = "timeoutlen", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'timeoutlen' 'tm'\tnumber\t(default 1000)\n\t\tglobal\nTime in milliseconds to wait for a mapped sequence to complete."}}, title = {binding = "title", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'title'\t\t\tboolean\t(default off)\n\t\tglobal\nWhen on, the title of the window will be set to the value of\n'titlestring' (if it is not empty), or to:\n\tfilename [+=-] (path) - Nvim\nWhere:\n\tfilename\tthe name of the file being edited\n\t-\t\tindicates the file cannot be modified, 'ma' off\n\t+\t\tindicates the file was modified\n\t=\t\tindicates the file is read-only\n\t=+\t\tindicates the file is read-only and modified\n\t(path)\t\tis the path of the file being edited\n\t- Nvim\t\tthe server name |v:servername| or \"Nvim\""}}, titlelen = {binding = "titlelen", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'titlelen'\t\tnumber\t(default 85)\n\t\tglobal\nGives the percentage of 'columns' to use for the length of the window\ntitle.  When the title is longer, only the end of the path name is\nshown.  A '<' character before the path name is used to indicate this.\nUsing a percentage makes this adapt to the width of the window.  But\nit won't work perfectly, because the actual number of characters\navailable also depends on the font used and other things in the title\nbar.  When 'titlelen' is zero the full path is used.  Otherwise,\nvalues from 1 to 30000 percent can be used.\n'titlelen' is also used for the 'titlestring' option."}}, titleold = {binding = "titleold", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'titleold'\t\tstring\t(default \"\")\n\t\tglobal\nIf not empty, this option will be used to set the window title when\nexiting.  Only if 'title' is enabled.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, titlestring = {binding = "titlestring", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'titlestring'\t\tstring\t(default \"\")\n\t\tglobal\nWhen this option is not empty, it will be used for the title of the\nwindow.  This happens only when the 'title' option is on.\n\nWhen this option contains printf-style '%' items, they will be\nexpanded according to the rules used for 'statusline'.  If it contains\nan invalid '%' format, the value is used as-is and no error or warning\nwill be given when the value is set.\n\nThe default behaviour is equivalent to: >vim\n    set titlestring=%t%(\\ %M%)%(\\ \\(%{expand(\\\"%:~:h\\\")}\\)%)%a\\ -\\ Nvim\n<\nThis option cannot be set in a modeline when 'modelineexpr' is off.\n\nExample: >vim\n    auto BufEnter * let &titlestring = hostname() .. \"/\" .. expand(\"%:p\")\n    set title titlestring=%<%F%=%l/%L-%P titlelen=70\n<\tThe value of 'titlelen' is used to align items in the middle or right\nof the available space.\nSome people prefer to have the file name first: >vim\n    set titlestring=%t%(\\ %M%)%(\\ (%{expand(\\\"%:~:.:h\\\")})%)%(\\ %a%)\n<\tNote the use of \"%{ }\" and an expression to get the path of the file,\nwithout the file name.  The \"%( %)\" constructs are used to add a\nseparating space only when needed.\nNOTE: Use of special characters in 'titlestring' may cause the display\nto be garbled (e.g., when it contains a CR or NL character)."}}, tl = {binding = "tl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'taglength' 'tl'\tnumber\t(default 0)\n\t\tglobal\nIf non-zero, tags are significant up to this number of characters."}}, tm = {binding = "tm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'timeoutlen' 'tm'\tnumber\t(default 1000)\n\t\tglobal\nTime in milliseconds to wait for a mapped sequence to complete."}}, to = {binding = "to", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'timeout' 'to'\t\tboolean\t(default on)\n\t\tglobal\nThis option and 'timeoutlen' determine the behavior when part of a\nmapped key sequence has been received. For example, if <c-f> is\npressed and 'timeout' is set, Nvim will wait 'timeoutlen' milliseconds\nfor any key that can follow <c-f> in a mapping."}}, top = {binding = "top", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tildeop' 'top'\t\tboolean\t(default off)\n\t\tglobal\nWhen on: The tilde command \"~\" behaves like an operator."}}, tpf = {binding = "tpf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'termpastefilter' 'tpf'\tstring\t(default \"BS,HT,ESC,DEL\")\n\t\tglobal\nA comma-separated list of options for specifying control characters\nto be removed from the text pasted into the terminal window. The\nsupported values are:\n\n   BS\t    Backspace\n\n   HT\t    TAB\n\n   FF\t    Form feed\n\n   ESC\t    Escape\n\n   DEL\t    DEL\n\n   C0\t    Other control characters, excluding Line feed and\n\t    Carriage return < ' '\n\n   C1\t    Control characters 0x80...0x9F"}}, tpm = {binding = "tpm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabpagemax' 'tpm'\tnumber\t(default 50)\n\t\tglobal\nMaximum number of tab pages to be opened by the |-p| command line\nargument or the \":tab all\" command. |tabpage|"}}, tr = {binding = "tr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tagrelative' 'tr'\tboolean\t(default on)\n\t\tglobal\nIf on and using a tags file in another directory, file names in that\ntags file are relative to the directory where the tags file is."}}, ts = {binding = "ts", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'tabstop' 'ts'\t\tnumber\t(default 8)\n\t\tlocal to buffer\nNumber of spaces that a <Tab> in the file counts for.  Also see\nthe |:retab| command, and the 'softtabstop' option.\n\nNote: Setting 'tabstop' to any other value than 8 can make your file\nappear wrong in many places.\nThe value must be more than 0 and less than 10000.\n\nThere are five main ways to use tabs in Vim:\n1. Always keep 'tabstop' at 8, set 'softtabstop' and 'shiftwidth' to 4\n   (or 3 or whatever you prefer) and use 'noexpandtab'.  Then Vim\n   will use a mix of tabs and spaces, but typing <Tab> and <BS> will\n   behave like a tab appears every 4 (or 3) characters.\n   This is the recommended way, the file will look the same with other\n   tools and when listing it in a terminal.\n2. Set 'softtabstop' and 'shiftwidth' to whatever you prefer and use\n   'expandtab'.  This way you will always insert spaces.  The\n   formatting will never be messed up when 'tabstop' is changed (leave\n   it at 8 just in case).  The file will be a bit larger.\n   You do need to check if no Tabs exist in the file.  You can get rid\n   of them by first setting 'expandtab' and using `%retab!`, making\n   sure the value of 'tabstop' is set correctly.\n3. Set 'tabstop' and 'shiftwidth' to whatever you prefer and use\n   'expandtab'.  This way you will always insert spaces.  The\n   formatting will never be messed up when 'tabstop' is changed.\n   You do need to check if no Tabs exist in the file, just like in the\n   item just above.\n4. Set 'tabstop' and 'shiftwidth' to whatever you prefer and use a\n   |modeline| to set these values when editing the file again.  Only\n   works when using Vim to edit the file, other tools assume a tabstop\n   is worth 8 spaces.\n5. Always set 'tabstop' and 'shiftwidth' to the same value, and\n   'noexpandtab'.  This should then work (for initial indents only)\n   for any tabstop setting that people use.  It might be nice to have\n   tabs after the first non-blank inserted as spaces if you do this\n   though.  Otherwise aligned comments will be wrong when 'tabstop' is\n   changed.\n\nThe value of 'tabstop' will be ignored if |'vartabstop'| is set to\nanything other than an empty string."}}, tsr = {binding = "tsr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'thesaurus' 'tsr'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nList of file names, separated by commas, that are used to lookup words\nfor thesaurus completion commands |i_CTRL-X_CTRL-T|.  See\n|compl-thesaurus|.\n\nThis option is not used if 'thesaurusfunc' is set, either for the\nbuffer or globally.\n\nTo include a comma in a file name precede it with a backslash.  Spaces\nafter a comma are ignored, otherwise spaces are included in the file\nname.  See |option-backslash| about using backslashes.  The use of\n|:set+=| and |:set-=| is preferred when adding or removing directories\nfrom the list.  This avoids problems when a future version uses\nanother default.  Backticks cannot be used in this option for security\nreasons."}}, tsrfu = {binding = "tsrfu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'thesaurusfunc' 'tsrfu'\tstring\t(default \"\")\n\t\tglobal or local to buffer |global-local|\nThis option specifies a function to be used for thesaurus completion\nwith CTRL-X CTRL-T. |i_CTRL-X_CTRL-T| See |compl-thesaurusfunc|.\nThe value can be the name of a function, a |lambda| or a |Funcref|.\nSee |option-value-function| for more information.\n\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ttimeout = {binding = "ttimeout", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ttimeout'\t\tboolean\t(default on)\n\t\tglobal\nThis option and 'ttimeoutlen' determine the behavior when part of a\nkey code sequence has been received by the |TUI|.\n\nFor example if <Esc> (the \\x1b byte) is received and 'ttimeout' is\nset, Nvim waits 'ttimeoutlen' milliseconds for the terminal to\ncomplete a key code sequence. If no input arrives before the timeout,\na single <Esc> is assumed. Many TUI cursor key codes start with <Esc>.\n\nOn very slow systems this may fail, causing cursor keys not to work\nsometimes.  If you discover this problem you can \":set ttimeoutlen=9999\".\nNvim will wait for the next character to arrive after an <Esc>."}}, ttimeoutlen = {binding = "ttimeoutlen", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ttimeoutlen' 'ttm'\tnumber\t(default 50)\n\t\tglobal\nTime in milliseconds to wait for a key code sequence to complete. Also\nused for CTRL-\\ CTRL-N and CTRL-\\ CTRL-G when part of a command has\nbeen typed."}}, ttm = {binding = "ttm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'ttimeoutlen' 'ttm'\tnumber\t(default 50)\n\t\tglobal\nTime in milliseconds to wait for a key code sequence to complete. Also\nused for CTRL-\\ CTRL-N and CTRL-\\ CTRL-G when part of a command has\nbeen typed."}}, tw = {binding = "tw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'textwidth' 'tw'\tnumber\t(default 0)\n\t\tlocal to buffer\nMaximum width of text that is being inserted.  A longer line will be\nbroken after white space to get this width.  A zero value disables\nthis.\nWhen 'textwidth' is zero, 'wrapmargin' may be used.  See also\n'formatoptions' and |ins-textwidth|.\nWhen 'formatexpr' is set it will be used to break the line."}}, uc = {binding = "uc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'updatecount' 'uc'\tnumber\t(default 200)\n\t\tglobal\nAfter typing this many characters the swap file will be written to\ndisk.  When zero, no swap file will be created at all (see chapter on\nrecovery |crash-recovery|).  'updatecount' is set to zero by starting\nVim with the \"-n\" option, see |startup|.  When editing in readonly\nmode this option will be initialized to 10000.\nThe swapfile can be disabled per buffer with |'swapfile'|.\nWhen 'updatecount' is set from zero to non-zero, swap files are\ncreated for all buffers that have 'swapfile' set.  When 'updatecount'\nis set to zero, existing swap files are not deleted.\nThis option has no meaning in buffers where |'buftype'| is \"nofile\"\nor \"nowrite\"."}}, udf = {binding = "udf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undofile' 'udf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen on, Vim automatically saves undo history to an undo file when\nwriting a buffer to a file, and restores undo history from the same\nfile on buffer read.\nThe directory where the undo file is stored is specified by 'undodir'.\nFor more information about this feature see |undo-persistence|.\nThe undo file is not read when 'undoreload' causes the buffer from\nbefore a reload to be saved for undo.\nWhen 'undofile' is turned off the undo file is NOT deleted."}}, udir = {binding = "udir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undodir' 'udir'\tstring\t(default \"$XDG_STATE_HOME/nvim/undo//\")\n\t\tglobal\nList of directory names for undo files, separated with commas.\nSee 'backupdir' for details of the format.\n\".\" means using the directory of the file.  The undo file name for\n\"file.txt\" is \".file.txt.un~\".\nFor other directories the file name is the full path of the edited\nfile, with path separators replaced with \"%\".\nWhen writing: The first directory that exists is used.  \".\" always\nworks, no directories after \".\" will be used for writing.  If none of\nthe directories exist Nvim will attempt to create the last directory in\nthe list.\nWhen reading all entries are tried to find an undo file.  The first\nundo file that exists is used.  When it cannot be read an error is\ngiven, no further entry is used.\nSee |undo-persistence|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n\nNote that unlike 'directory' and 'backupdir', 'undodir' always acts as\nthough the trailing slashes are present (see 'backupdir' for what this\nmeans)."}}, ul = {binding = "ul", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undolevels' 'ul'\tnumber\t(default 1000)\n\t\tglobal or local to buffer |global-local|\nMaximum number of changes that can be undone.  Since undo information\nis kept in memory, higher numbers will cause more memory to be used.\nNevertheless, a single change can already use a large amount of memory.\nSet to 0 for Vi compatibility: One level of undo and \"u\" undoes\nitself: >vim\n\tset ul=0\n<\tBut you can also get Vi compatibility by including the 'u' flag in\n'cpoptions', and still be able to use CTRL-R to repeat undo.\nAlso see |undo-two-ways|.\nSet to -1 for no undo at all.  You might want to do this only for the\ncurrent buffer: >vim\n\tsetlocal ul=-1\n<\tThis helps when you run out of memory for a single change.\n\nThe local value is set to -123456 when the global value is to be used.\n\nAlso see |clear-undo|."}}, undodir = {binding = "undodir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undodir' 'udir'\tstring\t(default \"$XDG_STATE_HOME/nvim/undo//\")\n\t\tglobal\nList of directory names for undo files, separated with commas.\nSee 'backupdir' for details of the format.\n\".\" means using the directory of the file.  The undo file name for\n\"file.txt\" is \".file.txt.un~\".\nFor other directories the file name is the full path of the edited\nfile, with path separators replaced with \"%\".\nWhen writing: The first directory that exists is used.  \".\" always\nworks, no directories after \".\" will be used for writing.  If none of\nthe directories exist Nvim will attempt to create the last directory in\nthe list.\nWhen reading all entries are tried to find an undo file.  The first\nundo file that exists is used.  When it cannot be read an error is\ngiven, no further entry is used.\nSee |undo-persistence|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons.\n\nNote that unlike 'directory' and 'backupdir', 'undodir' always acts as\nthough the trailing slashes are present (see 'backupdir' for what this\nmeans)."}}, undofile = {binding = "undofile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undofile' 'udf'\tboolean\t(default off)\n\t\tlocal to buffer\nWhen on, Vim automatically saves undo history to an undo file when\nwriting a buffer to a file, and restores undo history from the same\nfile on buffer read.\nThe directory where the undo file is stored is specified by 'undodir'.\nFor more information about this feature see |undo-persistence|.\nThe undo file is not read when 'undoreload' causes the buffer from\nbefore a reload to be saved for undo.\nWhen 'undofile' is turned off the undo file is NOT deleted."}}, undolevels = {binding = "undolevels", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undolevels' 'ul'\tnumber\t(default 1000)\n\t\tglobal or local to buffer |global-local|\nMaximum number of changes that can be undone.  Since undo information\nis kept in memory, higher numbers will cause more memory to be used.\nNevertheless, a single change can already use a large amount of memory.\nSet to 0 for Vi compatibility: One level of undo and \"u\" undoes\nitself: >vim\n\tset ul=0\n<\tBut you can also get Vi compatibility by including the 'u' flag in\n'cpoptions', and still be able to use CTRL-R to repeat undo.\nAlso see |undo-two-ways|.\nSet to -1 for no undo at all.  You might want to do this only for the\ncurrent buffer: >vim\n\tsetlocal ul=-1\n<\tThis helps when you run out of memory for a single change.\n\nThe local value is set to -123456 when the global value is to be used.\n\nAlso see |clear-undo|."}}, undoreload = {binding = "undoreload", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undoreload' 'ur'\tnumber\t(default 10000)\n\t\tglobal\nSave the whole buffer for undo when reloading it.  This applies to the\n\":e!\" command and reloading for when the buffer changed outside of\nVim. |FileChangedShell|\nThe save only happens when this option is negative or when the number\nof lines is smaller than the value of this option.\nSet this option to zero to disable undo for a reload.\n\nWhen saving undo for a reload, any undo file is not read.\n\nNote that this causes the whole buffer to be stored in memory.  Set\nthis option to a lower value if you run out of memory."}}, updatecount = {binding = "updatecount", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'updatecount' 'uc'\tnumber\t(default 200)\n\t\tglobal\nAfter typing this many characters the swap file will be written to\ndisk.  When zero, no swap file will be created at all (see chapter on\nrecovery |crash-recovery|).  'updatecount' is set to zero by starting\nVim with the \"-n\" option, see |startup|.  When editing in readonly\nmode this option will be initialized to 10000.\nThe swapfile can be disabled per buffer with |'swapfile'|.\nWhen 'updatecount' is set from zero to non-zero, swap files are\ncreated for all buffers that have 'swapfile' set.  When 'updatecount'\nis set to zero, existing swap files are not deleted.\nThis option has no meaning in buffers where |'buftype'| is \"nofile\"\nor \"nowrite\"."}}, updatetime = {binding = "updatetime", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'updatetime' 'ut'\tnumber\t(default 4000)\n\t\tglobal\nIf this many milliseconds nothing is typed the swap file will be\nwritten to disk (see |crash-recovery|).  Also used for the\n|CursorHold| autocommand event."}}, ur = {binding = "ur", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'undoreload' 'ur'\tnumber\t(default 10000)\n\t\tglobal\nSave the whole buffer for undo when reloading it.  This applies to the\n\":e!\" command and reloading for when the buffer changed outside of\nVim. |FileChangedShell|\nThe save only happens when this option is negative or when the number\nof lines is smaller than the value of this option.\nSet this option to zero to disable undo for a reload.\n\nWhen saving undo for a reload, any undo file is not read.\n\nNote that this causes the whole buffer to be stored in memory.  Set\nthis option to a lower value if you run out of memory."}}, ut = {binding = "ut", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'updatetime' 'ut'\tnumber\t(default 4000)\n\t\tglobal\nIf this many milliseconds nothing is typed the swap file will be\nwritten to disk (see |crash-recovery|).  Also used for the\n|CursorHold| autocommand event."}}, varsofttabstop = {binding = "varsofttabstop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'varsofttabstop' 'vsts'\tstring\t(default \"\")\n\t\tlocal to buffer\nA list of the number of spaces that a <Tab> counts for while editing,\nsuch as inserting a <Tab> or using <BS>.  It \"feels\" like variable-\nwidth <Tab>s are being inserted, while in fact a mixture of spaces\nand <Tab>s is used.  Tab widths are separated with commas, with the\nfinal value applying to all subsequent tabs.\n\nFor example, when editing assembly language files where statements\nstart in the 9th column and comments in the 41st, it may be useful\nto use the following: >vim\n\tset varsofttabstop=8,32,8\n<\tThis will set soft tabstops with 8 and 8 + 32 spaces, and 8 more\nfor every column thereafter.\n\nNote that the value of |'softtabstop'| will be ignored while\n'varsofttabstop' is set."}}, vartabstop = {binding = "vartabstop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'vartabstop' 'vts'\tstring\t(default \"\")\n\t\tlocal to buffer\nA list of the number of spaces that a <Tab> in the file counts for,\nseparated by commas.  Each value corresponds to one tab, with the\nfinal value applying to all subsequent tabs. For example: >vim\n\tset vartabstop=4,20,10,8\n<\tThis will make the first tab 4 spaces wide, the second 20 spaces,\nthe third 10 spaces, and all following tabs 8 spaces.\n\nNote that the value of |'tabstop'| will be ignored while 'vartabstop'\nis set."}}, vb = {binding = "vb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'visualbell' 'vb'\tboolean\t(default off)\n\t\tglobal\nUse visual bell instead of beeping.  Also see 'errorbells'."}}, vbs = {binding = "vbs", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'verbose' 'vbs'\t\tnumber\t(default 0)\n\t\tglobal\nSets the verbosity level.  Also set by |-V| and |:verbose|.\n\nTracing of assignments to options, mappings, etc. in Lua scripts is\nenabled at level 1; Lua scripts are not traced when 'verbose' is 0,\nfor performance.\n\nIf greater than or equal to a given level, Nvim produces the following\nmessages:\n\nLevel   Messages ~\n----------------------------------------------------------------------\n1\tEnables Lua tracing (see above). Does not produce messages.\n2\tWhen a file is \":source\"'ed, or |shada| file is read or written.\n3\tUI info, terminal capabilities.\n4\tShell commands.\n5\tEvery searched tags file and include file.\n8\tFiles for which a group of autocommands is executed.\n9\tExecuted autocommands.\n11\tFinding items in a path.\n12\tVimscript function calls.\n13\tWhen an exception is thrown, caught, finished, or discarded.\n14\tAnything pending in a \":finally\" clause.\n15\tEx commands from a script (truncated at 200 characters).\n16\tEx commands.\n\nIf 'verbosefile' is set then the verbose messages are not displayed."}}, vdir = {binding = "vdir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'viewdir' 'vdir'\tstring\t(default \"$XDG_STATE_HOME/nvim/view//\")\n\t\tglobal\nName of the directory where to store files for |:mkview|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, ve = {binding = "ve", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'virtualedit' 've'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nA comma-separated list of these words:\n    block\tAllow virtual editing in Visual block mode.\n    insert\tAllow virtual editing in Insert mode.\n    all\t\tAllow virtual editing in all modes.\n    onemore\tAllow the cursor to move just past the end of the line\n    none\tWhen used as the local value, do not allow virtual\n\t\tediting even when the global value is set.  When used\n\t\tas the global value, \"none\" is the same as \"\".\n    NONE\tAlternative spelling of \"none\".\n\nVirtual editing means that the cursor can be positioned where there is\nno actual character.  This can be halfway into a tab or beyond the end\nof the line.  Useful for selecting a rectangle in Visual mode and\nediting a table.\n\"onemore\" is not the same, it will only allow moving the cursor just\nafter the last character of the line.  This makes some commands more\nconsistent.  Previously the cursor was always past the end of the line\nif the line was empty.  But it is far from Vi compatible.  It may also\nbreak some plugins or Vim scripts.  For example because |l| can move\nthe cursor after the last character.  Use with care!\nUsing the `$` command will move to the last character in the line, not\npast it.  This may actually move the cursor to the left!\nThe `g$` command will move to the end of the screen line.\nIt doesn't make sense to combine \"all\" with \"onemore\", but you will\nnot get a warning for it.\nWhen combined with other words, \"none\" is ignored."}}, verbose = {binding = "verbose", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'verbose' 'vbs'\t\tnumber\t(default 0)\n\t\tglobal\nSets the verbosity level.  Also set by |-V| and |:verbose|.\n\nTracing of assignments to options, mappings, etc. in Lua scripts is\nenabled at level 1; Lua scripts are not traced when 'verbose' is 0,\nfor performance.\n\nIf greater than or equal to a given level, Nvim produces the following\nmessages:\n\nLevel   Messages ~\n----------------------------------------------------------------------\n1\tEnables Lua tracing (see above). Does not produce messages.\n2\tWhen a file is \":source\"'ed, or |shada| file is read or written.\n3\tUI info, terminal capabilities.\n4\tShell commands.\n5\tEvery searched tags file and include file.\n8\tFiles for which a group of autocommands is executed.\n9\tExecuted autocommands.\n11\tFinding items in a path.\n12\tVimscript function calls.\n13\tWhen an exception is thrown, caught, finished, or discarded.\n14\tAnything pending in a \":finally\" clause.\n15\tEx commands from a script (truncated at 200 characters).\n16\tEx commands.\n\nIf 'verbosefile' is set then the verbose messages are not displayed."}}, verbosefile = {binding = "verbosefile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'verbosefile' 'vfile'\tstring\t(default \"\")\n\t\tglobal\nWhen not empty all messages are written in a file with this name.\nWhen the file exists messages are appended.\nWriting to the file ends when Vim exits or when 'verbosefile' is made\nempty.  Writes are buffered, thus may not show up for some time.\nSetting 'verbosefile' to a new value is like making it empty first.\nThe difference with |:redir| is that verbose messages are not\ndisplayed when 'verbosefile' is set.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, vfile = {binding = "vfile", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'verbosefile' 'vfile'\tstring\t(default \"\")\n\t\tglobal\nWhen not empty all messages are written in a file with this name.\nWhen the file exists messages are appended.\nWriting to the file ends when Vim exits or when 'verbosefile' is made\nempty.  Writes are buffered, thus may not show up for some time.\nSetting 'verbosefile' to a new value is like making it empty first.\nThe difference with |:redir| is that verbose messages are not\ndisplayed when 'verbosefile' is set.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, viewdir = {binding = "viewdir", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'viewdir' 'vdir'\tstring\t(default \"$XDG_STATE_HOME/nvim/view//\")\n\t\tglobal\nName of the directory where to store files for |:mkview|.\nThis option cannot be set from a |modeline| or in the |sandbox|, for\nsecurity reasons."}}, viewoptions = {binding = "viewoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'viewoptions' 'vop'\tstring\t(default \"folds,cursor,curdir\")\n\t\tglobal\nChanges the effect of the |:mkview| command.  It is a comma-separated\nlist of words.  Each word enables saving and restoring something:\n   word\t\tsave and restore ~\n   cursor\tcursor position in file and in window\n   curdir\tlocal current directory, if set with |:lcd|\n   folds\tmanually created folds, opened/closed folds and local\n\t\tfold options\n   options\toptions and mappings local to a window or buffer (not\n\t\tglobal values for local options)\n   localoptions same as \"options\"\n   slash\t|deprecated| Always enabled. Uses \"/\" in filenames.\n   unix\t\t|deprecated| Always enabled. Uses \"\\n\" line endings."}}, virtualedit = {binding = "virtualedit", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'virtualedit' 've'\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nA comma-separated list of these words:\n    block\tAllow virtual editing in Visual block mode.\n    insert\tAllow virtual editing in Insert mode.\n    all\t\tAllow virtual editing in all modes.\n    onemore\tAllow the cursor to move just past the end of the line\n    none\tWhen used as the local value, do not allow virtual\n\t\tediting even when the global value is set.  When used\n\t\tas the global value, \"none\" is the same as \"\".\n    NONE\tAlternative spelling of \"none\".\n\nVirtual editing means that the cursor can be positioned where there is\nno actual character.  This can be halfway into a tab or beyond the end\nof the line.  Useful for selecting a rectangle in Visual mode and\nediting a table.\n\"onemore\" is not the same, it will only allow moving the cursor just\nafter the last character of the line.  This makes some commands more\nconsistent.  Previously the cursor was always past the end of the line\nif the line was empty.  But it is far from Vi compatible.  It may also\nbreak some plugins or Vim scripts.  For example because |l| can move\nthe cursor after the last character.  Use with care!\nUsing the `$` command will move to the last character in the line, not\npast it.  This may actually move the cursor to the left!\nThe `g$` command will move to the end of the screen line.\nIt doesn't make sense to combine \"all\" with \"onemore\", but you will\nnot get a warning for it.\nWhen combined with other words, \"none\" is ignored."}}, visualbell = {binding = "visualbell", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'visualbell' 'vb'\tboolean\t(default off)\n\t\tglobal\nUse visual bell instead of beeping.  Also see 'errorbells'."}}, vop = {binding = "vop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'viewoptions' 'vop'\tstring\t(default \"folds,cursor,curdir\")\n\t\tglobal\nChanges the effect of the |:mkview| command.  It is a comma-separated\nlist of words.  Each word enables saving and restoring something:\n   word\t\tsave and restore ~\n   cursor\tcursor position in file and in window\n   curdir\tlocal current directory, if set with |:lcd|\n   folds\tmanually created folds, opened/closed folds and local\n\t\tfold options\n   options\toptions and mappings local to a window or buffer (not\n\t\tglobal values for local options)\n   localoptions same as \"options\"\n   slash\t|deprecated| Always enabled. Uses \"/\" in filenames.\n   unix\t\t|deprecated| Always enabled. Uses \"\\n\" line endings."}}, vsts = {binding = "vsts", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'varsofttabstop' 'vsts'\tstring\t(default \"\")\n\t\tlocal to buffer\nA list of the number of spaces that a <Tab> counts for while editing,\nsuch as inserting a <Tab> or using <BS>.  It \"feels\" like variable-\nwidth <Tab>s are being inserted, while in fact a mixture of spaces\nand <Tab>s is used.  Tab widths are separated with commas, with the\nfinal value applying to all subsequent tabs.\n\nFor example, when editing assembly language files where statements\nstart in the 9th column and comments in the 41st, it may be useful\nto use the following: >vim\n\tset varsofttabstop=8,32,8\n<\tThis will set soft tabstops with 8 and 8 + 32 spaces, and 8 more\nfor every column thereafter.\n\nNote that the value of |'softtabstop'| will be ignored while\n'varsofttabstop' is set."}}, vts = {binding = "vts", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'vartabstop' 'vts'\tstring\t(default \"\")\n\t\tlocal to buffer\nA list of the number of spaces that a <Tab> in the file counts for,\nseparated by commas.  Each value corresponds to one tab, with the\nfinal value applying to all subsequent tabs. For example: >vim\n\tset vartabstop=4,20,10,8\n<\tThis will make the first tab 4 spaces wide, the second 20 spaces,\nthe third 10 spaces, and all following tabs 8 spaces.\n\nNote that the value of |'tabstop'| will be ignored while 'vartabstop'\nis set."}}, wa = {binding = "wa", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writeany' 'wa'\t\tboolean\t(default off)\n\t\tglobal\nAllows writing to any file with no need for \"!\" override."}}, wak = {binding = "wak", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winaltkeys' 'wak'\tstring\t(default \"menu\")\n\t\tglobal\n\t\tonly used in Win32\nSome GUI versions allow the access to menu entries by using the ALT\nkey in combination with a character that appears underlined in the\nmenu.  This conflicts with the use of the ALT key for mappings and\nentering special characters.  This option tells what to do:\n  no\tDon't use ALT keys for menus.  ALT key combinations can be\n\tmapped, but there is no automatic handling.\n  yes\tALT key handling is done by the windowing system.  ALT key\n\tcombinations cannot be mapped.\n  menu\tUsing ALT in combination with a character that is a menu\n\tshortcut key, will be handled by the windowing system.  Other\n\tkeys can be mapped.\nIf the menu is disabled by excluding 'm' from 'guioptions', the ALT\nkey is never used for the menu.\nThis option is not used for <F10>; on Win32."}}, warn = {binding = "warn", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'warn'\t\t\tboolean\t(default on)\n\t\tglobal\nGive a warning message when a shell command is used while the buffer\nhas been changed."}}, wb = {binding = "wb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writebackup' 'wb'\tboolean\t(default on)\n\t\tglobal\nMake a backup before overwriting a file.  The backup is removed after\nthe file was successfully written, unless the 'backup' option is\nalso on.\nWARNING: Switching this option off means that when Vim fails to write\nyour buffer correctly and then, for whatever reason, Vim exits, you\nlose both the original file and what you were writing.  Only reset\nthis option if your file system is almost full and it makes the write\nfail (and make sure not to exit Vim until the write was successful).\nSee |backup-table| for another explanation.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nDepending on 'backupcopy' the backup is a new file or the original\nfile renamed (and a new file is written)."}}, wbr = {binding = "wbr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winbar' 'wbr'\t\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nWhen non-empty, this option enables the window bar and determines its\ncontents. The window bar is a bar that's shown at the top of every\nwindow with it enabled. The value of 'winbar' is evaluated like with\n'statusline'.\n\nWhen changing something that is used in 'winbar' that does not trigger\nit to be updated, use |:redrawstatus|.\n\nFloating windows do not use the global value of 'winbar'. The\nwindow-local value of 'winbar' must be set for a floating window to\nhave a window bar.\n\nThis option cannot be set in a modeline when 'modelineexpr' is off."}}, wc = {binding = "wc", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildchar' 'wc'\t\tnumber\t(default <Tab>)\n\t\tglobal\nCharacter you have to type to start wildcard expansion in the\ncommand-line, as specified with 'wildmode'.\nMore info here: |cmdline-completion|.\nThe character is not recognized when used inside a macro.  See\n'wildcharm' for that.\nSome keys will not work, such as CTRL-C, <CR> and Enter.\n<Esc> can be used, but hitting it twice in a row will still exit\ncommand-line as a failsafe measure.\nAlthough 'wc' is a number option, it can be specified as a number, a\nsingle character, a |key-notation| (e.g. <Up>, <C-F>) or a letter\npreceded with a caret (e.g. `^F` is CTRL-F): >vim\n\t:set wc=27\n\t:set wc=X\n\t:set wc=^I\n\tset wc=<Tab>\n<"}}, wcm = {binding = "wcm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildcharm' 'wcm'\tnumber\t(default 0)\n\t\tglobal\n'wildcharm' works exactly like 'wildchar', except that it is\nrecognized when used inside a macro.  You can find \"spare\" command-line\nkeys suitable for this option by looking at |ex-edit-index|.  Normally\nyou'll never actually type 'wildcharm', just use it in mappings that\nautomatically invoke completion mode, e.g.: >vim\n\tset wcm=<C-Z>\n\tcnoremap ss so $vim/sessions/*.vim<C-Z>\n<\tThen after typing :ss you can use CTRL-P & CTRL-N."}}, wd = {binding = "wd", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writedelay' 'wd'\tnumber\t(default 0)\n\t\tglobal\nOnly takes effect together with 'redrawdebug'.\nThe number of milliseconds to wait after each line or each flush"}}, wfb = {binding = "wfb", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixbuf' 'wfb'\tboolean\t(default off)\n\t\tlocal to window\nIf enabled, the window and the buffer it is displaying are paired.\nFor example, attempting to change the buffer with |:edit| will fail.\nOther commands which change a window's buffer such as |:cnext| will\nalso skip any window with 'winfixbuf' enabled.  However if an Ex\ncommand has a \"!\" modifier, it can force switching buffers."}}, wfh = {binding = "wfh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixheight' 'wfh'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window height when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.  Set by default for the\n|preview-window| and |quickfix-window|.\nThe height may be changed anyway when running out of room."}}, wfw = {binding = "wfw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixwidth' 'wfw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window width when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.\nThe width may be changed anyway when running out of room."}}, wh = {binding = "wh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winheight' 'wh'\tnumber\t(default 1)\n\t\tglobal\nMinimal number of lines for the current window.  This is not a hard\nminimum, Vim will use fewer lines if there is not enough room.  If the\nfocus goes to a window that is smaller, its size is increased, at the\ncost of the height of other windows.\nSet 'winheight' to a small number for normal editing.\nSet it to 999 to make the current window fill most of the screen.\nOther windows will be only 'winminheight' high.  This has the drawback\nthat \":all\" will create only two windows.  To avoid \"vim -o 1 2 3 4\"\nto create only two windows, set the option after startup is done,\nusing the |VimEnter| event: >vim\n\tau VimEnter * set winheight=999\n<\tMinimum value is 1.\nThe height is not adjusted after one of the commands that change the\nheight of the current window.\n'winheight' applies to the current window.  Use 'winminheight' to set\nthe minimal height for other windows."}}, whichwrap = {binding = "whichwrap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'whichwrap' 'ww'\tstring\t(default \"b,s\")\n\t\tglobal\nAllow specified keys that move the cursor left/right to move to the\nprevious/next line when the cursor is on the first/last character in\nthe line.  Concatenate characters to allow this for these keys:\n\tchar   key\t  mode\t~\n\t b    <BS>\t Normal and Visual\n\t s    <Space>\t Normal and Visual\n\t h    \"h\"\t Normal and Visual (not recommended)\n\t l    \"l\"\t Normal and Visual (not recommended)\n\t <    <Left>\t Normal and Visual\n\t >    <Right>\t Normal and Visual\n\t ~    \"~\"\t Normal\n\t [    <Left>\t Insert and Replace\n\t ]    <Right>\t Insert and Replace\nFor example: >vim\n\tset ww=<,>,[,]\n<\tallows wrap only when cursor keys are used.\nWhen the movement keys are used in combination with a delete or change\noperator, the <EOL> also counts for a character.  This makes \"3h\"\ndifferent from \"3dh\" when the cursor crosses the end of a line.  This\nis also true for \"x\" and \"X\", because they do the same as \"dl\" and\n\"dh\".  If you use this, you may also want to use the mapping\n\":map <BS> X\" to make backspace delete the character in front of the\ncursor.\nWhen 'l' is included and it is used after an operator at the end of a\nline (not an empty line) then it will not move to the next line.  This\nmakes \"dl\", \"cl\", \"yl\" etc. work normally."}}, wi = {binding = "wi", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'window' 'wi'\t\tnumber\t(default screen height - 1)\n\t\tglobal\nWindow height used for |CTRL-F| and |CTRL-B| when there is only one\nwindow and the value is smaller than 'lines' minus one.  The screen\nwill scroll 'window' minus two lines, with a minimum of one.\nWhen 'window' is equal to 'lines' minus one CTRL-F and CTRL-B scroll\nin a much smarter way, taking care of wrapping lines.\nWhen resizing the Vim window, and the value is smaller than 1 or more\nthan or equal to 'lines' it will be set to 'lines' minus 1.\nNote: Do not confuse this with the height of the Vim window, use\n'lines' for that."}}, wic = {binding = "wic", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildignorecase' 'wic'\tboolean\t(default off)\n\t\tglobal\nWhen set case is ignored when completing file names and directories.\nHas no effect when 'fileignorecase' is set.\nDoes not apply when the shell is used to expand wildcards, which\nhappens when there are special characters."}}, wig = {binding = "wig", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildignore' 'wig'\tstring\t(default \"\")\n\t\tglobal\nA list of file patterns.  A file that matches with one of these\npatterns is ignored when expanding |wildcards|, completing file or\ndirectory names, and influences the result of |expand()|, |glob()| and\n|globpath()| unless a flag is passed to disable this.\nThe pattern is used like with |:autocmd|, see |autocmd-pattern|.\nAlso see 'suffixes'.\nExample: >vim\n\tset wildignore=*.o,*.obj\n<\tThe use of |:set+=| and |:set-=| is preferred when adding or removing\na pattern from the list.  This avoids problems when a future version\nuses another default."}}, wildchar = {binding = "wildchar", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildchar' 'wc'\t\tnumber\t(default <Tab>)\n\t\tglobal\nCharacter you have to type to start wildcard expansion in the\ncommand-line, as specified with 'wildmode'.\nMore info here: |cmdline-completion|.\nThe character is not recognized when used inside a macro.  See\n'wildcharm' for that.\nSome keys will not work, such as CTRL-C, <CR> and Enter.\n<Esc> can be used, but hitting it twice in a row will still exit\ncommand-line as a failsafe measure.\nAlthough 'wc' is a number option, it can be specified as a number, a\nsingle character, a |key-notation| (e.g. <Up>, <C-F>) or a letter\npreceded with a caret (e.g. `^F` is CTRL-F): >vim\n\t:set wc=27\n\t:set wc=X\n\t:set wc=^I\n\tset wc=<Tab>\n<"}}, wildcharm = {binding = "wildcharm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildcharm' 'wcm'\tnumber\t(default 0)\n\t\tglobal\n'wildcharm' works exactly like 'wildchar', except that it is\nrecognized when used inside a macro.  You can find \"spare\" command-line\nkeys suitable for this option by looking at |ex-edit-index|.  Normally\nyou'll never actually type 'wildcharm', just use it in mappings that\nautomatically invoke completion mode, e.g.: >vim\n\tset wcm=<C-Z>\n\tcnoremap ss so $vim/sessions/*.vim<C-Z>\n<\tThen after typing :ss you can use CTRL-P & CTRL-N."}}, wildignore = {binding = "wildignore", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildignore' 'wig'\tstring\t(default \"\")\n\t\tglobal\nA list of file patterns.  A file that matches with one of these\npatterns is ignored when expanding |wildcards|, completing file or\ndirectory names, and influences the result of |expand()|, |glob()| and\n|globpath()| unless a flag is passed to disable this.\nThe pattern is used like with |:autocmd|, see |autocmd-pattern|.\nAlso see 'suffixes'.\nExample: >vim\n\tset wildignore=*.o,*.obj\n<\tThe use of |:set+=| and |:set-=| is preferred when adding or removing\na pattern from the list.  This avoids problems when a future version\nuses another default."}}, wildignorecase = {binding = "wildignorecase", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildignorecase' 'wic'\tboolean\t(default off)\n\t\tglobal\nWhen set case is ignored when completing file names and directories.\nHas no effect when 'fileignorecase' is set.\nDoes not apply when the shell is used to expand wildcards, which\nhappens when there are special characters."}}, wildmenu = {binding = "wildmenu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildmenu' 'wmnu'\tboolean\t(default on)\n\t\tglobal\nWhen 'wildmenu' is on, command-line completion operates in an enhanced\nmode.  On pressing 'wildchar' (usually <Tab>) to invoke completion,\nthe possible matches are shown.\nWhen 'wildoptions' contains \"pum\", then the completion matches are\nshown in a popup menu.  Otherwise they are displayed just above the\ncommand line, with the first match highlighted (overwriting the status\nline, if there is one).\nKeys that show the previous/next match, such as <Tab> or\nCTRL-P/CTRL-N, cause the highlight to move to the appropriate match.\n'wildmode' must specify \"full\": \"longest\" and \"list\" do not start\n'wildmenu' mode. You can check the current mode with |wildmenumode()|.\nThe menu is cancelled when a key is hit that is not used for selecting\na completion.\n\nWhile the menu is active these keys have special meanings:\nCTRL-P\t\t- go to the previous entry\nCTRL-N\t\t- go to the next entry\n<Left> <Right>\t- select previous/next match (like CTRL-P/CTRL-N)\n<PageUp>\t- select a match several entries back\n<PageDown>\t- select a match several entries further\n<Up>\t\t- in filename/menu name completion: move up into\n\t\t  parent directory or parent menu.\n<Down>\t\t- in filename/menu name completion: move into a\n\t\t  subdirectory or submenu.\n<CR>\t\t- in menu completion, when the cursor is just after a\n\t\t  dot: move into a submenu.\nCTRL-E\t\t- end completion, go back to what was there before\n\t\t  selecting a match.\nCTRL-Y\t\t- accept the currently selected match and stop\n\t\t  completion.\n\nIf you want <Left> and <Right> to move the cursor instead of selecting\na different match, use this: >vim\n\tcnoremap <Left> <Space><BS><Left>\n\tcnoremap <Right> <Space><BS><Right>\n<\n|hl-WildMenu| highlights the current match."}}, wildmode = {binding = "wildmode", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildmode' 'wim'\tstring\t(default \"full\")\n\t\tglobal\nCompletion mode that is used for the character specified with\n'wildchar'.  It is a comma-separated list of up to four parts.  Each\npart specifies what to do for each consecutive use of 'wildchar'.  The\nfirst part specifies the behavior for the first use of 'wildchar',\nThe second part for the second use, etc.\n\nEach part consists of a colon separated list consisting of the\nfollowing possible values:\n\"\"\t\tComplete only the first match.\n\"full\"\t\tComplete the next full match.  After the last match,\n\t\tthe original string is used and then the first match\n\t\tagain.  Will also start 'wildmenu' if it is enabled.\n\"longest\"\tComplete till longest common string.  If this doesn't\n\t\tresult in a longer string, use the next part.\n\"list\"\t\tWhen more than one match, list all matches.\n\"lastused\"\tWhen completing buffer names and more than one buffer\n\t\tmatches, sort buffers by time last used (other than\n\t\tthe current buffer).\n\"noselect\"\tDo not pre-select first menu item and start 'wildmenu'\n\t\tif it is enabled.\nWhen there is only a single match, it is fully completed in all cases\nexcept when \"noselect\" is present.\n\nExamples of useful colon-separated values:\n\"longest:full\"\tLike \"longest\", but also start 'wildmenu' if it is\n\t\tenabled.  Will not complete to the next full match.\n\"list:full\"\tWhen more than one match, list all matches and\n\t\tcomplete first match.\n\"list:longest\"\tWhen more than one match, list all matches and\n\t\tcomplete till longest common string.\n\"list:lastused\" When more than one buffer matches, list all matches\n\t\tand sort buffers by time last used (other than the\n\t\tcurrent buffer).\n\nExamples: >vim\n\tset wildmode=full\n<\tComplete first full match, next match, etc.  (the default) >vim\n\tset wildmode=longest,full\n<\tComplete longest common string, then each full match >vim\n\tset wildmode=list:full\n<\tList all matches and complete each full match >vim\n\tset wildmode=list,full\n<\tList all matches without completing, then each full match >vim\n\tset wildmode=longest,list\n<\tComplete longest common string, then list alternatives >vim\n\tset wildmode=noselect:full\n<\tDisplay 'wildmenu' without completing, then each full match >vim\n\tset wildmode=noselect:lastused,full\n<\tSame as above, but sort buffers by time last used.\nMore info here: |cmdline-completion|."}}, wildoptions = {binding = "wildoptions", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildoptions' 'wop'\tstring\t(default \"pum,tagfile\")\n\t\tglobal\nA list of words that change how |cmdline-completion| is done.\nThe following values are supported:\n  fuzzy\t\tUse |fuzzy-matching| to find completion matches. When\n\t\tthis value is specified, wildcard expansion will not\n\t\tbe used for completion.  The matches will be sorted by\n\t\tthe \"best match\" rather than alphabetically sorted.\n\t\tThis will find more matches than the wildcard\n\t\texpansion. Currently fuzzy matching based completion\n\t\tis not supported for file and directory names and\n\t\tinstead wildcard expansion is used.\n  pum\t\tDisplay the completion matches using the popup menu\n\t\tin the same style as the |ins-completion-menu|.\n  tagfile\tWhen using CTRL-D to list matching tags, the kind of\n\t\ttag and the file of the tag is listed.\tOnly one match\n\t\tis displayed per line.  Often used tag kinds are:\n\t\t\td\t#define\n\t\t\tf\tfunction"}}, wim = {binding = "wim", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildmode' 'wim'\tstring\t(default \"full\")\n\t\tglobal\nCompletion mode that is used for the character specified with\n'wildchar'.  It is a comma-separated list of up to four parts.  Each\npart specifies what to do for each consecutive use of 'wildchar'.  The\nfirst part specifies the behavior for the first use of 'wildchar',\nThe second part for the second use, etc.\n\nEach part consists of a colon separated list consisting of the\nfollowing possible values:\n\"\"\t\tComplete only the first match.\n\"full\"\t\tComplete the next full match.  After the last match,\n\t\tthe original string is used and then the first match\n\t\tagain.  Will also start 'wildmenu' if it is enabled.\n\"longest\"\tComplete till longest common string.  If this doesn't\n\t\tresult in a longer string, use the next part.\n\"list\"\t\tWhen more than one match, list all matches.\n\"lastused\"\tWhen completing buffer names and more than one buffer\n\t\tmatches, sort buffers by time last used (other than\n\t\tthe current buffer).\n\"noselect\"\tDo not pre-select first menu item and start 'wildmenu'\n\t\tif it is enabled.\nWhen there is only a single match, it is fully completed in all cases\nexcept when \"noselect\" is present.\n\nExamples of useful colon-separated values:\n\"longest:full\"\tLike \"longest\", but also start 'wildmenu' if it is\n\t\tenabled.  Will not complete to the next full match.\n\"list:full\"\tWhen more than one match, list all matches and\n\t\tcomplete first match.\n\"list:longest\"\tWhen more than one match, list all matches and\n\t\tcomplete till longest common string.\n\"list:lastused\" When more than one buffer matches, list all matches\n\t\tand sort buffers by time last used (other than the\n\t\tcurrent buffer).\n\nExamples: >vim\n\tset wildmode=full\n<\tComplete first full match, next match, etc.  (the default) >vim\n\tset wildmode=longest,full\n<\tComplete longest common string, then each full match >vim\n\tset wildmode=list:full\n<\tList all matches and complete each full match >vim\n\tset wildmode=list,full\n<\tList all matches without completing, then each full match >vim\n\tset wildmode=longest,list\n<\tComplete longest common string, then list alternatives >vim\n\tset wildmode=noselect:full\n<\tDisplay 'wildmenu' without completing, then each full match >vim\n\tset wildmode=noselect:lastused,full\n<\tSame as above, but sort buffers by time last used.\nMore info here: |cmdline-completion|."}}, winaltkeys = {binding = "winaltkeys", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winaltkeys' 'wak'\tstring\t(default \"menu\")\n\t\tglobal\n\t\tonly used in Win32\nSome GUI versions allow the access to menu entries by using the ALT\nkey in combination with a character that appears underlined in the\nmenu.  This conflicts with the use of the ALT key for mappings and\nentering special characters.  This option tells what to do:\n  no\tDon't use ALT keys for menus.  ALT key combinations can be\n\tmapped, but there is no automatic handling.\n  yes\tALT key handling is done by the windowing system.  ALT key\n\tcombinations cannot be mapped.\n  menu\tUsing ALT in combination with a character that is a menu\n\tshortcut key, will be handled by the windowing system.  Other\n\tkeys can be mapped.\nIf the menu is disabled by excluding 'm' from 'guioptions', the ALT\nkey is never used for the menu.\nThis option is not used for <F10>; on Win32."}}, winbar = {binding = "winbar", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winbar' 'wbr'\t\tstring\t(default \"\")\n\t\tglobal or local to window |global-local|\nWhen non-empty, this option enables the window bar and determines its\ncontents. The window bar is a bar that's shown at the top of every\nwindow with it enabled. The value of 'winbar' is evaluated like with\n'statusline'.\n\nWhen changing something that is used in 'winbar' that does not trigger\nit to be updated, use |:redrawstatus|.\n\nFloating windows do not use the global value of 'winbar'. The\nwindow-local value of 'winbar' must be set for a floating window to\nhave a window bar.\n\nThis option cannot be set in a modeline when 'modelineexpr' is off."}}, winbl = {binding = "winbl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winblend' 'winbl'\tnumber\t(default 0)\n\t\tlocal to window\nEnables pseudo-transparency for a floating window. Valid values are in\nthe range of 0 for fully opaque window (disabled) to 100 for fully\ntransparent background. Values between 0-30 are typically most useful.\n\nUI-dependent. Works best with RGB colors. 'termguicolors'"}}, winblend = {binding = "winblend", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winblend' 'winbl'\tnumber\t(default 0)\n\t\tlocal to window\nEnables pseudo-transparency for a floating window. Valid values are in\nthe range of 0 for fully opaque window (disabled) to 100 for fully\ntransparent background. Values between 0-30 are typically most useful.\n\nUI-dependent. Works best with RGB colors. 'termguicolors'"}}, winborder = {binding = "winborder", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winborder'\t\tstring\t(default \"\")\n\t\tglobal\nDefines the default border style of floating windows. The default value\nis empty, which is equivalent to \"none\". Valid values include:\n- \"bold\": Bold line box.\n- \"double\": Double-line box.\n- \"none\": No border.\n- \"rounded\": Like \"single\", but with rounded corners (\"\226\149\173\" etc.).\n- \"shadow\": Drop shadow effect, by blending with the background.\n- \"single\": Single-line box.\n- \"solid\": Adds padding by a single whitespace cell."}}, window = {binding = "window", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'window' 'wi'\t\tnumber\t(default screen height - 1)\n\t\tglobal\nWindow height used for |CTRL-F| and |CTRL-B| when there is only one\nwindow and the value is smaller than 'lines' minus one.  The screen\nwill scroll 'window' minus two lines, with a minimum of one.\nWhen 'window' is equal to 'lines' minus one CTRL-F and CTRL-B scroll\nin a much smarter way, taking care of wrapping lines.\nWhen resizing the Vim window, and the value is smaller than 1 or more\nthan or equal to 'lines' it will be set to 'lines' minus 1.\nNote: Do not confuse this with the height of the Vim window, use\n'lines' for that."}}, winfixbuf = {binding = "winfixbuf", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixbuf' 'wfb'\tboolean\t(default off)\n\t\tlocal to window\nIf enabled, the window and the buffer it is displaying are paired.\nFor example, attempting to change the buffer with |:edit| will fail.\nOther commands which change a window's buffer such as |:cnext| will\nalso skip any window with 'winfixbuf' enabled.  However if an Ex\ncommand has a \"!\" modifier, it can force switching buffers."}}, winfixheight = {binding = "winfixheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixheight' 'wfh'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window height when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.  Set by default for the\n|preview-window| and |quickfix-window|.\nThe height may be changed anyway when running out of room."}}, winfixwidth = {binding = "winfixwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winfixwidth' 'wfw'\tboolean\t(default off)\n\t\tlocal to window  |local-noglobal|\nKeep the window width when windows are opened or closed and\n'equalalways' is set.  Also for |CTRL-W_=|.\nThe width may be changed anyway when running out of room."}}, winheight = {binding = "winheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winheight' 'wh'\tnumber\t(default 1)\n\t\tglobal\nMinimal number of lines for the current window.  This is not a hard\nminimum, Vim will use fewer lines if there is not enough room.  If the\nfocus goes to a window that is smaller, its size is increased, at the\ncost of the height of other windows.\nSet 'winheight' to a small number for normal editing.\nSet it to 999 to make the current window fill most of the screen.\nOther windows will be only 'winminheight' high.  This has the drawback\nthat \":all\" will create only two windows.  To avoid \"vim -o 1 2 3 4\"\nto create only two windows, set the option after startup is done,\nusing the |VimEnter| event: >vim\n\tau VimEnter * set winheight=999\n<\tMinimum value is 1.\nThe height is not adjusted after one of the commands that change the\nheight of the current window.\n'winheight' applies to the current window.  Use 'winminheight' to set\nthe minimal height for other windows."}}, winhighlight = {binding = "winhighlight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winhighlight' 'winhl'\tstring\t(default \"\")\n\t\tlocal to window\nWindow-local highlights.  Comma-delimited list of highlight\n|group-name| pairs \"{hl-from}:{hl-to},...\" where each {hl-from} is\na |highlight-groups| item to be overridden by {hl-to} group in\nthe window.\n\nNote: highlight namespaces take precedence over 'winhighlight'.\nSee |nvim_win_set_hl_ns()| and |nvim_set_hl()|.\n\nHighlights of vertical separators are determined by the window to the\nleft of the separator.  The 'tabline' highlight of a tabpage is\ndecided by the last-focused window of the tabpage.  Highlights of\nthe popupmenu are determined by the current window.  Highlights in the\nmessage area cannot be overridden.\n\nExample: show a different color for non-current windows: >vim\n\tset winhighlight=Normal:MyNormal,NormalNC:MyNormalNC\n<"}}, winhl = {binding = "winhl", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winhighlight' 'winhl'\tstring\t(default \"\")\n\t\tlocal to window\nWindow-local highlights.  Comma-delimited list of highlight\n|group-name| pairs \"{hl-from}:{hl-to},...\" where each {hl-from} is\na |highlight-groups| item to be overridden by {hl-to} group in\nthe window.\n\nNote: highlight namespaces take precedence over 'winhighlight'.\nSee |nvim_win_set_hl_ns()| and |nvim_set_hl()|.\n\nHighlights of vertical separators are determined by the window to the\nleft of the separator.  The 'tabline' highlight of a tabpage is\ndecided by the last-focused window of the tabpage.  Highlights of\nthe popupmenu are determined by the current window.  Highlights in the\nmessage area cannot be overridden.\n\nExample: show a different color for non-current windows: >vim\n\tset winhighlight=Normal:MyNormal,NormalNC:MyNormalNC\n<"}}, winminheight = {binding = "winminheight", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winminheight' 'wmh'\tnumber\t(default 1)\n\t\tglobal\nThe minimal height of a window, when it's not the current window.\nThis is a hard minimum, windows will never become smaller.\nWhen set to zero, windows may be \"squashed\" to zero lines (i.e. just a\nstatus bar) if necessary.  They will return to at least one line when\nthey become active (since the cursor has to have somewhere to go.)\nUse 'winheight' to set the minimal height of the current window.\nThis option is only checked when making a window smaller.  Don't use a\nlarge number, it will cause errors when opening more than a few\nwindows.  A value of 0 to 3 is reasonable."}}, winminwidth = {binding = "winminwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winminwidth' 'wmw'\tnumber\t(default 1)\n\t\tglobal\nThe minimal width of a window, when it's not the current window.\nThis is a hard minimum, windows will never become smaller.\nWhen set to zero, windows may be \"squashed\" to zero columns (i.e. just\na vertical separator) if necessary.  They will return to at least one\nline when they become active (since the cursor has to have somewhere\nto go.)\nUse 'winwidth' to set the minimal width of the current window.\nThis option is only checked when making a window smaller.  Don't use a\nlarge number, it will cause errors when opening more than a few\nwindows.  A value of 0 to 12 is reasonable."}}, winwidth = {binding = "winwidth", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winwidth' 'wiw'\tnumber\t(default 20)\n\t\tglobal\nMinimal number of columns for the current window.  This is not a hard\nminimum, Vim will use fewer columns if there is not enough room.  If\nthe current window is smaller, its size is increased, at the cost of\nthe width of other windows.  Set it to 999 to make the current window\nalways fill the screen.  Set it to a small number for normal editing.\nThe width is not adjusted after one of the commands to change the\nwidth of the current window.\n'winwidth' applies to the current window.  Use 'winminwidth' to set\nthe minimal width for other windows."}}, wiw = {binding = "wiw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winwidth' 'wiw'\tnumber\t(default 20)\n\t\tglobal\nMinimal number of columns for the current window.  This is not a hard\nminimum, Vim will use fewer columns if there is not enough room.  If\nthe current window is smaller, its size is increased, at the cost of\nthe width of other windows.  Set it to 999 to make the current window\nalways fill the screen.  Set it to a small number for normal editing.\nThe width is not adjusted after one of the commands to change the\nwidth of the current window.\n'winwidth' applies to the current window.  Use 'winminwidth' to set\nthe minimal width for other windows."}}, wm = {binding = "wm", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrapmargin' 'wm'\tnumber\t(default 0)\n\t\tlocal to buffer\nNumber of characters from the right window border where wrapping\nstarts.  When typing text beyond this limit, an <EOL> will be inserted\nand inserting continues on the next line.\nOptions that add a margin, such as 'number' and 'foldcolumn', cause\nthe text width to be further reduced.\nWhen 'textwidth' is non-zero, this option is not used.\nSee also 'formatoptions' and |ins-textwidth|."}}, wmh = {binding = "wmh", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winminheight' 'wmh'\tnumber\t(default 1)\n\t\tglobal\nThe minimal height of a window, when it's not the current window.\nThis is a hard minimum, windows will never become smaller.\nWhen set to zero, windows may be \"squashed\" to zero lines (i.e. just a\nstatus bar) if necessary.  They will return to at least one line when\nthey become active (since the cursor has to have somewhere to go.)\nUse 'winheight' to set the minimal height of the current window.\nThis option is only checked when making a window smaller.  Don't use a\nlarge number, it will cause errors when opening more than a few\nwindows.  A value of 0 to 3 is reasonable."}}, wmnu = {binding = "wmnu", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildmenu' 'wmnu'\tboolean\t(default on)\n\t\tglobal\nWhen 'wildmenu' is on, command-line completion operates in an enhanced\nmode.  On pressing 'wildchar' (usually <Tab>) to invoke completion,\nthe possible matches are shown.\nWhen 'wildoptions' contains \"pum\", then the completion matches are\nshown in a popup menu.  Otherwise they are displayed just above the\ncommand line, with the first match highlighted (overwriting the status\nline, if there is one).\nKeys that show the previous/next match, such as <Tab> or\nCTRL-P/CTRL-N, cause the highlight to move to the appropriate match.\n'wildmode' must specify \"full\": \"longest\" and \"list\" do not start\n'wildmenu' mode. You can check the current mode with |wildmenumode()|.\nThe menu is cancelled when a key is hit that is not used for selecting\na completion.\n\nWhile the menu is active these keys have special meanings:\nCTRL-P\t\t- go to the previous entry\nCTRL-N\t\t- go to the next entry\n<Left> <Right>\t- select previous/next match (like CTRL-P/CTRL-N)\n<PageUp>\t- select a match several entries back\n<PageDown>\t- select a match several entries further\n<Up>\t\t- in filename/menu name completion: move up into\n\t\t  parent directory or parent menu.\n<Down>\t\t- in filename/menu name completion: move into a\n\t\t  subdirectory or submenu.\n<CR>\t\t- in menu completion, when the cursor is just after a\n\t\t  dot: move into a submenu.\nCTRL-E\t\t- end completion, go back to what was there before\n\t\t  selecting a match.\nCTRL-Y\t\t- accept the currently selected match and stop\n\t\t  completion.\n\nIf you want <Left> and <Right> to move the cursor instead of selecting\na different match, use this: >vim\n\tcnoremap <Left> <Space><BS><Left>\n\tcnoremap <Right> <Space><BS><Right>\n<\n|hl-WildMenu| highlights the current match."}}, wmw = {binding = "wmw", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'winminwidth' 'wmw'\tnumber\t(default 1)\n\t\tglobal\nThe minimal width of a window, when it's not the current window.\nThis is a hard minimum, windows will never become smaller.\nWhen set to zero, windows may be \"squashed\" to zero columns (i.e. just\na vertical separator) if necessary.  They will return to at least one\nline when they become active (since the cursor has to have somewhere\nto go.)\nUse 'winwidth' to set the minimal width of the current window.\nThis option is only checked when making a window smaller.  Don't use a\nlarge number, it will cause errors when opening more than a few\nwindows.  A value of 0 to 12 is reasonable."}}, wop = {binding = "wop", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wildoptions' 'wop'\tstring\t(default \"pum,tagfile\")\n\t\tglobal\nA list of words that change how |cmdline-completion| is done.\nThe following values are supported:\n  fuzzy\t\tUse |fuzzy-matching| to find completion matches. When\n\t\tthis value is specified, wildcard expansion will not\n\t\tbe used for completion.  The matches will be sorted by\n\t\tthe \"best match\" rather than alphabetically sorted.\n\t\tThis will find more matches than the wildcard\n\t\texpansion. Currently fuzzy matching based completion\n\t\tis not supported for file and directory names and\n\t\tinstead wildcard expansion is used.\n  pum\t\tDisplay the completion matches using the popup menu\n\t\tin the same style as the |ins-completion-menu|.\n  tagfile\tWhen using CTRL-D to list matching tags, the kind of\n\t\ttag and the file of the tag is listed.\tOnly one match\n\t\tis displayed per line.  Often used tag kinds are:\n\t\t\td\t#define\n\t\t\tf\tfunction"}}, wrap = {binding = "wrap", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrap'\t\t\tboolean\t(default on)\n\t\tlocal to window\nThis option changes how text is displayed.  It doesn't change the text\nin the buffer, see 'textwidth' for that.\nWhen on, lines longer than the width of the window will wrap and\ndisplaying continues on the next line.  When off lines will not wrap\nand only part of long lines will be displayed.  When the cursor is\nmoved to a part that is not shown, the screen will scroll\nhorizontally.\nThe line will be broken in the middle of a word if necessary.  See\n'linebreak' to get the break at a word boundary.\nTo make scrolling horizontally a bit more useful, try this: >vim\n\tset sidescroll=5\n\tset listchars+=precedes:<,extends:>\n<\tSee 'sidescroll', 'listchars' and |wrap-off|.\nThis option can't be set from a |modeline| when the 'diff' option is\non.\nIf 'nowrap' was set from a |modeline| or in the |sandbox|, '>' is used\nas the |lcs-extends| character regardless of the value of the 'list'\nand 'listchars' options.  This is to prevent malicious code outside\nthe viewport from going unnoticed.  Use `:setlocal nowrap` manually\nafterwards to disable this behavior."}}, wrapmargin = {binding = "wrapmargin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrapmargin' 'wm'\tnumber\t(default 0)\n\t\tlocal to buffer\nNumber of characters from the right window border where wrapping\nstarts.  When typing text beyond this limit, an <EOL> will be inserted\nand inserting continues on the next line.\nOptions that add a margin, such as 'number' and 'foldcolumn', cause\nthe text width to be further reduced.\nWhen 'textwidth' is non-zero, this option is not used.\nSee also 'formatoptions' and |ins-textwidth|."}}, wrapscan = {binding = "wrapscan", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrapscan' 'ws'\t\tboolean\t(default on)\n\t\tglobal\nSearches wrap around the end of the file.  Also applies to |]s| and\n|[s|, searching for spelling mistakes."}}, write = {binding = "write", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'write'\t\t\tboolean\t(default on)\n\t\tglobal\nAllows writing files.  When not set, writing a file is not allowed.\nCan be used for a view-only mode, where modifications to the text are\nstill allowed.  Can be reset with the |-m| or |-M| command line\nargument.  Filtering text is still possible, even though this requires\nwriting a temporary file."}}, writeany = {binding = "writeany", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writeany' 'wa'\t\tboolean\t(default off)\n\t\tglobal\nAllows writing to any file with no need for \"!\" override."}}, writebackup = {binding = "writebackup", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writebackup' 'wb'\tboolean\t(default on)\n\t\tglobal\nMake a backup before overwriting a file.  The backup is removed after\nthe file was successfully written, unless the 'backup' option is\nalso on.\nWARNING: Switching this option off means that when Vim fails to write\nyour buffer correctly and then, for whatever reason, Vim exits, you\nlose both the original file and what you were writing.  Only reset\nthis option if your file system is almost full and it makes the write\nfail (and make sure not to exit Vim until the write was successful).\nSee |backup-table| for another explanation.\nWhen the 'backupskip' pattern matches, a backup is not made anyway.\nDepending on 'backupcopy' the backup is a new file or the original\nfile renamed (and a new file is written)."}}, writedelay = {binding = "writedelay", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'writedelay' 'wd'\tnumber\t(default 0)\n\t\tglobal\nOnly takes effect together with 'redrawdebug'.\nThe number of milliseconds to wait after each line or each flush"}}, ws = {binding = "ws", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'wrapscan' 'ws'\t\tboolean\t(default on)\n\t\tglobal\nSearches wrap around the end of the file.  Also applies to |]s| and\n|[s|, searching for spelling mistakes."}}, ww = {binding = "ww", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "\t'whichwrap' 'ww'\tstring\t(default \"b,s\")\n\t\tglobal\nAllow specified keys that move the cursor left/right to move to the\nprevious/next line when the cursor is on the first/last character in\nthe line.  Concatenate characters to allow this for these keys:\n\tchar   key\t  mode\t~\n\t b    <BS>\t Normal and Visual\n\t s    <Space>\t Normal and Visual\n\t h    \"h\"\t Normal and Visual (not recommended)\n\t l    \"l\"\t Normal and Visual (not recommended)\n\t <    <Left>\t Normal and Visual\n\t >    <Right>\t Normal and Visual\n\t ~    \"~\"\t Normal\n\t [    <Left>\t Insert and Replace\n\t ]    <Right>\t Insert and Replace\nFor example: >vim\n\tset ww=<,>,[,]\n<\tallows wrap only when cursor keys are used.\nWhen the movement keys are used in combination with a delete or change\noperator, the <EOL> also counts for a character.  This makes \"3h\"\ndifferent from \"3dh\" when the cursor crosses the end of a line.  This\nis also true for \"x\" and \"X\", because they do the same as \"dl\" and\n\"dh\".  If you use this, you may also want to use the mapping\n\":map <BS> X\" to make backspace delete the character in front of the\ncursor.\nWhen 'l' is included and it is used after an operator at the end of a\nline (not an empty line) then it will not move to the next line.  This\nmakes \"dl\", \"cl\", \"yl\" etc. work normally."}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "A special interface |vim.opt| exists for conveniently interacting with list-\nand map-style option from Lua: It allows accessing them as Lua tables and\noffers object-oriented method for adding and removing entries."}}, opt_global = {binding = "opt_global", metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "A special interface |vim.opt| exists for conveniently interacting with list-\nand map-style option from Lua: It allows accessing them as Lua tables and\noffers object-oriented method for adding and removing entries."}}, opt_local = {binding = "opt_local", metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "A special interface |vim.opt| exists for conveniently interacting with list-\nand map-style option from Lua: It allows accessing them as Lua tables and\noffers object-oriented method for adding and removing entries."}}, paste = {binding = "paste", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lines", "phase"}, ["fnl/docstring"] = "Paste handler, invoked by |nvim_paste()|.\n\nNote: This is provided only as a \"hook\", don't call it directly; call\n|nvim_paste()| instead, which arranges redo (dot-repeat) and invokes\n`vim.paste`.\n\nExample: To remove ANSI color codes when pasting: >lua\n    vim.paste = (function(overridden)\n      return function(lines, phase)\n        for i,line in ipairs(lines) do\n          -- Scrub ANSI color codes from paste input.\n          lines[i] = line:gsub('\\27%[[0-9;mK]+', '')\n        end\n        return overridden(lines, phase)\n      end\n    end)(vim.paste)\n<\n\nParameters: ~\n  \226\128\162 {lines}  (`string[]`) |readfile()|-style list of lines to paste.\n             |channel-lines|\n  \226\128\162 {phase}  (`-1|1|2|3`) -1: \"non-streaming\" paste: the call contains all\n             lines. If paste is \"streamed\", `phase` indicates the stream\n             state:\n             \226\128\162 1: starts the paste (exactly once)\n             \226\128\162 2: continues the paste (zero or more times)\n             \226\128\162 3: ends the paste (exactly once)\n\nReturn: ~\n    (`boolean`) result false if client should cancel the paste.\n\nSee also: ~\n  \226\128\162 |paste|"}}, pesc = {binding = "pesc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s"}, ["fnl/docstring"] = "Escapes magic chars in |lua-pattern|s.\n\nParameters: ~\n  \226\128\162 {s}  (`string`) String to escape\n\nReturn: ~\n    (`string`) %-escaped pattern string\n\nSee also: ~\n  \226\128\162 https://github.com/rxi/lume"}}, print = {binding = "print", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"..."}, ["fnl/docstring"] = "\"Pretty prints\" the given arguments and returns them unmodified.\n\nExample: >lua\n    local hl_normal = vim.print(vim.api.nvim_get_hl(0, { name = 'Normal' }))\n<\n\nParameters: ~\n  \226\128\162 {...}  (`any`)\n\nReturn: ~\n    (`any`) given arguments.\n\nSee also: ~\n  \226\128\162 |vim.inspect()|\n  \226\128\162 |:=|"}}, re = {binding = "re", fields = {compile = {binding = "compile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"string", "?defs"}, ["fnl/docstring"] = "Compiles the given {string} and returns an equivalent LPeg pattern. The\ngiven string may define either an expression or a grammar. The optional\n{defs} table provides extra Lua values to be used by the pattern.\n\nParameters: ~\n  \226\128\162 {string}  (`string`)\n  \226\128\162 {defs}    (`table?`)\n\nReturn: ~\n    (`vim.lpeg.Pattern`)"}}, find = {binding = "find", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"subject", "pattern", "?init"}, ["fnl/docstring"] = "Searches the given {pattern} in the given {subject}. If it finds a match,\nreturns the index where this occurrence starts and the index where it\nends. Otherwise, returns nil.\n\nAn optional numeric argument {init} makes the search starts at that\nposition in the subject string. As usual in Lua libraries, a negative\nvalue counts from the end.\n\nParameters: ~\n  \226\128\162 {subject}  (`string`)\n  \226\128\162 {pattern}  (`vim.lpeg.Pattern|string`)\n  \226\128\162 {init}     (`integer?`)\n\nReturn (multiple): ~\n    (`integer?`) the index where the occurrence starts, nil if no match\n    (`integer?`) the index where the occurrence ends, nil if no match"}}, gsub = {binding = "gsub", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"subject", "pattern", "replacement"}, ["fnl/docstring"] = "Does a global substitution, replacing all occurrences of {pattern} in the\ngiven {subject} by {replacement}.\n\nParameters: ~\n  \226\128\162 {subject}      (`string`)\n  \226\128\162 {pattern}      (`vim.lpeg.Pattern|string`)\n  \226\128\162 {replacement}  (`string`)\n\nReturn: ~\n    (`string`)"}}, match = {binding = "match", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"subject", "pattern", "?init"}, ["fnl/docstring"] = "Matches the given {pattern} against the given {subject}, returning all\ncaptures.\n\nParameters: ~\n  \226\128\162 {subject}  (`string`)\n  \226\128\162 {pattern}  (`vim.lpeg.Pattern|string`)\n  \226\128\162 {init}     (`integer?`)\n\nReturn: ~\n    (`integer|vim.lpeg.Capture?`)\n\nSee also: ~\n  \226\128\162 vim.lpeg.match()"}}, updatelocale = {binding = "updatelocale", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Updates the pre-defined character classes to the current locale."}}}, metadata = {["fls/itemKind"] = "Module"}}, regex = {binding = "regex", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"re"}, ["fnl/docstring"] = "Parses the Vim regex `re` and returns a regex object. Regexes are \"magic\"\nand case-sensitive by default, regardless of 'magic' and 'ignorecase'.\nThey can be controlled with flags, see |/magic| and |/ignorecase|.\n\nParameters: ~\n  \226\128\162 {re}  (`string`)\n\nReturn: ~\n    (`vim.regex`)"}}, ringbuf = {binding = "ringbuf", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"size"}, ["fnl/docstring"] = "Create a ring buffer limited to a maximal number of items. Once the buffer\nis full, adding a new entry overrides the oldest entry. >lua\n    local ringbuf = vim.ringbuf(4)\n    ringbuf:push(\"a\")\n    ringbuf:push(\"b\")\n    ringbuf:push(\"c\")\n    ringbuf:push(\"d\")\n    ringbuf:push(\"e\")    -- overrides \"a\"\n    print(ringbuf:pop()) -- returns \"b\"\n    print(ringbuf:pop()) -- returns \"c\"\n\n    -- Can be used as iterator. Pops remaining items:\n    for val in ringbuf do\n      print(val)\n    end\n<\n\nReturns a Ringbuf instance with the following methods:\n\226\128\162 |Ringbuf:push()|\n\226\128\162 |Ringbuf:pop()|\n\226\128\162 |Ringbuf:peek()|\n\226\128\162 |Ringbuf:clear()|\n\nParameters: ~\n  \226\128\162 {size}  (`integer`)\n\nReturn: ~\n    (`vim.Ringbuf`) ringbuf See |vim.Ringbuf|."}}, rpcnotify = {binding = "rpcnotify", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"channel", "method", "?..."}, ["fnl/docstring"] = "Sends {event} to {channel} via |RPC| and returns immediately. If {channel}\nis 0, the event is broadcast to all channels.\n\nThis function also works in a fast callback |lua-loop-callbacks|.\n\nParameters: ~\n  \226\128\162 {channel}  (`integer`)\n  \226\128\162 {method}   (`string`)\n  \226\128\162 {...}      (`any?`)"}}, rpcrequest = {binding = "rpcrequest", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"channel", "method", "?..."}, ["fnl/docstring"] = "Sends a request to {channel} to invoke {method} via |RPC| and blocks until\na response is received.\n\nNote: NIL values as part of the return value is represented as |vim.NIL|\nspecial value\n\nParameters: ~\n  \226\128\162 {channel}  (`integer`)\n  \226\128\162 {method}   (`string`)\n  \226\128\162 {...}      (`any?`)"}}, schedule = {binding = "schedule", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fn"}, ["fnl/docstring"] = "Schedules {fn} to be invoked soon by the main event-loop. Useful to avoid\n|textlock| or other temporary restrictions.\n\nParameters: ~\n  \226\128\162 {fn}  (`fun()`)"}}, schedule_wrap = {binding = "schedule_wrap", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fn"}, ["fnl/docstring"] = "Returns a function which calls {fn} via |vim.schedule()|.\n\nThe returned function passes all arguments to {fn}.\n\nExample: >lua\n    function notify_readable(_err, readable)\n      vim.notify(\"readable? \" .. tostring(readable))\n    end\n    vim.uv.fs_access(vim.fn.stdpath(\"config\"), \"R\", vim.schedule_wrap(notify_readable))\n<\n\nParameters: ~\n  \226\128\162 {fn}  (`function`)\n\nReturn: ~\n    (`function`)\n\nSee also: ~\n  \226\128\162 |lua-loop-callbacks|\n  \226\128\162 |vim.schedule()|\n  \226\128\162 |vim.in_fast_event()|\n\n                                                     "}}, secure = {binding = "secure", fields = {read = {binding = "read", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path"}, ["fnl/docstring"] = "If {path} is a file: attempt to read the file, prompting the user if the\nfile should be trusted.\n\nIf {path} is a directory: return true if the directory is trusted\n(non-recursive), prompting the user as necessary.\n\nThe user's choice is persisted in a trust database at\n$XDG_STATE_HOME/nvim/trust.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {path}  (`string`) Path to a file or directory to read.\n\nReturn: ~\n    (`boolean|string?`) If {path} is not trusted or does not exist,\n    returns `nil`. Otherwise, returns the contents of {path} if it is a\n    file, or true if {path} is a directory.\n\nSee also: ~\n  \226\128\162 |:trust|"}}, trust = {binding = "trust", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"opts", "action"}, ["fnl/docstring"] = "Manage the trust database.\n\nThe trust database is located at |$XDG_STATE_HOME|/nvim/trust.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {opts}  (`table`) A table with the following fields:\n            \226\128\162 {action} (`'allow'|'deny'|'remove'`) - `'allow'` to add a\n              file to the trust database and trust it,\n            \226\128\162 `'deny'` to add a file to the trust database and deny it,\n            \226\128\162 `'remove'` to remove file from the trust database\n            \226\128\162 {path}? (`string`) Path to a file to update. Mutually\n              exclusive with {bufnr}. Cannot be used when {action} is\n              \"allow\".\n            \226\128\162 {bufnr}? (`integer`) Buffer number to update. Mutually\n              exclusive with {path}.\n\nReturn (multiple): ~\n    (`boolean`) success true if operation was successful\n    (`string`) msg full path if operation was successful, else error\n    message"}}}, metadata = {["fls/itemKind"] = "Module"}}, show_pos = {binding = "show_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?row", "?col", "?filter"}, ["fnl/docstring"] = "Show all the items at a given buffer position.\n\nCan also be shown with `:Inspect`.                              *:Inspect*\n\nExample: To bind this function to the vim-scriptease inspired `zS` in\nNormal mode: >lua\n    vim.keymap.set('n', 'zS', vim.show_pos)\n<\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {bufnr}   (`integer?`) defaults to the current buffer\n  \226\128\162 {row}     (`integer?`) row to inspect, 0-based. Defaults to the row of\n              the current cursor\n  \226\128\162 {col}     (`integer?`) col to inspect, 0-based. Defaults to the col of\n              the current cursor\n  \226\128\162 {filter}  (`table?`) A table with the following fields:\n              \226\128\162 {syntax} (`boolean`, default: `true`) Include syntax based\n                highlight groups.\n              \226\128\162 {treesitter} (`boolean`, default: `true`) Include\n                treesitter based highlight groups.\n              \226\128\162 {extmarks} (`boolean|\"all\"`, default: true) Include\n                extmarks. When `all`, then extmarks without a `hl_group`\n                will also be included.\n              \226\128\162 {semantic_tokens} (`boolean`, default: true) Include\n                semantic token highlights."}}, snippet = {binding = "snippet", fields = {active = {binding = "active", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?filter"}, ["fnl/docstring"] = "Returns `true` if there's an active snippet in the current buffer,\napplying the given filter if provided.\n\nParameters: ~\n  \226\128\162 {filter}  (`vim.snippet.ActiveFilter?`) Filter to constrain the search\n              with:\n              \226\128\162 `direction` (vim.snippet.Direction): Navigation direction.\n                Will return `true` if the snippet can be jumped in the\n                given direction. See |vim.snippet.ActiveFilter|.\n\nReturn: ~\n    (`boolean`)"}}, expand = {binding = "expand", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"input"}, ["fnl/docstring"] = "Expands the given snippet text. Refer to\nhttps://microsoft.github.io/language-server-protocol/specification/#snippet_syntax\nfor the specification of valid input.\n\nTabstops are highlighted with |hl-SnippetTabstop|.\n\nParameters: ~\n  \226\128\162 {input}  (`string`)"}}, jump = {binding = "jump", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"direction"}, ["fnl/docstring"] = "Jumps to the next (or previous) placeholder in the current snippet, if\npossible.\n\nBy default `<Tab>` is setup to jump if a snippet is active. The default\nmapping looks like: >lua\n    vim.keymap.set({ 'i', 's' }, '<Tab>', function()\n       if vim.snippet.active({ direction = 1 }) then\n         return '<Cmd>lua vim.snippet.jump(1)<CR>'\n       else\n         return '<Tab>'\n       end\n     end, { descr = '...', expr = true, silent = true })\n<\n\nParameters: ~\n  \226\128\162 {direction}  (`vim.snippet.Direction`) Navigation direction. -1 for\n                 previous, 1 for next."}}, stop = {binding = "stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Exits the current snippet."}}}, metadata = {["fls/itemKind"] = "Module"}}, spairs = {binding = "spairs", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t"}, ["fnl/docstring"] = "Enumerates key-value pairs of a table, ordered by key.\n\nParameters: ~\n  \226\128\162 {t}  (`table`) Dict-like table\n\nReturn (multiple): ~\n    (`fun(table: table<K, V>, index?: K):K, V`) |for-in| iterator over\n    sorted keys and their values\n    (`table`)\n\nSee also: ~\n  \226\128\162 Based on\n    https://github.com/premake/premake-core/blob/master/src/base/table.lua"}}, spell = {binding = "spell", fields = {check = {binding = "check", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Check {str} for spelling errors. Similar to the Vimscript function\n|spellbadword()|.\n\nNote: The behaviour of this function is dependent on: 'spelllang',\n'spellfile', 'spellcapcheck' and 'spelloptions' which can all be local to\nthe buffer. Consider calling this with |nvim_buf_call()|.\n\nExample: >lua\n    vim.spell.check(\"the quik brown fox\")\n    -- =>\n    -- {\n    --     {'quik', 'bad', 5}\n    -- }\n<\n\nParameters: ~\n  \226\128\162 {str}  (`string`)\n\nReturn: ~\n    (`[string, 'bad'|'rare'|'local'|'caps', integer][]`) List of tuples\n    with three items:\n    \226\128\162 The badly spelled word.\n    \226\128\162 The type of the spelling error: \"bad\" spelling mistake \"rare\" rare\n      word \"local\" word only valid in another region \"caps\" word should\n      start with Capital\n    \226\128\162 The position in {str} where the word begins."}}}, metadata = {["fls/itemKind"] = "Module"}}, split = {binding = "split", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s", "sep", "?opts"}, ["fnl/docstring"] = "Splits a string at each instance of a separator and returns the result as\na table (unlike |vim.gsplit()|).\n\nExamples: >lua\n    split(\":aa::b:\", \":\")                   --> {'','aa','','b',''}\n    split(\"axaby\", \"ab?\")                   --> {'','x','y'}\n    split(\"x*yz*o\", \"*\", {plain=true})      --> {'x','yz','o'}\n    split(\"|x|y|z|\", \"|\", {trimempty=true}) --> {'x', 'y', 'z'}\n<\n\nParameters: ~\n  \226\128\162 {s}     (`string`) String to split\n  \226\128\162 {sep}   (`string`) Separator or pattern\n  \226\128\162 {opts}  (`table?`) Keyword arguments |kwargs|:\n            \226\128\162 {plain}? (`boolean`) Use `sep` literally (as in\n              string.find).\n            \226\128\162 {trimempty}? (`boolean`) Discard empty segments at start and\n              end of the sequence.\n\nReturn: ~\n    (`string[]`) List of split components\n\nSee also: ~\n  \226\128\162 |vim.gsplit()|\n  \226\128\162 |string.gmatch()|"}}, startswith = {binding = "startswith", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s", "prefix"}, ["fnl/docstring"] = "Tests if `s` starts with `prefix`.\n\nParameters: ~\n  \226\128\162 {s}       (`string`) String\n  \226\128\162 {prefix}  (`string`) Prefix to match\n\nReturn: ~\n    (`boolean`) `true` if `prefix` is a prefix of `s`"}}, str_byteindex = {binding = "str_byteindex", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s", "encoding", "index", "?strict_indexing"}, ["fnl/docstring"] = "Convert UTF-32, UTF-16 or UTF-8 {index} to byte index. If\n{strict_indexing} is false then then an out of range index will return\nbyte length instead of throwing an error.\n\nInvalid UTF-8 and NUL is treated like in |vim.str_utfindex()|. An {index}\nin the middle of a UTF-16 sequence is rounded upwards to the end of that\nsequence.\n\nParameters: ~\n  \226\128\162 {s}                (`string`)\n  \226\128\162 {encoding}         (`\"utf-8\"|\"utf-16\"|\"utf-32\"`)\n  \226\128\162 {index}            (`integer`)\n  \226\128\162 {strict_indexing}  (`boolean?`) default: true\n\nReturn: ~\n    (`integer`)\n\n                                                      "}}, str_utf_end = {binding = "str_utf_end", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "index"}, ["fnl/docstring"] = "Gets the distance (in bytes) from the last byte of the codepoint\n(character) that {index} points to.\n\nExamples: >lua\n    -- The character '\195\166' is stored as the bytes '\\xc3\\xa6' (using UTF-8)\n\n    -- Returns 0 because the index is pointing at the last byte of a character\n    vim.str_utf_end('\195\166', 2)\n\n    -- Returns 1 because the index is pointing at the penultimate byte of a character\n    vim.str_utf_end('\195\166', 1)\n<\n\nParameters: ~\n  \226\128\162 {str}    (`string`)\n  \226\128\162 {index}  (`integer`)\n\nReturn: ~\n    (`integer`)"}}, str_utf_pos = {binding = "str_utf_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Gets a list of the starting byte positions of each UTF-8 codepoint in the\ngiven string.\n\nEmbedded NUL bytes are treated as terminating the string.\n\nParameters: ~\n  \226\128\162 {str}  (`string`)\n\nReturn: ~\n    (`integer[]`)"}}, str_utf_start = {binding = "str_utf_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "index"}, ["fnl/docstring"] = "Gets the distance (in bytes) from the starting byte of the codepoint\n(character) that {index} points to.\n\nThe result can be added to {index} to get the starting byte of a\ncharacter.\n\nExamples: >lua\n    -- The character '\195\166' is stored as the bytes '\\xc3\\xa6' (using UTF-8)\n\n    -- Returns 0 because the index is pointing at the first byte of a character\n    vim.str_utf_start('\195\166', 1)\n\n    -- Returns -1 because the index is pointing at the second byte of a character\n    vim.str_utf_start('\195\166', 2)\n<\n\nParameters: ~\n  \226\128\162 {str}    (`string`)\n  \226\128\162 {index}  (`integer`)\n\nReturn: ~\n    (`integer`)"}}, str_utfindex = {binding = "str_utfindex", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s", "encoding", "?index", "?strict_indexing"}, ["fnl/docstring"] = "Convert byte index to UTF-32, UTF-16 or UTF-8 indices. If {index} is not\nsupplied, the length of the string is used. All indices are zero-based.\n\nIf {strict_indexing} is false then an out of range index will return\nstring length instead of throwing an error. Invalid UTF-8 bytes, and\nembedded surrogates are counted as one code point each. An {index} in the\nmiddle of a UTF-8 sequence is rounded upwards to the end of that sequence.\n\nParameters: ~\n  \226\128\162 {s}                (`string`)\n  \226\128\162 {encoding}         (`\"utf-8\"|\"utf-16\"|\"utf-32\"`)\n  \226\128\162 {index}            (`integer?`)\n  \226\128\162 {strict_indexing}  (`boolean?`) default: true\n\nReturn: ~\n    (`integer`)"}}, stricmp = {binding = "stricmp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"a", "b"}, ["fnl/docstring"] = "Compares strings case-insensitively.\n\nParameters: ~\n  \226\128\162 {a}  (`string`)\n  \226\128\162 {b}  (`string`)\n\nReturn: ~\n    (`0|1|-1`) if strings are equal, {a} is greater than {b} or {a} is\n    lesser than {b}, respectively."}}, system = {binding = "system", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cmd", "?opts", "?on_exit"}, ["fnl/docstring"] = "Runs a system command or throws an error if {cmd} cannot be run.\n\nExamples: >lua\n    local on_exit = function(obj)\n      print(obj.code)\n      print(obj.signal)\n      print(obj.stdout)\n      print(obj.stderr)\n    end\n\n    -- Runs asynchronously:\n    vim.system({'echo', 'hello'}, { text = true }, on_exit)\n\n    -- Runs synchronously:\n    local obj = vim.system({'echo', 'hello'}, { text = true }):wait()\n    -- { code = 0, signal = 0, stdout = 'hello\\n', stderr = '' }\n<\n\nSee |uv.spawn()| for more details. Note: unlike |uv.spawn()|, vim.system\nthrows an error if {cmd} cannot be run.\n\nParameters: ~\n  \226\128\162 {cmd}      (`string[]`) Command to execute\n  \226\128\162 {opts}     (`vim.SystemOpts?`) Options:\n               \226\128\162 cwd: (string) Set the current working directory for the\n                 sub-process.\n               \226\128\162 env: table<string,string> Set environment variables for\n                 the new process. Inherits the current environment with\n                 `NVIM` set to |v:servername|.\n               \226\128\162 clear_env: (boolean) `env` defines the job environment\n                 exactly, instead of merging current environment. Note: if\n                 `env` is `nil`, the current environment is used but\n                 without `NVIM` set.\n               \226\128\162 stdin: (string|string[]|boolean) If `true`, then a pipe\n                 to stdin is opened and can be written to via the\n                 `write()` method to SystemObj. If string or string[] then\n                 will be written to stdin and closed. Defaults to `false`.\n               \226\128\162 stdout: (boolean|function) Handle output from stdout.\n                 When passed as a function must have the signature\n                 `fun(err: string, data: string)`. Defaults to `true`\n               \226\128\162 stderr: (boolean|function) Handle output from stderr.\n                 When passed as a function must have the signature\n                 `fun(err: string, data: string)`. Defaults to `true`.\n               \226\128\162 text: (boolean) Handle stdout and stderr as text.\n                 Replaces `\\r\\n` with `\\n`.\n               \226\128\162 timeout: (integer) Run the command with a time limit.\n                 Upon timeout the process is sent the TERM signal (15) and\n                 the exit code is set to 124.\n               \226\128\162 detach: (boolean) If true, spawn the child process in a\n                 detached state - this will make it a process group\n                 leader, and will effectively enable the child to keep\n                 running after the parent exits. Note that the child\n                 process will still keep the parent's event loop alive\n                 unless the parent process calls |uv.unref()| on the\n                 child's process handle.\n  \226\128\162 {on_exit}  (`fun(out: vim.SystemCompleted)?`) Called when subprocess\n               exits. When provided, the command runs asynchronously.\n               Receives SystemCompleted object, see return of\n               SystemObj:wait().\n\nReturn: ~\n    (`vim.SystemObj`) Object with the fields:\n    \226\128\162 cmd (string[]) Command name and args\n    \226\128\162 pid (integer) Process ID\n    \226\128\162 wait (fun(timeout: integer|nil): SystemCompleted) Wait for the\n      process to complete. Upon timeout the process is sent the KILL\n      signal (9) and the exit code is set to 124. Cannot be called in\n      |api-fast|.\n      \226\128\162 SystemCompleted is an object with the fields:\n        \226\128\162 code: (integer)\n        \226\128\162 signal: (integer)\n        \226\128\162 stdout: (string), nil if stdout argument is passed\n        \226\128\162 stderr: (string), nil if stderr argument is passed\n    \226\128\162 kill (fun(signal: integer|string))\n    \226\128\162 write (fun(data: string|nil)) Requires `stdin=true`. Pass `nil` to\n      close the stream.\n    \226\128\162 is_closing (fun(): boolean)"}}, t = {binding = "t", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Tabpage-scoped (|t:|) variables for the current tabpage.\nInvalid or unset key returns `nil`. Can be indexed with\nan integer to access variables for a specific tabpage."}}, tbl_contains = {binding = "tbl_contains", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t", "value", "?opts"}, ["fnl/docstring"] = "Checks if a table contains a given value, specified either directly or via\na predicate that is checked for each value.\n\nExample: >lua\n    vim.tbl_contains({ 'a', { 'b', 'c' } }, function(v)\n      return vim.deep_equal(v, { 'b', 'c' })\n    end, { predicate = true })\n    -- true\n<\n\nParameters: ~\n  \226\128\162 {t}      (`table`) Table to check\n  \226\128\162 {value}  (`any`) Value to compare or predicate function reference\n  \226\128\162 {opts}   (`table?`) Keyword arguments |kwargs|:\n             \226\128\162 {predicate}? (`boolean`) `value` is a function reference to\n               be checked (default false)\n\nReturn: ~\n    (`boolean`) `true` if `t` contains `value`\n\nSee also: ~\n  \226\128\162 |vim.list_contains()| for checking values in list-like tables"}}, tbl_count = {binding = "tbl_count", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t"}, ["fnl/docstring"] = "Counts the number of non-nil values in table `t`. >lua\n    vim.tbl_count({ a=1, b=2 })  --> 2\n    vim.tbl_count({ 1, 2 })      --> 2\n<\n\nParameters: ~\n  \226\128\162 {t}  (`table`) Table\n\nReturn: ~\n    (`integer`) Number of non-nil values in table\n\nSee also: ~\n  \226\128\162 https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua"}}, tbl_deep_extend = {binding = "tbl_deep_extend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"behavior", "..."}, ["fnl/docstring"] = "Merges recursively two or more tables.\n\nOnly values that are empty tables or tables that are not |lua-list|s\n(indexed by consecutive integers starting from 1) are merged recursively.\nThis is useful for merging nested tables like default and user\nconfigurations where lists should be treated as literals (i.e., are\noverwritten instead of merged).\n\nParameters: ~\n  \226\128\162 {behavior}  (`'error'|'keep'|'force'`) Decides what to do if a key is\n                found in more than one map:\n                \226\128\162 \"error\": raise an error\n                \226\128\162 \"keep\": use value from the leftmost map\n                \226\128\162 \"force\": use value from the rightmost map\n  \226\128\162 {...}       (`table`) Two or more tables\n\nReturn: ~\n    (`table`) Merged table\n\nSee also: ~\n  \226\128\162 |vim.tbl_extend()|"}}, tbl_extend = {binding = "tbl_extend", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"behavior", "..."}, ["fnl/docstring"] = "Merges two or more tables.\n\nParameters: ~\n  \226\128\162 {behavior}  (`'error'|'keep'|'force'`) Decides what to do if a key is\n                found in more than one map:\n                \226\128\162 \"error\": raise an error\n                \226\128\162 \"keep\": use value from the leftmost map\n                \226\128\162 \"force\": use value from the rightmost map\n  \226\128\162 {...}       (`table`) Two or more tables\n\nReturn: ~\n    (`table`) Merged table\n\nSee also: ~\n  \226\128\162 |extend()|"}}, tbl_filter = {binding = "tbl_filter", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"func", "t"}, ["fnl/docstring"] = "Filter a table using a predicate function\n\nParameters: ~\n  \226\128\162 {func}  (`function`) Function\n  \226\128\162 {t}     (`table`) Table\n\nReturn: ~\n    (`any[]`) Table of filtered values"}}, tbl_get = {binding = "tbl_get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"o", "..."}, ["fnl/docstring"] = "Index into a table (first argument) via string keys passed as subsequent\narguments. Return `nil` if the key does not exist.\n\nExamples: >lua\n    vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true\n    vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil\n<\n\nParameters: ~\n  \226\128\162 {o}    (`table`) Table to index\n  \226\128\162 {...}  (`any`) Optional keys (0 or more, variadic) via which to index\n           the table\n\nReturn: ~\n    (`any`) Nested value indexed by key (if it exists), else nil"}}, tbl_isempty = {binding = "tbl_isempty", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t"}, ["fnl/docstring"] = "Checks if a table is empty.\n\nParameters: ~\n  \226\128\162 {t}  (`table`) Table to check\n\nReturn: ~\n    (`boolean`) `true` if `t` is empty\n\nSee also: ~\n  \226\128\162 https://github.com/premake/premake-core/blob/master/src/base/table.lua"}}, tbl_keys = {binding = "tbl_keys", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t"}, ["fnl/docstring"] = "Return a list of all keys used in a table. However, the order of the\nreturn table of keys is not guaranteed.\n\nParameters: ~\n  \226\128\162 {t}  (`table`) Table\n\nReturn: ~\n    (`any[]`) List of keys\n\nSee also: ~\n  \226\128\162 From\n    https://github.com/premake/premake-core/blob/master/src/base/table.lua"}}, tbl_map = {binding = "tbl_map", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"func", "t"}, ["fnl/docstring"] = "Apply a function to all values of a table.\n\nParameters: ~\n  \226\128\162 {func}  (`fun(value: T): any`) Function\n  \226\128\162 {t}     (`table<any, T>`) Table\n\nReturn: ~\n    (`table`) Table of transformed values"}}, tbl_values = {binding = "tbl_values", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"t"}, ["fnl/docstring"] = "Return a list of all values used in a table. However, the order of the\nreturn table of values is not guaranteed.\n\nParameters: ~\n  \226\128\162 {t}  (`table`) Table\n\nReturn: ~\n    (`any[]`) List of values"}}, text = {binding = "text", fields = {hexdecode = {binding = "hexdecode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"enc"}, ["fnl/docstring"] = "Hex decode a string.\n\nParameters: ~\n  \226\128\162 {enc}  (`string`) String to decode\n\nReturn (multiple): ~\n    (`string?`) Decoded string\n    (`string?`) Error message, if any"}}, hexencode = {binding = "hexencode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "Hex encode a string.\n\nParameters: ~\n  \226\128\162 {str}  (`string`) String to encode\n\nReturn: ~\n    (`string`) Hex encoded string"}}, indent = {binding = "indent", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"size", "text", "?opts"}, ["fnl/docstring"] = "Sets the indent (i.e. the common leading whitespace) of non-empty lines in\n`text` to `size` spaces/tabs.\n\nIndent is calculated by number of consecutive indent chars.\n\226\128\162 The first indented, non-empty line decides the indent char (space/tab):\n  \226\128\162 `SPC SPC TAB \226\128\166` = two-space indent.\n  \226\128\162 `TAB SPC \226\128\166` = one-tab indent.\n\226\128\162 Set `opts.expandtab` to treat tabs as spaces.\n\nTo \"dedent\" (remove the common indent), pass `size=0`: >lua\n    vim.print(vim.text.indent(0, ' a\\n  b\\n'))\n<\n\nTo adjust relative-to an existing indent, call indent() twice: >lua\n    local indented, old_indent = vim.text.indent(0, ' a\\n b\\n')\n    indented = vim.text.indent(old_indent + 2, indented)\n    vim.print(indented)\n<\n\nTo ignore the final, blank line when calculating the indent, use gsub()\nbefore calling indent(): >lua\n    local text = '  a\\n  b\\n '\n    vim.print(vim.text.indent(0, (text:gsub('\\n[\\t ]+\\n?$', '\\n'))))\n<\n\nParameters: ~\n  \226\128\162 {size}  (`integer`) Number of spaces.\n  \226\128\162 {text}  (`string`) Text to indent.\n  \226\128\162 {opts}  (`{ expandtab?: number }?`)\n\nReturn (multiple): ~\n    (`string`) Indented text.\n    (`integer`) Indent size before modification."}}}, metadata = {["fls/itemKind"] = "Module"}}, treesitter = {binding = "treesitter", fields = {foldexpr = {binding = "foldexpr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?lnum"}, ["fnl/docstring"] = "Returns the fold level for {lnum} in the current buffer. Can be set\ndirectly to 'foldexpr': >lua\n    vim.wo.foldexpr = 'v:lua.vim.treesitter.foldexpr()'\n<\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {lnum}  (`integer?`) Line number to calculate fold level for\n\nReturn: ~\n    (`string`)\n\n                                 "}}, get_captures_at_cursor = {binding = "get_captures_at_cursor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?winnr"}, ["fnl/docstring"] = "Returns a list of highlight capture names under the cursor\n\nParameters: ~\n  \226\128\162 {winnr}  (`integer?`) |window-ID| or 0 for current window (default)\n\nReturn: ~\n    (`string[]`) List of capture names\n\n                                    "}}, get_captures_at_pos = {binding = "get_captures_at_pos", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr", "row", "col"}, ["fnl/docstring"] = "Returns a list of highlight captures at the given position\n\nEach capture is represented by a table containing the capture name as a\nstring, the capture's language, a table of metadata (`priority`,\n`conceal`, ...; empty if none are defined), and the id of the capture.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer`) Buffer number (0 for current buffer)\n  \226\128\162 {row}    (`integer`) Position row\n  \226\128\162 {col}    (`integer`) Position column\n\nReturn: ~\n    (`{capture: string, lang: string, metadata: vim.treesitter.query.TSMetadata, id: integer}[]`)"}}, get_node = {binding = "get_node", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts", "?bufnr", "?pos", "?lang", "?ignore_injections", "?include_anonymous"}, ["fnl/docstring"] = "Returns the smallest named node at the given position\n\nNOTE: Calling this on an unparsed tree can yield an invalid node. If the\ntree is not known to be parsed by, e.g., an active highlighter, parse the\ntree first via >lua\n    vim.treesitter.get_parser(bufnr):parse(range)\n<\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) Optional keyword arguments:\n            \226\128\162 {bufnr} (`integer?`) Buffer number (nil or 0 for current\n              buffer)\n            \226\128\162 {pos} (`[integer, integer]?`) 0-indexed (row, col) tuple.\n              Defaults to cursor position in the current window. Required\n              if {bufnr} is not the current buffer\n            \226\128\162 {lang} (`string?`) Parser language. (default: from buffer\n              filetype)\n            \226\128\162 {ignore_injections} (`boolean?`) Ignore injected languages\n              (default true)\n            \226\128\162 {include_anonymous} (`boolean?`) Include anonymous nodes\n              (default false)\n\nReturn: ~\n    (`TSNode?`) Node at the given position"}}, get_node_range = {binding = "get_node_range", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"node_or_range"}, ["fnl/docstring"] = "Returns the node's range or an unpacked range table\n\nParameters: ~\n  \226\128\162 {node_or_range}  (`TSNode|Range4`) Node or table of positions\n\nReturn (multiple): ~\n    (`integer`) start_row\n    (`integer`) start_col\n    (`integer`) end_row\n    (`integer`) end_col\n\n                                          "}}, get_node_text = {binding = "get_node_text", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"node", "source", "?opts"}, ["fnl/docstring"] = "Gets the text corresponding to a given node\n\nParameters: ~\n  \226\128\162 {node}    (`TSNode`)\n  \226\128\162 {source}  (`integer|string`) Buffer or string from which the {node} is\n              extracted\n  \226\128\162 {opts}    (`table?`) Optional parameters.\n              \226\128\162 metadata (table) Metadata of a specific capture. This\n                would be set to `metadata[capture_id]` when using\n                |vim.treesitter.query.add_directive()|.\n\nReturn: ~\n    (`string`)"}}, get_parser = {binding = "get_parser", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?lang", "?opts"}, ["fnl/docstring"] = "Returns the parser for a specific buffer and attaches it to the buffer\n\nIf needed, this will create the parser.\n\nIf no parser can be created, an error is thrown. Set `opts.error = false`\nto suppress this and return nil (and an error message) instead. WARNING:\nThis behavior will become default in Nvim 0.12 and the option will be\nremoved.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer the parser should be tied to (default:\n             current buffer)\n  \226\128\162 {lang}   (`string?`) Language of this parser (default: from buffer\n             filetype)\n  \226\128\162 {opts}   (`table?`) Options to pass to the created language tree\n\nReturn (multiple): ~\n    (`vim.treesitter.LanguageTree?`) object to use for parsing\n    (`string?`) error message, if applicable"}}, get_range = {binding = "get_range", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"node", "?source", "?metadata"}, ["fnl/docstring"] = "Get the range of a |TSNode|. Can also supply {source} and {metadata} to\nget the range with directives applied.\n\nParameters: ~\n  \226\128\162 {node}      (`TSNode`)\n  \226\128\162 {source}    (`integer|string?`) Buffer or string from which the {node}\n                is extracted\n  \226\128\162 {metadata}  (`vim.treesitter.query.TSMetadata?`)\n\nReturn: ~\n    (`table`) A table with the following fields:\n    \226\128\162 {[1]} (`integer`) start row\n    \226\128\162 {[2]} (`integer`) start column\n    \226\128\162 {[3]} (`integer`) start bytes\n    \226\128\162 {[4]} (`integer`) end row\n    \226\128\162 {[5]} (`integer`) end column\n    \226\128\162 {[6]} (`integer`) end bytes\n\n                                      "}}, get_string_parser = {binding = "get_string_parser", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "lang", "?opts"}, ["fnl/docstring"] = "Returns a string parser\n\nParameters: ~\n  \226\128\162 {str}   (`string`) Text to parse\n  \226\128\162 {lang}  (`string`) Language of this string\n  \226\128\162 {opts}  (`table?`) Options to pass to the created language tree\n\nReturn: ~\n    (`vim.treesitter.LanguageTree`) object to use for parsing"}}, inspect_tree = {binding = "inspect_tree", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts"}, ["fnl/docstring"] = "Open a window that displays a textual representation of the nodes in the\nlanguage tree.\n\nWhile in the window, press \"a\" to toggle display of anonymous nodes, \"I\"\nto toggle the display of the source language of each node, \"o\" to toggle\nthe query editor, and press <Enter> to jump to the node under the cursor\nin the source buffer. Folding also works (try |zo|, |zc|, etc.).\n\nCan also be shown with `:InspectTree`.                      *:InspectTree*\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {opts}  (`table?`) Optional options table with the following possible\n            keys:\n            \226\128\162 lang (string|nil): The language of the source buffer. If\n              omitted, detect from the filetype of the source buffer.\n            \226\128\162 bufnr (integer|nil): Buffer to draw the tree into. If\n              omitted, a new buffer is created.\n            \226\128\162 winid (integer|nil): Window id to display the tree buffer\n              in. If omitted, a new window is created with {command}.\n            \226\128\162 command (string|nil): Vimscript command to create the\n              window. Default value is \"60vnew\". Only used when {winid} is\n              nil.\n            \226\128\162 title (string|fun(bufnr:integer):string|nil): Title of the\n              window. If a function, it accepts the buffer number of the\n              source buffer as its only argument and should return a\n              string."}}, is_ancestor = {binding = "is_ancestor", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dest", "source"}, ["fnl/docstring"] = "Determines whether a node is the ancestor of another\n\nParameters: ~\n  \226\128\162 {dest}    (`TSNode`) Possible ancestor\n  \226\128\162 {source}  (`TSNode`) Possible descendant\n\nReturn: ~\n    (`boolean`) True if {dest} is an ancestor of {source}\n\n                                       "}}, is_in_node_range = {binding = "is_in_node_range", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"node", "line", "col"}, ["fnl/docstring"] = "Determines whether (line, col) position is in node range\n\nParameters: ~\n  \226\128\162 {node}  (`TSNode`) defining the range\n  \226\128\162 {line}  (`integer`) Line (0-based)\n  \226\128\162 {col}   (`integer`) Column (0-based)\n\nReturn: ~\n    (`boolean`) True if the position is in node range"}}, language = {binding = "language", fields = {add = {binding = "add", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang", "?opts"}, ["fnl/docstring"] = "Load parser with name {lang}\n\nParsers are searched in the `parser` runtime directory, or the provided\n{path}. Can be used to check for available parsers before enabling\ntreesitter features, e.g., >lua\n      if vim.treesitter.language.add('markdown') then\n        vim.treesitter.start(bufnr, 'markdown')\n      end\n<\n\nParameters: ~\n  \226\128\162 {lang}  (`string`) Name of the parser (alphanumerical and `_` only)\n  \226\128\162 {opts}  (`table?`) Options:\n            \226\128\162 {path}? (`string`) Optional path the parser is located at\n            \226\128\162 {symbol_name}? (`string`) Internal symbol name for the\n              language to load\n\nReturn (multiple): ~\n    (`boolean?`) True if parser is loaded\n    (`string?`) Error if parser cannot be loaded"}}, get_filetypes = {binding = "get_filetypes", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang"}, ["fnl/docstring"] = "Returns the filetypes for which a parser named {lang} is used.\n\nThe list includes {lang} itself plus all filetypes registered via\n|vim.treesitter.language.register()|.\n\nParameters: ~\n  \226\128\162 {lang}  (`string`) Name of parser\n\nReturn: ~\n    (`string[]`) filetypes"}}, get_lang = {binding = "get_lang", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"filetype"}, ["fnl/docstring"] = "Returns the language name to be used when loading a parser for {filetype}.\n\nIf no language has been explicitly registered via\n|vim.treesitter.language.register()|, default to {filetype}. For composite\nfiletypes like `html.glimmer`, only the main filetype is returned.\n\nParameters: ~\n  \226\128\162 {filetype}  (`string`)\n\nReturn: ~\n    (`string?`)"}}, inspect = {binding = "inspect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang"}, ["fnl/docstring"] = "Inspects the provided language.\n\nInspecting provides some useful information on the language like ABI\nversion, parser state count (a measure of parser complexity), node and\nfield names, and whether the language came from a WASM module.\n\nNode names are returned in a table mapping each node name to a `boolean`\nindicating whether or not the node is named (i.e., not anonymous).\nAnonymous nodes are surrounded with double quotes (`\"`).\n\nFor ABI 15 parsers, also show parser metadata (major, minor, patch\nversion) and a table of supertypes with their respective subtypes.\n\nParameters: ~\n  \226\128\162 {lang}  (`string`) Language\n\nReturn: ~\n    (`TSLangInfo`)"}}, register = {binding = "register", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang", "filetype"}, ["fnl/docstring"] = "Register a parser named {lang} to be used for {filetype}(s).\n\nNote: this adds or overrides the mapping for {filetype}, any existing\nmappings from other filetypes to {lang} will be preserved.\n\nParameters: ~\n  \226\128\162 {lang}      (`string`) Name of parser\n  \226\128\162 {filetype}  (`string|string[]`) Filetype(s) to associate with lang"}}}, metadata = {["fls/itemKind"] = "Module"}}, node_contains = {binding = "node_contains", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"node", "range"}, ["fnl/docstring"] = "Determines if a node contains a range\n\nParameters: ~\n  \226\128\162 {node}   (`TSNode`)\n  \226\128\162 {range}  (`table`)\n\nReturn: ~\n    (`boolean`) True if the {node} contains the {range}"}}, query = {binding = "query", fields = {add_directive = {binding = "add_directive", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "handler", "opts"}, ["fnl/docstring"] = "Adds a new directive to be used in queries\n\nHandlers can set match level data by setting directly on the metadata\nobject `metadata.key = value`. Additionally, handlers can set node level\ndata by using the capture id on the metadata table\n`metadata[capture_id].key = value`\n\nParameters: ~\n  \226\128\162 {name}     (`string`) Name of the directive, without leading #\n  \226\128\162 {handler}  (`fun(match: table<integer,TSNode[]>, pattern: integer, source: integer|string, predicate: any[], metadata: vim.treesitter.query.TSMetadata)`)\n               \226\128\162 match: A table mapping capture IDs to a list of captured\n                 nodes\n               \226\128\162 pattern: the index of the matching pattern in the query\n                 file\n               \226\128\162 predicate: list of strings containing the full directive\n                 being called, e.g. `(node (#set! conceal \"-\"))` would get\n                 the predicate `{ \"#set!\", \"conceal\", \"-\" }`\n  \226\128\162 {opts}     (`table`) A table with the following fields:\n               \226\128\162 {force}? (`boolean`) Override an existing predicate of\n                 the same name\n               \226\128\162 {all}? (`boolean`) Use the correct implementation of the\n                 match table where capture IDs map to a list of nodes\n                 instead of a single node. Defaults to true. This option\n                 will be removed in a future release.\n\n                                    "}}, add_predicate = {binding = "add_predicate", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "?handler", "?opts"}, ["fnl/docstring"] = "Adds a new predicate to be used in queries\n\nParameters: ~\n  \226\128\162 {name}     (`string`) Name of the predicate, without leading #\n  \226\128\162 {handler}  (`fun(match: table<integer,TSNode[]>, pattern: integer, source: integer|string, predicate: any[], metadata: vim.treesitter.query.TSMetadata): boolean?`)\n               \226\128\162 see |vim.treesitter.query.add_directive()| for argument\n                 meanings\n  \226\128\162 {opts}     (`table?`) A table with the following fields:\n               \226\128\162 {force}? (`boolean`) Override an existing predicate of\n                 the same name\n               \226\128\162 {all}? (`boolean`) Use the correct implementation of the\n                 match table where capture IDs map to a list of nodes\n                 instead of a single node. Defaults to true. This option\n                 will be removed in a future release."}}, edit = {binding = "edit", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?lang"}, ["fnl/docstring"] = "Opens a live editor to query the buffer you started from.\n\nCan also be shown with *:EditQuery*.\n\nIf you move the cursor to a capture name (\"@foo\"), text matching the\ncapture is highlighted in the source buffer. The query editor is a scratch\nbuffer, use `:write` to save it. You can find example queries at\n`$VIMRUNTIME/queries/`.\n\nParameters: ~\n  \226\128\162 {lang}  (`string?`) language to open the query editor for. If omitted,\n            inferred from the current buffer's filetype."}}, get = {binding = "get", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang", "query_name"}, ["fnl/docstring"] = "Returns the runtime query {query_name} for {lang}.\n\nParameters: ~\n  \226\128\162 {lang}        (`string`) Language to use for the query\n  \226\128\162 {query_name}  (`string`) Name of the query (e.g. \"highlights\")\n\nReturn: ~\n    (`vim.treesitter.Query?`) Parsed query. `nil` if no query files are\n    found. See |vim.treesitter.Query|.\n\n                                        "}}, get_files = {binding = "get_files", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang", "query_name", "?is_included"}, ["fnl/docstring"] = "Gets the list of files used to make up a query\n\nParameters: ~\n  \226\128\162 {lang}         (`string`) Language to get query for\n  \226\128\162 {query_name}   (`string`) Name of the query to load (e.g.,\n                   \"highlights\")\n  \226\128\162 {is_included}  (`boolean?`) Internal parameter, most of the time left\n                   as `nil`\n\nReturn: ~\n    (`string[]`) query_files List of files to load for given query and\n    language"}}, lint = {binding = "lint", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"buf", "?opts", "clear"}, ["fnl/docstring"] = "Lint treesitter queries using installed parser, or clear lint errors.\n\nUse |treesitter-parsers| in runtimepath to check the query file in {buf}\nfor errors:\n\226\128\162 verify that used nodes are valid identifiers in the grammar.\n\226\128\162 verify that predicates and directives are valid.\n\226\128\162 verify that top-level s-expressions are valid.\n\nThe found diagnostics are reported using |diagnostic-api|. By default, the\nparser used for verification is determined by the containing folder of the\nquery file, e.g., if the path ends in `/lua/highlights.scm`, the parser\nfor the `lua` language will be used.\n\nParameters: ~\n  \226\128\162 {buf}   (`integer`) Buffer handle\n  \226\128\162 {opts}  (`table?`) Optional keyword arguments:\n            \226\128\162 {langs}? (`string|string[]`) Language(s) to use for checking\n              the query. If multiple languages are specified, queries are\n              validated for all of them\n            \226\128\162 {clear} (`boolean`) Just clear current lint errors"}}, list_directives = {binding = "list_directives", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Lists the currently available directives to use in queries.\n\nReturn: ~\n    (`string[]`) Supported directives."}}, list_predicates = {binding = "list_predicates", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Lists the currently available predicates to use in queries.\n\nReturn: ~\n    (`string[]`) Supported predicates."}}, omnifunc = {binding = "omnifunc", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"findstart", "base"}, ["fnl/docstring"] = "Omnifunc for completing node names and predicates in treesitter queries.\n\nUse via >lua\n    vim.bo.omnifunc = 'v:lua.vim.treesitter.query.omnifunc'\n<\n\nParameters: ~\n  \226\128\162 {findstart}  (`0|1`)\n  \226\128\162 {base}       (`string`)"}}, parse = {binding = "parse", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang", "query"}, ["fnl/docstring"] = "Parses a {query} string and returns a `Query` object\n(|lua-treesitter-query|), which can be used to search the tree for the\nquery patterns (via |Query:iter_captures()|, |Query:iter_matches()|), or\ninspect/modify the query via these fields:\n\226\128\162 `captures`: a list of unique capture names defined in the query (alias:\n  `info.captures`).\n\226\128\162 `info.patterns`: information about predicates.\n\226\128\162 `query`: the underlying |TSQuery| which can be used to disable patterns\n  or captures.\n\nExample: >lua\n    local query = vim.treesitter.query.parse('vimdoc', [[\n      ; query\n      ((h1) @str\n        (#trim! @str 1 1 1 1))\n    ]])\n    local tree = vim.treesitter.get_parser():parse()[1]\n    for id, node, metadata in query:iter_captures(tree:root(), 0) do\n       -- Print the node name and source text.\n       vim.print({node:type(), vim.treesitter.get_node_text(node, vim.api.nvim_get_current_buf())})\n    end\n<\n\nParameters: ~\n  \226\128\162 {lang}   (`string`) Language to use for the query\n  \226\128\162 {query}  (`string`) Query text, in s-expr syntax\n\nReturn: ~\n    (`vim.treesitter.Query`) Parsed query . See |vim.treesitter.Query|.\n\nSee also: ~\n  \226\128\162 |vim.treesitter.query.get()|\n\n                                                   *Query:iter_captures()*\nQuery:iter_captures({node}, {source}, {start}, {stop}, {opts})\nIterates over all captures from all matches in {node}.\n\n{source} is required if the query contains predicates; then the caller\nmust ensure to use a freshly parsed tree consistent with the current text\nof the buffer (if relevant). {start} and {stop} can be used to limit\nmatches inside a row range (this is typically used with root node as the\n{node}, i.e., to get syntax highlight matches in the current viewport).\nWhen omitted, the {start} and {stop} row values are used from the given\nnode.\n\nThe iterator returns four values:\n1. the numeric id identifying the capture\n2. the captured node\n3. metadata from any directives processing the match\n4. the match itself\n\nExample: how to get captures by name: >lua\n    for id, node, metadata, match in query:iter_captures(tree:root(), bufnr, first, last) do\n      local name = query.captures[id] -- name of the capture in the query\n      -- typically useful info about the node:\n      local type = node:type() -- type of the captured node\n      local row1, col1, row2, col2 = node:range() -- range of the capture\n      -- ... use the info here ...\n    end\n<\n\nNote: ~\n  \226\128\162 Captures are only returned if the query pattern of a specific capture\n    contained predicates.\n\nParameters: ~\n  \226\128\162 {node}    (`TSNode`) under which the search will occur\n  \226\128\162 {source}  (`integer|string`) Source buffer or string to extract text\n              from\n  \226\128\162 {start}   (`integer?`) Starting line for the search. Defaults to\n              `node:start()`.\n  \226\128\162 {stop}    (`integer?`) Stopping line for the search (end-exclusive).\n              Defaults to `node:end_()`.\n  \226\128\162 {opts}    (`table?`) Optional keyword arguments:\n              \226\128\162 max_start_depth (integer) if non-zero, sets the maximum\n                start depth for each match. This is used to prevent\n                traversing too deep into a tree.\n              \226\128\162 match_limit (integer) Set the maximum number of\n                in-progress matches (Default: 256).\n\nReturn: ~\n    (`fun(end_line: integer?): integer, TSNode, vim.treesitter.query.TSMetadata, TSQueryMatch, TSTree`)\n    capture id, capture node, metadata, match, tree\n\n                                                    *Query:iter_matches()*\nQuery:iter_matches({node}, {source}, {start}, {stop}, {opts})\nIterates the matches of self on a given range.\n\nIterate over all matches within a {node}. The arguments are the same as\nfor |Query:iter_captures()| but the iterated values are different: an\n(1-based) index of the pattern in the query, a table mapping capture\nindices to a list of nodes, and metadata from any directives processing\nthe match.\n\nExample: >lua\n    for pattern, match, metadata in cquery:iter_matches(tree:root(), bufnr, 0, -1) do\n      for id, nodes in pairs(match) do\n        local name = query.captures[id]\n        for _, node in ipairs(nodes) do\n          -- `node` was captured by the `name` capture in the match\n\n          local node_data = metadata[id] -- Node level metadata\n          -- ... use the info here ...\n        end\n      end\n    end\n<\n\nParameters: ~\n  \226\128\162 {node}    (`TSNode`) under which the search will occur\n  \226\128\162 {source}  (`integer|string`) Source buffer or string to search\n  \226\128\162 {start}   (`integer?`) Starting line for the search. Defaults to\n              `node:start()`.\n  \226\128\162 {stop}    (`integer?`) Stopping line for the search (end-exclusive).\n              Defaults to `node:end_()`.\n  \226\128\162 {opts}    (`table?`) Optional keyword arguments:\n              \226\128\162 max_start_depth (integer) if non-zero, sets the maximum\n                start depth for each match. This is used to prevent\n                traversing too deep into a tree.\n              \226\128\162 match_limit (integer) Set the maximum number of\n                in-progress matches (Default: 256). all (boolean) When\n                `false` (default `true`), the returned table maps capture\n                IDs to a single (last) node instead of the full list of\n                matching nodes. This option is only for backward\n                compatibility and will be removed in a future release.\n\nReturn: ~\n    (`fun(): integer, table<integer, TSNode[]>, vim.treesitter.query.TSMetadata, TSTree`)\n    pattern id, match, metadata, tree"}}, set = {binding = "set", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"lang", "query_name", "text"}, ["fnl/docstring"] = "Sets the runtime query named {query_name} for {lang}\n\nThis allows users to override or extend any runtime files and/or\nconfiguration set by plugins.\n\nFor example, you could enable spellchecking of `C` identifiers with the\nfollowing code: >lua\n    vim.treesitter.query.set(\n      'c',\n      'highlights',\n      [[;inherits c\n      (identifier) @spell]])\n    ]])\n<\n\nParameters: ~\n  \226\128\162 {lang}        (`string`) Language to use for the query\n  \226\128\162 {query_name}  (`string`) Name of the query (e.g., \"highlights\")\n  \226\128\162 {text}        (`string`) Query text (unparsed)."}}}, metadata = {["fls/itemKind"] = "Module"}}, start = {binding = "start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr", "?lang"}, ["fnl/docstring"] = "Starts treesitter highlighting for a buffer\n\nCan be used in an ftplugin or FileType autocommand.\n\nNote: By default, disables regex syntax highlighting, which may be\nrequired for some plugins. In this case, add `vim.bo.syntax = 'on'` after\nthe call to `start`.\n\nNote: By default, the highlighter parses code asynchronously, using a\nsegment time of 3ms.\n\nExample: >lua\n    vim.api.nvim_create_autocmd( 'FileType', { pattern = 'tex',\n        callback = function(args)\n            vim.treesitter.start(args.buf, 'latex')\n            vim.bo[args.buf].syntax = 'on'  -- only if additional legacy syntax is needed\n        end\n    })\n<\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer to be highlighted (default: current\n             buffer)\n  \226\128\162 {lang}   (`string?`) Language of the parser (default: from buffer\n             filetype)"}}, stop = {binding = "stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?bufnr"}, ["fnl/docstring"] = "Stops treesitter highlighting for a buffer\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer?`) Buffer to stop highlighting (default: current\n             buffer)"}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "Treesitter integration\nNvim integrates the tree-sitter library for incremental parsing of buffers:\nhttps://tree-sitter.github.io/tree-sitter/\nWARNING: Treesitter support is still experimental and subject to frequent\nchanges. This documentation may also not fully reflect the latest changes."}}, trim = {binding = "trim", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"s"}, ["fnl/docstring"] = "Trim whitespace (Lua pattern \"%s\") from both sides of a string.\n\nParameters: ~\n  \226\128\162 {s}  (`string`) String to trim\n\nReturn: ~\n    (`string`) String with whitespace removed from its beginning and end\n\nSee also: ~\n  \226\128\162 |lua-pattern|s\n  \226\128\162 https://www.lua.org/pil/20.2.html\n\n                                                          "}}, type_idx = {binding = "type_idx", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Type index for use in |lua-special-tbl|. Specifying one of the values from\n|vim.types| allows typing the empty table (it is unclear whether empty Lua\ntable represents empty list or empty array) and forcing integral numbers\nto be |Float|. See |lua-special-tbl| for more details."}}, types = {binding = "types", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Table with possible values for |vim.type_idx|. Contains two sets of\nkey-value pairs: first maps possible values for |vim.type_idx| to\nhuman-readable strings, second maps human-readable type names to values\nfor |vim.type_idx|. Currently contains pairs for `float`, `array` and\n    `dictionary` types.\n\nNote: One must expect that values corresponding to `vim.types.float`,\n`vim.types.array` and `vim.types.dictionary` fall under only two following\nassumptions:\n1. Value may serve both as a key and as a value in a table. Given the\n   properties of Lua tables this basically means \226\128\156value is not `nil`\226\128\157.\n2. For each value in `vim.types` table `vim.types[vim.types[value]]` is the\n   same as `value`.\nNo other restrictions are put on types, and it is not guaranteed that\nvalues corresponding to `vim.types.float`, `vim.types.array` and\n`vim.types.dictionary` will not change or that `vim.types` table will only\ncontain values for these three types.\n\n                                               *log_levels* *vim.log.levels*\nLog levels are one of the values defined in `vim.log.levels`:\n\nvim.log.levels.DEBUG\nvim.log.levels.ERROR\nvim.log.levels.INFO\nvim.log.levels.TRACE\nvim.log.levels.WARN\nvim.log.levels.OFF"}}, ui = {binding = "ui", fields = {input = {binding = "input", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"?opts", "on_confirm"}, ["fnl/docstring"] = "Prompts the user for input, allowing arbitrary (potentially asynchronous)\nwork until `on_confirm`.\n\nExample: >lua\n    vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)\n        vim.o.shiftwidth = tonumber(input)\n    end)\n<\n\nParameters: ~\n  \226\128\162 {opts}        (`table?`) Additional options. See |input()|\n                  \226\128\162 prompt (string|nil) Text of the prompt\n                  \226\128\162 default (string|nil) Default reply to the input\n                  \226\128\162 completion (string|nil) Specifies type of completion\n                    supported for input. Supported types are the same that\n                    can be supplied to a user-defined command using the\n                    \"-complete=\" argument. See |:command-completion|\n                  \226\128\162 highlight (function) Function that will be used for\n                    highlighting user inputs.\n  \226\128\162 {on_confirm}  (`function`) ((input|nil) -> ()) Called once the user\n                  confirms or abort the input. `input` is what the user\n                  typed (it might be an empty string if nothing was\n                  entered), or `nil` if the user aborted the dialog."}}, open = {binding = "open", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "?opt"}, ["fnl/docstring"] = "Opens `path` with the system default handler (macOS `open`, Windows\n`explorer.exe`, Linux `xdg-open`, \226\128\166), or returns (but does not show) an\nerror message on failure.\n\nCan also be invoked with `:Open`.                                  *:Open*\n\nExpands \"~/\" and environment variables in filesystem paths.\n\nExamples: >lua\n    -- Asynchronous.\n    vim.ui.open(\"https://neovim.io/\")\n    vim.ui.open(\"~/path/to/file\")\n    -- Use the \"osurl\" command to handle the path or URL.\n    vim.ui.open(\"gh#neovim/neovim!29490\", { cmd = { 'osurl' } })\n    -- Synchronous (wait until the process exits).\n    local cmd, err = vim.ui.open(\"$VIMRUNTIME\")\n    if cmd then\n      cmd:wait()\n    end\n<\n\nParameters: ~\n  \226\128\162 {path}  (`string`) Path or URL to open\n  \226\128\162 {opt}   (`{ cmd?: string[] }?`) Options\n            \226\128\162 cmd string[]|nil Command used to open the path or URL.\n\nReturn (multiple): ~\n    (`vim.SystemObj?`) Command object, or nil if not found.\n    (`string?`) Error message on failure, or nil on success.\n\nSee also: ~\n  \226\128\162 |vim.system()|"}}, select = {binding = "select", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"items", "opts", "on_choice"}, ["fnl/docstring"] = "Prompts the user to pick from a list of items, allowing arbitrary\n(potentially asynchronous) work until `on_choice`.\n\nExample: >lua\n    vim.ui.select({ 'tabs', 'spaces' }, {\n        prompt = 'Select tabs or spaces:',\n        format_item = function(item)\n            return \"I'd like to choose \" .. item\n        end,\n    }, function(choice)\n        if choice == 'spaces' then\n            vim.o.expandtab = true\n        else\n            vim.o.expandtab = false\n        end\n    end)\n<\n\nParameters: ~\n  \226\128\162 {items}      (`any[]`) Arbitrary items\n  \226\128\162 {opts}       (`table`) Additional options\n                 \226\128\162 prompt (string|nil) Text of the prompt. Defaults to\n                   `Select one of:`\n                 \226\128\162 format_item (function item -> text) Function to format\n                   an individual item from `items`. Defaults to\n                   `tostring`.\n                 \226\128\162 kind (string|nil) Arbitrary hint string indicating the\n                   item shape. Plugins reimplementing `vim.ui.select` may\n                   wish to use this to infer the structure or semantics of\n                   `items`, or the context in which select() was called.\n  \226\128\162 {on_choice}  (`fun(item: T?, idx: integer?)`) Called once the user\n                 made a choice. `idx` is the 1-based index of `item`\n                 within `items`. `nil` if the user aborted the dialog."}}}, metadata = {["fls/itemKind"] = "Module"}}, ui_attach = {binding = "ui_attach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns", "options", "callback"}, ["fnl/docstring"] = "WARNING: This feature is experimental/unstable.\n\nSubscribe to |ui-events|, similar to |nvim_ui_attach()| but receive events\nin a Lua callback. Used to implement screen elements like popupmenu or\nmessage handling in Lua.\n\n{options} is a dict with one or more `ext_\226\128\166` |ui-option|s set to true to\nenable events for the respective UI element.\n\n{callback} receives event name plus additional parameters. See\n|ui-popupmenu| and the sections below for event format for respective\nevents.\n\nCallbacks for `msg_show` events are executed in |api-fast| context;\nshowing the message should be scheduled.\n\nExcessive errors inside the callback will result in forced detachment.\n\nWARNING: This api is considered experimental. Usability will vary for\ndifferent screen elements. In particular `ext_messages` behavior is\nsubject to further changes and usability improvements. This is expected to\nbe used to handle messages when setting 'cmdheight' to zero (which is\nlikewise experimental).\n\nExample (stub for a |ui-popupmenu| implementation): >lua\n    ns = vim.api.nvim_create_namespace('my_fancy_pum')\n\n    vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)\n      if event == 'popupmenu_show' then\n        local items, selected, row, col, grid = ...\n        print('display pum ', #items)\n      elseif event == 'popupmenu_select' then\n        local selected = ...\n        print('selected', selected)\n      elseif event == 'popupmenu_hide' then\n        print('FIN')\n      end\n    end)\n<\n\nParameters: ~\n  \226\128\162 {ns}        (`integer`)\n  \226\128\162 {options}   (`table<string, any>`)\n  \226\128\162 {callback}  (`fun()`)"}}, ui_detach = {binding = "ui_detach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ns"}, ["fnl/docstring"] = "Detach a callback previously attached with |vim.ui_attach()| for the given\nnamespace {ns}.\n\nParameters: ~\n  \226\128\162 {ns}  (`integer`)"}}, uri_decode = {binding = "uri_decode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str"}, ["fnl/docstring"] = "URI-decodes a string containing percent escapes.\n\nParameters: ~\n  \226\128\162 {str}  (`string`) string to decode\n\nReturn: ~\n    (`string`) decoded string"}}, uri_encode = {binding = "uri_encode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"str", "?rfc"}, ["fnl/docstring"] = "URI-encodes a string using percent escapes.\n\nParameters: ~\n  \226\128\162 {str}  (`string`) string to encode\n  \226\128\162 {rfc}  (`\"rfc2396\"|\"rfc2732\"|\"rfc3986\"?`)\n\nReturn: ~\n    (`string`) encoded string"}}, uri_from_bufnr = {binding = "uri_from_bufnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"bufnr"}, ["fnl/docstring"] = "Gets a URI from a bufnr.\n\nParameters: ~\n  \226\128\162 {bufnr}  (`integer`)\n\nReturn: ~\n    (`string`) URI"}}, uri_from_fname = {binding = "uri_from_fname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path"}, ["fnl/docstring"] = "Gets a URI from a file path.\n\nParameters: ~\n  \226\128\162 {path}  (`string`) Path to file\n\nReturn: ~\n    (`string`) URI"}}, uri_to_bufnr = {binding = "uri_to_bufnr", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"uri"}, ["fnl/docstring"] = "Gets the buffer for a uri. Creates a new unloaded buffer if no buffer for\nthe uri already exists.\n\nParameters: ~\n  \226\128\162 {uri}  (`string`)\n\nReturn: ~\n    (`integer`) bufnr"}}, uri_to_fname = {binding = "uri_to_fname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"uri"}, ["fnl/docstring"] = "Gets a filename from a URI.\n\nParameters: ~\n  \226\128\162 {uri}  (`string`)\n\nReturn: ~\n    (`string`) filename or unchanged URI for non-file URIs"}}, uv = {binding = "uv", fields = {accept = {binding = "accept", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "client_stream"}, ["fnl/docstring"] = "> method form `stream:accept(client_stream)`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `client_stream`: `userdata` for sub-type of |uv_stream_t|\n\nThis call is used in conjunction with |uv.listen()| to accept\nincoming connections. Call this function after receiving a\ncallback to accept the connection.\n\nWhen the connection callback is called it is guaranteed that\nthis function will complete successfully the first time. If\nyou attempt to use it more than once, it may fail. It is\nsuggested to only call this function once per connection call.\n\nReturns: `0` or `fail`\n\n    >lua\n    server:listen(128, function (err)\n      local client = uv.new_tcp()\n      server:accept(client)\n    end)\n<"}}, async_send = {binding = "async_send", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"async", "..."}, ["fnl/docstring"] = "> method form `async:send(...)`\n\nParameters:\n- `async`: `uv_async_t userdata`\n- `...`: `threadargs`\n\nWakeup the event loop and call the async handle's callback.\n\nReturns: `0` or `fail`\n\nNote: It's safe to call this function from any thread. The\ncallback will be called on the loop thread.\n\nWARNING: libuv will coalesce calls to `uv.async_send(async)`,\nthat is, not every call to it will yield an execution of the\ncallback. For example: if `uv.async_send()` is called 5 times\nin a row before the callback is called, the callback will only\nbe called once. If `uv.async_send()` is called again after the\ncallback was called, it will be called again."}}, available_parallelism = {binding = "available_parallelism", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns an estimate of the default amount of parallelism a\nprogram should use. Always returns a non-zero value.\n\nOn Linux, inspects the calling thread\226\128\153s CPU affinity mask to\ndetermine if it has been pinned to specific CPUs.\n\nOn Windows, the available parallelism may be underreported on\nsystems with more than 64 logical CPUs.\n\nOn other platforms, reports the number of CPUs that the\noperating system considers to be online.\n\nReturns: `integer`"}}, backend_fd = {binding = "backend_fd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Get backend file descriptor. Only kqueue, epoll, and event\nports are supported.\n\nThis can be used in conjunction with `uv.run(\"nowait\")` to\npoll in one thread and run the event loop's callbacks in\nanother\n\nReturns: `integer` or `nil`\n\nNote: Embedding a kqueue fd in another kqueue pollset doesn't\nwork on all platforms. It's not an error to add the fd but it\nnever generates events."}}, backend_timeout = {binding = "backend_timeout", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Get the poll timeout. The return value is in milliseconds, or\n-1 for no timeout.\n\nReturns: `integer`"}}, cancel = {binding = "cancel", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"req"}, ["fnl/docstring"] = "> method form `req:cancel()`\n\nParameters:\n- `req`: `userdata` for sub-type of |uv_req_t|\n\nCancel a pending request. Fails if the request is executing or\nhas finished executing. Only cancellation of |uv_fs_t|,\n`uv_getaddrinfo_t`, `uv_getnameinfo_t` and `uv_work_t`\nrequests is currently supported.\n\nReturns: `0` or `fail`"}}, chdir = {binding = "chdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"cwd"}, ["fnl/docstring"] = "Parameters:\n- `cwd`: `string`\n\nSets the current working directory with the string `cwd`.\n\nReturns: `0` or `fail`"}}, check_start = {binding = "check_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"check", "callback"}, ["fnl/docstring"] = "> method form `check:start(callback)`\n\nParameters:\n- `check`: `uv_check_t userdata`\n- `callback`: `callable`\n\nStart the handle with the given callback.\n\nReturns: `0` or `fail`"}}, check_stop = {binding = "check_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"check"}, ["fnl/docstring"] = "> method form `check:stop()`\n\nParameters:\n- `check`: `uv_check_t userdata`\n\nStop the handle, the callback will no longer be called.\n\nReturns: `0` or `fail`"}}, clock_gettime = {binding = "clock_gettime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"clock_id"}, ["fnl/docstring"] = "Parameters:\n- `clock_id`: `string`\n\nObtain the current system time from a high-resolution\nreal-time or monotonic clock source. `clock_id` can be the\nstring `\"monotonic\"` or `\"realtime\"`.\n\nThe real-time clock counts from the UNIX epoch (1970-01-01)\nand is subject to time adjustments; it can jump back in time.\n\nThe monotonic clock counts from an arbitrary point in the past\nand never jumps back in time.\n\nReturns: `table` or `fail`\n- `sec`: `integer`\n- `nsec`: `integer`"}}, close = {binding = "close", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle", "callback"}, ["fnl/docstring"] = "> method form `handle:close([callback])`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n- `callback`: `callable` or `nil`\n\nRequest handle to be closed. `callback` will be called\nasynchronously after this call. This MUST be called on each\nhandle before memory is released.\n\nHandles that wrap file descriptors are closed immediately but\n`callback` will still be deferred to the next iteration of the\nevent loop. It gives you a chance to free up any resources\nassociated with the handle.\n\nIn-progress requests, like `uv_connect_t` or `uv_write_t`, are\ncancelled and have their callbacks called asynchronously with\n`ECANCELED`.\n\nReturns: Nothing."}}, cpu_info = {binding = "cpu_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns information about the CPU(s) on the system as a table\nof tables for each CPU found.\n\nReturns: `table` or `fail`\n- `[1, 2, 3, ..., n]` : `table`\n  - `model` : `string`\n  - `speed` : `number`\n  - `times` : `table`\n    - `user` : `number`\n    - `nice` : `number`\n    - `sys` : `number`\n    - `idle` : `number`\n    - `irq` : `number`"}}, cpumask_size = {binding = "cpumask_size", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the maximum size of the mask used for process/thread\naffinities, or `ENOTSUP` if affinities are not supported on\nthe current platform.\n\nReturns: `integer` or `fail`"}}, cwd = {binding = "cwd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current working directory.\n\nReturns: `string` or `fail`"}}, disable_stdio_inheritance = {binding = "disable_stdio_inheritance", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Disables inheritance for file descriptors / handles that this\nprocess inherited from its parent. The effect is that child\nprocesses spawned by this process don't accidentally inherit\nthese handles.\n\nIt is recommended to call this function as early in your\nprogram as possible, before the inherited file descriptors can\nbe closed or duplicated.\n\nReturns: Nothing.\n\nNote: This function works on a best-effort basis: there is no\nguarantee that libuv can discover all file descriptors that\nwere inherited. In general it does a better job on Windows\nthan it does on Unix."}}, exepath = {binding = "exepath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the executable path.\n\nReturns: `string` or `fail`"}}, fileno = {binding = "fileno", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:fileno()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nGets the platform dependent file descriptor equivalent.\n\nThe following handles are supported: TCP, pipes, TTY, UDP and\npoll. Passing any other handle type will fail with `EINVAL`.\n\nIf a handle doesn't have an attached file descriptor yet or\nthe handle itself has been closed, this function will return\n`EBADF`.\n\nReturns: `integer` or `fail`\n\nWARNING: Be very careful when using this function. libuv\nassumes it's in control of the file descriptor so any change\nto it may lead to malfunction."}}, fs_access = {binding = "fs_access", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "mode", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `mode`: `integer` `string` (a combination of the `'r'`,\n  `'w'` and `'x'` characters denoting the symbolic mode as per\n  `chmod(1)`)\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `permission`: `boolean` or `nil`\n\nEquivalent to `access(2)` on Unix. Windows uses\n`GetFileAttributesW()`. Access `mode` can be an integer or a\nstring containing `\"R\"` or `\"W\"` or `\"X\"`. Returns `true` or\n`false` indicating access permission.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_chmod = {binding = "fs_chmod", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "mode", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `mode`: `integer` (octal representation of `chmod(1)` mode,\n  e.g. `tonumber('644', 8)`)\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `chmod(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_chown = {binding = "fs_chown", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "uid", "gid", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `uid`: `integer`\n- `gid`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `chown(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_close = {binding = "fs_close", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `close(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_closedir = {binding = "fs_closedir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dir", "callback"}, ["fnl/docstring"] = "> method form `dir:closedir([callback])`\n\nParameters:\n- `dir`: `luv_dir_t userdata`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nCloses a directory stream returned by a successful\n|uv.fs_opendir()| call.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_copyfile = {binding = "fs_copyfile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "new_path", "flags", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `new_path`: `string`\n- `flags`: `table`, `integer`, or `nil`\n  - `excl`: `boolean`\n  - `ficlone`: `boolean`\n  - `ficlone_force`: `boolean`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nCopies a file from path to new_path. If the `flags` parameter\nis omitted, then the 3rd parameter will be treated as the\n`callback`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_event_getpath = {binding = "fs_event_getpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `fs_event:getpath()`\n\nGet the path being monitored by the handle.\n\nReturns: `string` or `fail`"}}, fs_event_start = {binding = "fs_event_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fs_event", "path", "flags", "callback"}, ["fnl/docstring"] = "> method form `fs_event:start(path, flags, callback)`\n\nParameters:\n- `fs_event`: `uv_fs_event_t userdata`\n- `path`: `string`\n- `flags`: `table`\n  - `watch_entry`: `boolean` or `nil` (default: `false`)\n  - `stat`: `boolean` or `nil` (default: `false`)\n  - `recursive`: `boolean` or `nil` (default: `false`)\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n  - `filename`: `string`\n  - `events`: `table`\n    - `change`: `boolean` or `nil`\n    - `rename`: `boolean` or `nil`\n\nStart the handle with the given callback, which will watch the\nspecified path for changes.\n\nReturns: `0` or `fail`"}}, fs_event_stop = {binding = "fs_event_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `fs_event:stop()`\n\nStop the handle, the callback will no longer be called.\n\nReturns: `0` or `fail`"}}, fs_fchmod = {binding = "fs_fchmod", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "mode", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `mode`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `fchmod(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_fchown = {binding = "fs_fchown", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "uid", "gid", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `uid`: `integer`\n- `gid`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `fchown(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_fdatasync = {binding = "fs_fdatasync", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `fdatasync(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_fstat = {binding = "fs_fstat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `stat`: `table` or `nil` (see `uv.fs_stat`)\n\nEquivalent to `fstat(2)`.\n\nReturns (sync version): `table` or `fail` (see `uv.fs_stat`)\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_fsync = {binding = "fs_fsync", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `fsync(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_ftruncate = {binding = "fs_ftruncate", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "offset", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `offset`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `ftruncate(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`\n\n                                              "}}, fs_futime = {binding = "fs_futime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "atime", "mtime", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `atime`: `number`\n- `mtime`: `number`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `futime(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_lchown = {binding = "fs_lchown", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "uid", "gid", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `uid`: `integer`\n- `gid`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `lchown(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_link = {binding = "fs_link", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "new_path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `new_path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `link(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_lstat = {binding = "fs_lstat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `stat`: `table` or `nil` (see `uv.fs_stat`)\n\nEquivalent to `lstat(2)`.\n\nReturns (sync version): `table` or `fail` (see |uv.fs_stat()|)\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_lutime = {binding = "fs_lutime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "atime", "mtime", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `atime`: `number`\n- `mtime`: `number`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `lutime(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_mkdir = {binding = "fs_mkdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "mode", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `mode`: `integer` (octal representation of `chmod(1)` mode,\n  e.g. `tonumber('755', 8)`)\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `mkdir(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_mkdtemp = {binding = "fs_mkdtemp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"template", "callback"}, ["fnl/docstring"] = "Parameters:\n- `template`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `path`: `string` or `nil`\n\nEquivalent to `mkdtemp(3)`.\n\nReturns (sync version): `string` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_mkstemp = {binding = "fs_mkstemp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"template", "callback"}, ["fnl/docstring"] = "Parameters:\n- `template`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `fd`: `integer` or `nil`\n  - `path`: `string` or `nil`\n\nEquivalent to `mkstemp(3)`. Returns a temporary file handle\nand filename.\n\nReturns (sync version): `integer, string` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_open = {binding = "fs_open", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "flags", "mode", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `flags`: `string` or `integer`\n- `mode`: `integer` (octal `chmod(1)` mode, e.g.\n  `tonumber('644', 8)`)\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `fd`: `integer` or `nil`\n\nEquivalent to `open(2)`. Access `flags` may be an integer or\none of: `\"r\"`, `\"rs\"`, `\"sr\"`, `\"r+\"`, `\"rs+\"`, `\"sr+\"`,\n`\"w\"`, `\"wx\"`, `\"xw\"`, `\"w+\"`, `\"wx+\"`, `\"xw+\"`, `\"a\"`,\n`\"ax\"`, `\"xa\"`, `\"a+\"`, `\"ax+\"`, or \"`xa+`\".\n\nReturns (sync version): `integer` or `fail`\n\nReturns (async version): `uv_fs_t userdata`\n\nNote: On Windows, libuv uses `CreateFileW` and thus the file\nis always opened in binary mode. Because of this, the\n`O_BINARY` and `O_TEXT` flags are not supported."}}, fs_opendir = {binding = "fs_opendir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback", "entries"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `dir`: `luv_dir_t userdata` or `nil`\n- `entries`: `integer` or `nil`\n\nOpens path as a directory stream. Returns a handle that the\nuser can pass to |uv.fs_readdir()|. The `entries` parameter\ndefines the maximum number of entries that should be returned\nby each call to |uv.fs_readdir()|.\n\nReturns (sync version): `luv_dir_t userdata` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_poll_getpath = {binding = "fs_poll_getpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `fs_poll:getpath()`\n\nGet the path being monitored by the handle.\n\nReturns: `string` or `fail`"}}, fs_poll_start = {binding = "fs_poll_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fs_poll", "path", "interval", "callback"}, ["fnl/docstring"] = "> method form `fs_poll:start(path, interval, callback)`\n\nParameters:\n- `fs_poll`: `uv_fs_poll_t userdata`\n- `path`: `string`\n- `interval`: `integer`\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n  - `prev`: `table` or `nil` (see `uv.fs_stat`)\n  - `curr`: `table` or `nil` (see `uv.fs_stat`)\n\nCheck the file at `path` for changes every `interval`\nmilliseconds.\n\nNote: For maximum portability, use multi-second intervals.\nSub-second intervals will not detect all changes on many file\nsystems.\n\nReturns: `0` or `fail`"}}, fs_poll_stop = {binding = "fs_poll_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `fs_poll:stop()`\n\nStop the handle, the callback will no longer be called.\n\nReturns: `0` or `fail`"}}, fs_read = {binding = "fs_read", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "size", "offset", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `size`: `integer`\n- `offset`: `integer` or `nil`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `data`: `string` or `nil`\n\nEquivalent to `preadv(2)`. Returns any data. An empty string\nindicates EOF.\n\nIf `offset` is nil or omitted, it will default to `-1`, which\nindicates \"use and update the current file offset.\"\n\nNote: When `offset` is >= 0, the current file offset will not\nbe updated by the read.\n\nReturns (sync version): `string` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_readdir = {binding = "fs_readdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"dir", "callback"}, ["fnl/docstring"] = "> method form `dir:readdir([callback])`\n\nParameters:\n- `dir`: `luv_dir_t userdata`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `entries`: `table` or `nil` (see below)\n\nIterates over the directory stream `luv_dir_t` returned by a\nsuccessful |uv.fs_opendir()| call. A table of data tables is\nreturned where the number of entries `n` is equal to or less\nthan the `entries` parameter used in the associated\n|uv.fs_opendir()| call.\n\nReturns (sync version): `table` or `fail`\n- `[1, 2, 3, ..., n]` : `table`\n  - `name` : `string`\n  - `type` : `string`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_readlink = {binding = "fs_readlink", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `path`: `string` or `nil`\n\nEquivalent to `readlink(2)`.\n\nReturns (sync version): `string` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_realpath = {binding = "fs_realpath", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `path`: `string` or `nil`\n\nEquivalent to `realpath(3)`.\n\nReturns (sync version): `string` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_rename = {binding = "fs_rename", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "new_path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `new_path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `rename(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_rmdir = {binding = "fs_rmdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `rmdir(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_scandir = {binding = "fs_scandir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n  - `success`: `uv_fs_t userdata` or `nil`\n\nEquivalent to `scandir(3)`, with a slightly different API.\nReturns a handle that the user can pass to\n|uv.fs_scandir_next()|.\n\nNote: This function can be used synchronously or\nasynchronously. The request userdata is always synchronously\nreturned regardless of whether a callback is provided and the\nsame userdata is passed to the callback if it is provided.\n\nReturns: `uv_fs_t userdata` or `fail`"}}, fs_scandir_next = {binding = "fs_scandir_next", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fs"}, ["fnl/docstring"] = "Parameters:\n- `fs`: `uv_fs_t userdata`\n\nCalled on a |uv_fs_t| returned by |uv.fs_scandir()| to get the\nnext directory entry data as a `name, type` pair. When there\nare no more entries, `nil` is returned.\n\nNote: This function only has a synchronous version. See\n|uv.fs_opendir()| and its related functions for an\nasynchronous version.\n\nReturns: `string, string` or `nil` or `fail`"}}, fs_sendfile = {binding = "fs_sendfile", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"out_fd", "in_fd", "in_offset", "size", "callback"}, ["fnl/docstring"] = "Parameters:\n- `out_fd`: `integer`\n- `in_fd`: `integer`\n- `in_offset`: `integer`\n- `size`: `integer`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `bytes`: `integer` or `nil`\n\nLimited equivalent to `sendfile(2)`. Returns the number of\nbytes written.\n\nReturns (sync version): `integer` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_stat = {binding = "fs_stat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `stat`: `table` or `nil` (see below)\n\nEquivalent to `stat(2)`.\n\nReturns (sync version): `table` or `fail`\n- `dev` : `integer`\n- `mode` : `integer`\n- `nlink` : `integer`\n- `uid` : `integer`\n- `gid` : `integer`\n- `rdev` : `integer`\n- `ino` : `integer`\n- `size` : `integer`\n- `blksize` : `integer`\n- `blocks` : `integer`\n- `flags` : `integer`\n- `gen` : `integer`\n- `atime` : `table`\n  - `sec` : `integer`\n  - `nsec` : `integer`\n- `mtime` : `table`\n  - `sec` : `integer`\n  - `nsec` : `integer`\n- `ctime` : `table`\n  - `sec` : `integer`\n  - `nsec` : `integer`\n- `birthtime` : `table`\n  - `sec` : `integer`\n  - `nsec` : `integer`\n- `type` : `string`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_statfs = {binding = "fs_statfs", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `table` or `nil` (see below)\n\nEquivalent to `statfs(2)`.\n\nReturns `table` or `nil`\n- `type` : `integer`\n- `bsize` : `integer`\n- `blocks` : `integer`\n- `bfree` : `integer`\n- `bavail` : `integer`\n- `files` : `integer`\n- `ffree` : `integer`"}}, fs_symlink = {binding = "fs_symlink", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "new_path", "flags", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `new_path`: `string`\n- `flags`: `table`, `integer`, or `nil`\n  - `dir`: `boolean`\n  - `junction`: `boolean`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `symlink(2)`. If the `flags` parameter is\nomitted, then the 3rd parameter will be treated as the\n`callback`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_unlink = {binding = "fs_unlink", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `unlink(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_utime = {binding = "fs_utime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "atime", "mtime", "callback"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `atime`: `number`\n- `mtime`: `number`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `success`: `boolean` or `nil`\n\nEquivalent to `utime(2)`.\n\nReturns (sync version): `boolean` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, fs_write = {binding = "fs_write", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "data", "offset", "callback"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `data`: `buffer`\n- `offset`: `integer` or `nil`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `bytes`: `integer` or `nil`\n\nEquivalent to `pwritev(2)`. Returns the number of bytes\nwritten.\n\nIf `offset` is nil or omitted, it will default to `-1`, which\nindicates \"use and update the current file offset.\"\n\nNote: When `offset` is >= 0, the current file offset will not\nbe updated by the write.\n\nReturns (sync version): `integer` or `fail`\n\nReturns (async version): `uv_fs_t userdata`"}}, get_available_memory = {binding = "get_available_memory", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the amount of free memory that is still available to the\nprocess (in bytes). This differs from `uv.get_free_memory()`\nin that it takes into account any limits imposed by the OS. If\nthere is no such constraint, or the constraint is unknown, the\namount returned will be identical to `uv.get_free_memory()`.\n\nReturns: `number`"}}, get_constrained_memory = {binding = "get_constrained_memory", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the amount of memory available to the process in bytes\nbased on limits imposed by the OS. If there is no such\nconstraint, or the constraint is unknown, 0 is returned. Note\nthat it is not unusual for this value to be less than or\ngreater than the total system memory.\n\nReturns: `number`"}}, get_free_memory = {binding = "get_free_memory", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current free system memory in bytes.\n\nReturns: `number`"}}, get_process_title = {binding = "get_process_title", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the title of the current process.\n\nReturns: `string` or `fail`"}}, get_total_memory = {binding = "get_total_memory", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current total system memory in bytes.\n\nReturns: `number`"}}, getaddrinfo = {binding = "getaddrinfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"host", "service", "hints", "callback"}, ["fnl/docstring"] = "Parameters:\n- `host`: `string` or `nil`\n- `service`: `string` or `nil`\n- `hints`: `table` or `nil`\n  - `family`: `string` or `integer` or `nil`\n  - `socktype`: `string` or `integer` or `nil`\n  - `protocol`: `string` or `integer` or `nil`\n  - `addrconfig`: `boolean` or `nil`\n  - `v4mapped`: `boolean` or `nil`\n  - `all`: `boolean` or `nil`\n  - `numerichost`: `boolean` or `nil`\n  - `passive`: `boolean` or `nil`\n  - `numericserv`: `boolean` or `nil`\n  - `canonname`: `boolean` or `nil`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `addresses`: `table` or `nil` (see below)\n\nEquivalent to `getaddrinfo(3)`. Either `node` or `service` may\nbe `nil` but not both.\n\nSee |luv-constants| for supported address `family` input and\noutput values.\n\nSee |luv-constants| for supported `socktype` input and\noutput values.\n\nWhen `protocol` is set to `0` or `nil`, it will be\nautomatically chosen based on the socket's domain and type.\nWhen `protocol` is specified as a string, it will be looked up\nusing the `getprotobyname(3)` function. Examples: `\"ip\"`,\n`\"icmp\"`, `\"tcp\"`, `\"udp\"`, etc.\n\nReturns (sync version): `table` or `fail`\n- `[1, 2, 3, ..., n]` : `table`\n  - `addr` : `string`\n  - `family` : `string`\n  - `port` : `integer` or `nil`\n  - `socktype` : `string`\n  - `protocol` : `string`\n  - `canonname` : `string` or `nil`\n\nReturns (async version): `uv_getaddrinfo_t userdata` or `fail`"}}, getgid = {binding = "getgid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the group ID of the process.\n\nReturns: `integer`\n\nNote: This is not a libuv function and is not supported on\nWindows."}}, getnameinfo = {binding = "getnameinfo", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"address", "callback"}, ["fnl/docstring"] = "Parameters:\n- `address`: `table`\n  - `ip`: `string` or `nil`\n  - `port`: `integer` or `nil`\n  - `family`: `string` or `integer` or `nil`\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `host`: `string` or `nil`\n  - `service`: `string` or `nil`\n\nEquivalent to `getnameinfo(3)`.\n\nSee |luv-constants| for supported address `family` input values.\n\nReturns (sync version): `string, string` or `fail`\n\nReturns (async version): `uv_getnameinfo_t userdata` or `fail`"}}, getpid = {binding = "getpid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "DEPRECATED: Please use |uv.os_getpid()| instead."}}, getrusage = {binding = "getrusage", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the resource usage.\n\nReturns: `table` or `fail`\n- `utime` : `table` (user CPU time used)\n  - `sec` : `integer`\n  - `usec` : `integer`\n- `stime` : `table` (system CPU time used)\n  - `sec` : `integer`\n  - `usec` : `integer`\n- `maxrss` : `integer` (maximum resident set size)\n- `ixrss` : `integer` (integral shared memory size)\n- `idrss` : `integer` (integral unshared data size)\n- `isrss` : `integer` (integral unshared stack size)\n- `minflt` : `integer` (page reclaims (soft page faults))\n- `majflt` : `integer` (page faults (hard page faults))\n- `nswap` : `integer` (swaps)\n- `inblock` : `integer` (block input operations)\n- `oublock` : `integer` (block output operations)\n- `msgsnd` : `integer` (IPC messages sent)\n- `msgrcv` : `integer` (IPC messages received)\n- `nsignals` : `integer` (signals received)\n- `nvcsw` : `integer` (voluntary context switches)\n- `nivcsw` : `integer` (involuntary context switches)"}}, getrusage_thread = {binding = "getrusage_thread", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the resource usage measures for the calling thread.\n\nNote: Not supported on all platforms. May return `ENOTSUP`.\n\nOn macOS and Windows not all fields are set (the unsupported\nfields are filled with zeroes).\n\nReturns: `table` or `fail`\n- `utime` : `table` (user CPU time used)\n  - `sec` : `integer`\n  - `usec` : `integer`\n- `stime` : `table` (system CPU time used)\n  - `sec` : `integer`\n  - `usec` : `integer`\n- `maxrss` : `integer` (maximum resident set size)\n- `ixrss` : `integer` (integral shared memory size)\n- `idrss` : `integer` (integral unshared data size)\n- `isrss` : `integer` (integral unshared stack size)\n- `minflt` : `integer` (page reclaims (soft page faults))\n- `majflt` : `integer` (page faults (hard page faults))\n- `nswap` : `integer` (swaps)\n- `inblock` : `integer` (block input operations)\n- `oublock` : `integer` (block output operations)\n- `msgsnd` : `integer` (IPC messages sent)\n- `msgrcv` : `integer` (IPC messages received)\n- `nsignals` : `integer` (signals received)\n- `nvcsw` : `integer` (voluntary context switches)\n- `nivcsw` : `integer` (involuntary context switches)"}}, gettimeofday = {binding = "gettimeofday", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Cross-platform implementation of `gettimeofday(2)`. Returns\nthe seconds and microseconds of a unix time as a pair.\n\nReturns: `integer, integer` or `fail`"}}, getuid = {binding = "getuid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the user ID of the process.\n\nReturns: `integer`\n\nNote: This is not a libuv function and is not supported on\nWindows."}}, guess_handle = {binding = "guess_handle", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n\nUsed to detect what type of stream should be used with a given\nfile descriptor `fd`. Usually this will be used during\ninitialization to guess the type of the stdio streams.\n\nReturns: `string`"}}, handle_get_type = {binding = "handle_get_type", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:get_type()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nReturns the name of the struct for a given handle (e.g.\n`\"pipe\"` for |uv_pipe_t|) and the libuv enum integer for the\nhandle's type (`uv_handle_type`).\n\nReturns: `string, integer`"}}, has_ref = {binding = "has_ref", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:has_ref()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nReturns `true` if the handle referenced, `false` if not.\n\nReturns: `boolean` or `fail`\n\nSee |luv-reference-counting|."}}, hrtime = {binding = "hrtime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns a current high-resolution time in nanoseconds as a\nnumber. This is relative to an arbitrary time in the past. It\nis not related to the time of day and therefore not subject to\nclock drift. The primary use is for measuring time between\nintervals.\n\nReturns: `number`"}}, idle_start = {binding = "idle_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"idle", "callback"}, ["fnl/docstring"] = "> method form `idle:start(callback)`\n\nParameters:\n- `idle`: `uv_idle_t userdata`\n- `callback`: `callable`\n\nStart the handle with the given callback.\n\nReturns: `0` or `fail`"}}, idle_stop = {binding = "idle_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"check"}, ["fnl/docstring"] = "> method form `idle:stop()`\n\nParameters:\n- `idle`: `uv_idle_t userdata`\n\nStop the handle, the callback will no longer be called.\n\nReturns: `0` or `fail`"}}, if_indextoiid = {binding = "if_indextoiid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ifindex"}, ["fnl/docstring"] = "Parameters:\n- `ifindex`: `integer`\n\nRetrieves a network interface identifier suitable for use in\nan IPv6 scoped address. On Windows, returns the numeric\n`ifindex` as a string. On all other platforms,\n|uv.if_indextoname()| is used.\n\nReturns: `string` or `fail`"}}, if_indextoname = {binding = "if_indextoname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ifindex"}, ["fnl/docstring"] = "Parameters:\n- `ifindex`: `integer`\n\nIPv6-capable implementation of `if_indextoname(3)`.\n\nReturns: `string` or `fail`"}}, interface_addresses = {binding = "interface_addresses", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns address information about the network interfaces on\nthe system in a table. Each table key is the name of the\ninterface while each associated value is an array of address\ninformation where fields are `ip`, `family`, `netmask`,\n`internal`, and `mac`.\n\nSee |luv-constants| for supported address `family` output values.\n\nReturns: `table`\n- `[name(s)]` : `table`\n  - `ip` : `string`\n  - `family` : `string`\n  - `netmask` : `string`\n  - `internal` : `boolean`\n  - `mac` : `string`"}}, is_active = {binding = "is_active", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:is_active()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nReturns `true` if the handle is active, `false` if it's\ninactive. What \"active\226\128\157 means depends on the type of handle:\n\n  - A |uv_async_t| handle is always active and cannot be\n    deactivated, except by closing it with |uv.close()|.\n\n  - A |uv_pipe_t|, |uv_tcp_t|, |uv_udp_t|, etc.\n    handle - basically any handle that deals with I/O - is\n    active when it is doing something that involves I/O, like\n    reading, writing, connecting, accepting new connections,\n    etc.\n\n  - A |uv_check_t|, |uv_idle_t|, |uv_timer_t|,\n    etc. handle is active when it has been started with a call\n    to |uv.check_start()|, |uv.idle_start()|,\n    |uv.timer_start()| etc. until it has been stopped with a\n    call to its respective stop function.\n\nReturns: `boolean` or `fail`"}}, is_closing = {binding = "is_closing", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:is_closing()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nReturns `true` if the handle is closing or closed, `false`\notherwise.\n\nReturns: `boolean` or `fail`\n\nNote: This function should only be used between the\ninitialization of the handle and the arrival of the close\ncallback."}}, is_readable = {binding = "is_readable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream"}, ["fnl/docstring"] = "> method form `stream:is_readable()`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n\nReturns `true` if the stream is readable, `false` otherwise.\n\nReturns: `boolean`"}}, is_writable = {binding = "is_writable", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream"}, ["fnl/docstring"] = "> method form `stream:is_writable()`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n\nReturns `true` if the stream is writable, `false` otherwise.\n\nReturns: `boolean`"}}, kill = {binding = "kill", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pid", "signame"}, ["fnl/docstring"] = "Parameters:\n- `pid`: `integer`\n- `signame`: `string` or `integer` or `nil` (default: `sigterm`)\n\nSends the specified signal to the given PID. Check the\ndocumentation on |uv_signal_t| for signal support, specially\non Windows.\n\nSee |luv-constants| for supported `signame` input and output\nvalues.\n\nReturns: `0` or `fail`"}}, listen = {binding = "listen", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "backlog", "callback"}, ["fnl/docstring"] = "> method form `stream:listen(backlog, callback)`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `backlog`: `integer`\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n\nStart listening for incoming connections. `backlog` indicates\nthe number of connections the kernel might queue, same as\n`listen(2)`. When a new incoming connection is received the\ncallback is called.\n\nReturns: `0` or `fail`"}}, loadavg = {binding = "loadavg", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the load average as a triad. Not supported on Windows.\n\nReturns: `number, number, number`"}}, loop_alive = {binding = "loop_alive", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns `true` if there are referenced active handles, active\nrequests, or closing handles in the loop; otherwise, `false`.\n\nReturns: `boolean` or `fail`"}}, loop_close = {binding = "loop_close", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Closes all internal loop resources. In normal execution, the\nloop will automatically be closed when it is garbage collected\nby Lua, so it is not necessary to explicitly call\n`loop_close()`. Call this function only after the loop has\nfinished executing and all open handles and requests have been\nclosed, or it will return `EBUSY`.\n\nReturns: `0` or `fail`"}}, loop_configure = {binding = "loop_configure", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"option", "..."}, ["fnl/docstring"] = "Parameters:\n- `option`: `string`\n- `...`: depends on `option`, see below\n\nSet additional loop options. You should normally call this\nbefore the first call to uv_run() unless mentioned otherwise.\n\nSupported options:\n\n  - `\"block_signal\"`: Block a signal when polling for new\n    events. The second argument to loop_configure() is the\n    signal name (as a lowercase string) or the signal number.\n    This operation is currently only implemented for\n    `\"sigprof\"` signals, to suppress unnecessary wakeups when\n    using a sampling profiler. Requesting other signals will\n    fail with `EINVAL`.\n  - `\"metrics_idle_time\"`: Accumulate the amount of idle time\n    the event loop spends in the event provider. This option\n    is necessary to use `metrics_idle_time()`.\n\nAn example of a valid call to this function is:\n\n    >lua\n    uv.loop_configure(\"block_signal\", \"sigprof\")\n<\n\nReturns: `0` or `fail`\n\nNote: Be prepared to handle the `ENOSYS` error; it means the\nloop option is not supported by the platform."}}, loop_mode = {binding = "loop_mode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "If the loop is running, returns a string indicating the mode\nin use. If the loop is not running, `nil` is returned instead.\n\nReturns: `string` or `nil`"}}, metrics_idle_time = {binding = "metrics_idle_time", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Retrieve the amount of time the event loop has been idle in\nthe kernel\226\128\153s event provider (e.g. `epoll_wait`). The call is\nthread safe.\n\nThe return value is the accumulated time spent idle in the\nkernel\226\128\153s event provider starting from when the |uv_loop_t| was\nconfigured to collect the idle time.\n\nNote: The event loop will not begin accumulating the event\nprovider\226\128\153s idle time until calling `loop_configure` with\n`\"metrics_idle_time\"`.\n\nReturns: `number`"}}, metrics_info = {binding = "metrics_info", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Get the metrics table from current set of event loop metrics.\nIt is recommended to retrieve these metrics in a `prepare`\ncallback (see |uv.new_prepare()|, |uv.prepare_start()|) in order\nto make sure there are no inconsistencies with the metrics\ncounters.\n\nReturns: `table`\n\n- `loop_count` : `integer`\n- `events` : `integer`\n- `events_waiting` : `integer`"}}, new_async = {binding = "new_async", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"callback"}, ["fnl/docstring"] = "Parameters:\n- `callback`: `callable`\n  - `...`: `threadargs` passed to/from\n    `uv.async_send(async, ...)`\n\nCreates and initializes a new |uv_async_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_async_t userdata` or `fail`\n\nNote: Unlike other handle initialization functions, this\nimmediately starts the handle."}}, new_check = {binding = "new_check", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_check_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_check_t userdata`"}}, new_fs_event = {binding = "new_fs_event", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_fs_event_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_fs_event_t userdata` or `fail`"}}, new_fs_poll = {binding = "new_fs_poll", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_fs_poll_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_fs_poll_t userdata` or `fail`"}}, new_idle = {binding = "new_idle", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_idle_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_idle_t userdata`"}}, new_pipe = {binding = "new_pipe", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"ipc"}, ["fnl/docstring"] = "Parameters:\n- `ipc`: `boolean` or `nil` (default: `false`)\n\nCreates and initializes a new |uv_pipe_t|. Returns the Lua\nuserdata wrapping it. The `ipc` argument is a boolean to\nindicate if this pipe will be used for handle passing between\nprocesses.\n\nReturns: `uv_pipe_t userdata` or `fail`"}}, new_poll = {binding = "new_poll", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n\nInitialize the handle using a file descriptor.\n\nThe file descriptor is set to non-blocking mode.\n\nReturns: `uv_poll_t userdata` or `fail`"}}, new_prepare = {binding = "new_prepare", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_prepare_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_prepare_t userdata`"}}, new_signal = {binding = "new_signal", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_signal_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_signal_t userdata` or `fail`"}}, new_socket_poll = {binding = "new_socket_poll", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n\nInitialize the handle using a socket descriptor. On Unix this\nis identical to |uv.new_poll()|. On windows it takes a SOCKET\nhandle.\n\nThe socket is set to non-blocking mode.\n\nReturns: `uv_poll_t userdata` or `fail`"}}, new_tcp = {binding = "new_tcp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"flags"}, ["fnl/docstring"] = "Parameters:\n- `flags`: `string` or `integer` or `nil`\n\nCreates and initializes a new |uv_tcp_t|. Returns the Lua\nuserdata wrapping it.\n\nIf set, `flags` must be a valid address family. See\n|luv-constants| for supported address family input values.\n\nReturns: `uv_tcp_t userdata` or `fail`"}}, new_thread = {binding = "new_thread", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"options", "entry", "..."}, ["fnl/docstring"] = "Parameters:\n- `options`: `table` or `nil`\n  - `stack_size`: `integer` or `nil`\n- `entry`: `function` or `string`\n- `...`: `threadargs` passed to `entry`\n\nCreates and initializes a `luv_thread_t` (not `uv_thread_t`).\nReturns the Lua userdata wrapping it and asynchronously\nexecutes `entry`, which can be either a Lua function or a\nstring containing Lua code or bytecode dumped from a function.\nAdditional arguments `...` are passed to the `entry` function\nand an optional `options` table may be provided. Currently\naccepted `option` fields are `stack_size`.\n\nReturns: `luv_thread_t userdata` or `fail`\n\nNote: unsafe, please make sure that the thread's end of life\nis before Lua state is closed."}}, new_timer = {binding = "new_timer", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Creates and initializes a new |uv_timer_t|. Returns the Lua\nuserdata wrapping it.\n\nReturns: `uv_timer_t userdata` or `fail`\n\n    >lua\n    -- Creating a simple setTimeout wrapper\n    local function setTimeout(timeout, callback)\n      local timer = uv.new_timer()\n      timer:start(timeout, 0, function ()\n        timer:stop()\n        timer:close()\n        callback()\n      end)\n      return timer\n    end\n\n    -- Creating a simple setInterval wrapper\n    local function setInterval(interval, callback)\n      local timer = uv.new_timer()\n      timer:start(interval, interval, function ()\n        callback()\n      end)\n      return timer\n    end\n\n    -- And clearInterval\n    local function clearInterval(timer)\n      timer:stop()\n      timer:close()\n    end\n<"}}, new_tty = {binding = "new_tty", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"fd", "readable"}, ["fnl/docstring"] = "Parameters:\n- `fd`: `integer`\n- `readable`: `boolean`\n\nInitialize a new TTY stream with the given file descriptor.\nUsually the file descriptor will be:\n\n - 0 - stdin\n - 1 - stdout\n - 2 - stderr\n\nOn Unix this function will determine the path of the fd of the\nterminal using ttyname_r(3), open it, and use it if the passed\nfile descriptor refers to a TTY. This lets libuv put the tty\nin non-blocking mode without affecting other processes that\nshare the tty.\n\nThis function is not thread safe on systems that don\226\128\153t support\nioctl TIOCGPTN or TIOCPTYGNAME, for instance OpenBSD and\nSolaris.\n\nReturns: `uv_tty_t userdata` or `fail`\n\nNote: If reopening the TTY fails, libuv falls back to blocking\nwrites."}}, new_udp = {binding = "new_udp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"flags"}, ["fnl/docstring"] = "Parameters:\n- `flags`: `table` or `nil`\n  - `family`: `string` or `nil`\n  - `mmsgs`: `integer` or `nil` (default: `1`)\n\nCreates and initializes a new |uv_udp_t|. Returns the Lua\nuserdata wrapping it. The actual socket is created lazily.\n\nSee |luv-constants| for supported address `family` input values.\n\nWhen specified, `mmsgs` determines the number of messages able\nto be received at one time via `recvmmsg(2)` (the allocated\nbuffer will be sized to be able to fit the specified number of\nmax size dgrams). Only has an effect on platforms that support\n`recvmmsg(2)`.\n\nNote: For backwards compatibility reasons, `flags` can also be\na string or integer. When it is a string, it will be treated\nlike the `family` key above. When it is an integer, it will be\nused directly as the `flags` parameter when calling\n`uv_udp_init_ex`.\n\nReturns: `uv_udp_t userdata` or `fail`"}}, new_work = {binding = "new_work", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"work_callback", "after_work_callback"}, ["fnl/docstring"] = "Parameters:\n- `work_callback`: `function` or `string`\n  - `...`: `threadargs` passed to/from\n    `uv.queue_work(work_ctx, ...)`\n- `after_work_callback`: `function`\n  - `...`: `threadargs` returned from `work_callback`\n\nCreates and initializes a new `luv_work_ctx_t` (not\n`uv_work_t`).\n`work_callback` is a Lua function or a string containing Lua\ncode or bytecode dumped from a function. Returns the Lua\nuserdata wrapping it.\n\nReturns: `luv_work_ctx_t userdata`"}}, now = {binding = "now", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current timestamp in milliseconds. The timestamp\nis cached at the start of the event loop tick, see\n|uv.update_time()| for details and rationale.\n\nThe timestamp increases monotonically from some arbitrary\npoint in time. Don't make assumptions about the starting\npoint, you will only get disappointed.\n\nReturns: `integer`\n\nNote: Use |uv.hrtime()| if you need sub-millisecond\ngranularity."}}, os_environ = {binding = "os_environ", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns all environmental variables as a dynamic table of\nnames associated with their corresponding values.\n\nReturns: `table`\n\nWARNING: This function is not thread safe."}}, os_get_passwd = {binding = "os_get_passwd", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns password file information.\n\nReturns: `table`\n- `username` : `string`\n- `uid` : `integer`\n- `gid` : `integer`\n- `shell` : `string`\n- `homedir` : `string`"}}, os_getenv = {binding = "os_getenv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "size"}, ["fnl/docstring"] = "Parameters:\n- `name`: `string`\n- `size`: `integer` (default = `LUAL_BUFFERSIZE`)\n\nReturns the environment variable specified by `name` as\nstring. The internal buffer size can be set by defining\n`size`. If omitted, `LUAL_BUFFERSIZE` is used. If the\nenvironment variable exceeds the storage available in the\ninternal buffer, `ENOBUFS` is returned. If no matching\nenvironment variable exists, `ENOENT` is returned.\n\nReturns: `string` or `fail`\n\nWARNING: This function is not thread safe."}}, os_gethostname = {binding = "os_gethostname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the hostname.\n\nReturns: `string`"}}, os_getpid = {binding = "os_getpid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current process ID.\n\nReturns: `number`"}}, os_getppid = {binding = "os_getppid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the parent process ID.\n\nReturns: `number`"}}, os_getpriority = {binding = "os_getpriority", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pid"}, ["fnl/docstring"] = "Parameters:\n- `pid`: `integer`\n\nReturns the scheduling priority of the process specified by\n`pid`.\n\nReturns: `number` or `fail`"}}, os_homedir = {binding = "os_homedir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns: `string` or `fail`\n\nWARNING: This function is not thread safe."}}, os_setenv = {binding = "os_setenv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "value"}, ["fnl/docstring"] = "Parameters:\n- `name`: `string`\n- `value`: `string`\n\nSets the environmental variable specified by `name` with the\nstring `value`.\n\nReturns: `boolean` or `fail`\n\nWARNING: This function is not thread safe."}}, os_setpriority = {binding = "os_setpriority", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pid", "priority"}, ["fnl/docstring"] = "Parameters:\n- `pid`: `integer`\n- `priority`: `integer`\n\nSets the scheduling priority of the process specified by\n`pid`. The `priority` range is between -20 (high priority) and\n19 (low priority).\n\nReturns: `boolean` or `fail`"}}, os_tmpdir = {binding = "os_tmpdir", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns: `string` or `fail`\n\nWARNING: This function is not thread safe."}}, os_uname = {binding = "os_uname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns system information.\n\nReturns: `table`\n- `sysname` : `string`\n- `release` : `string`\n- `version` : `string`\n- `machine` : `string`"}}, os_unsetenv = {binding = "os_unsetenv", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Parameters:\n- `name`: `string`\n\nUnsets the environmental variable specified by `name`.\n\nReturns: `boolean` or `fail`\n\nWARNING: This function is not thread safe."}}, pipe = {binding = "pipe", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"read_flags", "write_flags"}, ["fnl/docstring"] = "Parameters:\n- `read_flags`: `table` or `nil`\n  - `nonblock`: `boolean` (default: `false`)\n- `write_flags`: `table` or `nil`\n  - `nonblock`: `boolean` (default: `false`)\n\nCreate a pair of connected pipe handles. Data may be written\nto the `write` fd and read from the `read` fd. The resulting\nhandles can be passed to `pipe_open`, used with `spawn`, or\nfor any other purpose.\n\nFlags:\n - `nonblock`: Opens the specified socket handle for\n   `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is\n   recommended for handles that will be used by libuv, and not\n   usually recommended otherwise.\n\nEquivalent to `pipe(2)` with the `O_CLOEXEC` flag set.\n\nReturns: `table` or `fail`\n- `read` : `integer` (file descriptor)\n- `write` : `integer` (file descriptor)\n\n    >lua\n    -- Simple read/write with pipe_open\n    local fds = uv.pipe({nonblock=true}, {nonblock=true})\n\n    local read_pipe = uv.new_pipe()\n    read_pipe:open(fds.read)\n\n    local write_pipe = uv.new_pipe()\n    write_pipe:open(fds.write)\n\n    write_pipe:write(\"hello\")\n    read_pipe:read_start(function(err, chunk)\n      assert(not err, err)\n      print(chunk)\n    end)\n<"}}, pipe_bind = {binding = "pipe_bind", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe", "name"}, ["fnl/docstring"] = "> method form `pipe:bind(name)`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `name`: `string`\n\nBind the pipe to a file path (Unix) or a name (Windows).\n\nReturns: `0` or `fail`\n\nNote: Paths on Unix get truncated to\nsizeof(sockaddr_un.sun_path) bytes, typically between 92 and\n108 bytes."}}, pipe_bind2 = {binding = "pipe_bind2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe", "name", "flags"}, ["fnl/docstring"] = "> method form `pipe:pipe_bind(name, flags)`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `name`: `string`\n- `flags`: `integer` or `table` or `nil` (default: 0)\n\nFlags:\n - If `type(flags)` is `number`, it must be `0` or\n   `uv.constants.PIPE_NO_TRUNCATE`.\n - If `type(flags)` is `table`, it must be `{}` or\n   `{ no_truncate = true|false }`.\n - If `type(flags)` is `nil`, it use default value `0`.\n - Returns `EINVAL` for unsupported flags without performing the\n   bind.\n\nBind the pipe to a file path (Unix) or a name (Windows).\n\nSupports Linux abstract namespace sockets. namelen must include\nthe leading '\\0' byte but not the trailing nul byte.\n\nReturns: `0` or `fail`\n\n*Note*:\n1. Paths on Unix get truncated to sizeof(sockaddr_un.sun_path)\n   bytes, typically between 92 and 108 bytes.\n2. New in version 1.46.0."}}, pipe_chmod = {binding = "pipe_chmod", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe", "flags"}, ["fnl/docstring"] = "> method form `pipe:chmod(flags)`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `flags`: `string`\n\nAlters pipe permissions, allowing it to be accessed from\nprocesses run by different users. Makes the pipe writable or\nreadable by all users. `flags` are: `\"r\"`, `\"w\"`, `\"rw\"`, or\n`\"wr\"` where `r` is `READABLE` and `w` is `WRITABLE`. This\nfunction is blocking.\n\nReturns: `0` or `fail`"}}, pipe_connect = {binding = "pipe_connect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe", "name", "callback"}, ["fnl/docstring"] = "> method form `pipe:connect(name, [callback])`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `name`: `string`\n- `callback`: `callable` or `nil`\n  - `err`: `nil` or `string`\n\nConnect to the Unix domain socket or the named pipe.\n\nReturns: `uv_connect_t userdata` or `fail`\n\nNote: Paths on Unix get truncated to\nsizeof(sockaddr_un.sun_path) bytes, typically between 92 and\n108 bytes."}}, pipe_connect2 = {binding = "pipe_connect2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `pipe:connect2(name, [flags], [callback])`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `name`: `string`\n- `flags`: `integer` or `table` or `nil` (default: 0)\n- `callback`: `callable` or `nil`\n  - `err`: `nil` or `string`\n\n`Flags`:\n\n- If `type(flags)` is `number`, it must be `0` or\n  `uv.constants.PIPE_NO_TRUNCATE`.\n- If `type(flags)` is `table`, it must be `{}` or\n  `{ no_truncate = true|false }`.\n- If `type(flags)` is `nil`, it use default value `0`.\n- Returns `EINVAL` for unsupported flags without performing the\n  bind operation.\n\nConnect to the Unix domain socket or the named pipe.\n\nSupports Linux abstract namespace sockets. namelen must include\nthe leading nul byte but not the trailing nul byte.\n\nReturns: `uv_connect_t userdata` or `fail`\n\n*Note*:\n1. Paths on Unix get truncated to sizeof(sockaddr_un.sun_path)\n   bytes, typically between 92 and 108 bytes.\n2. New in version 1.46.0."}}, pipe_getpeername = {binding = "pipe_getpeername", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe"}, ["fnl/docstring"] = "> method form `pipe:getpeername()`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n\nGet the name of the Unix domain socket or the named pipe to\nwhich the handle is connected.\n\nReturns: `string` or `fail`"}}, pipe_getsockname = {binding = "pipe_getsockname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe"}, ["fnl/docstring"] = "> method form `pipe:getsockname()`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n\nGet the name of the Unix domain socket or the named pipe.\n\nReturns: `string` or `fail`"}}, pipe_open = {binding = "pipe_open", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe", "fd"}, ["fnl/docstring"] = "> method form `pipe:open(fd)`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `fd`: `integer`\n\nOpen an existing file descriptor or |uv_handle_t| as a\npipe.\n\nReturns: `0` or `fail`\n\nNote: The file descriptor is set to non-blocking mode."}}, pipe_pending_count = {binding = "pipe_pending_count", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe"}, ["fnl/docstring"] = "> method form `pipe:pending_count()`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n\nReturns the pending pipe count for the named pipe.\n\nReturns: `integer`"}}, pipe_pending_instances = {binding = "pipe_pending_instances", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe", "count"}, ["fnl/docstring"] = "> method form `pipe:pending_instances(count)`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n- `count`: `integer`\n\nSet the number of pending pipe instance handles when the pipe\nserver is waiting for connections.\n\nReturns: Nothing.\n\nNote: This setting applies to Windows only."}}, pipe_pending_type = {binding = "pipe_pending_type", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"pipe"}, ["fnl/docstring"] = "> method form `pipe:pending_type()`\n\nParameters:\n- `pipe`: `uv_pipe_t userdata`\n\nUsed to receive handles over IPC pipes.\n\nFirst - call |uv.pipe_pending_count()|, if it's > 0 then\ninitialize a handle of the given type, returned by\n`uv.pipe_pending_type()` and call `uv.accept(pipe, handle)` .\n\nReturns: `string`"}}, poll_start = {binding = "poll_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"poll", "events", "callback"}, ["fnl/docstring"] = "> method form `poll:start(events, callback)`\n\nParameters:\n- `poll`: `uv_poll_t userdata`\n- `events`: `string` or `nil` (default: `\"rw\"`)\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n  - `events`: `string` or `nil`\n\nStarts polling the file descriptor. `events` are: `\"r\"`,\n`\"w\"`, `\"rw\"`, `\"d\"`, `\"rd\"`, `\"wd\"`, `\"rwd\"`, `\"p\"`, `\"rp\"`,\n`\"wp\"`, `\"rwp\"`, `\"dp\"`, `\"rdp\"`, `\"wdp\"`, or `\"rwdp\"` where\n`r` is `READABLE`, `w` is `WRITABLE`, `d` is `DISCONNECT`, and\n`p` is `PRIORITIZED`. As soon as an event is detected the\ncallback will be called with status set to 0, and the detected\nevents set on the events field.\n\nThe user should not close the socket while the handle is\nactive. If the user does that anyway, the callback may be\ncalled reporting an error status, but this is not guaranteed.\n\nReturns: `0` or `fail`\n\nNote Calling `uv.poll_start()` on a handle that is already\nactive is fine. Doing so will update the events mask that is\nbeing watched for."}}, poll_stop = {binding = "poll_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"poll"}, ["fnl/docstring"] = "> method form `poll:stop()`\n\nParameters:\n- `poll`: `uv_poll_t userdata`\n\nStop polling the file descriptor, the callback will no longer\nbe called.\n\nReturns: `0` or `fail`"}}, prepare_start = {binding = "prepare_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"prepare", "callback"}, ["fnl/docstring"] = "> method form `prepare:start(callback)`\n\nParameters:\n- `prepare`: `uv_prepare_t userdata`\n- `callback`: `callable`\n\nStart the handle with the given callback.\n\nReturns: `0` or `fail`"}}, prepare_stop = {binding = "prepare_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"prepare"}, ["fnl/docstring"] = "> method form `prepare:stop()`\n\nParameters:\n- `prepare`: `uv_prepare_t userdata`\n\nStop the handle, the callback will no longer be called.\n\nReturns: `0` or `fail`"}}, print_active_handles = {binding = "print_active_handles", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "The same as |uv.print_all_handles()| except only active\nhandles are printed.\n\nReturns: Nothing.\n\nNote: This is not available on Windows.\n\nWARNING: This function is meant for ad hoc debugging, there\nare no API/ABI stability guarantees."}}, print_all_handles = {binding = "print_all_handles", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Prints all handles associated with the main loop to stderr.\nThe format is `[flags] handle-type handle-address` . Flags are\n`R` for referenced, `A` for active and `I` for internal.\n\nReturns: Nothing.\n\nNote: This is not available on Windows.\n\nWARNING: This function is meant for ad hoc debugging, there\nare no API/ABI stability guarantees."}}, process_get_pid = {binding = "process_get_pid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"process"}, ["fnl/docstring"] = "> method form `process:get_pid()`\n\nParameters:\n- `process`: `uv_process_t userdata`\n\nReturns the handle's pid.\n\nReturns: `integer`"}}, process_kill = {binding = "process_kill", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"process", "signame"}, ["fnl/docstring"] = "> method form `process:kill(signame)`\n\nParameters:\n- `process`: `uv_process_t userdata`\n- `signame`: `string` or `integer` or `nil` (default: `sigterm`)\n\nSends the specified signal to the given process handle. Check\nthe documentation on |uv_signal_t| for signal support,\nspecially on Windows.\n\nSee |luv-constants| for supported `signame` input and output\nvalues.\n\nReturns: `0` or `fail`"}}, queue_work = {binding = "queue_work", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"work_ctx", "..."}, ["fnl/docstring"] = "> method form `work_ctx:queue(...)`\n\nParameters:\n- `work_ctx`: `luv_work_ctx_t userdata`\n- `...`: `threadargs`\n\nQueues a work request which will run `work_callback` in a new\nLua state in a thread from the threadpool with any additional\narguments from `...`. Values returned from `work_callback` are\npassed to `after_work_callback`, which is called in the main\nloop thread.\n\nReturns: `boolean` or `fail`"}}, random = {binding = "random", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"len", "flags", "callback"}, ["fnl/docstring"] = "Parameters:\n- `len`: `integer`\n- `flags`: `nil` (see below)\n- `callback`: `callable` (async version) or `nil` (sync\n  version)\n  - `err`: `nil` or `string`\n  - `bytes`: `string` or `nil`\n\nFills a string of length `len` with cryptographically strong\nrandom bytes acquired from the system CSPRNG. `flags` is\nreserved for future extension and must currently be `nil` or\n`0` or `{}`.\n\nShort reads are not possible. When less than `len` random\nbytes are available, a non-zero error value is returned or\npassed to the callback. If the callback is omitted, this\nfunction is completed synchronously.\n\nThe synchronous version may block indefinitely when not enough\nentropy is available. The asynchronous version may not ever\nfinish when the system is low on entropy.\n\nReturns (sync version): `string` or `fail`\n\nReturns (async version): `0` or `fail`"}}, read_start = {binding = "read_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "callback"}, ["fnl/docstring"] = "> method form `stream:read_start(callback)`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n  - `data`: `string` or `nil`\n\nRead data from an incoming stream. The callback will be made\nseveral times until there is no more data to read or\n|uv.read_stop()| is called. When we've reached EOF, `data`\nwill be `nil`.\n\nReturns: `0` or `fail`\n\n    >lua\n    stream:read_start(function (err, chunk)\n      if err then\n        -- handle read error\n      elseif chunk then\n        -- handle data\n      else\n        -- handle disconnect\n      end\n    end)\n<"}}, read_stop = {binding = "read_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream"}, ["fnl/docstring"] = "> method form `stream:read_stop()`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n\nStop reading data from the stream. The read callback will no\nlonger be called.\n\nThis function is idempotent and may be safely called on a\nstopped stream.\n\nReturns: `0` or `fail`"}}, recv_buffer_size = {binding = "recv_buffer_size", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle", "size"}, ["fnl/docstring"] = "> method form `handle:recv_buffer_size([size])`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n- `size`: `integer` or `nil` (default: `0`)\n\nGets or sets the size of the receive buffer that the operating\nsystem uses for the socket.\n\nIf `size` is omitted (or `0`), this will return the current\nsend buffer size; otherwise, this will use `size` to set the\nnew send buffer size.\n\nThis function works for TCP, pipe and UDP handles on Unix and\nfor TCP and UDP handles on Windows.\n\nReturns:\n- `integer` or `fail` (if `size` is `nil` or `0`)\n- `0` or `fail` (if `size` is not `nil` and not `0`)\n\nNote: Linux will set double the size and return double the\nsize of the original set value."}}, ref = {binding = "ref", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:ref()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nReference the given handle. References are idempotent, that\nis, if a handle is already referenced calling this function\nagain will have no effect.\n\nReturns: Nothing.\n\nSee |luv-reference-counting|."}}, req_get_type = {binding = "req_get_type", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"req"}, ["fnl/docstring"] = "> method form `req:get_type()`\n\nParameters:\n- `req`: `userdata` for sub-type of |uv_req_t|\n\nReturns the name of the struct for a given request (e.g.\n`\"fs\"` for |uv_fs_t|) and the libuv enum integer for the\nrequest's type (`uv_req_type`).\n\nReturns: `string, integer`"}}, resident_set_memory = {binding = "resident_set_memory", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the resident set size (RSS) for the current process.\n\nReturns: `integer` or `fail`"}}, run = {binding = "run", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"mode"}, ["fnl/docstring"] = "Parameters:\n- `mode`: `string` or `nil` (default: `\"default\"`)\n\nThis function runs the event loop. It will act differently\ndepending on the specified mode:\n\n  - `\"default\"`: Runs the event loop until there are no more\n    active and referenced handles or requests. Returns `true`\n    if |uv.stop()| was called and there are still active\n    handles or requests. Returns `false` in all other cases.\n\n  - `\"once\"`: Poll for I/O once. Note that this function\n    blocks if there are no pending callbacks. Returns `false`\n    when done (no active handles or requests left), or `true`\n    if more callbacks are expected (meaning you should run the\n    event loop again sometime in the future).\n\n  - `\"nowait\"`: Poll for I/O once but don't block if there are\n    no pending callbacks. Returns `false` if done (no active\n    handles or requests left), or `true` if more callbacks are\n    expected (meaning you should run the event loop again\n    sometime in the future).\n\nReturns: `boolean` or `fail`\n\nNote: Luvit will implicitly call `uv.run()` after loading user\ncode, but if you use the luv bindings directly, you need to\ncall this after registering your initial set of event\ncallbacks to start the event loop."}}, send_buffer_size = {binding = "send_buffer_size", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle", "size"}, ["fnl/docstring"] = "> method form `handle:send_buffer_size([size])`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n- `size`: `integer` or `nil` (default: `0`)\n\nGets or sets the size of the send buffer that the operating\nsystem uses for the socket.\n\nIf `size` is omitted (or `0`), this will return the current\nsend buffer size; otherwise, this will use `size` to set the\nnew send buffer size.\n\nThis function works for TCP, pipe and UDP handles on Unix and\nfor TCP and UDP handles on Windows.\n\nReturns:\n- `integer` or `fail` (if `size` is `nil` or `0`)\n- `0` or `fail` (if `size` is not `nil` and not `0`)\n\nNote: Linux will set double the size and return double the\nsize of the original set value."}}, set_process_title = {binding = "set_process_title", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"title"}, ["fnl/docstring"] = "Parameters:\n- `title`: `string`\n\nSets the title of the current process with the string `title`.\n\nReturns: `0` or `fail`"}}, setgid = {binding = "setgid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id"}, ["fnl/docstring"] = "Parameters:\n- `id`: `integer`\n\nSets the group ID of the process with the integer `id`.\n\nReturns: Nothing.\n\nNote: This is not a libuv function and is not supported on\nWindows."}}, setuid = {binding = "setuid", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"id"}, ["fnl/docstring"] = "Parameters:\n- `id`: `integer`\n\nSets the user ID of the process with the integer `id`.\n\nReturns: Nothing.\n\nNote: This is not a libuv function and is not supported on\nWindows."}}, shutdown = {binding = "shutdown", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "callback"}, ["fnl/docstring"] = "> method form `stream:shutdown([callback])`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `callback`: `callable` or `nil`\n  - `err`: `nil` or `string`\n\nShutdown the outgoing (write) side of a duplex stream. It\nwaits for pending write requests to complete. The callback is\ncalled after shutdown is complete.\n\nReturns: `uv_shutdown_t userdata` or `fail`"}}, signal_start = {binding = "signal_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"signal", "signame", "callback"}, ["fnl/docstring"] = "> method form `signal:start(signame, callback)`\n\nParameters:\n- `signal`: `uv_signal_t userdata`\n- `signame`: `string` or `integer`\n- `callback`: `callable`\n  - `signame`: `string`\n\nStart the handle with the given callback, watching for the\ngiven signal.\n\nSee |luv-constants| for supported `signame` input and output\nvalues.\n\nReturns: `0` or `fail`\n                                     "}}, signal_start_oneshot = {binding = "signal_start_oneshot", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"signal", "signame", "callback"}, ["fnl/docstring"] = "> method form `signal:start_oneshot(signame, callback)`\n\nParameters:\n- `signal`: `uv_signal_t userdata`\n- `signame`: `string` or `integer`\n- `callback`: `callable`\n  - `signame`: `string`\n\nSame functionality as |uv.signal_start()| but the signal\nhandler is reset the moment the signal is received.\n\nSee |luv-constants| for supported `signame` input and output\nvalues.\n\nReturns: `0` or `fail`"}}, signal_stop = {binding = "signal_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"signal"}, ["fnl/docstring"] = "> method form `signal:stop()`\n\nParameters:\n- `signal`: `uv_signal_t userdata`\n\nStop the handle, the callback will no longer be called.\n\nReturns: `0` or `fail`"}}, sleep = {binding = "sleep", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"msec"}, ["fnl/docstring"] = "Parameters:\n- `msec`: `integer`\n\nPauses the thread in which this is called for a number of\nmilliseconds.\n\nReturns: Nothing."}}, socketpair = {binding = "socketpair", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"socktype", "protocol", "flags1", "flags2"}, ["fnl/docstring"] = "Parameters:\n- `socktype`: `string`, `integer` or `nil` (default: `stream`)\n- `protocol`: `string`, `integer` or `nil` (default: 0)\n- `flags1`: `table` or `nil`\n  - `nonblock`: `boolean` (default: `false`)\n- `flags2`: `table` or `nil`\n  - `nonblock`: `boolean` (default: `false`)\n\nCreate a pair of connected sockets with the specified\nproperties. The resulting handles can be passed to\n|uv.tcp_open()|, used with |uv.spawn()|, or for any other\npurpose.\n\nSee |luv-constants| for supported `socktype` input values.\n\nWhen `protocol` is set to 0 or nil, it will be automatically\nchosen based on the socket's domain and type. When `protocol`\nis specified as a string, it will be looked up using the\n`getprotobyname(3)` function (examples: `\"ip\"`, `\"icmp\"`,\n`\"tcp\"`, `\"udp\"`, etc).\n\nFlags:\n - `nonblock`: Opens the specified socket handle for\n   `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is\n   recommended for handles that will be used by libuv, and not\n   usually recommended otherwise.\n\nEquivalent to `socketpair(2)` with a domain of `AF_UNIX`.\n\nReturns: `table` or `fail`\n- `[1, 2]` : `integer` (file descriptor)\n\n    >lua\n    -- Simple read/write with tcp\n    local fds = uv.socketpair(nil, nil, {nonblock=true}, {nonblock=true})\n\n    local sock1 = uv.new_tcp()\n    sock1:open(fds[1])\n\n    local sock2 = uv.new_tcp()\n    sock2:open(fds[2])\n\n    sock1:write(\"hello\")\n    sock2:read_start(function(err, chunk)\n      assert(not err, err)\n      print(chunk)\n    end)\n<"}}, spawn = {binding = "spawn", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"path", "options", "on_exit"}, ["fnl/docstring"] = "Parameters:\n- `path`: `string`\n- `options`: `table` (see below)\n- `on_exit`: `callable`\n  - `code`: `integer`\n  - `signal`: `integer`\n\nInitializes the process handle and starts the process. If the\nprocess is successfully spawned, this function will return the\nhandle and pid of the child process.\n\nPossible reasons for failing to spawn would include (but not\nbe limited to) the file to execute not existing, not having\npermissions to use the setuid or setgid specified, or not\nhaving enough memory to allocate for the new process.\n\n    >lua\n    local stdin = uv.new_pipe()\n    local stdout = uv.new_pipe()\n    local stderr = uv.new_pipe()\n\n    print(\"stdin\", stdin)\n    print(\"stdout\", stdout)\n    print(\"stderr\", stderr)\n\n    local handle, pid = uv.spawn(\"cat\", {\n      stdio = {stdin, stdout, stderr}\n    }, function(code, signal) -- on exit\n      print(\"exit code\", code)\n      print(\"exit signal\", signal)\n    end)\n\n    print(\"process opened\", handle, pid)\n\n    uv.read_start(stdout, function(err, data)\n      assert(not err, err)\n      if data then\n        print(\"stdout chunk\", stdout, data)\n      else\n        print(\"stdout end\", stdout)\n      end\n    end)\n\n    uv.read_start(stderr, function(err, data)\n      assert(not err, err)\n      if data then\n        print(\"stderr chunk\", stderr, data)\n      else\n        print(\"stderr end\", stderr)\n      end\n    end)\n\n    uv.write(stdin, \"Hello World\")\n\n    uv.shutdown(stdin, function()\n      print(\"stdin shutdown\", stdin)\n      uv.close(handle, function()\n        print(\"process closed\", handle, pid)\n      end)\n    end)\n<\n                                              *uv.spawn-options*\nThe `options` table accepts the following fields:\n\n  - `options.args` - Command line arguments as a list of\n    strings. The first string should not be the path to the\n    program, since that is already provided via `path`. On\n    Windows, this uses CreateProcess which concatenates the\n    arguments into a string. This can cause some strange\n    errors (see `options.verbatim` below for Windows).\n  - `options.stdio` - Set the file descriptors that will be\n    made available to the child process. The convention is\n    that the first entries are stdin, stdout, and stderr.\n    (Note: On Windows, file descriptors after the third are\n    available to the child process only if the child processes\n    uses the MSVCRT runtime.)\n  - `options.env` - Set environment variables for the new\n    process.\n  - `options.cwd` - Set the current working directory for the\n    sub-process.\n  - `options.uid` - Set the child process' user id.\n  - `options.gid` - Set the child process' group id.\n  - `options.verbatim` - If true, do not wrap any arguments in\n    quotes, or perform any other escaping, when converting the\n    argument list into a command line string. This option is\n    only meaningful on Windows systems. On Unix it is silently\n    ignored.\n  - `options.detached` - If true, spawn the child process in a\n    detached state - this will make it a process group leader,\n    and will effectively enable the child to keep running\n    after the parent exits. Note that the child process will\n    still keep the parent's event loop alive unless the parent\n    process calls |uv.unref()| on the child's process handle.\n  - `options.hide` - If true, hide the subprocess console\n    window that would normally be created. This option is only\n    meaningful on Windows systems. On Unix it is silently\n    ignored.\n\nThe `options.stdio` entries can take many shapes.\n\n  - If they are numbers, then the child process inherits that\n    same zero-indexed fd from the parent process.\n  - If |uv_stream_t| handles are passed in, those are used as\n    a read-write pipe or inherited stream depending if the\n    stream has a valid fd.\n  - Including `nil` placeholders means to ignore that fd in\n    the child process.\n\nWhen the child process exits, `on_exit` is called with an exit\ncode and signal.\n\nReturns: `uv_process_t userdata`, `integer`"}}, stop = {binding = "stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Stop the event loop, causing |uv.run()| to end as soon as\npossible. This will happen not sooner than the next loop\niteration. If this function was called before blocking for\nI/O, the loop won't block for I/O on this iteration.\n\nReturns: Nothing."}}, stream_get_write_queue_size = {binding = "stream_get_write_queue_size", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `stream:get_write_queue_size()`\n\nReturns the stream's write queue size.\n\nReturns: `integer`"}}, stream_set_blocking = {binding = "stream_set_blocking", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "blocking"}, ["fnl/docstring"] = "> method form `stream:set_blocking(blocking)`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `blocking`: `boolean`\n\nEnable or disable blocking mode for a stream.\n\nWhen blocking mode is enabled all writes complete\nsynchronously. The interface remains unchanged otherwise, e.g.\ncompletion or failure of the operation will still be reported\nthrough a callback which is made asynchronously.\n\nReturns: `0` or `fail`\n\nWARNING: Relying too much on this API is not recommended. It\nis likely to change significantly in the future. Currently\nthis only works on Windows and only for |uv_pipe_t| handles.\nAlso libuv currently makes no ordering guarantee when the\nblocking mode is changed after write requests have already\nbeen submitted. Therefore it is recommended to set the\nblocking mode immediately after opening or creating the\nstream."}}, tcp_bind = {binding = "tcp_bind", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp", "host", "port", "flags"}, ["fnl/docstring"] = "> method form `tcp:bind(host, port, [flags])`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `host`: `string`\n- `port`: `integer`\n- `flags`: `table` or `nil`\n  - `ipv6only`: `boolean`\n\nBind the handle to an host and port. `host` should be an IP\naddress and not a domain name. Any `flags` are set with a\ntable with field `ipv6only` equal to `true` or `false`.\n\nWhen the port is already taken, you can expect to see an\n`EADDRINUSE` error from either `uv.tcp_bind()`, |uv.listen()|\nor |uv.tcp_connect()|. That is, a successful call to this\nfunction does not guarantee that the call to |uv.listen()| or\n|uv.tcp_connect()| will succeed as well.\n\nUse a port of `0` to let the OS assign an ephemeral port.  You\ncan look it up later using |uv.tcp_getsockname()|.\n\nReturns: `0` or `fail`"}}, tcp_close_reset = {binding = "tcp_close_reset", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"callback"}, ["fnl/docstring"] = "> method form `tcp:close_reset([callback])`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `callback`: `callable` or `nil`\n\nResets a TCP connection by sending a RST packet. This is\naccomplished by setting the SO_LINGER socket option with a\nlinger interval of zero and then calling |uv.close()|. Due to\nsome platform inconsistencies, mixing of |uv.shutdown()| and\n`uv.tcp_close_reset()` calls is not allowed.\n\nReturns: `0` or `fail`\n                                               "}}, tcp_connect = {binding = "tcp_connect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp", "host", "port", "callback"}, ["fnl/docstring"] = "> method form `tcp:connect(host, port, callback)`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `host`: `string`\n- `port`: `integer`\n- `callback`: `callable`\n   - `err`: `nil` or `string`\n\nEstablish an IPv4 or IPv6 TCP connection.\n\nReturns: `uv_connect_t userdata` or `fail`\n\n    >lua\n    local client = uv.new_tcp()\n    client:connect(\"127.0.0.1\", 8080, function (err)\n      -- check error and carry on.\n    end)\n<"}}, tcp_getpeername = {binding = "tcp_getpeername", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp"}, ["fnl/docstring"] = "> method form `tcp:getpeername()`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n\nGet the address of the peer connected to the handle.\n\nSee |luv-constants| for supported address `family` output values.\n\nReturns: `table` or `fail`\n- `ip` : `string`\n- `family` : `string`\n- `port` : `integer`"}}, tcp_getsockname = {binding = "tcp_getsockname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp"}, ["fnl/docstring"] = "> method form `tcp:getsockname()`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n\nGet the current address to which the handle is bound.\n\nSee |luv-constants| for supported address `family` output values.\n\nReturns: `table` or `fail`\n- `ip` : `string`\n- `family` : `string`\n- `port` : `integer`"}}, tcp_keepalive = {binding = "tcp_keepalive", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp", "enable", "delay"}, ["fnl/docstring"] = "> method form `tcp:keepalive(enable, [delay])`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `enable`: `boolean`\n- `delay`: `integer` or `nil`\n\nEnable / disable TCP keep-alive. `delay` is the initial delay\nin seconds, ignored when enable is `false`.\n\nReturns: `0` or `fail`"}}, tcp_nodelay = {binding = "tcp_nodelay", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp", "enable"}, ["fnl/docstring"] = "> method form `tcp:nodelay(enable)`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `enable`: `boolean`\n\nEnable / disable Nagle's algorithm.\n\nReturns: `0` or `fail`"}}, tcp_open = {binding = "tcp_open", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp", "sock"}, ["fnl/docstring"] = "> method form `tcp:open(sock)`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `sock`: `integer`\n\nOpen an existing file descriptor or SOCKET as a TCP handle.\n\nReturns: `0` or `fail`\n\nNote: The passed file descriptor or SOCKET is not checked for\nits type, but it's required that it represents a valid stream\nsocket."}}, tcp_simultaneous_accepts = {binding = "tcp_simultaneous_accepts", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp", "enable"}, ["fnl/docstring"] = "> method form `tcp:simultaneous_accepts(enable)`\n\nParameters:\n- `tcp`: `uv_tcp_t userdata`\n- `enable`: `boolean`\n\nEnable / disable simultaneous asynchronous accept requests\nthat are queued by the operating system when listening for new\nTCP connections.\n\nThis setting is used to tune a TCP server for the desired\nperformance. Having simultaneous accepts can significantly\nimprove the rate of accepting connections (which is why it is\nenabled by default) but may lead to uneven load distribution\nin multi-process setups.\n\nReturns: `0` or `fail`"}}, tcp_write_queue_size = {binding = "tcp_write_queue_size", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tcp"}, ["fnl/docstring"] = "> method form `tcp:write_queue_size()`\n\nDEPRECATED: Please use |uv.stream_get_write_queue_size()|\ninstead."}}, thread = {binding = "thread", fields = {getpriority = {binding = "getpriority", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread"}, ["fnl/docstring"] = "> method form `thread:getpriority()`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n\nGets the thread's priority setting.\n\nRetrieves the scheduling priority of the specified thread. The\nreturned priority value is platform dependent.\n\nFor Linux, when schedule policy is SCHED_OTHER (default),\npriority is 0.\n\nReturns: `number` or `fail`"}}, setpriority = {binding = "setpriority", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread", "priority"}, ["fnl/docstring"] = "> method form `thread:setpriority(priority)`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n- `priority`: `number`\n\nSets the specified thread's scheduling priority setting. It\nrequires elevated privilege to set specific priorities on some\nplatforms. The priority can be set to the following constants:\n- `uv.constants.THREAD_PRIORITY_HIGHEST`\n- `uv.constants.THREAD_PRIORITY_ABOVE_NORMAL`\n- `uv.constants.THREAD_PRIORITY_NORMAL`\n- `uv.constants.THREAD_PRIORITY_BELOW_NORMAL`\n- `uv.constants.THREAD_PRIORITY_LOWEST`\n\nReturns: `boolean` or `fail`"}}}, metadata = {["fls/itemKind"] = "Module"}}, thread_detach = {binding = "thread_detach", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread"}, ["fnl/docstring"] = "> method form `thread:detach()`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n\nDetaches a thread. Detached threads automatically release\ntheir resources upon termination, eliminating the need for the\napplication to call `uv.thread_join`.\n\nReturns: `boolean` or `fail`"}}, thread_equal = {binding = "thread_equal", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread", "other_thread"}, ["fnl/docstring"] = "> method form `thread:equal(other_thread)`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n- `other_thread`: `luv_thread_t userdata`\n\nReturns a boolean indicating whether two threads are the same.\nThis function is equivalent to the `__eq` metamethod.\n\nReturns: `boolean`\n                                     "}}, thread_getaffinity = {binding = "thread_getaffinity", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread", "mask_size"}, ["fnl/docstring"] = "> method form `thread:getaffinity([mask_size])`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n- `mask_size`: `integer`\n\nGets the specified thread's affinity setting.\n\nIf `mask_size` is provided, it must be greater than or equal\nto `uv.cpumask_size()`. If the `mask_size` parameter is\nomitted, then the return of `uv.cpumask_size()` will be used.\nReturns an array-like table where each of the keys correspond\nto a CPU number and the values are booleans that represent\nwhether the `thread` is eligible to run on that CPU.\n\nNote: Thread affinity getting is not atomic on Windows.\nUnsupported on macOS.\n\nReturns: `table` or `fail`\n- `[1, 2, 3, ..., n]` : `boolean`"}}, thread_getcpu = {binding = "thread_getcpu", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Gets the CPU number on which the calling thread is running.\n\nNote: The first CPU will be returned as the number 1, not 0.\nThis allows for the number to correspond with the table keys\nused in `uv.thread_getaffinity` and `uv.thread_setaffinity`.\n\nReturns: `integer` or `fail`"}}, thread_getname = {binding = "thread_getname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread"}, ["fnl/docstring"] = "> method form `thread:getname()`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n\nGets the name of the thread specified by `thread`.\n\nReturns: `string` or `fail`"}}, thread_join = {binding = "thread_join", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread"}, ["fnl/docstring"] = "> method form `thread:join()`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n\nWaits for the `thread` to finish executing its entry function.\n\nReturns: `boolean` or `fail`"}}, thread_self = {binding = "thread_self", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the handle for the thread in which this is called.\n\nReturns: `luv_thread_t`"}}, thread_setaffinity = {binding = "thread_setaffinity", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"thread", "affinity", "get_old_affinity"}, ["fnl/docstring"] = "> method form `thread:setaffinity(affinity, [get_old_affinity])`\n\nParameters:\n- `thread`: `luv_thread_t userdata`\n- `affinity`: `table`\n  - `[1, 2, 3, ..., n]` : `boolean`\n- `get_old_affinity`: `boolean`\n\nSets the specified thread's affinity setting.\n\n`affinity` must be a table where each of the keys are a CPU\nnumber and the values are booleans that represent whether the\n`thread` should be eligible to run on that CPU. If the length\nof the `affinity` table is not greater than or equal to\n|uv.cpumask_size()|, any CPU numbers missing from the table\nwill have their affinity set to `false`. If setting the\naffinity of more than |uv.cpumask_size()| CPUs is desired,\n`affinity` must be an array-like table with no gaps, since\n`#affinity` will be used as the `cpumask_size` if it is\ngreater than |uv.cpumask_size()|.\n\nIf `get_old_affinity` is `true`, the previous affinity\nsettings for the `thread` will be returned. Otherwise, `true`\nis returned after a successful call.\n\nNote: Thread affinity setting is not atomic on Windows.\nUnsupported on macOS.\n\nReturns: `table` or `boolean` or `fail`\n- `[1, 2, 3, ..., n]` : `boolean`"}}, thread_setname = {binding = "thread_setname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name"}, ["fnl/docstring"] = "Parameters:\n- `name`: `string`\n\nSets the name of the current thread. Different platforms\ndefine different limits on the max number of characters a\nthread name can be: Linux, IBM i (16), macOS (64), Windows\n(32767), and NetBSD (32), etc. The name will be truncated if\n`name` is larger than the limit of the platform.\n\nReturns: `0` or `fail`"}}, timer_again = {binding = "timer_again", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer"}, ["fnl/docstring"] = "> method form `timer:again()`\n\nParameters:\n- `timer`: `uv_timer_t userdata`\n\nStop the timer, and if it is repeating restart it using the\nrepeat value as the timeout. If the timer has never been\nstarted before it raises `EINVAL`.\n\nReturns: `0` or `fail`"}}, timer_get_due_in = {binding = "timer_get_due_in", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer"}, ["fnl/docstring"] = "> method form `timer:get_due_in()`\n\nParameters:\n- `timer`: `uv_timer_t userdata`\n\nGet the timer due value or 0 if it has expired. The time is\nrelative to |uv.now()|.\n\nReturns: `integer`\n\nNote: New in libuv version 1.40.0."}}, timer_get_repeat = {binding = "timer_get_repeat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer"}, ["fnl/docstring"] = "> method form `timer:get_repeat()`\n\nParameters:\n- `timer`: `uv_timer_t userdata`\n\nGet the timer repeat value.\n\nReturns: `integer`"}}, timer_set_repeat = {binding = "timer_set_repeat", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer", "repeat"}, ["fnl/docstring"] = "> method form `timer:set_repeat(repeat)`\n\nParameters:\n- `timer`: `uv_timer_t userdata`\n- `repeat`: `integer`\n\nSet the repeat interval value in milliseconds. The timer will\nbe scheduled to run on the given interval, regardless of the\ncallback execution duration, and will follow normal timer\nsemantics in the case of a time-slice overrun.\n\nFor example, if a 50 ms repeating timer first runs for 17 ms,\nit will be scheduled to run again 33 ms later. If other tasks\nconsume more than the 33 ms following the first timer\ncallback, then the callback will run as soon as possible.\n\nReturns: Nothing."}}, timer_start = {binding = "timer_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer", "timeout", "repeat", "callback"}, ["fnl/docstring"] = "> method form `timer:start(timeout, repeat, callback)`\n\nParameters:\n- `timer`: `uv_timer_t userdata`\n- `timeout`: `integer`\n- `repeat`: `integer`\n- `callback`: `callable`\n\nStart the timer. `timeout` and `repeat` are in milliseconds.\n\nIf `timeout` is zero, the callback fires on the next event\nloop iteration. If `repeat` is non-zero, the callback fires\nfirst after `timeout` milliseconds and then repeatedly after\n`repeat` milliseconds.\n\nReturns: `0` or `fail`"}}, timer_stop = {binding = "timer_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"timer"}, ["fnl/docstring"] = "> method form `timer:stop()`\n\nParameters:\n- `timer`: `uv_timer_t userdata`\n\nStop the timer, the callback will not be called anymore.\n\nReturns: `0` or `fail`"}}, translate_sys_error = {binding = "translate_sys_error", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"errcode"}, ["fnl/docstring"] = "Parameters:\n- `errcode`: `integer`\n\nReturns the libuv error message and error name (both in string\nform, see `err` and `name` in |luv-error-handling|) equivalent\nto the given platform dependent error code: POSIX error codes\non Unix (the ones stored in errno), and Win32 error codes on\nWindows (those returned by GetLastError() or\nWSAGetLastError()).\n\nReturns: `string, string` or `nil`"}}, try_write = {binding = "try_write", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "data"}, ["fnl/docstring"] = "> method form `stream:try_write(data)`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `data`: `buffer`\n\nSame as |uv.write()|, but won't queue a write request if it\ncan't be completed immediately.\n\nWill return number of bytes written (can be less than the\nsupplied buffer size).\n\nReturns: `integer` or `fail`"}}, try_write2 = {binding = "try_write2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "data", "send_handle"}, ["fnl/docstring"] = "> method form `stream:try_write2(data, send_handle)`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `data`: `buffer`\n- `send_handle`: `userdata` for sub-type of |uv_stream_t|\n\nLike |uv.write2()|, but with the properties of\n|uv.try_write()|. Not supported on Windows, where it returns\n`UV_EAGAIN`.\n\nWill return number of bytes written (can be less than the\nsupplied buffer size).\n\nReturns: `integer` or `fail`"}}, tty_get_vterm_state = {binding = "tty_get_vterm_state", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Get the current state of whether console virtual terminal\nsequences are handled by libuv or the console. The return\nvalue is `\"supported\"` or `\"unsupported\"`.\n\nThis function is not implemented on Unix, where it returns\n`ENOTSUP`.\n\nReturns: `string` or `fail`"}}, tty_get_winsize = {binding = "tty_get_winsize", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tty"}, ["fnl/docstring"] = "> method form `tty:get_winsize()`\n\nParameters:\n- `tty`: `uv_tty_t userdata`\n\nGets the current Window width and height.\n\nReturns: `integer, integer` or `fail`"}}, tty_reset_mode = {binding = "tty_reset_mode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "To be called when the program exits. Resets TTY settings to\ndefault values for the next process to take over.\n\nThis function is async signal-safe on Unix platforms but can\nfail with error code `EBUSY` if you call it when execution is\ninside |uv.tty_set_mode()|.\n\nReturns: `0` or `fail`"}}, tty_set_mode = {binding = "tty_set_mode", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"tty", "mode"}, ["fnl/docstring"] = "> method form `tty:set_mode(mode)`\n\nParameters:\n- `tty`: `uv_tty_t userdata`\n- `mode`: `string` or `integer`\n\nSet the TTY using the specified terminal mode.\n\nSee |luv-constants| for supported TTY mode input values.\n\nReturns: `0` or `fail`"}}, tty_set_vterm_state = {binding = "tty_set_vterm_state", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"state"}, ["fnl/docstring"] = "Parameters:\n- `state`: `string`\n\nControls whether console virtual terminal sequences are\nprocessed by libuv or console. Useful in particular for\nenabling ConEmu support of ANSI X3.64 and Xterm 256 colors.\nOtherwise Windows10 consoles are usually detected\nautomatically. State should be one of: `\"supported\"` or\n`\"unsupported\"`.\n\nThis function is only meaningful on Windows systems. On Unix\nit is silently ignored.\n\nReturns: none"}}, udp_bind = {binding = "udp_bind", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "host", "port", "flags"}, ["fnl/docstring"] = "> method form `udp:bind(host, port, [flags])`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `host`: `string`\n- `port`: `number`\n- `flags`: `table` or `nil`\n  - `ipv6only`: `boolean`\n  - `reuseaddr`: `boolean`\n\nBind the UDP handle to an IP address and port. Any `flags` are\nset with a table with fields `reuseaddr` or `ipv6only` equal\nto `true` or `false`.\n\nReturns: `0` or `fail`"}}, udp_connect = {binding = "udp_connect", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "host", "port"}, ["fnl/docstring"] = "> method form `udp:connect(host, port)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `host`: `string`\n- `port`: `integer`\n\nAssociate the UDP handle to a remote address and port, so\nevery message sent by this handle is automatically sent to\nthat destination. Calling this function with a NULL addr\ndisconnects the handle. Trying to call `uv.udp_connect()` on\nan already connected handle will result in an `EISCONN` error.\nTrying to disconnect a handle that is not connected will\nreturn an `ENOTCONN` error.\n\nReturns: `0` or `fail`"}}, udp_get_send_queue_count = {binding = "udp_get_send_queue_count", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `udp:get_send_queue_count()`\n\nReturns the handle's send queue count.\n\nReturns: `integer`"}}, udp_get_send_queue_size = {binding = "udp_get_send_queue_size", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "> method form `udp:get_send_queue_size()`\n\nReturns the handle's send queue size.\n\nReturns: `integer`"}}, udp_getpeername = {binding = "udp_getpeername", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp"}, ["fnl/docstring"] = "> method form `udp:getpeername()`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n\nGet the remote IP and port of the UDP handle on connected UDP\nhandles.\n\nReturns: `table` or `fail`\n- `ip` : `string`\n- `family` : `string`\n- `port` : `integer`\n\n                                       "}}, udp_getsockname = {binding = "udp_getsockname", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp"}, ["fnl/docstring"] = "> method form `udp:getsockname()`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n\nGet the local IP and port of the UDP handle.\n\nReturns: `table` or `fail`\n- `ip` : `string`\n- `family` : `string`\n- `port` : `integer`"}}, udp_open = {binding = "udp_open", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "fd"}, ["fnl/docstring"] = "> method form `udp:open(fd)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `fd`: `integer`\n\nOpens an existing file descriptor or Windows SOCKET as a UDP\nhandle.\n\nUnix only: The only requirement of the sock argument is that\nit follows the datagram contract (works in unconnected mode,\nsupports sendmsg()/recvmsg(), etc). In other words, other\ndatagram-type sockets like raw sockets or netlink sockets can\nalso be passed to this function.\n\nThe file descriptor is set to non-blocking mode.\n\nNote: The passed file descriptor or SOCKET is not checked for\nits type, but it's required that it represents a valid\ndatagram socket.\n\nReturns: `0` or `fail`"}}, udp_recv_start = {binding = "udp_recv_start", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "callback"}, ["fnl/docstring"] = "> method form `udp:recv_start(callback)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n  - `data`: `string` or `nil`\n  - `addr`: `table` or `nil`\n    - `ip`: `string`\n    - `port`: `integer`\n    - `family`: `string`\n  - `flags`: `table`\n    - `partial`: `boolean` or `nil`\n    - `mmsg_chunk`: `boolean` or `nil`\n\nPrepare for receiving data. If the socket has not previously\nbeen bound with |uv.udp_bind()| it is bound to `0.0.0.0` (the\n\"all interfaces\" IPv4 address) and a random port number.\n\nSee |luv-constants| for supported address `family` output values.\n\nReturns: `0` or `fail`"}}, udp_recv_stop = {binding = "udp_recv_stop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp"}, ["fnl/docstring"] = "> method form `udp:recv_stop()`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n\nStop listening for incoming datagrams.\n\nReturns: `0` or `fail`"}}, udp_send = {binding = "udp_send", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "data", "host", "port", "callback"}, ["fnl/docstring"] = "> method form `udp:send(data, host, port, callback)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `data`: `buffer`\n- `host`: `string`\n- `port`: `integer`\n- `callback`: `callable`\n  - `err`: `nil` or `string`\n\nSend data over the UDP socket. If the socket has not\npreviously been bound with |uv.udp_bind()| it will be bound to\n`0.0.0.0` (the \"all interfaces\" IPv4 address) and a random\nport number.\n\nReturns: `uv_udp_send_t userdata` or `fail`"}}, udp_set_broadcast = {binding = "udp_set_broadcast", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "on"}, ["fnl/docstring"] = "> method form `udp:set_broadcast(on)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `on`: `boolean`\n\nSet broadcast on or off.\n\nReturns: `0` or `fail`"}}, udp_set_membership = {binding = "udp_set_membership", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "multicast_addr", "interface_addr", "membership"}, ["fnl/docstring"] = "> method form\n> `udp:set_membership(multicast_addr, interface_addr, membership)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `multicast_addr`: `string`\n- `interface_addr`: `string` or `nil`\n- `membership`: `string`\n\nSet membership for a multicast address. `multicast_addr` is\nmulticast address to set membership for. `interface_addr` is\ninterface address. `membership` can be the string `\"leave\"` or\n`\"join\"`.\n\nReturns: `0` or `fail`\n\n                                "}}, udp_set_multicast_interface = {binding = "udp_set_multicast_interface", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "interface_addr"}, ["fnl/docstring"] = "> method form `udp:set_multicast_interface(interface_addr)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `interface_addr`: `string`\n\nSet the multicast interface to send or receive data on.\n\nReturns: `0` or `fail`"}}, udp_set_multicast_loop = {binding = "udp_set_multicast_loop", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "on"}, ["fnl/docstring"] = "> method form `udp:set_multicast_loop(on)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `on`: `boolean`\n\nSet IP multicast loop flag. Makes multicast packets loop back\nto local sockets.\n\nReturns: `0` or `fail`"}}, udp_set_multicast_ttl = {binding = "udp_set_multicast_ttl", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "ttl"}, ["fnl/docstring"] = "> method form `udp:set_multicast_ttl(ttl)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `ttl`: `integer`\n\nSet the multicast ttl.\n\n`ttl` is an integer 1 through 255.\n\nReturns: `0` or `fail`\n\n                              "}}, udp_set_source_membership = {binding = "udp_set_source_membership", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "multicast_addr", "interface_addr", "source_addr", "membership"}, ["fnl/docstring"] = "> method form\n> `udp:set_source_membership(multicast_addr, interface_addr, source_addr, membership)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `multicast_addr`: `string`\n- `interface_addr`: `string` or `nil`\n- `source_addr`: `string`\n- `membership`: `string`\n\nSet membership for a source-specific multicast group.\n`multicast_addr` is multicast address to set membership for.\n`interface_addr` is interface address. `source_addr` is source\naddress. `membership` can be the string `\"leave\"` or `\"join\"`.\n\nReturns: `0` or `fail`"}}, udp_set_ttl = {binding = "udp_set_ttl", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "ttl"}, ["fnl/docstring"] = "> method form `udp:set_ttl(ttl)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `ttl`: `integer`\n\nSet the time to live.\n\n`ttl` is an integer 1 through 255.\n\nReturns: `0` or `fail`"}}, udp_try_send = {binding = "udp_try_send", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "data", "host", "port"}, ["fnl/docstring"] = "> method form `udp:try_send(data, host, port)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `data`: `buffer`\n- `host`: `string`\n- `port`: `integer`\n\nSame as |uv.udp_send()|, but won't queue a send request if it\ncan't be completed immediately.\n\nReturns: `integer` or `fail`"}}, udp_try_send2 = {binding = "udp_try_send2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"udp", "messages", "flags"}, ["fnl/docstring"] = "> method form `udp:try_send2(messages, flags)`\n\nParameters:\n- `udp`: `uv_udp_t userdata`\n- `messages`: `table`\n  - `[1, 2, 3, ..., n]` : `table`\n    - `data` : `buffer`\n    - `addr` : `table`\n      - `ip` : `string`\n      - `port` : `integer`\n- `flags`: `nil` (see below)\n- `port`: `integer`\n\nLike `uv.udp_try_send()`, but can send multiple datagrams.\nLightweight abstraction around `sendmmsg(2)`, with a\n`sendmsg(2)` fallback loop for platforms that do not support\nthe former. The `udp` handle must be fully initialized, either\nfrom a `uv.udp_bind` call, another call that will bind\nautomatically (`udp_send`, `udp_try_send`, etc), or from\n`uv.udp_connect`. `messages` should be an array-like table,\nwhere `addr` must be specified if the `udp` has not been\nconnected via `udp_connect`. Otherwise, `addr` must be `nil`.\n\n`flags` is reserved for future extension and must currently be\n`nil` or `0` or `{}`.\n\nReturns the number of messages sent successfully. An error will only be returned\nif the first datagram failed to be sent.\n\nReturns: `integer` or `fail`\n>lua\n  -- If client:connect(...) was not called\n  local addr = { ip = \"127.0.0.1\", port = 1234 }\n  client:try_send2({\n    { data = \"Message 1\", addr = addr },\n    { data = \"Message 2\", addr = addr },\n  })\n  -- If client:connect(...) was called\n  client:try_send2({\n    { data = \"Message 1\" },\n    { data = \"Message 2\" },\n  })\n<"}}, unref = {binding = "unref", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"handle"}, ["fnl/docstring"] = "> method form `handle:unref()`\n\nParameters:\n- `handle`: `userdata` for sub-type of |uv_handle_t|\n\nUn-reference the given handle. References are idempotent, that\nis, if a handle is not referenced calling this function again\nwill have no effect.\n\nReturns: Nothing.\n\nSee |luv-reference-counting|."}}, update_time = {binding = "update_time", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Update the event loop's concept of \"now\". Libuv caches the\ncurrent time at the start of the event loop tick in order to\nreduce the number of time-related system calls.\n\nYou won't normally need to call this function unless you have\ncallbacks that block the event loop for longer periods of\ntime, where \"longer\" is somewhat subjective but probably on\nthe order of a millisecond or more.\n\nReturns: Nothing."}}, uptime = {binding = "uptime", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the current system uptime in seconds.\n\nReturns: `number` or `fail`"}}, utf16_length_as_wtf8 = {binding = "utf16_length_as_wtf8", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"utf16"}, ["fnl/docstring"] = "Get the length (in bytes) of a UTF-16 (or UCS-2) string\n`utf16` value after converting it to WTF-8. The endianness of\nthe UTF-16 (or UCS-2) string is assumed to be the same as the\nnative endianness of the platform.\n\nParameters:\n- `utf16`: `string`\n\nReturns: `integer`"}}, utf16_to_wtf8 = {binding = "utf16_to_wtf8", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"utf16"}, ["fnl/docstring"] = "Convert UTF-16 (or UCS-2) string `utf16` to UTF-8 string. The\nendianness of the UTF-16 (or UCS-2) string is assumed to be\nthe same as the native endianness of the platform.\n\nParameters:\n- `utf16`: `string`\n\nReturns: `string`"}}, version = {binding = "version", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the libuv version packed into a single integer. 8 bits\nare used for each component, with the patch number stored in\nthe 8 least significant bits. For example, this would be\n0x010203 in libuv 1.2.3.\n\nReturns: `integer`"}}, version_string = {binding = "version_string", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {}, ["fnl/docstring"] = "Returns the libuv version number as a string. For example,\nthis would be \"1.2.3\" in libuv 1.2.3. For non-release\nversions, the version suffix is included.\n\nReturns: `string`"}}, walk = {binding = "walk", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"callback"}, ["fnl/docstring"] = "Parameters:\n- `callback`: `callable`\n  - `handle`: `userdata` for sub-type of |uv_handle_t|\n\nWalk the list of handles: `callback` will be executed with\neach handle.\n\nReturns: Nothing.\n\n    >lua\n    -- Example usage of uv.walk to close all handles that\n    -- aren't already closing.\n    uv.walk(function (handle)\n      if not handle:is_closing() then\n        handle:close()\n      end\n    end)\n<"}}, write = {binding = "write", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "data", "callback"}, ["fnl/docstring"] = "> method form `stream:write(data, [callback])`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `data`: `buffer`\n- `callback`: `callable` or `nil`\n  - `err`: `nil` or `string`\n\nWrite data to stream.\n\n`data` can either be a Lua string or a table of strings. If a\ntable is passed in, the C backend will use writev to send all\nstrings in a single system call.\n\nThe optional `callback` is for knowing when the write is\ncomplete.\n\nReturns: `uv_write_t userdata` or `fail`"}}, write2 = {binding = "write2", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"stream", "data", "send_handle", "callback"}, ["fnl/docstring"] = "> method form `stream:write2(data, send_handle, [callback])`\n\nParameters:\n- `stream`: `userdata` for sub-type of |uv_stream_t|\n- `data`: `buffer`\n- `send_handle`: `userdata` for sub-type of |uv_stream_t|\n- `callback`: `callable` or `nil`\n  - `err`: `nil` or `string`\n\nExtended write function for sending handles over a pipe. The\npipe must be initialized with `ipc` option `true`.\n\nReturns: `uv_write_t userdata` or `fail`\n\nNote: `send_handle` must be a TCP socket or pipe, which is a\nserver or a connection (listening or connected state). Bound\nsockets or pipes will be assumed to be servers."}}, wtf8_length_as_utf16 = {binding = "wtf8_length_as_utf16", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"wtf16"}, ["fnl/docstring"] = "Get the length (in UTF-16 code units) of a WTF-8 `wtf8` value\nafter converting it to UTF-16 (or UCS-2).\n\nNote: The number of bytes needed for a UTF-16 (or UCS-2)\nstring is `<number of code units> * 2`.\n\nParameters:\n- `wtf8`: `string`\n\nReturns: `integer`"}}, wtf8_to_utf16 = {binding = "wtf8_to_utf16", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"wtf16"}, ["fnl/docstring"] = "Convert WTF-8 string in `wtf8` to UTF-16 (or UCS-2) string.\nThe endianness of the UTF-16 (or UCS-2) string is assumed to\nbe the same as the native endianness of the platform.\n\nParameters:\n- `wtf8`: `string`\n\nReturns: `string`"}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/docstring"] = "Lua bindings for the LibUV library which is used for Nvim's event-loop\nand is accessible from Lua via vim.uv (e.g., uv.version() is exposed as\nvim.uv.version())."}}, v = {binding = "v", fields = {argv = {binding = "argv", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The command line arguments Vim was invoked with.  This is a\nlist of strings.  The first item is the Vim command.\nSee |v:progpath| for the command with full path."}}, char = {binding = "char", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Argument for evaluating 'formatexpr' and used for the typed\ncharacter when using <expr> in an abbreviation |:map-<expr>|.\nIt is also used by the |InsertCharPre| and |InsertEnter| events."}}, charconvert_from = {binding = "charconvert_from", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the character encoding of a file to be converted.\nOnly valid while evaluating the 'charconvert' option."}}, charconvert_to = {binding = "charconvert_to", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the character encoding of a file after conversion.\nOnly valid while evaluating the 'charconvert' option."}}, cmdarg = {binding = "cmdarg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\nread/write command.  This is set before an autocommand event\nfor a file read/write command is triggered.  There is a\nleading space to make it possible to append this variable\ndirectly after the read/write command. Note: \"+cmd\" isn't\nincluded here, because it will be executed anyway."}}, cmdbang = {binding = "cmdbang", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Set like v:cmdarg for a file read/write command.  When a \"!\"\nwas used the value is 1, otherwise it is 0.  Note that this\ncan only be used in autocommands.  For user commands |<bang>|\ncan be used."}}, collate = {binding = "collate", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The current locale setting for collation order of the runtime\nenvironment.  This allows Vim scripts to be aware of the\ncurrent locale encoding.  Technical: it's the value of\nLC_COLLATE.  When not using a locale the value is \"C\".\nThis variable can not be set directly, use the |:language|\ncommand.\nSee |multi-lang|."}}, completed_item = {binding = "completed_item", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Dictionary containing the |complete-items| for the most\nrecently completed word after |CompleteDone|.  Empty if the\ncompletion failed, or after leaving and re-entering insert\nmode.\nNote: Plugins can modify the value to emulate the builtin\n|CompleteDone| event behavior."}}, count = {binding = "count", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The count given for the last Normal mode command.  Can be used\nto get the count before a mapping.  Read-only.  Example: >vim\n  :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n<\nNote: The <C-U> is required to remove the line range that you\nget when typing ':' after a count.\nWhen there are two counts, as in \"3d2w\", they are multiplied,\njust like what happens in the command, \"d6w\" for the example.\nAlso used for evaluating the 'formatexpr' option."}}, count1 = {binding = "count1", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Just like \"v:count\", but defaults to one when no count is\nused."}}, ctype = {binding = "ctype", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The current locale setting for characters of the runtime\nenvironment.  This allows Vim scripts to be aware of the\ncurrent locale encoding.  Technical: it's the value of\nLC_CTYPE.  When not using a locale the value is \"C\".\nThis variable can not be set directly, use the |:language|\ncommand.\nSee |multi-lang|."}}, dying = {binding = "dying", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Normally zero.  When a deadly signal is caught it's set to\none.  When multiple signals are caught the number increases.\nCan be used in an autocommand to check if Vim didn't\nterminate normally.\nExample: >vim\n  :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n<\nNote: if another deadly signal is caught when v:dying is one,\nVimLeave autocommands will not be executed."}}, echospace = {binding = "echospace", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Number of screen cells that can be used for an `:echo` message\nin the last screen line before causing the |hit-enter-prompt|.\nDepends on 'showcmd', 'ruler' and 'columns'.  You need to\ncheck 'cmdheight' for whether there are full-width lines\navailable above the last line."}}, errmsg = {binding = "errmsg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Last given error message.\nModifiable (can be set).\nExample: >vim\n  let v:errmsg = \"\"\n  silent! next\n  if v:errmsg != \"\"\n    \" ... handle error\n<"}}, errors = {binding = "errors", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Errors found by assert functions, such as |assert_true()|.\nThis is a list of strings.\nThe assert functions append an item when an assert fails.\nThe return value indicates this: a one is returned if an item\nwas added to v:errors, otherwise zero is returned.\nTo remove old results make it empty: >vim\n  let v:errors = []\n<\nIf v:errors is set to anything but a list it is made an empty\nlist by the assert function."}}, event = {binding = "event", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Dictionary of event data for the current |autocommand|.  Valid\nonly during the event lifetime; storing or passing v:event is\ninvalid!  Copy it instead: >vim\n  au TextYankPost * let g:foo = deepcopy(v:event)\n<\nKeys vary by event; see the documentation for the specific\nevent, e.g. |DirChanged| or |TextYankPost|.\n  KEY              DESCRIPTION ~\n  abort            Whether the event triggered during\n                   an aborting condition (e.g. |c_Esc| or\n                   |c_CTRL-C| for |CmdlineLeave|).\n  chan             |channel-id|\n  changed_window   Is |v:true| if the event fired while\n                   changing window  (or tab) on |DirChanged|.\n  cmdlevel         Level of cmdline.\n  cmdtype          Type of cmdline, |cmdline-char|.\n  col              Column count of popup menu on |CompleteChanged|,\n                   relative to screen.\n  complete_type    See |complete_info_mode|\n  complete_word    The selected word, or empty if completion\n                   was abandoned/discarded.\n  completed_item   Current selected item on |CompleteChanged|,\n                   or `{}` if no item selected.\n  cwd              Current working directory.\n  height           Height of popup menu on |CompleteChanged|\n  inclusive        Motion is |inclusive|, else exclusive.\n  info             Dict of arbitrary event data.\n  operator         Current |operator|.  Also set for Ex\n                   commands (unlike |v:operator|). For\n                   example if |TextYankPost| is triggered\n                   by the |:yank| Ex command then\n                   `v:event.operator` is \"y\".\n  reason           |CompleteDone| reason.\n  regcontents      Text stored in the register as a\n                   |readfile()|-style list of lines.\n  regname          Requested register (e.g \"x\" for \"xyy), or\n                   empty string for an unnamed operation.\n  regtype          Type of register as returned by\n                   |getregtype()|.\n  row              Row count of popup menu on |CompleteChanged|,\n                   relative to screen.\n  scope            Event-specific scope name.\n  scrollbar        |v:true| if popup menu has a scrollbar, or\n                   |v:false| if not.\n  size             Total number of completion items on\n                   |CompleteChanged|.\n  status           Job status or exit code, -1 means \"unknown\". |TermClose|\n  visual           Selection is visual (as opposed to e.g. a motion range).\n  width            Width of popup menu on |CompleteChanged|\n  windows          List of window IDs that changed on |WinResized|"}}, exception = {binding = "exception", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The value of the exception most recently caught and not\nfinished.  See also |v:stacktrace|, |v:throwpoint|, and\n|throw-variables|.\nExample: >vim\n  try\n    throw \"oops\"\n  catch /.*/\n    echo \"caught \" .. v:exception\n  endtry\n<\nOutput: \"caught oops\"."}}, exiting = {binding = "exiting", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Exit code, or |v:null| before invoking the |VimLeavePre|\nand |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\nExample: >vim\n  :au VimLeave * echo \"Exit value is \" .. v:exiting\n<"}}, ["false"] = {binding = "false", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Special value used to put \"false\" in JSON and msgpack.  See\n|json_encode()|.  This value is converted to \"v:false\" when used\nas a String (e.g. in |expr5| with string concatenation\noperator) and to zero when used as a Number (e.g. in |expr5|\nor |expr7| when used with numeric operators). Read-only."}}, fcs_choice = {binding = "fcs_choice", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "What should happen after a |FileChangedShell| event was\ntriggered.  Can be used in an autocommand to tell Vim what to\ndo with the affected buffer:\n  reload  Reload the buffer (does not work if\n          the file was deleted).\n  edit    Reload the buffer and detect the\n          values for options such as\n          'fileformat', 'fileencoding', 'binary'\n          (does not work if the file was\n          deleted).\n  ask     Ask the user what to do, as if there\n          was no autocommand.  Except that when\n          only the timestamp changed nothing\n          will happen.\n  <empty> Nothing, the autocommand should do\n          everything that needs to be done.\nThe default is empty.  If another (invalid) value is used then\nVim behaves like it is empty, there is no warning message."}}, fcs_reason = {binding = "fcs_reason", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The reason why the |FileChangedShell| event was triggered.\nCan be used in an autocommand to decide what to do and/or what\nto set v:fcs_choice to.  Possible values:\n  deleted   file no longer exists\n  conflict  file contents, mode or timestamp was\n            changed and buffer is modified\n  changed   file contents has changed\n  mode      mode of file changed\n  time      only file timestamp changed"}}, fname = {binding = "fname", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "When evaluating 'includeexpr': the file name that was\ndetected.  Empty otherwise."}}, fname_diff = {binding = "fname_diff", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the diff (patch) file.  Only valid while\nevaluating 'patchexpr'."}}, fname_in = {binding = "fname_in", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the input file.  Valid while evaluating:\n  option         used for ~\n  'charconvert'  file to be converted\n  'diffexpr'     original file\n  'patchexpr'    original file\nAnd set to the swap file name for |SwapExists|."}}, fname_new = {binding = "fname_new", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the new version of the file.  Only valid while\nevaluating 'diffexpr'."}}, fname_out = {binding = "fname_out", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the output file.  Only valid while\nevaluating:\n  option           used for ~\n  'charconvert'    resulting converted file [1]\n  'diffexpr'       output of diff\n  'patchexpr'      resulting patched file\n[1] When doing conversion for a write command (e.g., \":w\nfile\") it will be equal to v:fname_in.  When doing conversion\nfor a read command (e.g., \":e file\") it will be a temporary\nfile and different from v:fname_in."}}, folddashes = {binding = "folddashes", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Used for 'foldtext': dashes representing foldlevel of a closed\nfold.\nRead-only in the |sandbox|. |fold-foldtext|"}}, foldend = {binding = "foldend", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Used for 'foldtext': last line of closed fold.\nRead-only in the |sandbox|. |fold-foldtext|"}}, foldlevel = {binding = "foldlevel", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Used for 'foldtext': foldlevel of closed fold.\nRead-only in the |sandbox|. |fold-foldtext|"}}, foldstart = {binding = "foldstart", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Used for 'foldtext': first line of closed fold.\nRead-only in the |sandbox|. |fold-foldtext|"}}, hlsearch = {binding = "hlsearch", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Variable that indicates whether search highlighting is on.\nSetting it makes sense only if 'hlsearch' is enabled. Setting\nthis variable to zero acts like the |:nohlsearch| command,\nsetting it to one acts like >vim\n  let &hlsearch = &hlsearch\n<\nNote that the value is restored when returning from a\nfunction. |function-search-undo|."}}, insertmode = {binding = "insertmode", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Used for the |InsertEnter| and |InsertChange| autocommand\nevents.  Values:\n  i    Insert mode\n  r    Replace mode\n  v    Virtual Replace mode"}}, key = {binding = "key", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Key of the current item of a |Dictionary|.  Only valid while\nevaluating the expression used with |map()| and |filter()|.\nRead-only."}}, lang = {binding = "lang", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The current locale setting for messages of the runtime\nenvironment.  This allows Vim scripts to be aware of the\ncurrent language.  Technical: it's the value of LC_MESSAGES.\nThe value is system dependent.\nThis variable can not be set directly, use the |:language|\ncommand.\nIt can be different from |v:ctype| when messages are desired\nin a different language than what is used for character\nencoding.  See |multi-lang|."}}, lc_time = {binding = "lc_time", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The current locale setting for time messages of the runtime\nenvironment.  This allows Vim scripts to be aware of the\ncurrent language.  Technical: it's the value of LC_TIME.\nThis variable can not be set directly, use the |:language|\ncommand.  See |multi-lang|."}}, lnum = {binding = "lnum", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Line number for the 'foldexpr' |fold-expr|, 'formatexpr',\n'indentexpr' and 'statuscolumn' expressions, tab page number\nfor 'guitablabel' and 'guitabtooltip'.  Only valid while one of\nthese expressions is being evaluated.  Read-only when in the\n|sandbox|."}}, lua = {binding = "lua", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Prefix for calling Lua functions from expressions.\nSee |v:lua-call| for more information."}}, maxcol = {binding = "maxcol", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Maximum line length.  Depending on where it is used it can be\nscreen columns, characters or bytes.  The value currently is\n2147483647 on all systems."}}, mouse_col = {binding = "mouse_col", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Column number for a mouse click obtained with |getchar()|.\nThis is the screen column number, like with |virtcol()|.  The\nvalue is zero when there was no mouse button click."}}, mouse_lnum = {binding = "mouse_lnum", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Line number for a mouse click obtained with |getchar()|.\nThis is the text line number, not the screen line number.  The\nvalue is zero when there was no mouse button click."}}, mouse_win = {binding = "mouse_win", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Window number for a mouse click obtained with |getchar()|.\nFirst window has number 1, like with |winnr()|.  The value is\nzero when there was no mouse button click."}}, mouse_winid = {binding = "mouse_winid", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "|window-ID| for a mouse click obtained with |getchar()|.\nThe value is zero when there was no mouse button click."}}, msgpack_types = {binding = "msgpack_types", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Dictionary containing msgpack types used by |msgpackparse()|\nand |msgpackdump()|. All types inside dictionary are fixed\n(not editable) empty lists. To check whether some list is one\nof msgpack types, use |is| operator."}}, null = {binding = "null", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Special value used to put \"null\" in JSON and NIL in msgpack.\nSee |json_encode()|.  This value is converted to \"v:null\" when\nused as a String (e.g. in |expr5| with string concatenation\noperator) and to zero when used as a Number (e.g. in |expr5|\nor |expr7| when used with numeric operators). Read-only.\nIn some places `v:null` can be used for a List, Dict, etc.\nthat is not set.  That is slightly different than an empty\nList, Dict, etc."}}, numbermax = {binding = "numbermax", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Maximum value of a number."}}, numbermin = {binding = "numbermin", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Minimum value of a number (negative)."}}, numbersize = {binding = "numbersize", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Number of bits in a Number.  This is normally 64, but on some\nsystems it may be 32."}}, oldfiles = {binding = "oldfiles", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "List of file names that is loaded from the |shada| file on\nstartup.  These are the files that Vim remembers marks for.\nThe length of the List is limited by the ' argument of the\n'shada' option (default is 100).\nWhen the |shada| file is not used the List is empty.\nAlso see |:oldfiles| and |c_#<|.\nThe List can be modified, but this has no effect on what is\nstored in the |shada| file later.  If you use values other\nthan String this will cause trouble."}}, operator = {binding = "operator", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The last operator given in Normal mode.  This is a single\ncharacter except for commands starting with <g> or <z>,\nin which case it is two characters.  Best used alongside\n|v:prevcount| and |v:register|.  Useful if you want to cancel\nOperator-pending mode and then use the operator, e.g.: >vim\n  :omap O <Esc>:call MyMotion(v:operator)<CR>\n<\nThe value remains set until another operator is entered, thus\ndon't expect it to be empty.\nv:operator is not set for |:delete|, |:yank| or other Ex\ncommands.\nRead-only."}}, option_command = {binding = "option_command", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Command used to set the option. Valid while executing an\n|OptionSet| autocommand.\n  value        option was set via ~\n  \"setlocal\"   |:setlocal| or `:let l:xxx`\n  \"setglobal\"  |:setglobal| or `:let g:xxx`\n  \"set\"        |:set| or |:let|\n  \"modeline\"   |modeline|"}}, option_new = {binding = "option_new", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "New value of the option. Valid while executing an |OptionSet|\nautocommand."}}, option_old = {binding = "option_old", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Old value of the option. Valid while executing an |OptionSet|\nautocommand. Depending on the command used for setting and the\nkind of option this is either the local old value or the\nglobal old value."}}, option_oldglobal = {binding = "option_oldglobal", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Old global value of the option. Valid while executing an\n|OptionSet| autocommand."}}, option_oldlocal = {binding = "option_oldlocal", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Old local value of the option. Valid while executing an\n|OptionSet| autocommand."}}, option_type = {binding = "option_type", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Scope of the set command. Valid while executing an\n|OptionSet| autocommand. Can be either \"global\" or \"local\""}}, prevcount = {binding = "prevcount", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The count given for the last but one Normal mode command.\nThis is the v:count value of the previous command.  Useful if\nyou want to cancel Visual or Operator-pending mode and then\nuse the count, e.g.: >vim\n  :vmap % <Esc>:call MyFilter(v:prevcount)<CR>\n<\nRead-only."}}, profiling = {binding = "profiling", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Normally zero.  Set to one after using \":profile start\".\nSee |profiling|."}}, progname = {binding = "progname", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name by which Nvim was invoked (with path removed).\nRead-only."}}, progpath = {binding = "progpath", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Absolute path to the current running Nvim.\nRead-only."}}, register = {binding = "register", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The name of the register in effect for the current normal mode\ncommand (regardless of whether that command actually used a\nregister).  Or for the currently executing normal mode mapping\n(use this in custom commands that take a register).\nIf none is supplied it is the default register '\"', unless\n'clipboard' contains \"unnamed\" or \"unnamedplus\", then it is\n\"*\" or '+'.\nAlso see |getreg()| and |setreg()|"}}, relnum = {binding = "relnum", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Relative line number for the 'statuscolumn' expression.\nRead-only."}}, scrollstart = {binding = "scrollstart", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "String describing the script or function that caused the\nscreen to scroll up.  It's only set when it is empty, thus the\nfirst reason is remembered.  It is set to \"Unknown\" for a\ntyped command.\nThis can be used to find out why your script causes the\nhit-enter prompt."}}, searchforward = {binding = "searchforward", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Search direction:  1 after a forward search, 0 after a\nbackward search.  It is reset to forward when directly setting\nthe last search pattern, see |quote/|.\nNote that the value is restored when returning from a\nfunction. |function-search-undo|.\nRead-write."}}, servername = {binding = "servername", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Primary listen-address of Nvim, the first item returned by\n|serverlist()|. Usually this is the named pipe created by Nvim\nat |startup| or given by |--listen| (or the deprecated\n|$NVIM_LISTEN_ADDRESS| env var).\n\nSee also |serverstart()| |serverstop()|.\nRead-only.\n\n                                                     *$NVIM*\n$NVIM is set to v:servername by |terminal| and |jobstart()|,\nand is thus a hint that the current environment is a child\n(direct subprocess) of Nvim.\n\nExample: a child Nvim process can detect and make requests to\nits parent Nvim: >lua\n\n  if vim.env.NVIM then\n    local ok, chan = pcall(vim.fn.sockconnect, 'pipe', vim.env.NVIM, {rpc=true})\n    if ok and chan then\n      local client = vim.api.nvim_get_chan_info(chan).client\n      local rv = vim.rpcrequest(chan, 'nvim_exec_lua', [[return ... + 1]], { 41 })\n      vim.print(('got \"%s\" from parent Nvim'):format(rv))\n    end\n  end\n<"}}, shell_error = {binding = "shell_error", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Result of the last shell command.  When non-zero, the last\nshell command had an error.  When zero, there was no problem.\nThis only works when the shell returns the error code to Vim.\nThe value -1 is often used when the command could not be\nexecuted.  Read-only.\nExample: >vim\n  !mv foo bar\n  if v:shell_error\n    echo 'could not rename \"foo\" to \"bar\"!'\n  endif\n<"}}, stacktrace = {binding = "stacktrace", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The stack trace of the exception most recently caught and\nnot finished.  Refer to |getstacktrace()| for the structure of\nstack trace.  See also |v:exception|, |v:throwpoint|, and\n|throw-variables|."}}, statusmsg = {binding = "statusmsg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Last given status message.\nModifiable (can be set)."}}, stderr = {binding = "stderr", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "|channel-id| corresponding to stderr. The value is always 2;\nuse this variable to make your code more descriptive.\nUnlike stdin and stdout (see |stdioopen()|), stderr is always\nopen for writing. Example: >vim\n:call chansend(v:stderr, \"error: toaster empty\\n\")\n<"}}, swapchoice = {binding = "swapchoice", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "|SwapExists| autocommands can set this to the selected choice\nfor handling an existing swapfile:\n  'o'    Open read-only\n  'e'    Edit anyway\n  'r'    Recover\n  'd'    Delete swapfile\n  'q'    Quit\n  'a'    Abort\nThe value should be a single-character string.  An empty value\nresults in the user being asked, as would happen when there is\nno SwapExists autocommand.  The default is empty."}}, swapcommand = {binding = "swapcommand", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Normal mode command to be executed after a file has been\nopened.  Can be used for a |SwapExists| autocommand to have\nanother Vim open the file and jump to the right place.  For\nexample, when jumping to a tag the value is \":tag tagname\\r\".\nFor \":edit +cmd file\" the value is \":cmd\\r\"."}}, swapname = {binding = "swapname", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Name of the swapfile found.\nOnly valid during |SwapExists| event.\nRead-only."}}, t_blob = {binding = "t_blob", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |Blob| type.  Read-only.  See: |type()|"}}, t_bool = {binding = "t_bool", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |Boolean| type.  Read-only.  See: |type()|"}}, t_dict = {binding = "t_dict", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |Dictionary| type.  Read-only.  See: |type()|"}}, t_float = {binding = "t_float", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |Float| type.  Read-only.  See: |type()|"}}, t_func = {binding = "t_func", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |Funcref| type.  Read-only.  See: |type()|"}}, t_list = {binding = "t_list", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |List| type.  Read-only.  See: |type()|"}}, t_number = {binding = "t_number", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |Number| type.  Read-only.  See: |type()|"}}, t_string = {binding = "t_string", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of |String| type.  Read-only.  See: |type()|"}}, termrequest = {binding = "termrequest", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The value of the most recent OSC, DCS or APC control sequence\nsent from a process running in the embedded |terminal|.\nThis can be read in a |TermRequest| event handler to respond\nto queries from embedded applications."}}, termresponse = {binding = "termresponse", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The value of the most recent OSC or DCS control sequence\nreceived by Nvim from the terminal. This can be read in a\n|TermResponse| event handler after querying the terminal using\nanother escape sequence."}}, testing = {binding = "testing", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Must be set before using `test_garbagecollect_now()`."}}, this_session = {binding = "this_session", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Full filename of the last loaded or saved session file.\nEmpty when no session file has been saved.  See |:mksession|.\nModifiable (can be set)."}}, throwpoint = {binding = "throwpoint", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "The point where the exception most recently caught and not\nfinished was thrown.  Not set when commands are typed.  See\nalso |v:exception|, |v:stacktrace|, and |throw-variables|.\nExample: >vim\n  try\n    throw \"oops\"\n  catch /.*/\n    echo \"Exception from\" v:throwpoint\n  endtry\n<\nOutput: \"Exception from test.vim, line 2\""}}, ["true"] = {binding = "true", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Special value used to put \"true\" in JSON and msgpack.  See\n|json_encode()|.  This value is converted to \"v:true\" when used\nas a String (e.g. in |expr5| with string concatenation\noperator) and to one when used as a Number (e.g. in |expr5| or\n|expr7| when used with numeric operators). Read-only."}}, val = {binding = "val", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value of the current item of a |List| or |Dictionary|.  Only\nvalid while evaluating the expression used with |map()| and\n|filter()|.  Read-only."}}, version = {binding = "version", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Vim version number: major version times 100 plus minor\nversion.  Vim 5.0 is 500, Vim 5.1 is 501.\nRead-only.\nUse |has()| to check the Nvim (not Vim) version: >vim\n  :if has(\"nvim-0.2.1\")\n<"}}, vim_did_enter = {binding = "vim_did_enter", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "0 during startup, 1 just before |VimEnter|.\nRead-only."}}, virtnum = {binding = "virtnum", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Virtual line number for the 'statuscolumn' expression.\nNegative when drawing the status column for virtual lines, zero\nwhen drawing an actual buffer line, and positive when drawing\nthe wrapped part of a buffer line.\nRead-only."}}, warningmsg = {binding = "warningmsg", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Last given warning message.\nModifiable (can be set)."}}, windowid = {binding = "windowid", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Application-specific window \"handle\" which may be set by any\nattached UI. Defaults to zero.\nNote: For Nvim |windows| use |winnr()| or |win_getid()|, see\n|window-ID|."}}}, metadata = {["fls/itemKind"] = "Module", ["fnl/arglist"] = {"value"}, ["fnl/docstring"] = "Predefined variables\n\nMost variables are read-only, when a variable can be set by the user, it will\nbe mentioned at the variable description below. The type cannot be changed."}}, val_idx = {binding = "val_idx", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Value index for tables representing |Float|s. A table representing\nfloating-point value 1.0 looks like this: >lua\n    {\n      [vim.type_idx] = vim.types.float,\n      [vim.val_idx] = 1.0,\n    }\n<    See also |vim.type_idx| and |lua-special-tbl|."}}, validate = {binding = "validate", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"name", "value", "validator", "?optional", "?message"}, ["fnl/docstring"] = "Validate function arguments.\n\nThis function has two valid forms:\n1. `vim.validate(name, value, validator[, optional][, message])`\n   Validates that argument {name} with value {value} satisfies\n   {validator}. If {optional} is given and is `true`, then {value} may be\n   `nil`. If {message} is given, then it is used as the expected type in\n   the error message.\n   Example: >lua\n     function vim.startswith(s, prefix)\n      vim.validate('s', s, 'string')\n      vim.validate('prefix', prefix, 'string')\n      -- ...\n    end\n<\n2. `vim.validate(spec)` (deprecated) where `spec` is of type\n   `table<string,[value:any, validator: vim.validate.Validator, optional_or_msg? : boolean|string]>)`\n   Validates a argument specification. Specs are evaluated in alphanumeric\n   order, until the first failure.\n   Example: >lua\n     function user.new(name, age, hobbies)\n      vim.validate{\n        name={name, 'string'},\n        age={age, 'number'},\n        hobbies={hobbies, 'table'},\n      }\n      -- ...\n    end\n<\n\nExamples with explicit argument values (can be run directly): >lua\n    vim.validate('arg1', {'foo'}, 'table')\n       --> NOP (success)\n    vim.validate('arg2', 'foo', 'string')\n       --> NOP (success)\n\n    vim.validate('arg1', 1, 'table')\n       --> error('arg1: expected table, got number')\n\n    vim.validate('arg1', 3, function(a) return (a % 2) == 0 end, 'even number')\n       --> error('arg1: expected even number, got 3')\n<\n\nIf multiple types are valid they can be given as a list. >lua\n    vim.validate('arg1', {'foo'}, {'table', 'string'})\n    vim.validate('arg2', 'foo', {'table', 'string'})\n    -- NOP (success)\n\n    vim.validate('arg1', 1, {'string', 'table'})\n    -- error('arg1: expected string|table, got number')\n<\n\nNote: ~\n  \226\128\162 `validator` set to a value returned by |lua-type()| provides the best\n    performance.\n\nParameters: ~\n  \226\128\162 {name}       (`string`) Argument name\n  \226\128\162 {value}      (`any`) Argument value\n  \226\128\162 {validator}  (`vim.validate.Validator`)\n                 \226\128\162 (`string|string[]`): Any value that can be returned\n                   from |lua-type()| in addition to `'callable'`:\n                   `'boolean'`, `'callable'`, `'function'`, `'nil'`,\n                   `'number'`, `'string'`, `'table'`, `'thread'`,\n                   `'userdata'`.\n                 \226\128\162 (`fun(val:any): boolean, string?`) A function that\n                   returns a boolean and an optional string message.\n  \226\128\162 {optional}   (`boolean?`) Argument is optional (may be omitted)\n  \226\128\162 {message}    (`string?`) message when validation fails"}}, version = {binding = "version", fields = {cmp = {binding = "cmp", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v1", "v2"}, ["fnl/docstring"] = "Parses and compares two version objects (the result of\n|vim.version.parse()|, or specified literally as a `{major, minor, patch}`\ntuple, e.g. `{1, 0, 3}`).\n\nExample: >lua\n    if vim.version.cmp({1,0,3}, {0,2,1}) == 0 then\n      -- ...\n    end\n    local v1 = vim.version.parse('1.0.3-pre')\n    local v2 = vim.version.parse('0.2.1')\n    if vim.version.cmp(v1, v2) == 0 then\n      -- ...\n    end\n<\n\nNote: ~\n  \226\128\162 Per semver, build metadata is ignored when comparing two\n    otherwise-equivalent versions.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {v1}  (`vim.Version|number[]|string`) Version object.\n  \226\128\162 {v2}  (`vim.Version|number[]|string`) Version to compare with `v1`.\n\nReturn: ~\n    (`integer`) -1 if `v1 < v2`, 0 if `v1 == v2`, 1 if `v1 > v2`."}}, eq = {binding = "eq", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v1", "v2"}, ["fnl/docstring"] = "Returns `true` if the given versions are equal. See |vim.version.cmp()|\nfor usage.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {v1}  (`vim.Version|number[]|string`)\n  \226\128\162 {v2}  (`vim.Version|number[]|string`)\n\nReturn: ~\n    (`boolean`)"}}, ge = {binding = "ge", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v1", "v2"}, ["fnl/docstring"] = "Returns `true` if `v1 >= v2`. See |vim.version.cmp()| for usage.\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {v1}  (`vim.Version|number[]|string`)\n  \226\128\162 {v2}  (`vim.Version|number[]|string`)\n\nReturn: ~\n    (`boolean`)"}}, gt = {binding = "gt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v1", "v2"}, ["fnl/docstring"] = "Returns `true` if `v1 > v2`. See |vim.version.cmp()| for usage.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {v1}  (`vim.Version|number[]|string`)\n  \226\128\162 {v2}  (`vim.Version|number[]|string`)\n\nReturn: ~\n    (`boolean`)"}}, last = {binding = "last", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"versions"}, ["fnl/docstring"] = "TODO: generalize this, move to func.lua\n\nParameters: ~\n  \226\128\162 {versions}  (`vim.Version[]`)\n\nReturn: ~\n    (`vim.Version?`)"}}, le = {binding = "le", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v1", "v2"}, ["fnl/docstring"] = "Returns `true` if `v1 <= v2`. See |vim.version.cmp()| for usage.\n\nAttributes: ~\n    Since: 0.10.0\n\nParameters: ~\n  \226\128\162 {v1}  (`vim.Version|number[]|string`)\n  \226\128\162 {v2}  (`vim.Version|number[]|string`)\n\nReturn: ~\n    (`boolean`)"}}, lt = {binding = "lt", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"v1", "v2"}, ["fnl/docstring"] = "Returns `true` if `v1 < v2`. See |vim.version.cmp()| for usage.\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {v1}  (`vim.Version|number[]|string`)\n  \226\128\162 {v2}  (`vim.Version|number[]|string`)\n\nReturn: ~\n    (`boolean`)"}}, parse = {binding = "parse", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"version", "?opts"}, ["fnl/docstring"] = "Parses a semantic version string and returns a version object which can be\nused with other `vim.version` functions. For example \"1.0.1-rc1+build.2\"\nreturns: >\n    { major = 1, minor = 0, patch = 1, prerelease = \"rc1\", build = \"build.2\" }\n<\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {version}  (`string`) Version string to parse.\n  \226\128\162 {opts}     (`table?`) Optional keyword arguments:\n               \226\128\162 strict (boolean): Default false. If `true`, no coercion\n                 is attempted on input not conforming to semver v2.0.0. If\n                 `false`, `parse()` attempts to coerce input such as\n                 \"1.0\", \"0-x\", \"tmux 3.2a\" into valid versions.\n\nReturn: ~\n    (`vim.Version?`) parsed_version Version object or `nil` if input is\n    invalid.\n\nSee also: ~\n  \226\128\162 https://semver.org/spec/v2.0.0.html"}}, range = {binding = "range", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"spec"}, ["fnl/docstring"] = "Parses a semver |version-range| \"spec\" and returns a range object: >\n    {\n      from: Version\n      to: Version\n      has(v: string|Version)\n    }\n<\n\n`:has()` checks if a version is in the range (inclusive `from`, exclusive\n`to`).\n\nExample: >lua\n    local r = vim.version.range('1.0.0 - 2.0.0')\n    print(r:has('1.9.9'))       -- true\n    print(r:has('2.0.0'))       -- false\n    print(r:has(vim.version())) -- check against current Nvim version\n<\n\nOr use cmp(), le(), lt(), ge(), gt(), and/or eq() to compare a version\nagainst `.to` and `.from` directly: >lua\n    local r = vim.version.range('1.0.0 - 2.0.0') -- >=1.0, <2.0\n    print(vim.version.ge({1,0,3}, r.from) and vim.version.lt({1,0,3}, r.to))\n<\n\nAttributes: ~\n    Since: 0.9.0\n\nParameters: ~\n  \226\128\162 {spec}  (`string`) Version range \"spec\"\n\nReturn: ~\n    (`table?`) A table with the following fields:\n    \226\128\162 {from} (`vim.Version`)\n    \226\128\162 {to}? (`vim.Version`)\n    \226\128\162 {has} (`fun(self: vim.VersionRange, version: string|vim.Version)`)\n\nSee also: ~\n  \226\128\162 https://github.com/npm/node-semver#ranges"}}}, metadata = {["fls/itemKind"] = "Module"}}, w = {binding = "w", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Window-scoped (|w:|) variables for the current window.\nInvalid or unset key returns `nil`. Can be indexed with\nan integer to access variables for a specific window."}}, wait = {binding = "wait", metadata = {["fls/itemKind"] = "Function", ["fnl/arglist"] = {"time", "?callback", "?interval", "?fast_only"}, ["fnl/docstring"] = "Wait for {time} in milliseconds until {callback} returns `true`.\n\nExecutes {callback} immediately and at approximately {interval}\nmilliseconds (default 200). Nvim still processes other events during this\ntime.\n\nCannot be called while in an |api-fast| event.\n\nExamples: >lua\n    ---\n    -- Wait for 100 ms, allowing other events to process\n    vim.wait(100, function() end)\n\n    ---\n    -- Wait for 100 ms or until global variable set.\n    vim.wait(100, function() return vim.g.waiting_for_var end)\n\n    ---\n    -- Wait for 1 second or until global variable set, checking every ~500 ms\n    vim.wait(1000, function() return vim.g.waiting_for_var end, 500)\n\n    ---\n    -- Schedule a function to set a value in 100ms\n    vim.defer_fn(function() vim.g.timer_result = true end, 100)\n\n    -- Would wait ten seconds if results blocked. Actually only waits  100 ms\n    if vim.wait(10000, function() return vim.g.timer_result end) then\n      print('Only waiting a little bit of time!')\n    end\n<\n\nParameters: ~\n  \226\128\162 {time}       (`integer`) Number of milliseconds to wait\n  \226\128\162 {callback}   (`fun(): boolean?`) Optional callback. Waits until\n                 {callback} returns true\n  \226\128\162 {interval}   (`integer?`) (Approximate) number of milliseconds to wait\n                 between polls\n  \226\128\162 {fast_only}  (`boolean?`) If true, only |api-fast| events will be\n                 processed.\n\nReturn (multiple): ~\n    (`boolean`)\n    (`-1|-2?`)\n    \226\128\162 If {callback} returns `true` during the {time}: `true, nil`\n    \226\128\162 If {callback} never returns `true` during the {time}: `false, -1`\n    \226\128\162 If {callback} is interrupted during the {time}: `false, -2`\n    \226\128\162 If {callback} errors, the error is raised."}}, wo = {binding = "wo", metadata = {["fls/itemKind"] = "Variable", ["fnl/docstring"] = "Get or set window-scoped |options| for the window with handle {winid} and\nbuffer with number {bufnr}. Like `:setlocal` if setting a |global-local|\noption or if {bufnr} is provided, like `:set` otherwise. If {winid} is\nomitted then the current window is used. Invalid {winid}, {bufnr} or key\nis an error.\n\nNote: only {bufnr} with value `0` (the current buffer in the window) is\nsupported.\n\nExample: >lua\n    local winid = vim.api.nvim_get_current_win()\n    vim.wo[winid].number = true    -- same as vim.wo.number = true\n    print(vim.wo.foldmarker)\n    print(vim.wo.quux)             -- error: invalid key\n    vim.wo[winid][0].spell = false -- like ':setlocal nospell'\n<"}}}, metadata = {["fls/itemKind"] = "Module"}}}
docs.vim.fields.o.fields = docs.vim.fields.opt.fields
docs.vim.fields.bo.fields = docs.vim.fields.opt.fields
docs.vim.fields.wo.fields = docs.vim.fields.opt.fields
docs.vim.fields.go.fields = docs.vim.fields.opt.fields
docs.vim.fields.opt_local.fields = docs.vim.fields.opt.fields
docs.vim.fields.opt_global.fields = docs.vim.fields.opt.fields
return docs
